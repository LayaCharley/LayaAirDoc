{"./":{"url":"./","title":"引擎介绍","keywords":"","body":"LayaAir引擎介绍一、引擎的背景与发展历程1.1 Layabox的前世1.2 Layabox的今生二、LayaAir引擎的服务与生态LayaAir引擎介绍 Author: Charley 欢迎来到LayaAir引擎文档~ 一、引擎的背景与发展历程 1.1 Layabox的前世 Layabox的创始人谢成鸿在2003年将国内三大休闲娱乐平台之一的”可乐吧“以数千万价格卖给清华同方后，创立了3D端游研发公司”中娱在线“。 Layabox公司成立时的引擎技术骨干均来自于追随谢成鸿多年的3D端游引擎核心成员，时间最长者达10多年。 早在2011年底，Layabox的创始人谢成鸿就成立了LAYA实验室，开始研究可同时发布APP和HTML5的通用型引擎。并分别在2012年推出行业首款同屏多人实时交互对战的休闲对战类大型HTML5游戏《疯狂雪球》、2013年推出行业首款HTML5与APP同时发行的大型卡牌策略类HTML5游戏《上吧主公》（曾用名《喵喵三国传》）。并取得不错的商业成绩。2014年完成首款重度动作类HTML5游戏《猎刃2》的测试版，力证HTML5游戏技术与品质表现力已达到APP精品水准。 无论是3D端次世代引擎的积累，还是多年HTML5与APP跨平台大型游戏引擎的积累。为Layabox的成立与爆发奠定了深厚的基础。 1.2 Layabox的今生 Layabox是北京蓝亚盒子科技有限公司打造的引擎服务商与元宇宙服务商品牌。 Layabox成立于2014年，旗下的开源引擎产品LayaAir，截止到2022年,拥有超百万的全球开发者，是HTML5与小游戏领域的3D龙头引擎。 作为技术领航的引擎企业，众多知名企业及上市企业纷纷采用LayaAir引擎研发项目，这些企业如：腾讯、阿里巴巴、美团、网易、三七互娱、完美世界、掌趣、电魂网络、蓝港、光宇游戏、汤姆猫、猎豹移动、第七大道、第九城市、精锐教育、商汤科技等等。 自2018年微信小游戏推出以来，休闲小游戏时代来临，国内外知名流量平台相继携手Layabox建立深入的合作伙伴关系，推进小游戏时代的发展，这些已合作的平台为：微信、手机QQ、百度、小米、OPPO、vivo、支付宝、bilibili、淘宝、优酷、华为。 2021年，Layabox全资收购著名的游戏行业工具软件FairyGUI，并全力打造LayaAir 3.0。 2022年11月8日，元宇宙平台Layaverse正式推出，同一天，LayaAir3.0也开启了测试（面向定向邀请的开发者）。 二、LayaAir引擎的服务与生态 LayaAir引擎开源免费，拥有超百万的开发者生态。 提供了：免费的社区服务、LayaAir集成开发环境（IDE）、丰富的学习资料（文档、API、DEMO、视频）。 引擎官网地址：https://layaair.layabox.com/ 引擎社区地址：https://ask.layabox.com/ Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:54 "},"basics/readme.html":{"url":"basics/readme.html","title":"引擎功能概述","keywords":"","body":"LayaAir3.0引擎功能概述一、引擎代码1.1 引擎通用部分1.2 2D引擎1.3 3D引擎二、IDE(集成开发环境)2.1 通用模块2.1 2D模块2.2 3D模块三、项目发布3.1 Web版发布3.2 小游戏发布3.3 Native打包发布LayaAir3.0引擎功能概述 Author：Charley LayaAir3.0引擎，包括引擎代码、项目开发工具、项目发布，三大部分。本篇仅对大块功能简要概述，让开发者有一个初步的认知。 一、引擎代码 引擎代码，除了开放式的可编程的渲染管线，全平台的图形引擎架构，次世代PBR渲染流，ClusterLighting多光源技术，Forward+渲染管线，高性能并行渲染器API的接入（WebGPU）等核心基础。对于开发者而言，我们从通用、2D、3D，这三个部分来分别介绍。 1.1 引擎通用部分 网络（HTTP请求、WebSocket请求） 加载（可加载文本、JSON、XML、二进制、音频、视频、骨骼文件、图像文件等资源） ECS组件系统（组件系统、生命周期方法） 场景管理 事件（派发、侦听，捕获） 交互（鼠标、键盘、屏幕touch、VR手柄） 多媒体播放（音频、视频） 缓动 浏览器接口（封装常用的浏览器window功能、调用浏览器window功能） 设备接口（陀螺仪、加速计、地理位置） 节点 屏幕适配 小游戏适配（微信、手机QQ、字节跳动小游戏、OPPO、vivo、……等） 1.2 2D引擎 2D精灵（2D基础显示对象与容器） 2D视图（视窗、弹窗） 2D动画（图集动画、逐帧动画、缓动动画、时间轴动画、龙骨动画、spine动画） 2D文本（基础文本、HTML文本、BitmapFont位图字体） 2D UI组件（图像、按钮、显示文本、文本输入、文本域、下拉框、多选框、单选框、单选框组、导航标签组、导航容器、位图切片、位图字体切片、 垂直滚动条、水平滚动条、进度条、垂直划动条、水平划动条、取色器、基础容器、列表、树状列表、面板容器） 2D UI效果（遮罩、滤镜） 2D场景继承类（管理UI） 2D绘图（绘制矩形与圆角矩形、绘制圆形与扇形、绘制多边形、绘制线段、绘制折线、绘制曲线、绘制纹理与填充纹理） 2D物理（Box2D） Tiled Map地图 1.3 3D引擎 3D精灵（3D基础显示对象与容器） 3D基础工具（3D坐标系、3D变换、3D数学工具、等） 3D场景（场景管理、环境光、环境反射、场景天空、场景雾、等） 3D摄像机 3D光照（方向光、点光、聚光、区域光、阴影、光效） 3D网格 3D材质（模型材质、粒子材质、拖尾材质、天空材质） 3D纹理 3D粒子系统 3D拖尾 3D物理（bullet 、PhysX） 3D动画（刚体动画、材质动画、骨骼动画、摄像机动画、时间轴动画） 自定义Shader webXR 二、IDE(集成开发环境) IDE的概述，也分为通用模块、2D模块、3D模块进行概要说明。 2.1 通用模块 层级管理面板 项目资源面板 场景视窗 预览窗口 控制台面板 时间轴动画面板 动画状态机面板 属性设置面板 项目设置面板 IDE插件开发 IDE资源商店 2.1 2D模块 2D布局小部件（基础显示对象节点、UI组件、骨骼动画节点） 2D动画编辑 2DUI编辑 2D脚本管理 场景继承类管理 2D预制体 2.2 3D模块 3D场景编辑 3D摄像机 3D灯光设置 3D动画编辑 3D粒子系统 3D材质编辑 3D蓝图编辑 3D预制体 3D物理编辑 三、项目发布 3.1 Web版发布 发布web版是基础的发布方式，可以用于浏览器上运行，也可以用于Native打包发布。 3.2 小游戏发布 提供了各小游戏平台的适配库，以及快捷的各小游戏平台发布功能。 3.3 Native打包发布 支持发布为iOS与安卓平台的安装包。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-18 16:02:56 "},"basics/developmentEnvironment/readme.html":{"url":"basics/developmentEnvironment/readme.html","title":"开发环境","keywords":"","body":"熟悉开发环境《搭建基础开发环境》《IDE开发流程界面概述》熟悉开发环境 准备好相关的开发环境，熟悉一下基础的开发工作流，是学习引擎的前置条件哦~ 《搭建基础开发环境》 《IDE开发流程界面概述》 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"basics/developmentEnvironment/download/readme.html":{"url":"basics/developmentEnvironment/download/readme.html","title":"搭建基础开发环境","keywords":"","body":"搭建开发环境一、下载并安装LayaAir IDE二、搭建TS开发环境2.1 下载并安装Node.js2.2 安装TSC三、安装浏览器四、下载安装VSCode搭建开发环境 Author: Charley 在熟悉开发环境之前，请开发者们准备好相关的工具环境~ 一、下载并安装LayaAir IDE IDE内集成了引擎，直接下载IDE即可。 下载地址：https://layaair.layabox.com/#/engineDownload 二、搭建TS开发环境 LayaAir 3.0只支持TypeScript语言开发，所以TypeScript的安装环境还是要准备好。 2.1 下载并安装Node.js 2.1.1 检查是否已安装node.js环境 使用TypeScript开发需要Node.js环境，如果没有安装过的，请前往官方下载(建议LTS版本)。 在安装前，如果不确定是否有现成的环境，可以先确认一下node环境是否已安装，打开命令行工具（windows是cmd），输入指令 npm -h npm -h 按回车键后，如果能看到npm的命令说明、版本号，以及安装路径等信息，如图1-1所示（类似信息即可），那说明已经安装过了，如果不影响使用，可以跳过下载和安装node环境的步骤。 (图1-1) 2.1.2 Node.js官网下载并安装 如果没有安装环境，而直接前往node官网下载安装即可，推荐LTS版本，如图1-2所示，URL地址为：https://nodejs.org/en/ （图1-2） 图1-2仅作为参照使用，打开链接直接下载LTS版本即可。 注意：默认链接打开的是window(x64)，非64位的电脑，可以点击Other Downloads，下载对应的版本即可。 下载完成后，找到刚刚下载的Node.js安装包，一步一步的安装即可，安装完全时界面如图1-3所示。 （图1-3） 安装完成之后，可以按2.1小节介绍的方式，在命令行下输入 npm -h 检查一下安装状态。 2.2 安装TSC Node环境没问题后，就可以使用npm来安装TypeScript编译环境了。 2.2.1 命令行安装typescript 直接在命令行工具里输入指令“npm install -g typescript”，按回车键，如图2-1所示，即可开始下载并进行TypeScript环境的安装，此时一定要保持网络的畅通。 npm install -g typescript （图2-1） 开发者如果安装时遇到图2-2的情况，通常是缓存冲突导致。（没遇到的直接跳过本步骤。） （图2-2） 这时候，可以使用缓存清理命令 npm cache clean --force，回车执行该命令，重新输入安装指令即可。 npm cache clean --force [!Tip|label:Tips] 如果没有翻墙，npm可能会安装不太顺利，此时，建议执行npm cache clean --force 把npm缓存清掉。 然后使用cnpm来安装。 当我们看到 “All packages installed”这些字样的时候，可以确认完成了 TypeScript 环境的安装，如图2-3所示，关闭命令行工具即可。 （图2-3） 图3-1中tsc目录中就是我们TypeScript编译环境的安装目录，有了这个，LayaAirIDE里就能通过这个Compiler将TypeScript编译成为JavaScript。 2.2.2 检查TypeScript编译环境版本 在命令行输入“tsc -v” 命令可查看当前TypeScript编译的版本，如图2-4所示。 tsc -v （图2-4） 如果显示出版本号，说明TypeScript Compiler（tsc）安装成功。 三、安装浏览器 推荐采用Chromium内核的浏览器作为LayaAir运行与调试环境，例如windows自带的Edge浏览器或谷歌的chrome浏览器。 chrome官网下载地址： https://www.google.cn/intl/zh-CN/chrome/ 四、下载安装VSCode VSCode是一个应用广泛的编码工具，也是LayaAir引擎推荐的编码工具。 VSCode官网下载地址： https://code.visualstudio.com/Download Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"basics/IDE/GUI/readme.html":{"url":"basics/IDE/GUI/readme.html","title":"IDE开发流程界面概述","keywords":"","body":"IDE开发工作流模块概述一、IDE帐号登录二、IDE首页2.1 项目列表2.2 导入项目2.3 创建项目2.4 开发者商城2.5 Web链接2.6 帐号设置三、编辑器初始界面3.1 层级管理面板3.2 工程管理面板3.3 UI布局小部件面板3.4 场景视窗3.5 预览窗口3.6 动画状态机面板3.7 项目设置面板3.8 控制台面板3.9 时间轴动画面板3.10 属性设置面板四、其它编辑面板4.1 预制体面板标签4.2 蓝图编辑面板五、项目预览与发布5.1 项目预览5.2 项目发布IDE开发工作流模块概述 Author：Charley && 诗换花 一、IDE帐号登录 LayaAir3.x由于在IDE内使用了资源商店，社区、IDE核心配置云存储等高度依赖网络的功能，因此必须要登录帐号才可以使用IDE。 帐号登录的方式有三种，中文版本帐号支持微信扫码登录与手机帐号登录。英文版本帐号支持邮箱注册登录。 登录界面如图1-1所示。 (图1-1) 公测前只支持微信登录。 二、IDE首页 登录之后的IDE首页，集合了帐号模块、项目列表、创建项目、删除项目引用、项目描述设置、资源商店、web链接（引擎动态、版本日志、开发者社区、引擎文档）等功能。 2.1 项目列表 登录之后的默认模块就是项目列表，此处是导入或创建的项目列表，点击鼠标选中的高亮区，即可打开项目，进入编辑器模式。 效果如图2-1所示。 (图2-1) 默认的项目排列顺序是依据编辑时间的由近到远，如果项目数量较多，也可以在搜索框内输入项目关键字找到对应的项目。 效果如图2-2所示。 (图2-2) 在项目列表单元的右侧菜单里，有着项目相关的设置功能，分别是：设置项目图标、设置项目描述、打开项目的目录、将该项目从列表出移除。效果如动图2-3所示。 (动图2-3) 2.2 导入项目 点击导入项目，可以将其它电脑中创建的3.x项目或被移除列表的项目，导入到项目列表中。操作如图2-4所示。 (图2-4) 2.3 创建项目 如果要创建一个新的项目，我们可以点击创建项目，如图3-1所示，创建一个新的项目。 （图3-1） 2.3.1 选择模板 在创建新项目的界面，我们有三种类型的模板供开发者选择，如图3-2所示。 (图3-2) 核心模板是指2D与3D的空项目模板，适合已经上手的开发者创建一个纯净的模板环境。 示例模板是功能相对简单和独立的功能模块示例，适用于针对具体某些功能进行理解。 学习模板是指模板里的项目功能相对完整与丰富，适合项目开发的入门学习借鉴。 2.3.2 项目名称 如图3-3所示。 (图3-3) 2.3.3 项目位置 如图3-4所示。 (图3-4) 2.3.4 创建项目 完成以上选项后，点击创建项目，如图3-5所示。即可完成项目的创建，进入IDE编辑界面。如图3-5所示。 (图3-5) 2.4 开发者商城 开发者商城正在建设中，稍晚推出。 2.5 Web链接 链接功能正在建设中，稍晚推出。 2.6 帐号设置 帐号设置功能，当前仅支持退出登录。其它功能正在建设中。如图4-6所示。 (图4-6) 三、编辑器初始界面 编辑器的初始界面，包括层级管理面板、工程管理项目、UI布局小部件面板、场景视窗、预览窗口、动画状态机面板、项目设置面板、控制台、时间轴动画面板、属性面板。 3.1 层级管理面板 层级管理面板，主要包括了2D节点与3D节点，如果是存粹的2D项目，也可以只包括2D节点。面板如图5-1所示。 (图5-1) 层级的关系就代表着父子节点的关系，子节点会受到父节点的影响，例如父节点改变了位置，或旋转了角度，子节点也会同步产生变化。 3D节点的根节点是Scene3D，2D节点的根节点是Scene2D。2D与3D节点之间不可以混合形成父子层级关系。 3.2 工程管理面板 工程管理面板里，包括了项目全部的资源与代码。资源位于assets目录，代码位于src目录。面板如图5-2所示。 (图5-2) 3.3 UI布局小部件面板 UI布局小部件面板，包括了2D基础显示对象、UI组件、骨骼节点三部分，用于UI的排版与布局。面板如图5-3所示。 (图5-3) 3.4 场景视窗 场景视窗是编辑2D场景与3D场景的地方，是开发者可视化编辑虚拟世界的窗口。面板如动图5-4所示。 （动图5-4） 3.5 预览窗口 预览窗口是通过开发者布局编辑与代码逻辑展示给用户的视觉效果预览窗口。面板如图5-5所示。 （图5-5） 3.6 动画状态机面板 动画状态机，是控制时间轴动画逻辑的工具，动画状态机面板包括动画图层与状态机相关的功能。面板如图5-6所示。 （图5-6） 3.7 项目设置面板 项目设置面板包括了屏幕适配设置、引擎初始化设置、项目启动设置等。面板如图5-7所示。 （图5-7） 3.8 控制台面板 控制台面板用来打印日志信息，可以复制和清空所打印的日志信息。面板如图5-8所示。 （图5-8） 3.9 时间轴动画面板 时间轴动画面板用于2D与3D动画的编辑，有两个模式，分别是关键帧模式和曲线模式。如图5-9所示。 （图5-9） 3.10 属性设置面板 属性面板就是用于设置对象或文件属性的地方， 例如，IDE层级面板中的2D与3D对象属性，资源文件的属性设置或预览查看。以及组件的添加。 对象属性设置，如图6-1所示： （图6-1） 资源属性设置，如图6-2所示： （图6-2） 代码预览，如图6-3所示： （图6-3） 添加组件（自定义的属性），如图6-4所示： （图6-4） 四、其它编辑面板 除了初始界面所显示的面板外，还有通过预制体文件打开的预制体面板标签，以及通过蓝图文件打开的蓝图编辑面板。 4.1 预制体面板标签 场景文件打开的标签，都是同一个。点击预制体文件，会形成独立的预制体面板标签。效果如动图7-1所示。 （动图7-1） 预制体面板标签，其实并没有专属于自己的独有面板。仅仅是层级管理面板的根节点与场景文件的根节点不同。 4.2 蓝图编辑面板 蓝图编辑面板可以不写代码就快捷的编写自定义的材质，大幅降低开发者的使用门槛。 打开Shader蓝图文件或Shader蓝图函数文件，即可进入蓝图编辑面板。如图动图7-2所示。 (动图7-2) 五、项目预览与发布 5.1 项目预览 项目预览用来查看项目在不同环境中的运行效果。 项目预览分为三种模式，分别是IDE内预览，浏览器预览，移动端预览。如图8所示。 （图8） 5.1.1 刷新场景 在开启IDE内预览后会出现两个按钮，分别是刷新场景和打开开发者工具。 刷新场景顾名思义，对当前预览运行场景进行刷新，如图8-1所示。 （图8-1） 5.1.2 打开开发者工具 在开启IDE内预览后会出现两个按钮，分别是刷新场景和打开开发者工具。 点击打开开发者工具会调出Developer Tools，方便开发者进行调试，也可以通过 Ctrl + Alt + I 快捷键来打开开发者工具。 （图8-2） 5.2 项目发布 项目发布是将开发版本发布成为网页版本、小游戏版本、Naitve APP版本。 通过File菜单的Build调出发布界面，如图9所示。 （图9） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:13 "},"basics/essentialSkills/readme.html":{"url":"basics/essentialSkills/readme.html","title":"引擎学习必备技能","keywords":"","body":"引擎学习的必备技能《TS语言基础》《DevTools调试工具》《LayaTree调试工具》引擎学习的必备技能 LayaAir引擎面向有计算机语言基础的开发者，需要熟悉JavaScript语言、TypeScript语言。 日常开发，查BUG，需要熟悉调试工具DevTools等。 《TS语言基础》 《DevTools调试工具》 《LayaTree调试工具》 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"basics/language/readme.html":{"url":"basics/language/readme.html","title":"TS语言基础","keywords":"","body":"语言基础一、 JavaScript 基础教程二、 JavaScript ES6 教程三、 TypeScript 基础教程四、 TypeScript 进阶教程语言基础 LayaAir引擎支持开发者采用TypeScript语言开发项目，由于TypeScript语言是JavaScript语言带类型的超集，所以我们也要熟悉JavaScript语言的基础用法。 [!Note|label:建议：] 新手如果不是学生，没有大量充足的精力。 无需把语言全部都理解。掌握基础语法后即可学习引擎。 多看引擎示例源码，在理解引擎API的过程中，边用边学，遇到不理解的再进行查询即可。 一、 JavaScript 基础教程 《JavaScript 语言入门教程》：https://wangdoc.com/javascript/ 二、 JavaScript ES6 教程 《ES6 标准入门》：https://wangdoc.com/es6/ 三、 TypeScript 基础教程 《TypeScript中文手册》：https://www.tslang.cn/docs/ 四、 TypeScript 进阶教程 《深入理解 TypeScript》：https://jkchao.github.io/typescript-book-chinese/ Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"basics/DevTools/readme.html":{"url":"basics/DevTools/readme.html","title":"DevTools调试工具","keywords":"","body":"DevTools调试工具DevTools开发工具概述：调试 JavaScript 入门：DevTools调试工具 最常用的调试工具就是DevTools了，Chrome浏览器或者是基于Chromium内核的浏览器（例如Edge），都可以使用DevTools。 这个必须要掌握，否则遇到问题无法定位。 DevTools开发工具概述： https://learn.microsoft.com/zh-cn/microsoft-edge/devtools-guide-chromium/overview 调试 JavaScript 入门： https://learn.microsoft.com/zh-cn/microsoft-edge/devtools-guide-chromium/javascript/ 这里仅提供两个基础的文档入口，其实文档很全面，请自行根据文档的菜单列表查看学习。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:13 "},"basics/LayaTree/readme.html":{"url":"basics/LayaTree/readme.html","title":"LayaTree调试工具","keywords":"","body":"LayaTree调试工具一、LayaTree安装1.1 通过Chrome应用商店添加1.2 下载并安装二、LayaTree 使用2.1 使用的入口2.2 使用技巧三、工具服务LayaTree调试工具 Author：李尔 [!Note] LayaTree是LayaAir引擎开发者李尔专门为LayaAir引擎广大的开发者而设计的Chrome浏览器插件工具，该工具能在项目运行时阶段进行调试和修改。 一、LayaTree安装 1.1 通过Chrome应用商店添加 [!Tip|label:Tips] 通过Chrome应用商店添加需要科学上网(vpn翻墙) LayaTree已在chrome浏览器网上商店上架，搜索laya即可。如下图所示： 商店地址：https://chrome.google.com/webstore/ 也可以直接在Chrome里输入安装地址：https://chrome.google.com/webstore/detail/laya-tree/jnmdcbmpmfhnlchjdkcngihpjmgofajm?hl=zh-CN&authuser=0 如下图所示： 1.2 下载并安装 也可以通过作者提供的国内zip包地址（ v1.0.5）下载： LayaTree zip包：https://womenzhai.cn/LayaTree_V1.0.5.zip zip包安装方法 打开Chrome浏览器进入chrome://extensions/ 页面 打开开发者模式， 将解压后crx文件拖入该页面即可，安装成功后重启浏览器。 [!Tip|label:Tips] 需要注意的一点是: 如果需要调试的页面是文件网址，需要打开允许访问文件网址。否则无法识别当前laya引擎; 二、LayaTree 使用 2.1 使用的入口 在需要调试的项目页面(需未混淆代码)，打开开发者工具页面(F12或 Ctrl+Shift+I) 选择LayaTree页签，如下图所示 2.2 使用技巧 2.2.1 更新节点树列表的方式 LayaTree设计的本意是尽可能少的影响到游戏，做一个安安静静的的幕后操作者。所以不会去实时更新当前页面的节点树。 所以需要手动点击捕获刷新按钮来更新节点树列表。或者勾选自动刷新节点树的选项。如下图所示： 开启自动刷新节点树功能后，能够实时看到场景层级的变化，不需要手动捕获刷新，当场景层级非常多的时候会轻微影响到性能调试的准确性。如果在进行性能调优，建议不要开启（默认关闭）。日常调试开发未有影响。 2.2.2 运行时调整参数：操作Camera相机节点 示例：操作Camera相机节点,可以通过鼠标拖放或输入数值操作节点的位移,旋转和缩放。 通过便捷的下拉框切换相机的clearFlag.开启或关闭HDR. 此外相机的FOV,远近裁面和比例都可以快速的动态修改,极大的便利了镜头调整. 加入了正交相机开关orthographic。 2.2.3 运行时调整参数：设置点击事件与穿透控制 操作Sprite节点,除了常规节点的位移,旋转和缩放.还能够动态设置层级关系zOrder,锚点,尺寸 此外还有开发中经常需要用到的设置点击事件与穿透控制 2.2.4 运行时调整参数：文本内容直接编辑 操作文本节点,文本内容直接编辑 非常好用的基于拾色器的颜色调整​ 使用下拉框来选择文本的水平对齐和垂直对齐方式 字体大小,粗细,描边,overflow超出行为随意调节 2.2.5 基于AOP的暂停与单帧调试运行 基于AOP的暂停与单帧调试运行,能够在不修改源码的情况下控制引擎循环（需要注意的是，暂停时修改的属性需要下一帧才会更新渲染，所以修改数据时要点击单帧后查看） 支持TimeScale时间缩放,最高支持50倍速,尽享鬼畜与丝滑 2.2.6 cacheAs优化技巧 cacheAs为\"none\"，不做任何缓存.当值为\"bitmap\"时，webgl模式下显示对象使用renderTarget缓存成静态图像可以大幅提升渲染效率.但是额外创建的renderTarget对象，会增加内存开销.通过该选项可以便捷的切换模式,找到优化方向. 7.增加标记选中功能,勾选后,选中2d节点时,会显示红框标记 三、工具服务 LayaTreeQQ群： 200482074 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:15 "},"basics/IDE/readme.html":{"url":"basics/IDE/readme.html","title":"IDE基础","keywords":"","body":"IDE基础IDE基础 LayaAir IDE的基础包括，对IDE各组成部分的基础认知，以及基础的交互操作。 通过该部分的文档，开发者将会对IDE有一个全局性的了解，掌握了基础的操作方式。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:14 "},"basics/IDE/layouts/readme.html":{"url":"basics/IDE/layouts/readme.html","title":"自定义界面布局","keywords":"","body":"自定义IDE界面布局一、调整为更方便资源预览二、调整为更方便层级展开三、调整为即时预览的方式自定义IDE界面布局 Author：Charley && 诗换花 LayaAir 3.0 IDE允许开发者按照自己的习惯或喜好，对各块功能进行任意布局排版。 一、调整为更方便资源预览 当我们创建一个空项目，例如3D空项目，界面布局如图1-1所示。 （图1-1） 默认的模式比较简洁，有的开发者也许对资源的预览要求更高一些，我们不妨调整为这样的效果，界面如图1-2所示。 (图1-2) 操作方式如动图1-3所示： （动图1-3） 二、调整为更方便层级展开 假如开发者的节点层级较多，并且需要展开查看的时候，纵向全屏查看，显然更加方便，效果如图2-1所示。 (图2-1) 操作方式如动图2-2所示： (动图2-2) 三、调整为即时预览的方式 有的时候，开发者还需要一边编辑场景（2D和3D），一边查看实时预览效果。那么我们可以将Game面板独立出来，效果如图3-1所示。 (图3-1) 操作方式如动图3-2所示： (动图3-2) [!Note] 以上三种方式，仅供参照，掌握好IDE面板的位置调整方式，就可以按自己的需求与喜好进行布局了~ Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:14 "},"basics/IDE/projecFolders/readme.html":{"url":"basics/IDE/projecFolders/readme.html","title":"项目工程目录说明","keywords":"","body":"项目工程目录说明一、目录构成概述1.1 工程文件1.2 ts编译配置文件二、日常开发的目录2.1 项目资源目录assets2.2 项目源码目录src三、其它目录3.1 vscode配置目录.vscode3.2 本地运行目录bin3.3、项目库目录libs项目工程目录说明 Author：Charley 一、目录构成概述 LayaAir IDE创建的项目工程，由五个可见目录与几个根目录的文件构成，效果如图1所示。 （图1） 1.1 工程文件 .laya 后缀的文件是LayaAir引擎项目工程文件，用于识别是否是LayaAir引擎项目，版本信息，以及不同名称的项目。 1.2 ts编译配置文件 由于LayaAir3.0项目只支持TS语言开发，所以也默认创建了一个tsconfig.json。 tsconfig.json是用来配置 TS 编译选项的，位于项目的根目录。 如果想了解该配置的详细信息，请直接前往TS语言的文档： https://www.tslang.cn/docs/handbook/tsconfig-json.html https://www.tslang.cn/docs/handbook/compiler-options.html 二、日常开发的目录 在LayaAir3.0的项目工程目录结构里，开发者真正需要关心的只有两个目录，项目资源目录assets与项目源码目录src。其它的目录，大家知道其作用即可。 2.1 项目资源目录assets assets目录是比较重要的项目目录，我们所有的场景与资源都在assets目录，IDE对项目资源的管理，都是来自于该目录。 效果如图2-1所示： （图2-1） 该目录与最终的发布有着密切的关联， 例如，场景Scene中在assets里引入的资源会自动复制到发布目录。 代码里引用的资源，必须放到resources目录里，才会被复制到发布目录里。 2.2 项目源码目录src src里源码目录，如图2-2所示。 (图2-2) [!Tip] 源码目录比较容易理解， 对于LayaAir1.0与2.0的用户，需要注意的是，Main.ts不再是入口，仅仅是默认创建的一个示例脚本。 入口是IDE里设置的启动场景，启动场景绑定的runtime类或脚本，会跟随启动场景运行，作为项目的入口。 三、其它目录 其它的目录，开发者知道其作用即可，日常开发中，开发者基本上不需要去处理。 3.1 vscode配置目录.vscode 由于LayaAir项目的推荐编码环境是vscode，所以在创建项目的时候，在.vscode里创建 了settings.json，如图3-1所示： （图3-1） settings.json里当前只配置了一些需要隐藏显示的文件，让项目看起来更“整洁”一些， .DS_Store是MacOS系统下产生的一些系统文件，所以没必要看到。 .meta是IDE用于识别与管理文件的文件，开发者也无需关注。 Library、temp、local、settingst这些目录，也是IDE仅供系统配置使用，不希望开发者修改，也给隐藏了起来。 3.2 本地运行目录bin bin目录内，开发者通常也不需要去管。在开发的过程中，assets目录作为资源使用的根目录即可。 bin目录内仅是测试运行的index.html首页的入口，以及IDE内置的代码入口。如图3-2所示： (图3-2) [!Tip] 开发者尽量不要去修改这里的入口，以及在bin目录下存放资源，这与LayaAir1.0与2.0有很大的不同。 3.3、项目库目录libs engine目录里存放的是引擎库的声名文件，如图3-3所示，通常不需要动。 （图3-3） 如果开发者有引用第三方的类库，也可以将声名文件放到这里。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:14 "},"basics/IDE/projectSettings/readme.html":{"url":"basics/IDE/projectSettings/readme.html","title":"项目设置详解","keywords":"","body":"项目设置详解一、运行设置1.1 屏幕适配设置 Resolution1.2 引擎初始化设置 Engine Options1.3 项目启动设置Startup1.4 调试启动设置Debug二、编辑器设置Editor2.1 3D预制体编辑环境 Prefab Edit Env2.2 3D节点层级设置项目设置详解 Author：Charley IDE的项目设置包括两个部分，运行设置与编辑器设置。 一、运行设置 1.1 屏幕适配设置 Resolution 屏幕适配的设置会影响IDE内的预览效果，以及项目运行时的画布宽高、适配模式、对齐方式，画布背景色等。可设置属性如图1所示： （图1） 1.1.1 画面宽高适配 影响产品画面宽高的三个设置，分别是设计宽高（Design Width、Design Height），缩放适配模式(Scale Mode)。 设计宽高，就是我们在IDE里的设置并看到的宽高， 这个宽高会影响在IDE里的UI场景背景大小，以及IDE的预览运行模式下，也是基于这个宽高查看效果。 在实际的运行环境里，例如不同的手机。由于屏幕比例的不同，肯定不可能与设计宽高完全吻合。 所以，就需要用引擎自带的缩放适配模式，进行缩放，从而来满足开发者的屏幕需求。 缩放适配模式涉及画布、舞台、适配算法等诸多知识点，我们在另一篇文档《屏幕适配》里详细介绍。 1.1.2 横竖屏适配ScreenMode 有的时候，我们需要根据屏幕的比例强制横竖屏设置，在IDE中可以通过设置屏幕模式（Screen Mode）来设置。 横竖屏有三种适配模式，如图2-1所示。 （图2-1） 无变化：none none时，无论屏幕方向如何旋转，游戏的水平方向都不会产生跟随屏幕旋转的变化。 效果如动图2-2所示。 (动图2-2) 通过动图2-2发现，none值时，当屏幕发生旋转后，基于竖屏设计的界面在横屏下就会变的不适合，同理，基于横屏设计的界面在竖屏下，也会变的不适合。 当然，如果我们的布局策略运用的比较合理，也许也可以兼顾横竖屏的体验。效果如动图2-3所示。 (动图2-3) 虽然不那么难看了，但为了达到最佳的效果，最好的方案，还是竖屏始终与设备竖屏的方向保持一致，横屏与设备横屏的方向保持一致。 始终横屏：horizontal 当我们设置的宽高就是横屏产品时，horizontal无疑是最佳的体验，效果如动图2-4所示。 (动图2-4) 通过动图2-4发现，screenMode属性值设置为horizontal时，无论屏幕方向如何旋转，设计上的水平方向都会与屏幕最短的边始终保持垂直，所以用户设备竖屏时看到横屏画面，自然就会把设备横过来，从而吻合了产品的设计。 始终竖屏：vertical 当我们设置的宽高就是竖屏产品时，vertical无疑是最佳的体验，效果如动图2-5所示。 (动图2-5) 通过动图2-5发现，screenMode属性值设置为vertical时，无论屏幕方向如何旋转，游戏的水平方向都会与屏幕较长的边始终保持垂直。所以用户哪怕是把设备横屏了，仍然看到的是竖屏画面，自然就会把设备恢复竖屏，从而吻合了产品的设计。 [!Tip] 需要注意的是，浏览器中运行的时候，引擎的自动横屏和自动竖屏，只能对画布进行旋转，如果用户的手机锁屏了，虽然画面自动旋转过来了，但是浏览器没有旋转过来，会导致输入法依然按浏览器的方向弹出，此时，可能会导致输入法与浏览器的显示呈90度。 在小游戏平台中运行，由于小游戏底层有横屏还是竖屏的配置，不会出现这个问题。 1.1.3 画布对齐适配AlignV、AlignH 引擎中的提供的alignV（垂直对齐）与alignH（水平对齐）是对画布进行对齐。设置方式如图3所示： （图3） 参数说明如下： AlignV垂直对齐的参数为：top（顶部对齐）、middle（垂直居中对齐）、bottom（底部对齐）。 AlignH水平对齐的参数为：left（居左对齐）、center（水平居中对齐）、right（居右对齐）。 [!Tip] 画布对齐不能理解为UI界面基于stage舞台的对齐，只是画布canvas相对于整个物理屏幕的对齐。 该设置在移动端，基本用不上，移动端绝大多数都需要全屏适配。当画布已经铺满整个屏幕时，设置就没有了意义。 通常是在PC端，非全屏的模式下使用，例如在画布非全屏适配的模式（showall和noscale）的情况下使用。 1.1.4 画布背景色设置BackgroundColor 画布背景色，其实就是给画布设置一个颜色，默认值为#888888，如图4所示： （图4） 1.2 引擎初始化设置 Engine Options 有一些引擎的配置项，需要在引擎初始化的时候设置，而设置的入口就是如图5所示： （图5） 属性参数说明 属性名称 属性说明 FPS 设备帧率；用于计算两帧之间的渲染最大间隔时长，通常设备上的帧率是最大60，也就是一秒钟内最多只有 60 帧会出现在屏幕上，那么两帧之间的时长为1000ms/60。对于高帧率设备，我们可以修改FPS值，例如120帧的设备，那两帧之间的时长则为1000ms/120。 Is Antialias 是否开启抗锯齿；用于设置webGL上下文的antialias抗锯齿开关属性，会产生额外的性能消耗，主要用于2D非矩形的矢量绘图抗锯齿，无矢量绘制图形或性能压力大时，可以选择不开启。3D抗锯齿推荐使用摄像机的Fxaa或Msaa。 Use Retinal Canvas 使用高清画布模式；开启后无论任何适配模式，画布均采用物理分辨率大小，开启后会比不采用物理分辨率多一些性能消耗，但会让文本等保持最佳清晰度。 Is Alpha 是否画布透明；默认状态画布有背景色，开启后，可以设置画布为无色透明。 MeshAlloc MaxMem 是否分配最大的VB缓冲区；开启后，渲染2D的时候，每次创建vb直接分配足够64k个顶点的缓存。这样可以提高效率。关闭后，可节省64k显存，但会牺牲性能效率，如果包含2D时，建议保持默认开启。 Enable Dynamic Batch 启用动态合批；开启动态合并后，满足 实例合并（同Mesh且同材质） ，即可减少RenderBatches渲染批次与Shader提交次数。 Enable Uniform Buffer Object 启用Uniform Buffer；当启用Uniform Buffer缓存后，可以减少CUP传递至GPU的数据量。 Pixel Ratio 设置3D的分辨率倍数，默认值为1 ；降低3D分辨率，不会影响2D UI的分辨率，适当的调节可降低性能的消耗。 Enable Multi Light 是否开启多光源；如果不需要多光源，关闭后可减少性能的消耗。 Max Light Count 最大光源数量；默认值为32个。 Light Cluster Count x、y、z轴的光照集群数量；z值会决定Cluster受区域光（点光、聚光）影响的数量，Math.floor(2048 / lightClusterCount.z - 1) * 4 为每个Cluster的最大平均接受区域光数量,如果每个Cluster所接受光源影响的平均数量大于该值，则较远的Cluster会忽略其中多余的光照影响。 1.3 项目启动设置Startup 1.3.1 入口启动场景 Startup Scene LayaAir 3.0项目运行入口的设置有两种方式，一种是将当前场景Current Scene（正编辑的场景）作为项目运行的入口，另一种是设置一个固定的项目入口场景。 当我们在构建发布里设置了启动场景，并且勾选了启动场景作为入口，如图6所示。在运行项目时，引擎初始化之后，就会先运行设置的启动场景。 （图6） 1.3.2 引擎库模块 LayaAir引擎由多个模块组件，默认只引入了较为基础的模块，如图7所示。 (图7) 如果应用到其它模块，需要勾选对应的模块，才可以使用其API，否则项目运行时会导致报错。 引擎库模块说明： 引擎库模块名 引擎库模块说明 laya.d3 3D基础模块，使用3D的必选库 laya.ui ui模块，包括常用的ui组件，使用2D UI组件的必选库 laya.ani 2D动画模块，包括2D节点动画（序列帧、图集动画）、内置的骨骼动画等 laya.device 陀螺仪、加速计、地理位置、摄像头、麦克风等设备接口调用封装 laya.html 原生DOM相关的接口封装 laya.tiledmap tiledmap地图接口封装 laya.particle 2D粒子的封装，不推荐使用 laya.spine spine动画引擎库 laya.gltf 代码直接使用gltf模型的加载解析库 laya.physics Box2D物理库的封装 laya.physics3D Bullet 3D物理库 laya.physics3D.wasm WebAssembly的Bullet 3D物理库 1.4 调试启动设置Debug IDE可以开启两种调试模块，分别是统计信息Stat与控制台V Console，如图8-1所示。 （图8-1） 1.4.1 统计信息 Stat 勾选统计信息Stat之后，可以查看当前帧率、内存占用、节点等信息，用于项目的分析与优化。如图8-2所示。 （图8-2） 如想了解更详细的统计信息面板上的参数，请查阅文档《性能统计与优化》 1.4.2 移动端调试工具 V Console 在移动端调试，通常需要联到电脑端的浏览器上。 如果开发者不需要断点，只是一些常用的日志打印、加载等查看等，开启V Console，在移动端会出现如图8-3所示的调试工具面板。 （图8-3） 二、编辑器设置Editor 2.1 3D预制体编辑环境 Prefab Edit Env 默认情况下，3D预制体是位于一个专用的系统空场景（DefaultPrefabEditEnv）的环境下进行编辑。 如果我们通过 Prefab Edit Env，指定了一个目标场景，相当于直接位于某个3D场景中进行编辑，这样当切换到3D场景中，就会更加符合需求。操作如图9-1所示： （图9-1） 效果如图9-2所示： 2.2 3D节点层级设置 3D节点，我们可以选择层级并设置，而编辑器设置EditorSettings中，正是增加、删除层级，以及为层级命名的地方。 效果如图10所示。 (图10) 关于层级Layer的更多介绍，可前往IDE文档《使用3D精灵》进行查看。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:14 "},"basics/IDE/entry/readme.html":{"url":"basics/IDE/entry/readme.html","title":"项目入口说明","keywords":"","body":"项目入口说明一、启动场景1.1 LayaAir2.0用户必看，入口变了1.2 设置启动场景1.3 项目入口之前的引擎配置项1.4 预览运行的入口设置二、入口的逻辑脚本2.1 自定义组件脚本的基础使用流程2.2 UI组件脚本三、自定义初始化项目入口说明 Author：Charley 、孟星煜 项目入口是在引擎初始化之后，项目首先要执行的地方。 对于大型项目通常是资源预加载与全局初始化的入口，无需预加载的微型产品，通常是主界面与全局入口逻辑。 一、启动场景 1.1 LayaAir2.0用户必看，入口变了 LayaAir2.x引擎中，是通过Main类来作为项目的入口类，所以一些引擎的初始化配置工作只能是在入口类中通过代码进行设置（如图1-1）。 （图1-1） 但是在LayaAir3.0中，为了简化开发者的理解与流程，项目的入口不再是以入口类的形式出现。项目的入口变为了启动场景。引擎的初始化配置工作仅需要在IDE里可视化的配置，即可完成。下文会详细介绍。 LayaAir2.0的老用户们，不要再找Main入口类了，已被干掉~ 1.2 设置启动场景 LayaAir 3.0引擎，只能在IDE里设置启动场景作为项目的入口。如果需要初始化引擎全局配置，直接在IDE的项目设置中配置。如果需要代码逻辑，直接为场景关联脚本，即可以执行代码逻辑。 本小节，我们先来介绍如何设置启动场景。 我们在文件导航菜单中打开 构建发布 面板。如图1-2所示， （图1-2） 构建发布面板的启动场景用于指定项目的启动场景，如图1-3所示。 （图1-3） 开发者可以在弹出的面板中，选择一个场景文件，指定为启动场景。操作如动图1-4所示， （动图1-4） 1.3 项目入口之前的引擎配置项 在执行项目入口之前，开发者也可以先配置一些引擎的初始化设置，如图1-5，我们打开项目设置面板，直接在引擎选项里进行配置即可。 （图1-5） 具体的参数设置说明，请查阅文档《项目设置详解》 。 1.4 预览运行的入口设置 启动场景在构建发布里进行线上版本的发布后，毫无疑问是作为项目的入口来率先加载与显示的。 但是在项目预览运行调试的时候，我们有的时候并不希望将启动场景优先显示，这会使得调试流程变的很长。 所以，点击图1-6红圈中的下拉箭头，可以通过点击勾选的方式，将启动场景或者当前场景作为预览运行的入口。 （图1-6） 当前场景是指，当前在IDE里正处于打开编辑状态的场景。 二、入口的逻辑脚本 虽然这个知识点并不属于项目入口的专属，但我们还是概要的讲一下流程。 首先，LayaAir3.0里并不建议开发者采用自定义的脚本作为项目的入口。所以从正常的流程上，代码的逻辑必须要跟随入口场景，通过入口场景激活与添加到舞台等引擎的生命周期方法来执行对应的逻辑。 对于场景的3D根节点Scene3D，可以绑定的脚本只有自定义的组件脚本。场景的2D根节点Scene2D，除了自定义的组件脚本还可以绑定UI组件脚本。 关于自定义的组件脚本与UI组件脚本区别与使用，请查阅相关文档，本篇仅介绍项目入口的核心流程。 自定义的组件脚本（装饰器暴露属性、事件方法、生命周期方法等）请参考《实体组件系统（ECS）》 UI组件脚本（关联UI组件、与自定义组件脚本的区别等）请参考《UI继承类》 2.1 自定义组件脚本的基础使用流程 自定义的组件脚本继承自Laya.Script类，定义了组件的事件方法和自身生命周期方法。 动图2-1演示了如何给Scene2D节点添加自定义的组件脚本。在属性设置面板中，点击增加组件->新建组件脚本，然后可以对要新建的脚本进行重命名（图中重命名为aaa），最后点击创建并添加即可创建脚本。 （动图2-1） 按以上动图添加的自定义组件脚本aaa.ts，生成了名称为aaa的脚本模板类，如图2-2，直接在该脚本中编写代码即可。 （图2-2） [!Tip] 具体的组件脚本使用文档请参考《实体组件系统（ECS）》 2.2 UI组件脚本 除了自定义的组件脚本以外，也可以使用UI组件脚本作为项目入口的逻辑代码。 UI组件主要是用于2D场景中，需要管理的节点比较多的时候，以及需要在打开场景的时候需要为场景传递参数（例如弹窗的动态提示等）的应用场景。 UI组件可以独立使用，也可以与组件脚本同时使用。 UI组件脚本需要在UI运行时（Runtime）属性入口进行添加，如图2-3所示。并且，只有在场景的Scene2D节点或2D预制体的属性设置面板中 （图2-3） 2D预制体只要是根节点都有UI运行时（Runtime）这个属性。 下面以Scene2D节点为例，介绍创建UI组件脚本的方式。在UI运行时属性输入框进行鼠标双击操作，IDE会弹窗提示创建UI组件脚本文件，默认是RuntimeScript.ts，开发者可以对其进行重命名，例如动图2-5所示的bbb，点击保存即可创建脚本。 （动图2-5） 建议先学习完自定义的组件脚本及其使用，再学习UI组件脚本的相关内容。 三、自定义初始化 由于之前的流程，是先初始化引擎，然后再加载与启动入口场景。但是在某些特殊的情况下，开发者可能需要在引擎初始化之前执行一些逻辑，例如需要提前判断不同的运行环境等。 那我们也提供了自定义的代码流程，通过Laya.LayaEnv.beforeInit定义引擎初始化之前要执行的逻辑，通过Laya.LayaEnv.afterInit定义引擎初始化之后要执行的逻辑。 例如，在开发者创建项目时会自动生成一个Main.ts，加入下面的代码： Laya.LayaEnv.beforeInit = function(config: Laya.IStageConfig) { //这个方法会在Laya.init前调用 console.log(\"before init\"); //这里可以对config以及Laya.Config、Laya.Config3D进行自定义的修改 } Laya.LayaEnv.afterInit = function() { //这个方法会在Laya.init后调用 console.log(\"after init\"); } const { regClass, property } = Laya; @regClass() export class Main extends Laya.Script { onStart() { console.log(\"Game start\"); } } 要注意的是，需保证这些代码所在的脚本文件是被场景中引用的，否则在发布版本时被消除项目中未使用的代码，那就无效了。 注意：如果没有特殊需求，不推荐使用本小节方法进行游戏初始化。开发者应使用为场景挂载组件脚本的方式。 运行可以看到，输出结果如图3-1所示： （图3-1） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-05-08 10:34:15 "},"basics/IDE/importJsLibrary/readme.html":{"url":"basics/IDE/importJsLibrary/readme.html","title":"引用第三方JS模块","keywords":"","body":"使用外部模块一、第三方模块1.1 支持方式1.2 使用示例二、第三方JS文件2.1 支持方式2.2 使用示例使用外部模块 一、第三方模块 1.1 支持方式 在开发过程中，如果需要使用一些第三方库，推荐的解决方法是使用JS的模块功能。 步骤如下： 在项目文件夹执行 npm init 初始化项目。 使用npm install xxx --save 安装xxx包。 然后在代码中使用import语句导入即可 1.2 使用示例 我们用第三方AStar模块在讲解： npm init 在开发中使用npm init会生成一个pakeage.json文件，这个文件主要是用来记录这个项目的详细信息的，它会将我们在项目开发中所要用到的包，以及项目的详细信息等记录在这个项目中。 执行npm init是需要在DOS窗口执行的，我们可以windows+r键来打开窗口，然后输入CMD执行，然后就可以打开DOS窗口了。打开窗口之后，在DOS窗口中进入自己项目所在的目录。进入到项目所在的目录之后我们就可以直接执行npm init，执行了npm init之后，会让我们填写一些配置信息，如果还不知道怎么填写的话可以一路回车。 package name：你的项目名字 version： 版本号 description： 对项目的描述 entry point： 项目的入口文件 test command：项目启动的时候要用什么命令来执行脚本文件 git repository：如果你要将项目上传到git中的话，那么就需要填写git的仓库地址（这里就不写地址了） keywirds： 项目关键字（这里就不写了） author：作者的名字（这里就不写了） license：发行项目需要的证书（这里就不写了） 如图1-1所示， （图1-1） npm install xxx --save 以npm安装AStar为例，如图1-2所示 （图1-2） 会把astar包安装到node_modules目录中 会在package.json的dependencies属性下添加astar 看一下package.json里的内容： { \"name\": \"test\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"bin\": { \"test\": \"bin/bundle.js\" }, \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": { \"astar-typescript\": \"^1.2.5\" } } 接下来在我们的代码中可以使用 import AstarFinder 了，示例代码如下： import { AStarFinder } from \"../node_modules/astar-typescript/dist/astar\"; const { regClass, property } = Laya; @regClass() export class Main extends Laya.Script { private aStarInstance: AStarFinder; onStart() { console.log(\"Game start\"); let myMatrix = [ [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 1, 0, 1, 1, 0], [0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 1, 0], [1, 1, 1, 0, 1, 0, 1, 0], [0, 0, 0, 0, 1, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0] ]; this.aStarInstance = new AStarFinder({ grid: { matrix: myMatrix } }); let startPos = { x: 0, y: 0 }; let goalPos = { x: 7, y: 7 }; let myPathway = this.aStarInstance.findPath(startPos, goalPos); console.log(myPathway); } } 通过在IDE中运行此脚本，可以获得从 0,0 点到 7,7 点的最短路线，如图1-3所示 （图1-3） 到此为止，第三方模块已经成功导入到项目中了，在IDE中会自动加载，预览和运行都能正常使用。我们也可以验证发布工程，通过点击发布可以看到，引入的AStarFinder类已经成功的集成到发布的代码中了，如图1-4所示 （图1-4） 二、第三方JS文件 在某些特殊情况下，如果需要直接使用一些第三方的JS文件，IDE也提供了单独导入的功能。 2.1 支持方式 导入为插件 首先将JS文件放置到项目的assets文件夹或src文件夹下，然后在属性设置里勾选“导入为插件”。如图2-1所示 （图2-1） 此时这个脚本会在预览、运行或者发布中会自动加载。 允许编辑器加载 如果勾选“允许编辑器加载”，则脚本在编辑器环境也会载入。 注意，JS脚本不要出现对全局环境的修改，否则影响编辑器稳定。另外，JS脚本一旦载入，没有卸载和刷新功能，如果修改了JS文件，需要刷新编辑器才生效。如果不勾选，这个脚本会在预览、运行或者发布中才会载入。 依赖其它 “依赖其它”可以设置多个脚本，这些脚本将会安排优先载入。 2.2 使用示例 我们用2D入门示例来讲解： 首先，在2D入门示例中，如果在没有导入astar.js的情况下，运行“进阶使用”下的“A*寻路”，点击任何区域，人物没有任何移动，如图2-2所示 （图2-2） 由于IDE本身不支持Astar的类库，同时也没有导入Astar类库，运行时会报错，如图2-3所示 （图2-3） 因此，我们需要引入Astar.js来支持A*算法，从 https://github.com/bgrins/javascript-astar 官网下载 astar.js 将 astar.js 放入 assets 目录下，或者 src 目录下，这里以 assets 为例，如图2-4所示 （图2-4） 点击 astar ，在属性面板中，勾选“导入为插件”，并点击“应用”，如图2-5所示 （图2-5） 此时，astar.js 已作为插件导入IDE中，在预览，运行和发布中会自动载入。 我们再次运行2D示例查看A*寻路示例，如动图2-6所示 （动图2-6） 运行正常了，接下来我们测试一下发布，看下发布后是如何实现的，如图2-7所示 （图2-7） 在发布后的web目录下，astar.js 已经发布到js目录下，并在index.html中被引入，再次运行，A*寻路依然正常运行。 开发者还可以对“允许编辑器加载”和“依赖其它”进行使用。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:14 "},"basics/IDE/assets/readme.html":{"url":"basics/IDE/assets/readme.html","title":"项目资源面板说明","keywords":"","body":"项目资源面板说明一、资源目录1.1 项目资源目录assets1.2 项目源码目录src1.3 右键菜单1.4 2D图片编辑成SpriteTexture二、快速创建文件2.1 创建文件夹2.2 创建预制体2.2.1 预制体2D2.2.2 预制体3D2.3 创建场景（scene）2.4 创建着色器2.4.1 着色器2.4.2 着色器蓝图2.4.3 着色器蓝图函数2.5 创建材质及配置2.4.1 材质文件2.5.2 TexturCube2.4.3 RenderTexture2.4.4 AvatarMask2.6 创建图片类型2.6.1 灯光设置2.6.2 自动图集设置2.7 创建动画状态机2.7.1 2D动画状态机2.7.2 3D动画状态机三、搜索面板3.1 文字搜索3.2 类型搜索四、目录设置面板4.1 两栏显示4.2 全部折叠项目资源面板说明 一、资源目录 LayaAir IDE打开项目工程后，由五个部分构成，效果如图1-1所示 （图1-1） 项目资源目录 项目源码目录 +快捷创建 搜索面板 目录设置按钮 首先我们可以简单了解一下项目资源目录和项目源码目录，然后会对其它三个功能做详解介绍 1.1 项目资源目录assets assets目录是比较重要的项目目录，我们所有的场景与资源都在assets目录，IDE对项目资源的管理，都是来自于该目录。 效果如图1-2所示： （图1-2） 该目录与最终的发布有着密切的关联， 例如，场景Scene中在assets里引入的资源会自动复制到发布目录。 代码里引用的资源，必须放到resources目录里，才会被复制到发布目录里。 1.2 项目源码目录src src里源码目录，如图1-3所示。 (图1-3) 源码目录比较容易理解，通常在安装了代码编辑器后，可以双击源码来打开代码编辑器 1.3 右键菜单 通过鼠标右键任何目录或者文件，可以打开菜单，如图1-4所示 (图1-4) 通过点击“创建”，动图1-5中在assets目录下创建了一个“灯光设置”文件 （动图1-5） 在第二节，我们会对菜单中可以创建的八个类型进行讲解 在文件管理器中打开，可以快速打开文件管理器查看文件 复制UUID，可以查看资源的UUID属性，后续IDE会提供通过UUID查找资源的功能 重命名和删除，对文件的基本操作 重新导入，通常用于导入失败，或者有些外部依赖更改了，比如模型里有个材质，材质引用了外部贴图，但一开始贴图没放进来，后来放进来了，可以使用此功能 在代码编辑器中打开，可以直接打开代码编辑器查看文件信息 1.4 2D图片编辑成SpriteTexture 2D图片资源，assets目录下，默认会作为3D模型的纹理格式，在2D界面开发中，通常要改为2D的图片格式，需要开发者自行编辑。 如图1-6所示，这是一张有透明通道的png图片 （图1-6） 点击图片，看下属性设置，如图1-7所示 （图1-7） Default：默认情况下，图片作为3D模型的Texture贴图文件，只能用在材质球上。 SpriteTexture：图片作为2D的Sprite对象的图片纹理格式，通常在2D开发中使用。此属性在图片资源按照官方的命名规则去命名的时候自动为Sprite Texture，否则就是Default，会导致资源显示异常。 在不改变图片类型的情况下，将这张图作为2D图片在Image组件中使用并运行，页面背景是蓝色，如图1-8所示 （图1-8） 可以看到图中绿色区域有白色毛边，因此需要更改设置，作为 SpriteTexture 并勾选 Alpha Channel ，如图1-9所示 （图1-9） 再看看运行效果，如图1-10所示 （图1-10） 二、快速创建文件 快速创建文件有两种快速方式 点击 + 快速创建 点击空白处快速创建 1，快速创建是方便开发者可以快速创建特殊类型文件的方式，如动图2-1所示 （动图2-1） 2，点击项目资源面板中的空白处，选择创建，也可以做到快速创建，如动图2-2所示 （动图2-2） 3，这里快速创建的文件只会在assets目录下，如果想放到某个目录中，可以拖住文件放入，如动图2-3所示 （动图2-3） 2.1 创建文件夹 如图2-3所示，在快速创建菜单中，点击“文件夹”会在assets下创建一个文件夹，并可以修改文件夹名字 （图2-3） 2.2 创建预制体 在快速创建菜单中，点击“预制体2D”和“预制体3D”会创建预制体文件 2.2.1 预制体2D 如图2-4所示，创建预制体2D后，点击后打开，预制体只有一个Box根节点，用于2D开发 （图2-4） 同时，我们也可以更改Box组件为Dialog组件，如动图2-5所示 （动图2-5） Dialog是弹窗面板，可以通过设置来实现弹窗效果 2.2.2 预制体3D 如图2-6所示，创建预制体3D后，点击后打开，预制体只包括Sprite3D对象，用于3D对象开发 （图2-6） 通常3D预制体用来创建可以重复使用的3D节点对象，比如场景中的主角，敌人等等 2.3 创建场景（scene） 如图2-7所示，在快速创建菜单中，点击“scene”会在assets下快速创建一个场景 （图2-7） 2.4 创建着色器 2.4.1 着色器 如图2-8所示，在快速创建菜单中，点击“着色器”会选择创建五种类型的shader文件 （图2-8） 通过创建shader，开发者可以对shader进行修改成自定义的shader使用，如图2-9所示 （图2-9） 2.4.2 着色器蓝图 如图2-10所示，在快速创建菜单中，点击“着色器蓝图”会在assets下快速创建一个着色器蓝图文件 （图2-10） 双击蓝图文件，可以通过可视化窗口来编辑 （图2-11） 2.4.3 着色器蓝图函数 如图2-12所示，在快速创建菜单中，点击“着色器蓝图函数”会在assets下快速创建一个着色器蓝图函数文件 （图2-12） 双击蓝图函数文件，可以通过可视化窗口来编辑 （图2-13） 2.5 创建材质及配置 2.4.1 材质文件 如图2-14所示，在快速创建菜单中，点击“Material”会选择创建八种类型的材质文件 （图2-14） 通过创建Material，开发者可以对材质进行修改，方便快速使用 2.5.2 TexturCube 如图2-15所示，在快速创建菜单中，点击“TexturCube”会在assets下快速创建一个TexturCube文件 （图2-15） 点击Cubemap文件，可以配置 （图2-16） 通常Cubemap文件，用于配置天空盒的贴图，如图2-17所示 （图2-17） 具体如何使用TextureCube，开发者请参考《3D场景环境设置》中的天空盒的详细讲解 2.4.3 RenderTexture 如图2-18所示，在快速创建菜单中，点击“RenderTexture”会在assets下快速创建一个RenderTexture文件 （图2-18） RenderTexture渲染纹理，用于将3D场景渲染到2D纹理中，混合2D开发使用，如动图2-19所示 （图2-19） 具体如何使用RenderTexture，开发者请参考 [《混合使用3D》]: https://layaair.layabox.com/3.x/doc/IDE/uiEditor/use3D/readme.html 中的详细讲解 2.4.4 AvatarMask 如图2-20所示，在快速创建菜单中，点击“AvatarMask”会创建AvatarMask文件 （图2-20） 通过创建AvatarMask，开发者可以用来描述动画层遮罩 2.6 创建图片类型 2.6.1 灯光设置 如图2-21所示，在快速创建菜单中，点击“灯光设置”会创建LightingSettings文件 （图2-21） 通过创建LightingSettings，开发者可以设置光照属性，用来烘焙光照贴图 （图2-22） 具体如何使用灯光设置，开发者请参考《3D场景环境设置》中关于烘焙光照贴图的详细讲解 2.6.2 自动图集设置 如图2-23所示，在快速创建菜单中，点击“自动图集设置”会创建AtlasConfig文件 （图2-23） 通过创建AtlasConfig，开发者可以用来自动打包图集 具体如何使用自动打包图集，开发者请参考《Web发布》中关于图集打包的详细讲解 2.7 创建动画状态机 在快速创建菜单中，点击“动画状态机2D”和“动画状态机3D”会创建动画状态机。 2.7.1 2D动画状态机 如图2-24所示，创建动画状态机2D后，点击后打开 （图2-24） 2.7.2 3D动画状态机 如图2-25所示，创建动画状态机3D后，点击后打开 （图2-25） 动画状态机定义动画状态，以及动画状态之间的切换条件，来驱动对象播放不同的动画，表现出不同的行为。 具体如何使用动画状态机，开发者请参考《动画状态机详解》中的详细讲解 三、搜索面板 由于assets下资源会很多，通常最常用的方式是通过搜索查找 3.1 文字搜索 通过在搜索框中，输入“button”可以快速检索出Button组件，并可快速拖入2D场景中，如动图3-1所示 （动图3-1） 3.2 类型搜索 通过点击类型搜索按钮，选择文件类型，比如选择“LightingSettings”，可以快速检索出所有灯光设置文件，如动图3-2所示 （动图3-2） 四、目录设置面板 4.1 两栏显示 在开发过程中，往往在目录中的文件太多，对目录的反复浏览会比较繁琐，通过点击“两栏显示”按钮，可以解决，如图4-1所示 （动图4-1） 4.2 全部折叠 如果打开的目录太多，开发者可以通过点击“全部折叠”来关闭所有的目录，恢复到只有assets和src目录，如动图4-2所示 （动图4-2） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-05-11 21:27:15 "},"basics/IDE/shortcutKeyCombinations/readme.html":{"url":"basics/IDE/shortcutKeyCombinations/readme.html","title":"IDE快捷键与鼠标交互操作大全","keywords":"","body":"IDE快捷键与鼠标交互操作大全一、通用的基础交互1.1 切换面板显示层级1.2 文件与节点的通用操作1.3 层级面板的常用操作1.4 层级与场景的通用操作1.5 运行预览功能1.6 属性面板操作二、2D场景视窗交互三、3D场景视窗交互3.1 操作视窗摄像机3.2 操作模型四、时间轴动画编辑快捷键4.1 时间轴帧面板的快捷键4.2 时间轴曲线面板的快捷键五、蓝图编辑器快捷键5.1 生成节点快捷键5.2 蓝图鼠标交互IDE快捷键与鼠标交互操作大全 Author: charley IDE的基础交互分为键盘输入、快捷键、鼠标交互、鼠标与键盘的功能组合， 本篇将介绍IDE的基础交互，了解全部的功能键组合，充分发挥双手的优势，提升开发效率。 文档中的按键均以windows系统键盘为例，Mac系统键盘的Command对应ctrl键，不再单独说明。 一、通用的基础交互 层级面板、属性面板、项目面板等，都是各块功能几乎都能用到的地方，所以我们先介绍这些通用的基础交互。 1.1 切换面板显示层级 IDE的功能面板，开发者可任意拖拽布局，当处于同一个窗口时，就会根据面板标签的点击切换来决定显示的层级。如动图1所示。 (动图1) 除了点击面板标签来切换，我们还可以用如下快捷键来切换一些常用的面板： 功能名称 操作 场景面板Scene Ctrl + 1 运行面板Game Ctrl + 2 属性面板Inspector Ctrl + 3 层级面板Hierarchy Ctrl + 4 项目面板Project Ctrl + 5 控制台面板Console Ctrl + 6 时间轴面板Timeline Ctrl + 7 1.2 文件与节点的通用操作 重命名：F2 无论是节点的名字还是文件与文件夹，使用快捷键F2即可可进入重命名模式 如果是鼠标操作，单击选中后间隔半秒再单击，也等同于F2。 1.2.2 复制、粘帖、删除、选中 无论是在层级面板、项目面板、场景面板，选中节点对象或文件，即可用以下快捷键操作： 功能名称 操作 拷贝 Ctrl + C 粘贴 Ctrl + V 删除 Delete 全选 Ctrl + A 选中单个 鼠标左键单击 多选 Ctrl + 鼠标左键单击 不间断多选 Shift + 鼠标左键单击 1.3 层级面板的常用操作 1.3.1 创建空节点 除了通过鼠标右键菜单创建节点，还可以用以下快捷键，快速创建空节点。 功能说明 操作 在根节点下，创建一个空子节点 Ctrl + shift + N 为选中的当前节点，创建一个空子节点 Alt + shift + N 为选中的当前节点（可多选），创建一个空父节点 Ctrl + shift + G 2D的空节点是Sprite，3D的空节点是Sprite3D 1.3.2 展开全部子节点：Alt + 鼠标左键单击 正展情况下，单击节点前的三角箭头，会展开一层子节点。 当使用 Alt + 鼠标左键单击 的组合功能键后，可直接展开其下的所有层级节点，效果如动图2所示。 (动图2) 1.3.3 层级面板的顺序调整 拖拽为目标节点的下级节点 当选中某个节点持续按住鼠标左键，将该节点拖拽到目标节点上，目标节点呈现绿色矩形框时，松开鼠标左键，即可成为目标节点的子节点，效果如动图3-1所示。 (动图3-1) 拖拽为目标节点同级之后 当选中某个节点持续按住鼠标左键，将该节点拖拽到目标节点上，绿色线条位于目标节点下方时，松开鼠标左键，可改变该节点位置到目标节点同层级的后面。效果如动图3-2所示。 (动图3-2) 拖拽为目标节点同级之前 当选中某个节点持续按住鼠标左键，将该节点拖拽到目标节点上，绿色线条位于目标节点上方时，松开鼠标左键，可改变该节点位置到目标节点同层级的前面。效果如动图3-3所示。 (动图3-3) 需要注意的是，2D节点只能在Scene2D下任意拖拽，3D节点只能在Scene3D下任意拖拽，2D与3D节点不可拖到对方的节点下。 1.4 层级与场景的通用操作 1.4.1 3D节点的视窗聚焦：F 无论是层级面板还是场景中，选中节点后，使用快捷键F，即可实现视窗摄像机对该节点的聚焦。效果如动图4所示。 （动图4） 鼠标左键双击3D节点，也可实现视窗摄像机对该节点的聚焦。 1.4.2 复制并粘贴节点：Ctrl + D 无论是2D节点还是3D节点，在层级面板或场景面板选中节点后，通过快捷键Ctrl + D，即可实现该节点的复制并粘贴。 1.5 运行预览功能 开发者在LayaAir IDE内编辑完成后，提供了三种运行预览方式，分别是的IDE内运行预览、浏览器内运行预览、手机扫码运行预览，按钮如图5所示。 (图5) 以上功能除了鼠标点击操作之外，还提供了如下快捷键： 功能说明 操作 IDE内运行预览 Ctrl + P 浏览器内运行预览 Ctrl + Shift + P 手机扫码运行预览 Ctrl + Shift + O 1.6 属性面板操作 1.6.1 属性数值滑动输入 当属性值是数字类型时，鼠标移动到输入框上，鼠标样式会转换为双向箭头样式， 此时可按箭头方向划动改变数值，也可点击直接输入框通过键盘输入。 1.6.2 属性保存：Ctrl + S 无论是在属性面板中改变属性，还是在场景中操作，都会导致属性值的变化。 如果确定改变，可通过快捷键 Ctrl + S进行保存。 保存是全局通用的，后面各功能针对保存都不再重复介绍。 二、2D场景视窗交互 当处于Scene2D节点或2D预制体节点时，会启动2D场景视图窗口。当前支持以下快捷键： 功能说明 操作 平移视图舞台 中键长按拖拽、右键长按拖拽 上下滚动视窗内容 鼠标滚轮 缩放视窗内容 Ctrl + 鼠标滚轮 效果如动图6所示： (动图6) 三、3D场景视窗交互 3D场景中，主要是两大类基础操作。 一是，改变场景视窗的摄像机位置与角度，让开发者如同自己的眼睛一样观察3D场景世界。 二是，改变模型的位置与角度，将模型摆放到场景中适当位置。 3.1 操作视窗摄像机 3.1.1 旋转视窗摄像机：鼠标右键 在3D场景中，只要持续按住鼠标右键即进入视窗摄像机的旋转模式，松开鼠标右键即退出视窗摄像机旋转模式。 在该模式下，在屏幕方向上移动鼠标，可以改变视窗摄像机的角度，对整个场景的任意角度进行观察，效果如动图7-1所示。 (动图7-1) 3.1.2 空间位移视窗摄像机： 当按住鼠标右键 + 键盘功能键，可以让摄像机按上下左右前后，具体功能键如下： 功能说明 操作 摄像机向上位移 鼠标右键 + E 摄像机向下位移 鼠标右键 + Q 摄像机向左位移 鼠标右键 + A 摄像机向右位移 鼠标右键 + D 摄像机向前位移 鼠标右键 + W 摄像机向后位移 鼠标右键 + S 位移视窗摄像机的效果如动图7-2所示。 (动图7-2) 上下前后左右，是一个相对的方向，无论旋转到任何角度，都会按这个相对的方向进行位移。 位移视窗摄像机加速： 在位移视窗摄像机的基础上，按住Shift叠加，可以在原功能基础上进行加速移动。 操作按键为：鼠标右键 + shift + (E、Q、A、D、W、S) 3.1.3 屏幕内位移视窗摄像机：Q \\ 鼠标中键 除了采用鼠标右键 + 键盘功能键（E、Q、A、D）实现视窗摄像机上下左右的位移外，还可以通过快捷键Q或鼠标中键来启动屏幕任意方向位移。 使用快捷键Q时，鼠标左键按下并拖拽，即可实现视窗摄像机在屏幕任意方向位移，效果如动图7-3所示。 (动图7-3) 要想退出该模式，则需要通过其它模式的快捷键，除非是需要持续不断的采用该模式位移视窗摄像机。否则更建议采用鼠标中键来启动屏幕任意方向位移。 鼠标中键的方式，只有在按下并拖拽时才会进入该模式，松开鼠标中键会自动回到其它模式。 3.1.4 视窗摄像机缩放：鼠标滚轮 视窗摄像机缩放本质上就是视窗摄像机的前后位移，只因在位移过程中，观察目标时基于近大远小的透视原理，有种缩放的错觉，所以称为缩放视窗摄像机。效果如动图7-4所示， (动图7-4） 3.1.5 视窗摄像机绕焦点中心旋转：Alt + 左键拖拽 在观察或操作具体某个模型时，我们可能需要找一个非正面的合适角度。此时，之前介绍的方式都不太方便。所以围绕目标进行任意旋转是最适合的操作。 要旋转视窗摄像机之前，我们首先要做的事，就是聚焦，将模型处于视窗摄像机的中心位置。 聚焦的快捷键为F，前文1.4.1已进行介绍。 聚焦后，通过Alt + 左键的组合，左键向任意角度拖拽，即可实现绕焦点中心旋转，效果如动图7-5所示， (动图7-5) 3.2 操作模型 操作模型的工具有四种，分别是位移、旋转、缩放、混合使用。可以通过快捷键 W、E、R、T进行启动不同的工具模式。 快捷键名称 按键 模型位移工具 W 模型旋转工具 E 模型缩放工具 R 混合编辑模型 T 3.2.1 模型位移工具：W 通过快捷键W进入模型位移工具模式后，模型上会出现红绿蓝三色的轴和片。 红绿蓝三个轴分别代表X、Y、Z三个方向，轴的颜色与右上角的坐标轴对应。 箭头所指的方向为正方向，拖动其中一个轴，可使该模型按该轴的正负方向进行位移，效果如动图8-1所示。 (动图8-1) 留意属性面板，如果该模型没有任何旋转（rotation都为0），拖动其中一个轴，只有该轴的属性值会发生变化 。如果有旋转，则会影响其它轴属性值。 三个相邻的面，蓝色为XY面、绿色XZ面、红色为YZ面。 拖动其中一个面，可使该模型在该面范围内任意位移，效果如动图8-2所示。 (动图8-2) 3.2.2 模型旋转工具：E 通过快捷键E进入模型旋转工具模式后，模型上出现红绿蓝三色的交叉弧线和外层白圈，当鼠标划到模型上时，还会出现一个半透明圆。 红绿蓝三色的弧线分别代表X、Y、Z三个轴的方向，颜色与右上角的坐标轴对应。 选中其中一个弧线后，会变成完整的圆圈，代表按该该轴方向进行旋转，效果如动图9-1所示。 (动图9-1) 外层白圈，是基于屏幕的垂直旋转，效果如动图9-2所示。 (动图9-2) 如果鼠标在半透明圆拖拽，则可以任意角度旋转，效果如动图9-3所示。 (动图9-3) 3.2.3 模型缩放工具：R 通过快捷键R进入模型缩放工具模式后，模型上不仅有红绿蓝三色轴，还有中心白块和外层白色圆圈。 红绿蓝三色轴分别代表X、Y、Z三个轴的方向，拉动其中一个轴，可在该轴对模式进行缩放，效果如动图10-1所示。 (动图10-1） 中心的白块与外层白色圆圈均是三轴同时缩放，两者的区别仅是缩放速率差异，效果如动图10-2所示。 (动图10-2） 3.2.4 模型工具集合：T 通过快捷键T进入模型工具集合后，前文介绍的模型操作工具，都会集合到一起。 唯一需要注意的是，混合模式下，中心块缩放不再保留，只能通过外层白色圆圈整体缩放，以及通过拉动各轴的方块从单轴方向缩放，效果如动图11所示。 (动图11) 3.2.5 模型的多选 多选的方式分别是框选、Shift、Ctrl这几种方式。 模型的框选，就是通过鼠标拉起屏幕矩形区，只要在矩形区内，无论远近都会被选中。 除了框选，也可以通过Shift或Ctrl结合鼠标点击，进行连续多选。 无论是单选，还是多选，选中的模型都会出现红色边框。 四、时间轴动画编辑快捷键 4.1 时间轴帧面板的快捷键 功能说明 按键 插入空白帧 F5 删除空白帧 Shift + F5 删除关键帧 Delete 复制关键帧 Ctrl + C 粘贴关键帧 Ctrl + V 当鼠标处于时间轴帧面板操作时，纵向滚动显示属性 Ctrl+滚轮 4.2 时间轴曲线面板的快捷键 功能说明 按键 锁定帧刻度面板（不缩放），以鼠标指针为中心，无限制缩放属性刻度面板的精度。 Ctrl+滚轮 锁定属性刻度面板（不缩放），以鼠标指针为中心，无限制缩放帧刻度面板的精度。（无限制缩放会导致当缩放拉伸到0帧可见时，不再以缩放前的鼠标指标为中心进行缩放）。 Alt+滚轮 锁定锁定属性刻度面板（不缩放），以鼠标指针为中心，有限制缩放帧刻度面板的精度。（始终保持以鼠标指针为中心进行缩放，当缩放拉伸至0帧可见时，禁止刻度精度缩小，只允许刻度精度放大） Alt+Shift+滚轮 持续按住Shift键，可以使得移动关键帧，始终保持水平方向位移，单个与批量移动均有效。 Shift 持续按住Ctrl键，可以使得移动关键帧，始终保持垂直方向位移，单个与批量移动均有效。 Ctrl 由于时间轴动画相关，有详细的文档说明，这里不再展开介绍，想了解更多，请移步时间轴动画编辑文档。 五、蓝图编辑器快捷键 5.1 生成节点快捷键 当长按键盘上的快捷键，再鼠标左键点击，即可快捷生成不同类型的蓝图节点。 功能说明 快捷组合键 快速生成Float节点1 1 + 鼠标左键 快速生成Vector2节点 2 + 鼠标左键 快速生成Vector3节点 3 + 鼠标左键 快速生成Vector4节点 4+ 鼠标左键 快速生成Int节点 i + 鼠标左键 快速生成Boolean节点b b + 鼠标左键 快速生成Time节点 t + 鼠标左键 5.2 蓝图鼠标交互 功能说明 按键 整体移动蓝图节点 鼠标中键\\右键 按下拖拽 整体缩放蓝图节点 鼠标滚轮 由于蓝图编辑器相关，有详细的文档说明，这里不再展开介绍，想了解更多，请移步蓝图编辑器文档。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:14 "},"basics/common/readme.html":{"url":"basics/common/readme.html","title":"引擎通用基础","keywords":"","body":"引擎通用基础引擎通用基础 引擎通用基础是指无论是2D项目还是3D项目，都会使用到的引擎基础功能 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"basics/common/terms/readme.html":{"url":"basics/common/terms/readme.html","title":"引擎基础概念","keywords":"","body":"引擎使用的基础概念一、画布二、舞台三、对象四、节点、显示列表、显示对象、容器对象引擎使用的基础概念 Author : Charley 一、画布 画布就是浏览器的canvas，如图1所示： （图1） LayaAir引擎游戏的所有可见画面，都是一帧一帧的绘制出来，连续播放显示的结果。每秒播放的画面帧数代表着游戏是否流畅的性能指标。而画布是引擎每一帧绘图显示的容器，没有了画布，如同画家没有了画纸，不可能凭空作画。 帧数越高画面越流畅，通常是60帧是满帧，但设备的不同会有所差异，有的机型上可以达到90帧满帧或者120帧满帧。 LayaAir画布的大小，取决于我们游戏自己设置的设计宽高以及LayaAir引擎中屏幕适配，如图2所示， (图2) 在不同机型分辨率下，会导致画布大小可能有所变化。这些知识，在屏幕适配的文档会展开介绍。 二、舞台 舞台是引擎的Stage，是LayaAir引擎用来在画布上绘制游戏画面以及交互事件反馈的实际区域。 可以想象一下，一个画家，在一张纸上（画布）只在中心区域作画，还是只留出一点边，或者把整张纸画满。这个规划在引擎里就可以理解为舞台的大小。 游戏中的画面实际上是受限于引擎的舞台，如果舞台不是全屏，光画布全屏，超出舞台的部分也是显示不出来的。如果把设备比喻成桌子，画布是画纸，即便是画纸铺满整个桌子，但是如果规定画家，只能在某一块区块作画，那画家在作画时就不会超出那个区域。所以，对于有全屏适配需求的游戏，不光要让画布的大小达到全屏的大小，也要让舞台的大小占满画布的大小。 舞台的大小，也与设计宽高以及屏幕适配有关，上面那个适配文档同样适用于想深入理解舞台这个概念的同学。 三、对象 对于有编程知识的同学，都能理解，在面向对象编程中，对象是类的实例。 从广义上理解，具有属性结构的数据或者可以设置属性的数据结构，也可以称为对象，例如json对象和空对象{}。 四、节点、显示列表、显示对象、容器对象 LayaAir引擎中，Node（节点）类是可放在显示列表中的所有对象的基类，2D的基础精灵Sprite与3D的基础精灵Sprite3D都继承于Node，不仅于此，所有继承于Node的子类或孙类，也可称为节点，例如：Sprite节点，Image节点。 只有继承于Node的子类或孙类的节点对象，才可以添加子节点对象。 节点中，图片、文字、动画、模型等这种可见的对象为显示对象。有的节点本身不负责渲染显示，仅仅是用于挂载子节点，这种对象称为容器对象。例如Sprite、Sprite3D、Box、等。 Sprite比较特别，当添加了纹理资源后，就是显示对象。不添加纹理，只是用于挂载子节点时，就是容器对象。 显示列表是一个抽象的概念，显示列表可以理解为基于舞台的节点树，无论是显示对象还是容器对象，都在显示列表内。 显示列表用于管理 LayaAir运行时显示的所有对象。需要注意的是，继承自Node的两个子类Sprite与Sprite3D分别是2D的基础显示对象和3D的基础显示对象。两者不能混合添加，也就是说Sprite及其子节点不能作为Sprite3D的子节点，Sprite3D及其子节点不能作为Sprite的子节点。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"basics/common/Component/readme.html":{"url":"basics/common/Component/readme.html","title":"实体组件系统","keywords":"","body":"实体组件系统（ECS）一、 什么是ECS二、组件脚本的内置方法2.1 组件的生命周期方法2.2 组件的事件方法三、组件在IDE的暴露方式3.1 组件脚本的识别@regClass()3.2 组件属性的识别@property()3.3 IDE中执行生命周期方法@runInEditor3.4 加入IDE的组件列表@classInfo()四、代码中使用属性4.1 节点类型方式4.2 组件类型的使用4.3 Prefab类型属性实体组件系统（ECS） Author：Charley 、谷主、孟星煜 一、 什么是ECS ECS是Entity-Component-System（实体-组件-系统）的简写，这是一种基于数据驱动的游戏设计模式。 LayaAir的ECS，将场景中每一个有着唯一ID的显示对象节点都被看做一个个的实体。每一个实体都可以为其添加一个或多个不同的组件系统脚本。 在这里，组件系统是组件与系统两个组成部分，组件只包含数据，不包含逻辑，游戏对象的逻辑行为由系统控制，所以系统是实体的逻辑控制部分，组件是系统与外界的数据接口部分。LayaAir通过装饰器将接口暴露在IDE中，方便开发者直观的传入数据。引擎为组件系统提供的生命周期方法与事件方法可以作为系统逻辑控制的入口。 开发者通过继承引擎的组件脚本类Laya.Script，可以实现组件系统脚本的完整功能，我们通常将组件系统脚本简称为组件脚本。然后通过IDE或者代码的方式添加到实体上，实现完整的ECS功能。 组件脚本，在原则上是解耦且具有单一职责的，这样方便多个实体可以共用同一个组件系统。 二、组件脚本的内置方法 继承引擎的组件脚本类Laya.Script之后，就可以直接使用引擎为组件脚本提供内置的生命周期方法与事件方法，这些方法可以用于组件脚本逻辑的执行入口。如下图所示： （图2-1）组件脚本的生命周期方法 2.1 组件的生命周期方法 生命周期方法是指在物体的创建、销毁、激活、禁用等过程中，会自动调用的方法。当使用自定义的组件脚本时，可以实现如下生命周期方法，方便快速开发业务逻辑。可以在每个方法中打印一条日志，方便开发者进行测试。 名称 条件 onAdded 被添加到节点后调用，和Awake不同的是即使节点未激活onAdded也会调用 onReset 重置组件参数到默认值，如果实现了这个函数，则组件会被重置并且自动回收到对象池，方便下次复用。如果没有重置，则不进行回收复用 onAwake 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onEnable 组件被启用后执行，比如节点被添加到舞台后 onStart 第一次执行onUpdate之前执行，只会执行一次 onUpdate 每帧更新时执行，尽量不要在这里写大循环逻辑或者使用getComponent方法 onLateUpdate 每帧更新时执行，在onUpdate之后执行，尽量不要在这里写大循环逻辑或者使用getComponent方法 onPreRender 渲染之前执行 onPostRender 渲染之后执行 onDisable 组件被禁用时执行，比如从节点从舞台移除后 onDestroy 手动调用节点销毁时执行 在代码中的使用如下： //被添加到节点后调用，和Awake不同的是即使节点未激活onAdded也会调用 onAdded(): void { console.log(\"Game onAdded\"); } //重置组件参数到默认值，如果实现了这个函数，则组件会被重置并且自动回收到对象池，方便下次复用。如果没有重置，则不进行回收复用 onReset(): void { console.log(\"Game onReset\"); } //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { console.log(\"Game onAwake\"); } //组件被启用后执行，比如节点被添加到舞台后 onEnable(): void { console.log(\"Game onEnable\"); } //第一次执行update之前执行，只会执行一次 onStart(): void { console.log(\"Game onStart\"); } //每帧更新时执行，尽量不要在这里写大循环逻辑或者使用getComponent方法 onUpdate(): void { console.log(\"Game onUpdate\"); } //每帧更新时执行，在update之后执行，尽量不要在这里写大循环逻辑或者使用getComponent方法 onLateUpdate(): void { console.log(\"Game onLateUpdate\"); } //渲染之前执行 onPreRender(): void { console.log(\"Game onPreRender\"); } //渲染之后执行 onPostRender(): void { console.log(\"Game onPostRender\"); } //组件被禁用时执行，比如从节点从舞台移除后 onDisable(): void { console.log(\"Game onDisable\"); } //手动调用节点销毁时执行 onDestroy(): void { console.log(\"Game onDestroy\"); } 下面以“2D入门示例”中的一个子弹脚本Bullet.ts为例，讲解生命周期方法，以下是此脚本文件的代码： const { regClass, property } = Laya; /** * 子弹脚本，实现子弹飞行逻辑及对象池回收机制 */ @regClass() export default class Bullet extends Laya.Script { constructor() { super(); } onEnable(): void { //设置初始速度 let rig: Laya.RigidBody = this.owner.getComponent(Laya.RigidBody); rig.setVelocity({ x: 0, y: -10 }); } onTriggerEnter(other: any, self: any, contact: any): void { //如果被碰到，则移除子弹 this.owner.removeSelf(); } onUpdate(): void { //如果子弹超出屏幕，则移除子弹 if ((this.owner as Laya.Sprite).y 在游戏中，将子弹添加到舞台上时，每次添加到舞台都得有初速度，但如果将onEnable()换成onAwake()，那么这个初速度就会失效。onUpdate()是每帧执行一次，子弹超出屏幕，则移除子弹，此处的 if 条件判断是每一帧都会判断一次。onDisable()是节点从舞台移除后触发，当子弹超出屏幕被移除时，就触发这个方法，这里是回收子弹到对象池了。 2.2 组件的事件方法 事件方法是指在某些特定的情况下，会根据条件自动触发的方法，例如碰撞事件只有在物体发生碰撞时才会触发。当使用自定义的组件脚本时，可以实现如下事件方法，方便快速开发业务逻辑。 2.2.1 物理事件 名称 条件 onTriggerEnter 开始触发时执行 onTriggerStay 持续触发时执行 onTriggerExit 结束触发时执行 onCollisionEnter 开始碰撞时执行 onCollisionStay 持续碰撞时执行 onCollisionExit 结束碰撞时执行 在代码中的使用如下： //开始触发时执行 onTriggerEnter(other: Laya.PhysicsComponent | Laya.ColliderBase, self?: Laya.ColliderBase, contact?: any): void { } //持续触发时执行 onTriggerStay(other: Laya.PhysicsComponent | Laya.ColliderBase, self?: Laya.ColliderBase, contact?: any): void { } //结束触发时执行 onTriggerExit(other: Laya.PhysicsComponent | Laya.ColliderBase, self?: Laya.ColliderBase, contact?: any): void { } //开始碰撞时执行 onCollisionEnter(collision: Laya.Collision): void { } //持续碰撞时执行 onCollisionStay(collision: Laya.Collision): void { } //结束碰撞时执行 onCollisionExit(collision: Laya.Collision): void { } 下面以一个小球碰撞的例子，演示物理事件。以下是程序中碰撞部分的代码片段： //碰撞进入后，物体改变颜色 public onTriggerEnter(other:Laya.PhysicsComponent):void { (this.owner.getComponent(Laya.MeshRenderer).material as Laya.BlinnPhongMaterial).albedoColor = new Laya.Color(0.0, 1.0, 0.0, 1.0);//绿色 } //持续碰撞时，打印日志 public onTriggerStay(other:Laya.PhysicsComponent):void { console.log(\"peng\"); } //碰撞离开后，物体变回原本颜色 public onTriggerExit(other:Laya.PhysicsComponent):void { (this.owner.getComponent(Laya.MeshRenderer).material as Laya.BlinnPhongMaterial).albedoColor = new Laya.Color(1.0, 1.0, 1.0, 1.0);//白色 } 如动图2-2所示，开始碰撞时执行onTriggerEnter，小球和立方体进入碰撞，小球变为绿色；持续碰撞时执行onTriggerStay，打印日志“peng”；碰撞离开后执行onTriggerExit，小球变为原来的颜色，立方体变为白色。 （动图2-2） 2.2.2 鼠标事件 名称 条件 onMouseDown 鼠标按下时执行 onMouseUp 鼠标抬起时执行 onRightMouseDown 鼠标右键或中键按下时执行 onRightMouseUp 鼠标右键或中键抬起时执行 onMouseMove 鼠标在节点上移动时执行 onMouseOver 鼠标进入节点时执行 onMouseOut 鼠标离开节点时执行 onMouseDrag 鼠标按住一个物体后，拖拽时执行 onMouseDragEnd 鼠标按住一个物体，拖拽一定距离，释放鼠标按键后执行 onMouseClick 鼠标点击时执行 onMouseDoubleClick 鼠标双击时执行 onMouseRightClick 鼠标右键点击时执行 在代码中的使用如下： //鼠标按下时执行 onMouseDown(evt: Laya.Event): void { } //鼠标抬起时执行 onMouseUp(evt: Laya.Event): void { } //鼠标右键或中键按下时执行 onRightMouseDown(evt: Laya.Event): void { } //鼠标右键或中键抬起时执行 onRightMouseUp(evt: Laya.Event): void { } //鼠标在节点上移动时执行 onMouseMove(evt: Laya.Event): void { } //鼠标进入节点时执行 onMouseOver(evt: Laya.Event): void { } //鼠标离开节点时执行 onMouseOut(evt: Laya.Event): void { } //鼠标按住一个物体后，拖拽时执行 onMouseDrag(evt: Laya.Event): void { } //鼠标按住一个物体，拖拽一定距离，释放鼠标按键后执行 onMouseDragEnd(evt: Laya.Event): void { } //鼠标点击时执行 onMouseClick(evt: Laya.Event): void { } //鼠标双击时执行 onMouseDoubleClick(evt: Laya.Event): void { } //鼠标右键点击时执行 onMouseRightClick(evt: Laya.Event): void { } 下面以onMouseDown和onMouseUp为例，在自定义的组件脚本“Script.ts”中加入以下代码： const { regClass, property } = Laya; @regClass() export class Script extends Laya.Script { /** * 鼠标按下时执行 */ onMouseDown(evt: Laya.Event): void { console.log(\"onMouseDown\"); } /** * 鼠标抬起时执行 */ onMouseUp(evt: Laya.Event): void { console.log(\"onMouseUp\"); } } 如图2-3所示，将组件脚本添加到Scene2D的属性面板后，先不勾选 Mouse Through，因为如果勾选它，Scene2D下鼠标事件将不会响应。如果是一个3D场景，它会传递到Scene3D中。 （图2-3） 运行项目，如动图2-4所示，当鼠标按下时执行onMouseDown，打印“onMouseDown”；松开鼠标，鼠标弹起时执行onMouseUp，打印“onMouseUp”。 （动图2-4） 2.2.3 键盘事件 名称 条件 onKeyDown 键盘按下时执行 onKeyPress 键盘产生一个字符时执行 onKeyUp 键盘抬起时执行 在代码中的使用如下： //键盘按下时执行 onKeyDown(evt: Laya.Event): void { } //键盘产生一个字符时执行 onKeyPress(evt: Laya.Event): void { } //键盘抬起时执行 onKeyUp(evt: Laya.Event): void { } 注意：onKeyPress是产生一个字符时执行，例如字母“a”、“b”，“c”等。像上、下、左、右键，F1、 F2等不是字符输入的按键，就不会执行此方法。 三、组件在IDE的暴露方式 在LayaAir 3.0 IDE中，如果想在IDE内展示组件脚本的属性，需要通过装饰器的规则来实现。 3.1 组件脚本的识别@regClass() 开发者编写的组件脚本，需要在类定义之前使用装饰器的标识@regClass()，示例代码如下所示： const { regClass } = Laya; @regClass() export class Script extends Laya.Script { } 如动图3-1所示，只有使用了上述的这个装饰器标识，开发者自定义的组件脚本才会被IDE识别为组件，可以被节点（实体）的属性设置面板 -> 增加组件 -> 自定义组件脚本所添加。 （动图3-1） 一个TS文件只能有一个类使用@regClass() 。 标记了@regClass()的类，在IDE环境内都会被编译，但最终发布时，如果这个类没有被其他类引用，也没有被添加到节点上，或者所在的预制体/场景没有发布，则这个类会被裁剪。 3.2 组件属性的识别@property() 3.2.1 组件属性的常规使用 当开发者想将组件的属性，通过IDE暴露给外界编辑来传入数据。需要在类属性定义之前使用装饰器的标识@property()，示例代码如下所示： const { regClass, property } = Laya; @regClass() export class NewScript1 extends Laya.Script { //装饰器属性的标准写法，适用于IDE的需要显示Tips或属性的中文别名等完整功能需求 @property({ type: String, caption: \"IDE显示用的别名\", tips: \"这是一个文本对象，只能输入文本哦\" }) public text1: string = \"\"; //装饰器属性类型的简写方式，适用于只定义类型的需求 @property(String) public text2: string = \"\"; constructor() { super(); } } @property()是IDE识别组件属性并显示到IDE属性面板上的装饰器标识，类型是装饰器属性标识必须携带的参数。 如果我们不需要给属性写一个tips说明，也不需要给属性重新定义一个在IDE里显示的别名，等需求。那按上面示例的简写方式即可。 如果简写方式有语法警告，请用新版本IDE，并通过IDE的开发者 -> 更新引擎d.ts文件功能来解决，或者使用标准写法来解决。 3.2.2 属性访问器的装饰器使用 有的时候，开发者会通过属性访问器(getter)和属性设置器(setter)来控制属性的读写行为。 当属性访问器和属性设置器同时存在时，装饰器的属性标识@property()直接用于属性访问器之前即可，此时的组件属性与上一小节中介绍的常规使用方式一样，都是可读写的。 如果，该脚本只有属性访问器，那这个属性则是只读的，仅可以在IDE中显示，但不能编辑。 getter和setter同时存在的装饰器使用示例代码如下： const { regClass, property } = Laya; @regClass() class Animal { private _weight: number = 0; @property( { type : Number } ) get weight() : number { return this._weight; } set weight(value: number) { this._weight = value; } } 3.2.3 是否序列化保存 通过装饰器定义为组件属性后，默认状态下，属性名与值都会被序列化保存到组件被添加的场景文件或预制体文件里。例如，scene.ls里添加完自定义组件，通过vscode打开这个scene.ls，可以找到序列化保存后的组件属性名称与值，效果如动图3-2所示。 （动图3-2） 序列化保存后，不仅方便在IDE中直观查看与编辑组件属性值。在运行阶段，也可以直接使用序列化存储的值，对于结构复杂的数据，直接使用序列化的值还可以节省数据结构生成带来的开销。所以，有些时候，即便是不需要在属性面板上显示与编辑，也可以通过装饰器设置为组件属性，将值序列化存储在场景或预制体文件中。 但是，也有的时候，我们的组件属性只是为了方便在IDE中理解与调整，在使用的时候，这些值其实用不到，所以，还提供了是否序列化保存的控制。当装饰器属性定义的时候，对象参数中传入serializable为false，那么该属性就不会被序列化。 例如，开发者的需求是序列化保存弧度值，但弧度值在人为调整数值的时候并不直观，此时，可以在IDE里直接输入角度值但不保存，仅将转换后的弧度值存起来。示例代码如下： const { regClass, property } = Laya; @regClass() export class Main extends Laya.Script { @property({ type: Number }) _radian: number = 0; //带下划线的属性，默认不会出现在IDE的属性面板上，只是用来存储输入的弧度 @property({ type: Number, caption: \"角度\", serializable: false }) //这里设置serializable为false，所以degree不会被保存到场景文件中 get degree() { return this._radian * (180 / Math.PI);//由于自己没有序列化保存，需要把_radian存下来的弧度反算回角度，用于IDE属性面板显示 } set degree(value: number) { this._radian = value * (Math.PI / 180);//把输入的角度值，转成弧度给_radian存起来。 } onStart() { console.log(this._radian); } } 3.2.4 组件属性是否在IDE中显示 在默认情况下，装饰器属性规则只会对非下划线的类属性标记为IDE的组件属性。 对于有下划线的属性，其实是不会被显示到IDE里，此时该组件属性的价值只剩下将值保存到场景文件中了，这一点上文有所提及，示例也有应用。 带下划线的属性如果没有序列化保存到场景文件的需求，那就不必使用装饰器了。 假如，开发者想对有下划线的属性，也要显示到IDE上，也可以做到。将修饰器属性标识的传入对象中，设置参数private为false即可。 示例代码如下： @property({ type: \"number\", private: false }) _velocity: number = 0; private参数不仅可以使得下划线属性显示，也可以通过将private设置为true，使得不带下划线的属性，不在IDE的属性面板出现。 这里，我们将前文的弧度转换示例稍作修改，代码如下： const { regClass, property } = Laya; @regClass() export class Main extends Laya.Script { @property({ type: Number , private: true }) radian: number = 0; //private设置为true之后，radian不会出现在IDE的属性面板上，只是用来存储输入的弧度 @property({ type: Number, caption: \"角度\", serializable: false }) //这里设置serializable为false，所以degree不会被保存到场景文件中 get degree() { return this.radian * (180 / Math.PI);//由于自己没有序列化保存，需要把radian存下来的弧度反算回角度，用于IDE属性面板显示 } set degree(value: number) { this.radian = value * (Math.PI / 180);//把输入的角度值，转成弧度给radian存起来。 } onStart() { console.log(this.radian); } } 3.2.5 装饰器属性标识的类型 装饰器属性标识的类型支持引擎对象类型（例如：Laya.Vector3、Laya.Sprite3D、Laya.Camera等）、自定义的对象类型（需要标记＠regClass()）、以及TS语言的基本类型。 3.2.5.1 引擎对象类型 引擎对象类型的理解比较简单，暴露组件属性之后，直接传入对应类型的值就可以。例如Laya.Sprite3D就只能传入3D节点，试图拖入2D节点或拖入资源都是禁止的。 常用的引擎对象类型使用示例如下： const { regClass, property } = Laya; @regClass() export class Main extends Laya.Script { @property( { type:Laya.Camera } ) //摄像机类型 private camera: Laya.Camera; @property( { type:Laya.Scene3D } ) //3D场景根节点类型 private scene3D: Laya.Scene3D; @property( { type:Laya.DirectionLightCom } ) //DirectionLight组件类型 private directionLight: Laya.DirectionLightCom; @property( { type:Laya.Sprite3D } ) //Sprite3D节点类型 private cube: Laya.Sprite3D; @property( { type:Laya.Prefab } ) //加载 Prefab 拿到的对象 private prefabFromResource: Laya.Prefab; @property( { type:Laya.ShurikenParticleRenderer } ) //ShurikenParticleRenderer组件类型 private particle3D: Laya.ShurikenParticleRenderer; @property( { type:Laya.Node } ) //节点类型 private scnen2D: Laya.Node; @property( { type:Laya.Box } ) //拿到 Box 组件 private box: Laya.Box; @property( { type:Laya.List } ) //拿到 List 组件 private list: Laya.List; @property( { type:Laya.Image } ) //拿到 Image 组件 private image: Laya.Image; @property( { type:Laya.Label } ) //拿到 Label 组件 private label: Laya.Label; @property( { type:Laya.Button } ) //拿到 Button 组件 private button: Laya.Button; @property( { type:Laya.Sprite } ) //拿到 Sprite 组件 private sprite: Laya.Sprite; @property( { type:Laya.Animation } ) //拿到 Animation 组件 private anmation: Laya.Animation; @property( { type:Laya.Vector3 } ) //Laya.Vector3类型 private vector3 : Laya.Vector3; } 如动图3-3所示，将场景中已经添加好的Image拖入到@property暴露的Image属性入口中，这样就获取到了此节点，然后可以在脚本中使用代码控制Image的属性了（参考4.1节）。 （动图3-3） 3.2.5.2 自定义对象类型 自定义对象类型，就是设置一个自定义的引入对象。按该对象的装饰器属性标识来暴露组件属性。 例如，下面这两个TS代码： //MyScript.ts const { regClass, property } = Laya; import Animal from \"./Animal\"; @regClass() export class MyScript extends Laya.Script { @property({ type : Animal }) animal : Animal; } //Animal.ts const { regClass, property } = Laya; @regClass() export default class Animal { @property({ type : Number }) weight : number; } 组件脚本MyScript中引用了Animal对象 ，并将装饰器属性标识的类型设置为Animal，尽管Animal不是继承于Laya.Script的组件脚本，但由于被组件脚本MyScript所引用并暴露给IDE，所以Animal类定义之前也需要标记＠regClass()，该类下使用了@property()标识的属性，也可以出现在IDE属性面板中。 3.2.5.3 TS语言基本类型 最后就是常用的TS语言基本类型，不过需要注意的是，基本类型需要使用字符串的方式来描述，只有数字、字符串、布尔类型，可以用其对象类型来标记。 类型 类型书写示范 类型说明 数字类型 \"number\" 也可以用Number来标记该类型 单行字符串文本类型 \"string\" 也可以用String来标记该类型 布尔值类型 \"boolean\" 也可以用Boolean来标记该类型 整数类型 \"int\" 等价于 { type: Number, fractionDigits: 0 } 正整数类型 \"uint\" 等价于 { type: Number, fractionDigits: 0 , min: 0 } 多行字符串文本类型 \"text\" 等价于 { type: string, multiline: true } 任意类型 \"any\" 类型只会被序列化，不能显示和编辑。 类型化数组类型 Int8Array、Uint8Array、Int16Array、Uint16Array、Int32Array、Uint32Array、Float32Array 支持7种类型化数组类型 数组类型 [\"number\"]、[\"string\"] 用中括号包含数组元素类型， 使用示例代码如下： const { regClass, property } = Laya; //枚举 enum TestEnum { A, B, C }; //字符串形式的枚举 enum Direction { Up = 'UP', Down = 'DOWN', Left = 'LEFT', Right = 'RIGHT' }; @regClass() export class Script extends Laya.Script { @property(Number)//数字类型，等价于{ type : \"number\" } num : number; @property(String)//单行字符串文本类型，等价于 { type: \"string\"} str : string; @property(Boolean)//布尔值类型，等价于 { type: \"boolean\"} bool : boolean; @property(\"int\")//整数类型，等价于 { type: Number, fractionDigits: 0 } int : number; @property(\"uint\") //正整数类型，等价于 { type: Number, fractionDigits: 0 , min: 0 } uint : number; @property(\"text\")//多行字符串文本类型，等价于 { type: String, multiline: true } text : string; @property(\"any\")//any类型只会被序列化，不能显示和编辑。 a : any; @property(Int8Array)//类型化数组类型,除了Int8Array，还支持Uint8Array、Int16Array、Uint16Array、Int32Array、Uint32Array、Float32Array，使用方式都类似 i8a: Int8Array; @property({ type: [\"number\"] })//数组类型，用中括号包含数组元素类型 arr1: number[]; @property({ type: [\"string\"] })//数组类型，用中括号包含数组元素类型 arr2: string[]; //普通的枚举类型（可以类型简写），会显示为下拉框供用户选择 @property(TestEnum) enum: TestEnum; //字符串形式的枚举，不能使用类型简写，如：@property(Direction)。必须下面带type参数指定的标准写法 @property({ type: Direction }) direc: Direction; //字典类型，需要用数组参数来设置类型，下面示例中的Record类型需要放到字符串内作为数组参数的第一个元素，数组参数的第二个元素是字典输入值的类型，用于决定属性面板的输入控件类型 @property({ type: [\"Record\", Number] }) dict: Record; } 示例效果如动图3-4所示： （动图3-4） 3.2.6 组件属性值的输入控件 IDE内置了number（数字输入）、string（字符串输入）、boolean（多选框）、color（颜色框+调色盘+拾色器）、vec2（XY输入组合）、vec3（XYZ输入组合）、vec4（XYZW输入组合）、asset（选择资源），这些输入控件。 通常情况下，IDE会根据组件属性类型自动选择对应的属性值输入控件。 但在某些情况下，也需要强制指定输入控件。例如，数据类型是string，但其实它表达的是颜色，用默认编辑string的控件不适合，需要在这里设置组件属性标识的参数inspector为“color”。示例代码如下： //显示为颜色输入（如果类型是Laya.Color，则不需要这样定义，如果是字符串类型，则需要） @property({ type: String, inspector: \"color\"}) color: string; 注意：按照以上方法得到的颜色，是2D组件的颜色值，例如：rgba(217, 232, 0, 1) 效果如动图3-5所示： （动图3-5） 如果inspector参数为null，则不会为属性构造属性输入控件，这与hidden参数设置为true不同。hidden为true是创建但不可见，inspector为null则是完全不创建。 3.2.7 组件属性分类与排序 组件的属性默认会统一显示在以组件脚本名称的属性分类栏目下，效果如图3-6所示： （图3-6） 如果开发者想对组件内的某些属性进行归类，可以通过装饰器属性标识的对象参数catalog来实现，示例代码如下： @property({ type : \"number\" }) a : number; @property({ type: \"string\"}) b : string; @property({ type: \"boolean\",catalog:\"adv\"}) c : boolean; @property({ type: String, inspector: \"color\" ,catalog:\"adv\"}) d: string; 通过上面的代码可以看出，当为多个属性（c和d）设置相同的catalog名称（“adv”），就会按catalog名称进行分类。效果如图3-7所示： （图3-7） 如果我们想给这个分类再起个中文别名，可以通过参数catalogCaption来实现，示例代码如下（更改上述示例的d属性）： @property({ type: String, inspector: \"color\" ,catalog:\"adv\", catalogCaption:\"高级组件\"}) d: string; 效果如图3-8所示： （图3-8） 在面对多个组件属性分类的时候，我们还可以通过参数catalogOrder对栏目的显示顺序自定义排序。数值越小显示在前面，不提供则按属性出现的顺序。示例代码如下： @property({ type : \"number\", catalog:\"bb\", catalogOrder:1 }) a : number; @property({ type: \"string\"}) b : string; @property({ type: \"boolean\", catalog:\"adv\"}) c : boolean; @property({ type: String, inspector: \"color\", catalog:\"adv\", catalogCaption:\"高级组件\", catalogOrder:0}) d: string; 效果如图3-9所示： （图3-9） 属性分类名称catalogCaption与属性分类排序catalogOrder，在任意一个catalog相同名称的属性里配置即可，无需所有的属性都配置一次。 3.2.8 装饰器属性标识参数总结 上文介绍了常用装饰器属性标识的参数作用（加粗为上文出现过的），这里我们概述总结一下全部的参数。 参数名 参数使用示例 说明 name name: \"abc\" 一般不需要设定 type type: \"string\" 组件属性可输入值的类型，参照上文的介绍 caption caption: \"角度\" 组件属性的别名，常用中文，可以不设置，默认会用组件属性名 tips tips: \"这是一个文本对象，只能输入文本哦\" 组件属性的Tips说明，用于进一步描述该属性的作用等用途 catalog catalog:\"adv\" 为多个属性设置相同的值，可以将它们显示在同一个栏目内 catalogCaption catalogCaption:\"高级组件\" 属性分类栏目的别名，不提供则直接使用栏目名称 catalogOrder catalogOrder:0 栏目的显示顺序，数值越小显示在前面。不提供则按属性出现的顺序 inspector inspector: \"color\" 属性值输入控件，内置有：number,string,boolean,color,vec2,vec3,vec4,asset hidden hidden: \"!data.a\" true隐藏，false显示。可以直接使用布尔值，也可以使用表达式，通过将条件表达式放到字符串里，获得布尔类型的运算结果 readonly readonly: \"data.b\" true表示只读。可以直接使用布尔值，也可以使用表达式，通过将条件表达式放到字符串里，获得布尔类型的运算结果 validator validator: \"if (value == data.text1) return '不能与text1值相同' \" 可以使用表达式，将表达式放到字符串里。例如示例中，若在IDE中输入的值和text1的值相等，就会显示”不能与text1值相同“ serializable serializable： false 控制组件属性是否序列化保存，true：序列化保存，false：不序列化保存 multiline multiline: true 字符串类型时，是否为多行输入，true：是，false：不是 password password: true 是否密码输入，true：是，false：不是。密码输入会隐藏输入的内容 submitOnTyping submitOnTyping: false 如果设置为true，那么每次输入一个字符，就会提交一次。如果设置为false，那么只有当输入完成后，并且点击其它地方，让文本输入框失去焦点时，才会提交一次。 prompt prompt: \"文本提示信息\" 在输入文本前，文本框内会有一个提示信息 enumSource enumSource: [{name:\"Yes\", value:1}, {name:\"No\",value:0}] 组件属性以下拉框的形式来展示与输入值 reverseBool reverseBool: true 反转布尔值，当属性值为true时，多选框显示为不勾选 nullable nullable: true 是否允许null值，默认为true min min: 0 数字类型时，数字的最小值 max max: 10 数字类型时，数字的最大值 range range: [0, 5] 数字类型时，组件属性在一个范围内以滑动杆的方式显示与输入值 step step: 0.5 数字类型时，在输入框的鼠标滑动或滚轮滚动的最小更改精度值 fractionDigits fractionDigits: 3 数字类型时，属性值的小数点后保留几位 percentage percentage: true 将range参数设置为[0,1]时，可以让percentage为true，显示为百分比 fixedLength fixedLength: true 数组类型时，固定数组长度，不允许修改 arrayActions arrayActions: [\"delete\", \"move\"] 数组类型时，可限制数组可以进行的操作。如果不提供，表示数组允许所有操作，如果提供，则只允许列出的操作。提供的类型有：\"append\"，\"insert\" ，\"delete\" ，\"move\" showAlpha showAlpha: false 颜色类型时，表示是否提供透明度a值的修改。true表示提供，false表示不提供 defaultColor defaultColor: \"rgba(217, 232, 0, 1)\" 颜色类型时，定义一个非null时的默认颜色值 colorNullable colorNullable: true 颜色类型时，设置为true可显示一个checkbox决定颜色是否为null isAsset isAsset: true 说明此属性是引用一个资源 assetTypeFilter assetTypeFilter: \"Image\" 资源类型时，设置加载的资源类型 useAssetPath useAssetPath: true 属性类型是string，并且进行资源选择时，这个选项决定属性值是资源原始路径还是res://uuid这样的格式。如果是true，则是资源原始路径。默认false private private：false 控制组件属性是否显示在IDE里，false：显示，true：不显示 addIndent addIndent:1 增加缩进，单位是层级，注意不是像素 onChange onChange: \"onChangeTest\" 当属性改变时，调用名称为onChangeTest的函数。函数需要在当前组件类上定义 代码示例如下（只列出上文没有介绍过的）： //隐藏控制 @property({ type: Boolean }) a: boolean; @property({ type: String, hidden: \"!data.a\" })//将条件表达式!data.a放在了字符串中，如果a为true（在IDE中为勾选状态），则!data.a返回false，此时hidden属性表示的是显示 hide: string = \"\"; // 只读控制 @property({ type: Boolean }) b: boolean; @property({ type: String, readonly: \"data.b\" })//将条件表达式data.b放在了字符串中，如果b为true（在IDE中为勾选状态），则data.b就返回true，此时readonly属性表示只读 read: string = \"\"; //数据检查机制 @property(String) text1: string; @property({ type: String, validator: \"if (value == data.text1) return '不能与a值相同' \" }) text2: string = \"\"; //密码输入 @property({ type: String, password: true }) password: string; //如果true或者缺省，文本输入每次输入都提交；否则只有在失焦时才提交 @property({ type: String, submitOnTyping: false }) submit: string; //输入文本的提示信息 @property({ type: \"text\", prompt: \"文本提示信息\" }) prompt: string; //显示为下拉框 @property({ type: Number, enumSource: [{name:\"Yes\", value:1}, {name:\"No\",value:0}] }) enumsource: number; //反转布尔值 @property({ type: \"boolean\", reverseBool: true }) reverseboolean : boolean; //允许null值 @property({ type: String, nullable: true }) nullable: string; //控制数字输入的精度和范围 @property({ type: Number, range:[0,5], step: 0.5, factionDigits: 3 }) range : number; //显示为百分比 @property({ type: Number, range:[0,1], percentage: true }) percent : number; //固定数组长度 @property({ type: [\"number\"], fixedLength: true }) arr1: number[]; //数组允许的操作 @property({ type: [\"number\"], arrayActions: [\"delete\", \"move\"] }) arr2: number[]; //不提供透明度a值的修改 @property({ type: Laya.Color, showAlpha: false }) color1: Laya.Color; //颜色类型时，defaultColor定义一个非null时的默认值 @property({ type: String, inspector: \"color\", defaultColor: \"rgba(217, 232, 0, 1)\" }) color2: string; //显示一个checkbox决定颜色是否为null @property({ type: Laya.Color, colorNullable: true }) color3: Laya.Color; //加载Image资源类型，设置资源路径格式 @property({ type: String, isAsset: true, assetTypeFilter: \"Image\", useAssetPath: true }) resource: string; //增加缩进，单位是层级 @property({ type: String, addIndent:1 }) indent1: string; @property({ type: String, addIndent:2 }) indent2: string; //当属性改变时，调用名称为onChangeTest的函数 @property({ type: Boolean, onChange: \"onChangeTest\"}) change: boolean; onChangeTest() { console.log(\"onChangeTest\"); } 3.3 IDE中执行生命周期方法@runInEditor 除了在IDE属性面板上暴露组件属性，开发者还可以通过装饰器标识 @runInEditor来让组件在IDE内加载时也可以触发生命周期方法（onEnable、onStart等所有的组件脚本生命周期方法）。示例代码如下： const { regClass, property, runInEditor } = Laya; @regClass() @runInEditor //重点看这里，要放到类之前，@regClass()与@runInEditor谁先谁后都可以。 export class NewScript extends Laya.Script { @property({ type: Laya.Sprite3D }) sp3: Laya.Sprite3D; constructor() { super(); } onEnable() { console.log(\"Game onStart\", this.sp3.name); } } 除非有特别的需求，我们并不建议这样做，一方面是因为静态物体更有利于IDE内进行编辑。另一方面是因为场景编辑器为了性能优化，帧率刷新要比正常运行慢很多，因此效果会与正常运行有明显差异。 3.4 加入IDE的组件列表@classInfo() 开发者的自定义组件脚本默认都位于属性设置面板的增加组件->自定义组件脚本的下面，如动图3-10所示。 （动图3-10） 如果我们想在这个组件列表中，将该组件加入自己定义的组件列表分类中，可以使用装饰器标识@classInfo(),示例代码如下所示： const { regClass, property, classInfo } = Laya; @regClass() @classInfo( { menu : \"MyScript\", caption : \"Main\", }) export class Main extends Laya.Script { onStart() { console.log(\"Game start\"); } } 然后我们保存代码，回到IDE，会发现自定义的分类已出现在组件列表中。如动图3-11所示。 （动图3-11） 四、代码中使用属性 前文已经介绍了组件组件的添加与识别。相信有一定基础的开发者已经可以直接使用LayaAir的实体组件系统了。 但针对一些新手开发者朋友，本小节通过几种常用类型的属性使用示例，进一步帮助大家理解组件化开发的基础。 4.1 节点类型方式 LayaAir分为2D节点与3D节点类型，当设置为2D节点Laya.Sprite时，不能将3D节点作为其属性值。当设置为3D节点Laya.Sprite3D时，不能将2D节点作为其属性值。 4.1.1 2D节点的使用 首先，如动图4-1所示，将场景中已经添加好的2D节点Sprite拖入到@property暴露的属性入口中，这样就获取到了此节点。 （动图4-1） 然后就可以在脚本中使用代码改变节点的属性了，例如，给Sprite添加纹理等，示例代码如下所示： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { @property({ type : Laya.Sprite}) public spr: Laya.Sprite; onAwake(): void { this.spr.size(512, 313); //设置Sprite大小 this.spr.loadImage(\"atlas/comp/image.png\"); //添加纹理 } } 效果如图4-2所示： （图4-2） 4.1.2 3D节点的基础使用 首先，如动图4-3所示，将场景中已经添加好的3D节点Cube拖入到@property暴露的属性入口中，这样就获取到了此节点。 （动图4-3） 然后就可以在脚本中使用代码改变节点的属性了，例如，可以让Cube绕自身旋转，示例代码如下所示： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { @property({ type : Laya.Sprite3D}) public cube: Laya.Sprite3D; private rotation: Laya.Vector3 = new Laya.Vector3(0, 0.01, 0); onStart() { Laya.timer.frameLoop(1, this, ()=> { this.cube.transform.rotate(this.rotation, false); }); } } 效果如动图4-4所示： （动图4-4） 4.1.3 3D节点的进阶使用 @property( { type :Laya.Sprite3D } ) //节点类型 public p3d: Laya.Sprite3D; onAwake(): void { this.p3d.transform.localPosition = new Laya.Vector3(0,5,5); let p3dRenderer = this.p3d.getComponent(Laya.ShurikenParticleRenderer); p3dRenderer.particleSystem.simulationSpeed = 10; } 通过暴露@property( { type :Laya.Sprite3D } )节点类型属性，来拖入particle节点，可以获得particle节点对象。transform可以直接修改，而simulationSpeed属性则通过getComponent(Laya.ShurikenParticleRenderer).particleSystem的方式获取。 4.2 组件类型的使用 @property( { type : Laya.ShurikenParticleRenderer } ) //组件类型 public p3dRenderer: Laya.ShurikenParticleRenderer; onAwake(): void { (this.p3dRenderer.owner as Laya.Sprite3D).transform.localPosition = new Laya.Vector3(0,5,5); this.p3dRenderer.particleSystem.simulationSpeed = 10; } 通过暴露@property( { type : Laya.ShurikenParticleRenderer } )组件类型属性，来拖入particle节点，可以获得particle的ShurikenParticleRenderer组件。transform可以通过(this.p3dRenderer.owner as Laya.Sprite3D)修改，而simulationSpeed属性则通过this.p3dRenderer.particleSystem的方式获取。 不能通过直接使用Laya.ShuriKenParticle3D作为属性类型，因为IDE无法识别，只有节点和组件类型可以识别。 就算将type类型设置为Laya.Sprite3D，这样IDE虽然标识了属性是Sprite3D节点，但也无法转换为Laya.ShuriKenParticle3D对象。 4.3 Prefab类型属性 当使用Laya.Prefab作为属性时，例如： @property( { type : Laya.Prefab } ) //加载 Prefab 的对象 private prefabFromResource: Laya.Prefab; 此时，需要按动图4-5所示，从assets目录下，拖入prefab资源。运行时会直接获取到加载实例化后的prefab。 （动图4-5） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-06-08 21:21:50 "},"basics/common/Loader/readme.html":{"url":"basics/common/Loader/readme.html","title":"资源加载","keywords":"","body":"LayaAir引擎的资源加载方法详解一、加载单个资源1.1 常用资源的加载方式1.2 带类型的加载方式二、加载多个资源2.1 省略类型的多资源加载方式2.2 可带类型的多资源加载方式2.3 统一类型的多资源加载方式三、不解析不缓存的加载资源3.1 fetch加载支持的类型四、Option参数五、如何不下载json文件（option { noMetaFile: true}）LayaAir引擎的资源加载方法详解 Author: Charley 资源加载是游戏引擎的核心模块，是必须要使用的功能，LayaAir引擎提供了Loader类用于加载文本、JSON、二进制、图像等资源。 下面我们在本篇文档中彻底掌握各种资源加载的使用。 一、加载单个资源 1.1 常用资源的加载方式 通常，采用Laya.loader.load(\"资源路径\")方法加载单个资源，通过.then(\"回调方法\")来处理加载后的逻辑。 Laya.loader.load(url).then((res)=> {/** 不带类型，用于常规的资源 */}); 完整的脚本示例如下： const { regClass, property } = Laya; @regClass() export class LoaderDemo extends Laya.Script { onAwake(): void { this.loadTexture(\"image/bird.jpg\", 500); this.loadTexture(\"https://layaair2.ldc2.layabox.com/demo2/h5/res/apes/monkey1.png\"); } /**加载并显示图片 */ loadTexture(url: string, x: number = 0, y: number = 0): void { Laya.loader.load(url).then((res: Laya.Texture) => { let img = new Laya.Image(); img.texture = res; // img.skin = url; //ui组件直接设置skin也可以 img.pos(x, y); this.owner.addChild(img); }); } } 1.2 带类型的加载方式 有的时候，网络资源没有后缀名，又或者，图片xxx.png并非是当成Texture使用，需要被定义为TextureCube。所以，这些时候需要通过类型进行区分。 使用方式与不带类型的基本相同，只是增加load第二个参数：类型标识字符串。 Laya.loader.load(url, type).then((res)=> { //带类型，用于区别无后缀，或同一后缀不同作用的资源。 //例如，图片xxx.png被定义为TextureCube，使用load(\"xxx.png\", Laya.Loader.TEXTURECUBE)。得到的是TextureCube。 }); 完整的脚本示例如下： const { regClass, property } = Laya; @regClass() export class LoaderDemo extends Laya.Script { onAwake(): void { //下面的URL未来可能会失效，仅用于示例参考 this.loadHTMLImage(\"http://lf3-sf-be-pack-sign.pglstatp-toutiao.com/ad.union.api/25dec97625d484d59beb22c408f072f9?x-expires=1942070400&x-signature=V5u1mTfzD6dnf6uSWif%2Fa65fI%2B4%3D\"); } /** 加载URL无后缀资源 */ loadHTMLImage(url: string): void { Laya.loader.load(url, Laya.Loader.IMAGE).then((res: Laya.Texture) => { let sp = new Laya.Sprite(); sp.texture = res; this.owner.addChild(sp); }); } } 常用类型如下： 引擎全局变量 类型标识字符串 类型说明 Laya.Loader.TEXT text 文本类型 Laya.Loader.JSON json JSON类型 Laya.Loader.XML xml XML类型 Laya.Loader.BUFFER arraybuffer 二进制类型 Laya.Loader.IMAGE image 纹理类型 Laya.Loader.SOUND sound 声音类型 Laya.Loader.VIDEO video 视频类型 Laya.Loader.ATLAS atlas 图集类型，加载完成后返回图集json信息(并创建图集内小图Texture) Laya.Loader.HIERARCHY HIERARCHY 层级资源，比如：场景ls文件与预制体lh文件 Laya.Loader.FONT font 位图字体类型 Laya.Loader.TTF ttf TTF字体类型 Laya.Loader.MESH MESH Mesh资源 Laya.Loader.MATERIAL MATERIAL Material资源 Laya.Loader.TEXTURE2D TEXTURE2D Texture2D资源 Laya.Loader.TEXTURECUBE TEXTURE2D TextureCube资源 Laya.Loader.SPINE SPINE Spine资源 二、加载多个资源 有很多时候，我们需要把大量的资源在Loading界面进行预加载，这样走完加载进度条再进游戏，就会直接显示资源，不会产生资源空白的加载等待现象。 此时，我们就需要用到多个资源加载的方式。 2.1 省略类型的多资源加载方式 如果我们只是加载比较常用的资源，通过文件后缀就可以识别出来，那么省略类型的方式，肯定更为简洁。 加载多个的API和加载单个基本相同，只是加载多个时，第一个参数是资源地址数组 Laya.loader.load([url1, url2]).then((res:Array)=> { /** 加载多个，不带类型，用于常规的资源 */ }); 完整的脚本示例如下： const { regClass, property } = Laya; @regClass() export class LoaderDemo extends Laya.Script { onAwake(): void { let resArr: Array = [ \"image/bird.jpg\", \"image/cloud.png\", \"https://layaair2.ldc2.layabox.com/demo2/h5/res/apes/monkey1.png\" ]; this.loadTextures(resArr); } /** 加载多个资源 * @param url 资源数组 */ loadTextures(url: Array): void { Laya.loader.load(url).then((res: Array) => { let sp: Laya.Sprite = new Laya.Sprite(); this.owner.addChild(sp); let i: number = 0; //每秒重画一次 Laya.timer.loop(1000, this, () => { i == res.length && (i = 0); //清除sp节点的所有绘图（不含子节点） sp.graphics.clear(); //在sp节点上重绘纹理 sp.graphics.drawTexture(res[i]); i++; }); }); } } 2.2 可带类型的多资源加载方式 假如，多数资源不需要带类型，有的资源又需要用类型区别，该如何使用加载方法呢？ 在资源数组里，为需要带类型的传入类型，不需要的传类型的，仍然可以省略。 Laya.loader.load([url1, { url:url2, type: type }]).then((res:Array)=> { /** 加载多个，按需设置类型，满足各种需要 */ }); 完整的脚本示例如下： const { regClass, property } = Laya; @regClass() export class LoaderDemo extends Laya.Script { onAwake(): void { let resArr: Array = [ \"image/bird.jpg\", \"image/cloud.png\", { url: \"https://layaair2.ldc2.layabox.com/demo2/h5/res/apes/monkey1.png\", type: \"image\" }, { url: \"http://lf3-sf-be-pack-sign.pglstatp-toutiao.com/ad.union.api/25dec97625d484d59beb22c408f072f9?x-expires=1942070400&x-signature=V5u1mTfzD6dnf6uSWif%2Fa65fI%2B4%3D\", type: Laya.Loader.IMAGE } ]; this.loadTextures(resArr); } /** 加载多个资源 * @param url 资源数组 */ loadTextures(url: Array): void { //加载回调返回的类型，如果是多样的，最好是any Laya.loader.load(url).then((res: Array) => { let sp: Laya.Sprite = new Laya.Sprite(); this.owner.addChild(sp); let i: number = 0; //每秒重画一次 Laya.timer.loop(1000, this, () => { i == res.length && (i = 0); //清除sp节点的所有绘图（不含子节点） sp.graphics.clear(); //在sp节点上重绘纹理 sp.graphics.drawTexture(res[i]); i++; }); }); } } 示例上的类型，故意采用了字符串标识和引擎全局变量标识两种方式。开发者用哪一种都可以。具体参照1.2的类型标识表格。 2.3 统一类型的多资源加载方式 也有的时候，加载的多资源，都需要使用类型标识，而这些类型都是同一种类型，例如，加载的全都是无后缀的URL资源。 这时，我们可以统一设置类型标识。 Laya.loader.load([url1, url2], type).then((res:Array)=> { /** 加载多个，统一类型，简洁实用 */ }); 完整的脚本示例如下： const { regClass, property } = Laya; @regClass() export class LoaderDemo extends Laya.Script { onAwake(): void { let resArr: Array = [ \"image/bird.jpg\", \"http://lf3-sf-be-pack-sign.pglstatp-toutiao.com/ad.union.api/25dec97625d484d59beb22c408f072f9?x-expires=1942070400&x-signature=V5u1mTfzD6dnf6uSWif%2Fa65fI%2B4%3D\", \"image/cloud.png\", \"http://lf3-sf-be-pack-sign.pglstatp-toutiao.com/ad.union.api/25dec97625d484d59beb22c408f072f9?x-expires=1942070400&x-signature=V5u1mTfzD6dnf6uSWif%2Fa65fI%2B4%3D\", ]; this.loadTextures(resArr); } /** 加载多个资源 * @param url 资源数组 */ loadTextures(url: Array): void { //加载回调返回的类型，如果不确定就any Laya.loader.load(url, Laya.Loader.IMAGE).then((res: Array) => { let sp: Laya.Sprite = new Laya.Sprite(); this.owner.addChild(sp); let i: number = 0; //每秒重画一次 Laya.timer.loop(1000, this, () => { i == res.length && (i = 0); //清除sp节点的所有绘图（不含子节点） sp.graphics.clear(); //在sp节点上重绘纹理 sp.graphics.drawTexture(res[i]); i++; }); }); } } 三、不解析不缓存的加载资源 引擎提供的load()方法加载资源，可能会在解析后做一些封装。 比如我们用load()方法加载一个json数据，需要在data里才能取到json文件里的数据。 使用load()方法，示例如下： onEnable(): void { const jsonPath: string = \"json/bagList.json\"; Laya.loader.load(jsonPath).then((json) => { let _json = json.data; if (_json.bagList && _json.bagList.length > 0) { //把json数据传递给list组件的数据源属性array this.bagList.array = _json.bagList; } }); } 而我们使用fetch()方法，则可以直接取到json文件里的数据。但需要注意的是，采用fetch加载的资源不会缓存，只能在加载完成的回调里使用，无法通过getRes读取加载缓存。 使用fetch()方法，示例如下： onEnable(): void { const jsonPath: string = \"json/bagList.json\"; //fetch取到的是原始数据，但没有缓存，无法用getRes获取 Laya.loader.fetch(jsonPath, \"json\").then((_json) => { if (_json.bagList && _json.bagList.length > 0) { //把json数据传递给list组件的数据源属性array this.bagList.array = _json.bagList; } }); } 3.1 fetch加载支持的类型 fetch的加载限定为以下类型： 类型标识字符串 资源类型 text string json any xml XMLDocument arraybuffer ArrayBuffer image HTMLImageElement \\ ImageBitmap sound HTMLAudioElement 在使用的时候，第二个参数那里填写对应的类型标识字符串即可。 更多fetch加载代码示例请参考《使用二进制图片》文档 Tips​ 除非是明确理解fetch的使用用途，否则不推荐开发者使用。 四、Option参数 当使用load()方法或者fetch()方法加载资源时，可以使用到Option参数，例如代码： //创建Option let option:any = {}; option.blob = this.imgBlob; //通过传递blob对象获得HTMLImageElement Laya.loader.fetch(\"\" ,\"image\", null, option).then((res)=>{ }); 通过Option参数指定fetch()方法，传递blob对象获得HTMLImageElement 目前支持的Option参数： export interface ILoadOptions { type?: string; //资源类型。比如：Loader.IMAGE。 priority?: number; //(default = 0)加载的优先级，数字越大优先级越高，优先级高的优先加载。 group?: string; //分组，方便对资源进行管理。 cache?: boolean; //是否缓存 noRetry?: boolean; //是否重新尝试加载 silent?: boolean; //是否提示加载失败 useWorkerLoader?: boolean; //(default = false)是否使用worker加载（只针对IMAGE类型和ATLAS类型，并且浏览器支持的情况下生效） constructParams?: TextureConstructParams; //图片属性，参考如下 propertyParams?: TexturePropertyParams; //纹理属性，参考如下 blob?: ArrayBuffer; //传递blob对象获得HTMLImageElement noMetaFile?: boolean; //是否不去下载Meta(json)文件 [key: string]: any; } TextureConstructParams { width?: number, height?: number, format?: TextureFormat, mipmap?: boolean, canRead?: boolean, sRGB?: boolean, } TexturePropertyParams { wrapModeU?: number, wrapModeV?: number, filterMode?: FilterMode, anisoLevel?: number, premultiplyAlpha?: boolean, hdrEncodeFormat?: HDREncodeFormat, } 五、如何不下载json文件（option { noMetaFile: true}） 当发布web后，在release/web目录下的资源中可以看到，每个图片资源对应一个json文件，如图5-1所示 （图5-1） 此json文件会记录IDE中设置的图片属性，如图5-2所示 （图5-2） 当LayaAir3.0引擎加载图片xxx.png时，先去加载xxx.png.json文件，来获取IDE中设置的图片信息 如果这些图片不是发布出来的，比如说服务器上的一些散图资源，那么就不存在json文件，当使用 load()或者fetch()方法加载图片时，会发现找不到json文件而提示错误信息： GET https://xxxx/xxx.png.json 404 (Not Found) 虽然无法获取json信息，但是LayaAir3.0引擎会使用默认属性 如果我们希望不去下载这些json文件，可以使用如下方式： //创建Option let option:any = {}; option.noMetaFile = true;//不去下载json Laya.loader.load(\"http://xxxx/xxx.png\",option).then((res)=>{ }); 这样，load资源的时候传option { noMetaFile: true}就不会去下载json文件 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-18 16:01:16 "},"basics/common/Scene/readme.html":{"url":"basics/common/Scene/readme.html","title":"场景管理","keywords":"","body":"场景的管理一、IDE中的场景1.1 新建场景1.2 场景划分1.3 autoDestroyAtClosed属性1.4 mouseThrough属性二、代码中使用2.1 场景类2.2 打开场景2.3 关闭场景2.4 场景的加载页面2.5 销毁和垃圾回收场景的管理 LayaAir3.0继续延用2.0开发思路为组件化，脚本化，场景管理开发，项目采用Scene管理方式，来管理场景，LayaAir 已经对Scene做了一系列方案，使得开发者无需考虑场景，关卡，页面的资源，内存管理，只需要单纯的调用接口，管理场景，其他的交给引擎去做，只需专注游戏逻辑开发即可。 在2.0项目开发中，无论是创建场景Scene，页面View，对话框Dialog，3d场景scene3d，文件类型和后缀都是scene。但是3.0中场景的划分有所区别，不再是统一的后缀scene方式。 一、IDE中的场景 1.1 新建场景 使用IDE新建一个3D项目，在IDE中创建一个场景，并保存，默认情况下，会在assets目录下，保存为Scene1.ls。如动图1-1所示 （动图1-1） 通过资源管理器打开assets目录，可以看到Scene1的后缀是ls文件，这个场景ls文件，与2.0的区别是，它包括了Scene3D场景和Scene2D场景。如图1-2所示 （图1-2） Scene3D：编辑3D场景的根节点，可以参考《3D场景编辑的基础交互》文档和《3D场景环境设置》文档来详细了解3D场景的操作和使用，如图1-3所示 （图1-3） Scene2D：编辑2D场景的根节点，可以参考《UI编辑器基础交互》文档和《UI继承类》文档来详细了解2D场景的操作和代码使用，如图1-4所示 （图1-4） 但是重要的一点是，在同一个IDE创建的场景中，可以支持编辑3D场景和2D场景 1.2 场景划分 如果针对某个场景，开发者只需要3D场景或者只需要2D场景，那怎么办呢？ 对于只需要2D场景时，可以点击Scene3D，点击鼠标右键选择删除，那么剩下的场景就是一个单纯的Scene2D场景，如图1-5所示 （图1-5） 对于只需要3D场景时，可以发现Scene2D是不可以删掉的，如图1-6所示 （图1-6） 之所以无法删除，是因为Scene2D有一个很重要的属性 Auto Destroy At Closed 只要不编辑Scene2D，那么Scene2D只是带有属性的一个Sprite节点，不会对3D场景有任何影响 1.3 autoDestroyAtClosed属性 /**场景被关闭后，是否自动销毁（销毁节点和使用到的资源），默认为false*/ autoDestroyAtClosed: boolean = false; 当勾选 Auto Destroy At Closed后，场景在关闭时会自动调用场景的销毁 Destroy() 方法 1.4 mouseThrough属性 另外一个属性是 Mouse Through，默认是勾选的 由于2D场景和3D场景都可以接收鼠标事件，这时可能会有冲突。 如果勾选 Mouse Through，Scene2D下脚本事件 onMouseClick 等将不会响应，会传递到Scene3D中 如果不勾选 Mouse Through，Scene2D下脚本事件 onMouseClick 等将会响应 二、代码中使用 2.1 场景类 /** * 场景类，负责场景创建，加载，销毁等功能 * 场景被从节点移除后，并不会被自动垃圾机制回收，如果想回收，请调用destroy接口，可以通过unDestroyedScenes属性查看还未被销毁的场景列表 */ export class Scene extends Sprite { /**创建后，还未被销毁的场景列表，方便查看还未被销毁的场景列表，方便内存管理，本属性只读，请不要直接修改*/ static readonly unDestroyedScenes: Set = new Set(); /**场景被关闭后，是否自动销毁（销毁节点和使用到的资源），默认为false*/ autoDestroyAtClosed: boolean = false; _scene3D: any; 场景类首先继承自Sprite，也就是本身是一个Scene2D节点，编辑2D界面，实际上就是在它下面添加2D子节点组件。而属性 _scene3D是用来管理Scene3D的，这与IDE中对应的Scene2D和Scene3D相关联。 2.2 打开场景 1，基础使用 首先来看看场景类中最基础的使用方式，打开一个场景 /** * 加载并打开场景 * @param url 场景地址 * @param closeOther 是否关闭其他场景，默认为true（可选），【注意】被关闭的场景，如果没有设置autoDestroyAtClosed=true，则资源可能不能被回收，需要自己手动回收 * @param param 打开页面的参数，会传递给onOpened方法（可选） * @param complete 打开完成回调，返回场景实例（可选） * @param progress 加载进度回调（可选） */ static open(url: string, closeOther: boolean = true, param: any = null, complete: Handler = null, progress: Handler = null): Promise { Scene.showLoadingPage(); return Scene.load(url, Handler.create(null, this._onSceneLoaded, [closeOther, complete, param]), progress); } （图2-1） 例如创建名为 OpenScene 的场景，保存在assets路径下 uiDemo/page/OpenScene.ls，代码中可以这样打开场景，同时不关闭其它场景 Laya.Scene.open(\"uiDemo/page/OpenScene.ls\", false); 也可以打开一个预制体实现的UI，例如代码 Laya.Scene.open(\"dailog.lh\"); 运行效果如动图所示 （动图） 2，传参与接收参数 （图2-2） 例如创建名为Msg的场景，用于进入这个场景时会传递文字，可以使用如下代码： Laya.Scene.open(\"uiDemo/Msg.ls\", false, { \"text\": \"没有勾选项，请先勾选\" }); 通过 Laya.Scene.open 附带传递参数给下一个场景，数据为 { \"text\": \"没有勾选项，请先勾选\" } onOpened方法中会接受传入的参数，param.text 就是 \"没有勾选项，请先勾选\"，如图2-3所示 （图2-3） 2.3 关闭场景 1，关闭指定的场景 /** * 根据地址，关闭场景（包括对话框） * @param url 场景地址 * @param name 如果name不为空，name必须相同才能关闭 * @return 返回是否关闭成功，如果url找不到，则不成功 */ static close(url: string, name?: string): boolean { 例如通过传入指定的地址参数，来关闭某一个场景 Laya.Scene.close(\"uiDemo/page/OpenScene.ls\"); 2，关闭当前场景 this.close() （图2-4） 采用Runtime的方式，可以方便使用 this.close() 来关闭场景 3，关闭所有场景（不包括dialog） /** * 关闭所有场景，不包括对话框，如果关闭对话框，请使用Dialog.closeAll() * 【注意】被关闭的场景，如果没有设置autoDestroyAtRemoved=true，则资源可能不能被回收，需要自己手动回收 */ static closeAll(): void { 4，关闭后调用的生命周期方法 /** * 关闭完成后，调用此方法（如果有关闭动画，则在动画完成后执行） * @param type 如果是点击默认关闭按钮触发，则传入关闭按钮的名字(name)，否则为null。 */ onClosed(type: string = null): void { //trace(\"onClosed\"); } 场景的Runtime类，当场景关闭的时候，会被调用 onClosed() 方法，可以在方法内实现各种资源的释放 2.4 场景的加载页面 Laya.Scene.setLoadingPage(loadPage: Sprite) 设置loading界面，引擎会在调用open方法后，延迟打开loading界面，在页面添加到舞台之后，关闭loading界面 Laya.Scene.showLoadingPage(param: any = null, delay: number = 500) 显示loading界面，打开参数，如果是scene，则会传递给 onOpened 方法，延迟打开时间，默认500毫秒 Laya.Scene.hideLoadingPage(delay: number = 500) 隐藏loading界面 例如要打开一个新场景，使用加载页面，那么就先定义一个脚本代码，加入可能拖入loading场景的Laya.Prefab属性，如图2-5所示 （图2-5） 在要打开的场景Scene.ls下，挂上脚本，并拖入Loading.ls场景 （图2-6） 这样就可以使用Loading场景作为加载场景了 2.5 销毁和垃圾回收 /** * 根据地址，销毁场景（包括对话框） * @param url 场景地址 * @param name 如果name不为空，name必须相同才能关闭 * @return 返回是否销毁成功，如果url找不到，则不成功 */ static destroy(url: string, name?: string): boolean { /** * 销毁当前没有被使用的资源,该函数会忽略lock=true的资源。 */ static gc(): void { Resource.destroyUnusedResources(); } 代码使用如下： Laya.Scene.destroy(\"scene.ls\"); Laya.Scene.gc(); Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-05-16 15:05:03 "},"basics/common/Node/readme.html":{"url":"basics/common/Node/readme.html","title":"节点管理","keywords":"","body":"节点的管理添加查找改变移除节点的管理 类似HTML，整个HTML由各种节点组成，根节点就是HTML标签，然后下面就是各个子节点，然后子节点再套子节点，形成了一个节点树，然后浏览器依据这个节点树进行渲染，然后就把我们需要的页面渲染出来，Laya 其实也是一样，不同的组件和场景组成了一个节点树，交给Laya 引擎渲染。 节点是项目开发的基础，只有充分了解如何操作节点，才能更快的实现复杂的需求。每个节点组件类都是继承自Node类，Node类是可放在显示列表中的所有对象的基类。该显示列表管理 Laya 运行时中显示的所有对象。使用 Node 类排列显示列表中的显示对象。Node 对象可以有子显示对象。 下面来熟悉一下Node类的所有基础的功能 添加 添加子节点addChild(node:Node) 在不考虑层级的情况下，我们可以给某个节点添加子节点，可让子节点跟随父节点显示与否，移动，以及方便管理。添加的子节点会加到所有子节点的最后面。 添加子节点到指定的索引位置addChildAt(index:number) 往往要考虑到节点的层级关系或者说遮挡关系，并且已经了解到需要添加到指定的层级位置可使用此方法 批量添加子节点addChildren(...args:any[]) 直接把一组子节点按顺序添加到父节点下，相当于循环调用一次addChild子节点 查找 根据名字，获取子节点对象getChildByName(name: string) 当我们知道某个节点的名字时，可以用个此方法找到父节点下一级的某个子节点 根据子节点的索引位置，获取子节点对象getChildAt(index:number) 当我们知道某个节点的索引位置时，可以用个此方法找到父节点下一级的某个子节点 根据子节点对象，获取子节点的索引位置getChildIndex(node:Node) 当我们想知道某个节点的索引位置时，可以用个此方法可获取子节点 获取子节点对象数量numChildren 通过调用父节点的numChildren属性，可以获得父节点下一级的所有子节点的数量，可用来遍历所有子节点使用，注意不包括子节点下的子节点 获取父节点对象parent 通过调用子节点的parent属性，可以直接获取父节点 当前容器是否包含指定的节点对象contains(node: Node) 判断一个节点下是否包含某个子节点，可以使用此方法，注意此查找过程会遍历所有嵌套的子节点 检查本节点是否是某个节点的上层节点isAncestorOf(node: Node) 改变 设置子节点的索引位置setChildIndex(node:Node,index:number) 如果想改变子节点的显示层级，可以调用此方法，注意index超出父节点的所有节点数会抛出异常 传入新节点替换到已有子节点索引位置replaceChild(newNode: Node, oldNode: Node) 如果想用新的节点替换某个已有节点，可以调用此方法，注意原有的子节点将会被移除，但不会销毁 移除 删除子节点removeChild(node: Node) 删除子节点的时调用此方法，注意子节点将会被移除，但不会销毁 从父容器删除自己removeSelf() 在不需要知道父节点的情况下，调用此方法可直接从父节点删除自己，此方法使用频率比较多 根据名字删除对应子节点removeChildByName(name: string) 当我们知道某个节点的名字时，可以用个此方法从父节点删除子节点 根据索引位置删除对应子节点removeChildAt(index: number) 当我们知道某个节点的索引位置时，可以用个此方法从父节点删除子节点 删除指定索引区间的所有子节点removeChildren(beginIndex: number = 0, endIndex: number = 0x7fffffff) 此方法可以快速删除指定索引区间的所有子节点 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:15 "},"basics/common/Timer/readme.html":{"url":"basics/common/Timer/readme.html","title":"定时器","keywords":"","body":"定时器帧间隔时间间隔暂停定时器执行当前帧延迟执行清理定时器立即执行并删除定时器定时器 定时器 Laya.Timer 是时钟管理类。它是一个单例，不要手动实例化此类，应该通过 Laya.timer 访问。 同时 Laya.Timer 表示游戏主时针，同时也是管理场景、动画、缓动等效果时钟，通过控制本时钟缩放可以达到快进慢播的效果。 帧间隔 Laya.timer.frameOnce(delay: number, caller: any, method: Function, args: any[] = null, coverBefore: boolean = true) 定时执行一次 (基于帧率) （图1） （图2） Laya.timer.frameLoop(delay: number, caller: any, method: Function, args: any[] = null, coverBefore: boolean = true) 定时重复执行 (基于帧率) （图3） （图4） 时间间隔 Laya.timer.once(delay: number, caller: any, method: Function, args: any[] = null, coverBefore: boolean = true) 定时执行一次 (单位为毫秒) （图5） （图6） Laya.timer.loop(delay: number, caller: any, method: Function, args: any[] = null, coverBefore: boolean = true, jumpFrame: boolean = false) 定时重复执行(单位为毫秒) （图7） （图8） 暂停定时器执行 一旦定时器暂停，游戏将处于静止状态 （图9） 当前帧延迟执行 callLater(caller: any, method: Function, args: any[] = null) 当前帧执行后立即执行。渲染之前执行，比延迟一帧的定时器，执行优先级更高 （图10） （图11） 清理定时器 Laya.timer.clear(caller: any, method: Function) 清理指定的定时器 Laya.timer.clearAll(caller: any) 清理对象指定作用域的所有定时器 （图12） （图13） 建议在一个模块功能销毁之前，清理定时器或者清除所有的定时器 立即执行并删除定时器 Laya.timer.runCallLater(caller: any, method: Function) 立即执行 Laya.timer.runTimer(caller: any, method: Function) 立即提前执行定时器，执行之后从队列中删除 （图14） （图15） 注意：hideImage() 方法只执行一次 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-04-18 21:03:42 "},"basics/common/Event/readme.html":{"url":"basics/common/Event/readme.html","title":"事件与交互","keywords":"","body":"事件管理什么是事件事件的分类引擎内置的事件事件类型 Laya.Event事件派发 Laya.EventDispatcher事件处理 Laya.Handler事件管理 什么是事件 事件Event指的是由系统事先设定的、能被对象识别和响应的动作，事件是指对象对于外部动作的响应，当对方发生了某个事件，就会执行于此事件对应的代码。比如用鼠标在一个对象上按下，这个对象预先设定了识别鼠标按下这个事件，就会执行对应的代码。 事件的分类 1，引擎内置的事件 2，自定义的事件 我们使用的事件可以是引擎内置的事件，也可以是自定义的事件，使用自定义类型的事件叫自定义事件。 引擎内置的事件 LayaAir3.0引擎中的事件主要包含三部分 Laya.Event 事件类型，事件接口，不同的事件类型都要实现此接口。 Laya.EventDispatcher 事件派发，每个传递过来的事件都会由它分发给特定的处理者。 Laya.Handler 事件处理，不同的处理器需实现该接口。 事件类型 Laya.Event Laya.Event 是事件类型的集合，当事件发生时Laya.Event对象将作为参数传递给事件监听器。 例如 Laya.Event.CLICK:string = \"click\" CLICK 静态属性用于定义事件对象的type类型属性值为单击事件。这个事件是由鼠标点击触发后系统派发的事件，开发者也可以调用event()方法派发这些事件，如何派发事件会在下面的内容涉及。 （图1） 点击3个按钮的任意一个，可以进入对应的功能。我们看看代码是如何使用CLICK 的 （图2） 事件派发 Laya.EventDispatcher 事件派发Laya.EventDispatcher模式是监听模式的一种扩展，由事件驱动，每当有事件产生的时候，由事件分发器Laya.EventDispatcher分发给特定的事件处理器Laya.Handler 处理该事件。Laya.EventDispatcher表示事件发送者、事件捕获传递与分发。 Laya.EventDispatcher 事件分发器是可调度事件类的基类，比如作为基础节点的Node类继承自Laya.EventDispatcher类，只要继承此类就可以作为一个事件发送者发送事件给它的监听者。那么比如上面示例代码中的Button就是继承自Laya.EventDispatcher，可以用.on的方法来监听CLICK事件 Laya.EventDispatcher 具有如下功能： 1，事件派发 event(type: string, data: any = null) 用于派发事件，例如我们可以在代码中来派发一个CLICK事件 （图3） 2，持续事件侦听 on(type: string, caller: any, listener: Function, args: any[] = null) 用于向事件派发器注册指定类型的事件监听器，使事件监听器能够接收事件通知。图3中 this.uiBtn.on 是使用了持续监听 当监听到事件后，会调用作用域 caller 的回调方法 listener 3，单次事件侦听 once(type: string, caller: any, listener: Function, args: any[] = null) 用于向事件分发器注册指定类型的事件监听器，使事件监听器能够接收事件通知，事件监听器响应一次后会自动移除。 （图4） 例如上述按钮的监听方式也可以改为单次事件监听 4，删除指定的侦听 off(type: string, caller: any, listener: Function, onceOnly: boolean = false) 用于从事件分发器对象中删除监听器 （图5） 当这个场景删除销毁时，最好删除按钮的事件监听，保证释放掉所有引用 5，删除指定事件类型的所有侦听 offAll(type: string = null) 用于从事件分发器对象中删除指定事件类型的所有监听器 （图6） 例如uiBtn按钮注册了多个事件的监听，我们可以用offAll方法来一次性删除所有监听 6，删除指定作用域的所有侦听 offAllCaller(caller: any) 用于从事件分发器对象中删除指定作用域的所有监听器 （图7） 例如uiBtn按钮注册了多个事件的监听，我们可以用offAllCaller方法来一次性删除this作用域上的所有监听 7，检查是否已注册侦听 hasListener(type: string) 用于判断事件分发器对象是否为特定类型的事件注册了监听器 （图8） 事件处理 Laya.Handler 当监听到事件后，用来处理事件的处理器 处理器的属性包括： 1，caller: Object | null; 执行域 2，method: Function | null 执行方法 3，args: any[] | null 参数 4，once = false 表示是否只执行一次。如果为true，回调后执行recover()进行回收，回收后会被再利用，默认为false 处理器的方法包括： 1，create() 从对象池内创建一个Handler Laya.Handler 事件处理器，推荐使用Laya.Handler.create()方法从对象池创建，以减少对象创建消耗。当创建的Handler对象不再使用后，可使用Laya.Handler.recover()将其回收到对象池，回收后不要再使用此对象，否则会导致不可预料的错误。需要注意的是，由于鼠标事件也使用了对象池，不正确的回收以及调用，可能会影响事件的执行。 Tab会监听用户点了某个标签，并从对象池创建一个处理器 ​ 2，clear(): Handler 清理对象引用 this.Tab.selectHandler.clear(); ​ 3，recover(): void 清理并回收到 Handler 对象池内 this.Tab.selectHandler.recover(); ​ 4，run(): any 执行处理器 this.Tab.selectHandler.run(); \\\\可以自行调用run() ​ 5，runWith(data: any): any 执行处理器，并携带额外数据 this.Tab.selectHandler.runWith(1); \\\\可以自行调用runWith(),并传入参数1 ​ 6，setTo(caller: any, method: Function | null, args: any[] | null, once = false): Handler 设置此对象的指定属性值。 可以自行更改指定的属性 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:15 "},"basics/common/Tween/readme.html":{"url":"basics/common/Tween/readme.html","title":"缓动","keywords":"","body":"缓动一、概述二、Ease2.1 匀速运动（linearIn）2.2 加速运动（expoIn）2.3 快速加速运动（strongIn）2.4 往后再反向（backIn）三、Tween3.1 常用API介绍3.2 参数说明3.3 缓动实例3.4 理解Props参数3.5 理解缓动持续时间（duration）与延迟执行（delay）参数3.6 理解ease参数3.7 理解完成回调（complete）参数3.8 通过Props参数实现过程回调缓动 一、概述 缓动的最大用处就是应用在设计的运动表现上，可以结合物理、数学等原理真实地模拟显示生活中的运动现象，更加符合自然规律及人类认知，并使对象按照用户期望的行为交互，提供连续性体验。游戏开发中缓动动画比较常见，它是提升游戏UI体验的重要因素之一，例如对话框弹出、关闭，按钮的动效出现与消失，道具飞入背包等，我们可以直接使用LayaAir引擎提供的Tween缓动类与Ease类来快捷实现。 接下来我们分别介绍 Tween 和 Ease 类 二、Ease Ease 类定义了大量的缓动函数，以便实现 Tween 动画的具体缓动效果。LayaAir引擎的Tween类与Ease类结合使用，能基本满足游戏开发的缓动效果需求。 我们主要看以下几种缓动效果来理解： 2.1 匀速运动（linearIn） 比较少的情况下，会用匀速运动，会显得比较僵硬。不符合物理世界的规律，真实的运动状态下，物体的速度是会随着运动状态发生变化的。 2.2 加速运动（expoIn） 以零速率开始运动，然后在执行时加快运动速度。 2.3 快速加速运动（strongIn） 以零速率开始运动，然后在执行时加快运动速度 2.4 往后再反向（backIn） 开始时往后运动，然后反向朝目标移动 更多的效果可以通过示例查看 三、Tween Tween 缓动类用以实现目标对象属性的缓动，例如目标对象的x或y轴的缓动距离等目标值设置，以及缓动开始、停止、清理等设置。 3.1 常用API介绍 缓动类 Tween 提供了较多的方法，而我们常用的是两种，分别为from()与to()方法，这两个方法的参数设置完全一样，但效果有所不同，from是从缓动目标点向初始位置产生运动（从缓动目标位置来），to是从初始位置向缓动目标的位置产生运动（到缓动目标位置去），后面会结合实例详细说明，开发者可以先了解一下这两个方法的基础说明： /** * 从props属性，缓动到当前状态。 * @param target 目标对象(即将更改属性值的对象)。 * @param props 变化的属性列表，比如{x:100,y:20,ease:Ease.backOut,complete:Handler.create(this,onComplete),update:new Handler(this,onComplete)}。 * @param duration 花费的时间，单位毫秒。 * @param ease 缓动类型，默认为匀速运动。 * @param complete 结束回调函数。 * @param delay 延迟执行时间。 * @param coverBefore 是否覆盖之前的缓动。 * @param autoRecover 是否自动回收，默认为true，缓动结束之后自动回收到对象池。 * @return 返回Tween对象。 */ static from(target: any, props: any, duration: number, ease: Function = null, complete: Handler = null, delay: number = 0, coverBefore: boolean = false, autoRecover: boolean = true): Tween { return Pool.getItemByClass(\"tween\", Tween)._create(target, props, duration, ease, complete, delay, coverBefore, false, autoRecover, true); } /** * 缓动对象的props属性到目标值。 * @param target 目标对象(即将更改属性值的对象)。 * @param props 变化的属性列表，比如{x:100,y:20,ease:Ease.backOut,complete:Handler.create(this,onComplete),update:new Handler(this,onComplete)}。 * @param duration 花费的时间，单位毫秒。 * @param ease 缓动类型，默认为匀速运动。 * @param complete 结束回调函数。 * @param delay 延迟执行时间。 * @param coverBefore 是否覆盖之前的缓动。 * @param autoRecover 是否自动回收，默认为true，缓动结束之后自动回收到对象池。 * @return 返回Tween对象。 */ static to(target: any, props: any, duration: number, ease: Function|null = null, complete: Handler|null = null, delay: number = 0, coverBefore: boolean = false, autoRecover: boolean = true): Tween { return Pool.getItemByClass(\"tween\", Tween)._create(target, props, duration, ease, complete, delay, coverBefore, true, autoRecover, true); } 3.2 参数说明 to()和from()这两种方法都支持静态方法，因此我们不需要去实例化Tween类就可以使用。 to()和from()它们的参数理解起来都较简单，这里我们重点强调一下props、duration、ease、complete、delay参数。 props props 是目标对象需要改变，从而产生缓动效果的属性。对象的公共属性都可以进行设置，比如最常用的x、y位置属性，及alpha透明属性，以及旋转、轴心、大小等其他属性。属性的设置是采用对象数据的形式，比如 {x:100,y:20,ease:Ease.backOut,complete:Handler.create(this,onComplete),update:new Handler(this,onComplete)} duration duration 是执行缓动效果花费的时间，单位是豪秒，时间越多，缓动效果越慢。 ease ease 为缓动类型，它可以使用Ease类下定义的各种函数来改变动画的变化过程。 complete complete 为缓动完成后回调方法。比如按钮出现的缓动，在缓动过程中我们不能让用户点击，这时就可以用到缓动完成回调，在回调函数中再加入按钮监听。 delay delay 是延迟执行的时间，稍后会通过实例中的延迟执行制作出文本缓动的波动效果。 3.3 缓动实例 下列代码中，我们先通过 Tween.from() 方法，实现 “LayaBox” 字符的文本缓动动画。 from() ： //创建缓动文本 private createTween():void{ //\"LayaBox字符串总宽度\" var w:number = 800; //文本创建的起始位置(>>在此使用右移运算符，相当于/2 用>>效率更高) var offsetX:number = Laya.stage.width - w >> 1; //显示的字符串 var demoString:string = \"LayaBox\"; var letterText:Laya.Text; //根据\"LayaBox\"字符串长度创建单个字符，并对每个单独字符使用缓动动画 for(var i:number = 0,len:number = demoString.length;i （动图3-1） 结合实例代码，然后通过动图2-1的运动效果，我们可以看出，文本”Layabox”在初始位置（y轴300）出现之后，瞬间消失，然后从缓动方法 Tween.from 设置的目标{ y : 100 }（y轴100）向初始位置发生运动（从上到下的缓动效果）。 由于这个方法是先在初始位置显示，再瞬间消失从缓动的目标位置向初始位置运动。会产生一个视觉差，感觉更像反弹效果。所以我们继续了解 Tween.to 的效果，开发者可以根据需要选择到底使用哪种缓动方法。 to() ：我们可以继续采用上面的实例，只是将 Tween.from 改变为 Tween.to //对象letterText属性y从初始的y属性向缓动目标的y的100属性运动，缓动效果需要3000毫秒，缓类型采用elasticOut函数方式，延迟间隔1000毫秒执行。 Laya.Tween.to( letterText , {y:100}, 3000, Laya.Ease.elasticOut, null, 1000 ); 运行效果如动图3-2所示 （动图3-2） 3.4 理解Props参数 无论 Tween.from 还是 Tween.to，第二个参数Props（属性）可以影响缓动效果的运动轨迹等。 由于 Tween.from 与 Tween.to 的缓动效果本来就是相反的，所以 Tween.from 有一种向下落的感觉，而动图3-2的 Tween.to 有一种向上弹起的感觉。 如果我们将初始y的属性值 与缓动目标的y属性值对调一下，再来看看，用 Tween.to 实现的落下效果与 Tween.from 有什么不同。 继续延续之前的示例，修改代码如下。 //文本的初始y属性 letterText.y = 100; //Laya.Tween.from(letterText,{y:100},3000,Laya.Ease.elasticOut,null,i*1000);//注释本行改为将Laya.Tween.from改变为Laya.Tween.to Laya.Tween.to(letterText, { y : 300 }, 3000, Laya.Ease.elasticOut, null, i * 1000); 运行效果如动图3-3所示 （动图3-3） 由于动图3-3中，是初始y属性在100，Tween.to 的效果是从初始属性向缓动目标的属性进行运动。所以缓动目标的y属性在300时，就会产生出从初始y轴的100向y轴300进行运动，也就是落下的效果。与 Tween.from 实现落下效果会有明显的不同。所以开发者在运用时要注意两者的效果区别。 3.5 理解缓动持续时间（duration）与延迟执行（delay）参数 继续沿用前面的示例，我们将第三个参数duration修改为1000毫秒，将第六个参数delay修改为100毫秒，效果如动图5所示。无论是缓动的速度还是下落间隔的速度都会产生较明显的变化。因此可以看出，通过持续时间或延迟时间的调整也可以实现不同的动画效果目标。这里不再深入，开发者可以自行调节体验。 （动图3-4） 动图3-4效果所修改代码如下： //文本的初始y属性 letterText.y = 100; //Laya.Tween.from(letterText,{y:100},3000,Laya.Ease.elasticOut,null,i*1000);//注释本行改为将Laya.Tween.from改变为Laya.Tween.to Laya.Tween.to(letterText, { y : 300 }, 1000, Laya.Ease.elasticOut, null, i * 100); 3.6 理解ease参数 第四个参数ease对应laya.utils.Ease类的各个方法，本节中我们改为Ease.bounceIn效果，如动图3-5所示。 （动图3-5） 动图3-5效果所修改代码如下： //文本的初始y属性 letterText.y = 100; //Laya.Tween.from(letterText,{y:100},3000,Laya.Ease.elasticOut,null,i*1000);//注释本行改为将Laya.Tween.from改变为Laya.Tween.to Laya.Tween.to(letterText, { y : 300 }, 1000, Laya.Ease.bounceIn, null, i * 100); 3.7 理解完成回调（complete）参数 第五个参数complete用于执行完缓动效果后的回调。我们继续沿用之前的示例，在缓动结束后，增加一个让字体颜色变红的回调方法。 使用示例： Laya.Tween.to(letterText, { y : 300 }, 1000, Laya.Ease.bounceIn, Laya.Handler.create(this,this.changeColor,[letterText]), i * 100); 增加的 changeColor 方法如下 /** * 缓动完成后的回调方法 * txt 缓动对象 */ private changeColor(txt:Laya.Text):void{ //将文本字体改变成红色 txt.color = \"#ff0000\"; } 代码运行效果如动图3-6所示 （动图3-6） 3.8 通过Props参数实现过程回调 complete（完成回调）参数，不仅可以在第五个参数中实现，也可以在第二个参数Props中实现。但是，为了代码更加清晰易读，我们并不建议将完成回调放在Props中实现。 这里我们只介绍一下在Props中实现update更新回调。也就是说如果我们想在缓动过程中就执行回调方法，那第五个参数中是不可能实现的，因为第五个参数一定是缓动结束后才执行。所以，我们继续沿用之前的示例，在Props参数里增加一个字体颜色的更新回调。 使用示例： /** * 对象letterText属性y从100缓动到300的位置，每一帧都通过回调方法更新颜色 * 用1000毫秒完成缓动效果 * 缓动类型采用bounceIn * 单个字符的缓动效果结束后，使用changeColor回调函数将字符改变为红色 * 延迟间隔i*100毫秒执行 */ Laya.Tween.to(letterText, { y : 300, update: new Laya.Handler(this, this.updateColor,[letterText])}, 1000, Laya.Ease.bounceIn, Laya.Handler.create(this,this.changeColor,[letterText]), i * 100); 增加的 changeColor 方法如下 /** * 缓动进行时的回调更新方法 * txt 缓动对象 */ private updateColor(txt:Laya.Text):void{ var c:number = Math.floor(Math.random()*3); switch (c) { case 0: txt.color = \"#eee000\"; break; case 1: txt.color = \"#ffffff\"; break; case 2: txt.color = \"#ff0000\"; break; default: txt.color = \"#eee000\"; break; } } 代码运行时，由于update回调是每一帧都在执行，所以在缓动的过程中，有一种闪光字的效果。如动图3-7所示 （动图3-7） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"basics/common/Pool/readme.html":{"url":"basics/common/Pool/readme.html","title":"对象池","keywords":"","body":"对象池使用一、概述二、对象池 Pool2.1 获得一个对象池2.2 清理一个对象池2.3 从池中获得对象2.4 回收对象到池中2.5 通过类名，获得和回收对象对象池使用 一、概述 在项目开发过程中，有许多对象会不停的创建与移除，比如角色攻击子弹、特效的创建与移除，NPC（非玩家角色）的被消灭与刷新等，在创建过程中非常消耗性能，特别是数量多的情况下，此时会造成卡顿的现象。 因此使用对象池就可以避免大量对象的创建。如果我们每次对象使用完了都放到池子里，比如怪物，子弹等等，怪物被杀死了，不需要用了，就可以放到池子里，下次使用的时候可以直接从池子里拿，对象池没有才需要创建。 对象池的优点是减少了实例化对象时的开销，且能让对象反复使用，减少了新内存分配与垃圾回收器运行的机会。另外对象移除时并不是立即从内存中抹去，只有认为内存不足时，才会使用垃圾回收机制清空，清空时很耗内存，很可能就会造成卡顿现象。用了对象池后将减少程序的垃圾对象，有效的提高程序的运行速度和稳定性。 接下来，我们来看看在LayaAir中是如何使用对象池（Pool）的。 二、对象池 Pool Pool 是对象池类，用于对象的存贮、重复使用。合理使用对象池，可以有效减少对象创建的开销，避免频繁的垃圾回收，从而优化游戏流畅度。 2.1 获得一个对象池 /** * 根据对象类型标识字符，获取对象池。 * @param sign 对象类型标识字符。 * @return 对象池。 */ static getPoolBySign(sign: string): any[] { return Pool._poolDic[sign] || (Pool._poolDic[sign] = []); } Laya.Pool 是通过对象类型标识符，也就是一个字符串名字来标识和管理对象池的。如果对象池系统中没有这个标识，那么会创建一个标识的对象池。因此我们也可以通过标识来定义多个对象池，分别处理不同类型的对象。比如攻击的子弹是一个对象池，NPC玩家是一个对象池。 所以，当我们想使用一个对象池的话，需要这样在代码中调用： let bulletPool = Laya.Pool.getPoolBySign(\"Bullet\"); 有了对象池，我们可以查看对象池当前的情况，比如查看对象池内对象的数量，继续添加对象等等。比如代码： let bulletPool = Laya.Pool.getPoolBySign(\"Bullet\"); // 查看当前对象池内对象数量 console.log( bulletPool.length ); if( bulletPool.length == 0 ) { // 把子弹放入对象池 pool.push( new Bullet() ); } 2.2 清理一个对象池 /** * 清除对象池的对象。 * @param sign 对象类型标识字符。 */ static clearBySign(sign: string): void { if (Pool._poolDic[sign]) Pool._poolDic[sign].length = 0; } 比如在游戏中，当一场战斗结束时，当没有需要子弹的对象池的需求了，我们可以通过代码来清理对象池： Laya.Pool.clearBySign(\"Bullet\"); 2.3 从池中获得对象 2.3.1 通过标识获得 /** * 根据传入的对象类型标识字符，获取对象池中已存储的此类型的一个对象，如果对象池中无此类型的对象，则返回 null 。 * @param sign 对象类型标识字符。 * @return 对象池中此类型的一个对象，如果对象池中无此类型的对象，则返回 null 。 */ static getItem(sign: string): any { var pool: any[] = Pool.getPoolBySign(sign); var rst: any = pool.length ? pool.pop() : null; if (rst) { rst[Pool.POOLSIGN] = false; } return rst; } 这是最基本的操作，从对象池中拿到一个对象的示例，如果对象池里已经没有可以拿的对象时，返回 null，使用代码如下： let bullet = Pool.getItem(\"Bullet\"); 此时如果拿到的对象是 null，那么我们应该考虑下，有两种情况： 1，对于特别频繁需要创建的某个对象，或者创建这个对象的过程比较消耗性能，我们可以在进入这个场景的加载过程中，预先创建好一组对象，并把这组对象放入对象池中 // 第一次创建子弹的对象池 let bulletPool = Laya.Pool.getPoolBySign(\"Bullet\"); // 创建10个子弹对象，并放入对象池中 for( var i = 0 ; i 2，对于创建对象性能要求不高，我们可以通过下面的方法来创建对象，并随时把对象放入对象池中 2.3.2 通过标识获得，没有则创建 /** * 根据传入的对象类型标识字符，获取对象池中此类型标识的一个对象实例。 * 当对象池中无此类型标识的对象时，则使用传入的创建此类型对象的函数，新建一个对象返回。 * @param sign 对象类型标识字符。 * @param createFun 用于创建该类型对象的方法。 * @param caller this对象 * @return 此类型标识的一个对象。 */ static getItemByCreateFun(sign: string, createFun: Function, caller: any = null): any { var pool: any[] = Pool.getPoolBySign(sign); var rst: any = pool.length ? pool.pop() : createFun.call(caller); rst[Pool.POOLSIGN] = false; return rst; } 基于上述的情况，如果对象池中没有对象了，可以随时利用这个方法创建对象： let bullet = Laya.Pool.getItemByCreateFun(\"Bullet\", function() { // 创建一个子弹 let bullet = new Bullet(); // 拿到子弹的对象池 var pool = Laya.Pool.getPoolBySign(\"Bullet\"); // 把子弹放入对象池，也可以不放入对象池，根据开发者需求 pool.push( bullet ); // 返回子弹对象 return bullet; }); 2.4 回收对象到池中 2.4.1 通过对象进行回收 /** * 将对象放到对应类型标识的对象池中。 * @param sign 对象类型标识字符。 * @param item 对象。 */ static recover(sign: string, item: any): void { if (item[Pool.POOLSIGN]) return; item[Pool.POOLSIGN] = true; Pool.getPoolBySign(sign).push(item); } 比如在游戏的一场战斗过程中，从对象池中拿出的子弹已经结束了它的生命周期时，我们可以通过代码来回收这个子弹对象到对象池中： Laya.Pool.recover(\"Bullet\", bullet); 2.5 通过类名，获得和回收对象 往往我们在做复杂的系统架构过程中，通过使用类名来获得和回收对象是一种很好的处理方式。Laya的Pool对象已经为我们考虑了这种情况，我们先来看看 2.5.1 通过类名获得对象 /** * 根据传入的对象类型标识字符，获取对象池中此类型标识的一个对象实例。 * 当对象池中无此类型标识的对象时，则根据传入的类型，创建一个新的对象返回。 * @param sign 对象类型标识字符。 * @param cls 用于创建该类型对象的类。 * @return 此类型标识的一个对象。 */ static getItemByClass(sign: string, cls: new () => T): T { if (!Pool._poolDic[sign]) return new cls(); var pool = Pool.getPoolBySign(sign); if (pool.length) { var rst = pool.pop(); rst[Pool.POOLSIGN] = false; } else { rst = new cls(); } return rst; } 2.5.2 根据类名进行回收 /** * 根据类名进行回收，如果类有类名才进行回收，没有则不回收 * @param instance 类的具体实例 */ static recoverByClass(instance: any): void { if (instance) { var className: string = instance[\"__className\"] || instance.constructor._$gid; if (className) Pool.recover(className, instance); } } 有了这两种对应的方式，我们可以不用在代码中去关心每个对象的创建和回收，只关心对象的内部逻辑就好了。比如在战斗过程中有很多的技能特效，我们可以对每个特效用统一的方式进行管理对象池： export class EffectA { constructor() { super(); } static create(): EffectA { Pool.getItemByClass(EffectA); } recover(): void { Pool.recoverByClass(this); } } export class EffectB { constructor() { super(); } static create(): EffectB { Pool.getItemByClass(EffectB); } recover(): void { Pool.recoverByClass(this); } } 总结，Laya提供的Pool是一个比较基本的对象池，开发者可以根据自己的需求来扩展对象池的使用，从而更方便的实现更复杂的对象管理。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"basics/common/network/readme.html":{"url":"basics/common/network/readme.html","title":"网络通信","keywords":"","body":"网络通信一、概述二、Http连接2.1 Laya.HttpRequest2.2 GET2.3 POST2.4 扩展HttpRequest三、 WebSocket连接3.1 Laya.Sokcet3.2 Laya.Byte 二进制读写四、ProtocolBuffer使用4.1 Message 定义4.2 项目中添加protobuf 类库4.3 加载协议文件4.4 Message 方法4.5 代码示例网络通信 一、概述 在我们的项目开发过程中，除了单机不需要使用网络通信，开发一个网络项目，难免要处理网络通信。本章将讲解LayaAir的网络通信部分。通常我们使用 Http 和WebSocket 这两种网络通信方式。首先我们来对比一下两者的区别: HTTP： 优点：协议较成熟，应用广泛、基于TCP/IP，拥有TCP优点、研发成本很低，开发快速、nginx/apache/tomact等 缺点：无状态无连接、只有PULL模式，不支持PUSH、数据报文较大 特性：无状态，无连接（短链接）、支持C/S模式、适用于文本传输。 WebSocket： 优点：协议较成熟、基于TCP/IP，拥有TCP优点、数据报文较小，包头非常小、面向连接，有状态协议、开发较快 缺点：websocket 是应用层协议所以数据包不简洁，更耗流量，还耗费性能 特性：有状态，面向连接、数据报头较小 通过以上对协议特性分析，建议： 1，对于弱联网类游戏，比如消除类的，卡牌类的，可以直接HTTP协议，考虑安全的话直接HTTPS，或者对内容体做对称加密； 2，对于实时性，交互性要求较高，且team有过相关经验，可以优先选择websocket协议，比如SLG和RPG等大型网络游戏 二、Http连接 HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。 2.1 Laya.HttpRequest 在LayaAir引擎中 HttpRequest 就是我们发送请求的基本类。HttpRequest 类其实包装的就是原生的 XMLHttpRequest，我们先来了解下 HttpRequest。 2.1.1 原生 XMLHttpRequest 对象 /** * 本对象所封装的原生 XMLHttpRequest 引用。 */ get http(): any { return this._http; } 通过 .http 属性可以获得XMLHttpRequest。XMLHttpRequest 中文可以解释为可扩展超文本传输请求。它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。 1，属性 属性 类型 描述 onreadystatechange function 一个JavaScript函数对象，当readyState属性改变时会调用它。 readyState unsigned short 请求的五种状态 response varies 响应实体的类型由 responseType 来指定， 可以是 ArrayBuffer ，Blob， Document， JavaScript 对象 (即 “json”)， 或者是字符串。如果请求未完成或失败，则该值为 null responseText DOMString 此次请求的响应为文本，或是当请求未成功或还未发送时为 null只读。 responseType XMLHttpRequestResponseType 设置该值能够改变响应类型。就是告诉服务器你期望的响应格式。 status unsigned short 该请求的响应状态码 (例如，状态码200 表示一个成功的请求).只读 statusText DOMString 该请求的响应状态信息，包含一个状态码和原因短语 (例如 “200 OK“)。 只读 upload XMLHttpRequestUpload 可以在 upload 上添加一个事件监听来跟踪上传过程。 withCredentials boolean 表明在进行跨站(cross-site)的访问控制(Access-Control)请求时，是否使用认证信息(例如cookie或授权的header)。 默认为 false timeout number 请求超时时间 2，方法 abort() 如果请求已经被发送,则立刻中止请求。 getAllResponseHeaders() 返回所有响应头信息(响应头名和值)， 如果响应头还没接受,则返回null。 getResponseHeader() 返回指定的响应头的值, 如果响应头还没被接受,或该响应头不存在,则返回null。 open() 初始化一个请求. send() 发送请求. 如果该请求是异步模式(默认)，该方法会立刻返回。 相反，如果请求是同步模式，则直到请求的响应完全接受以后，该方法才会返回。 setRequestHeader() 给指定的HTTP请求头赋值。在这之前，你必须确认已经调用 open() 方法打开了一个url。 因此使用 HttpRequest 的过程中，我们也可以获得 XMLHttpRequest 对象，并对 XMLHttpRequest 对象做相关的操作，在此我们就不对 XMLHttpRequest 做过多讲解，开发者可以自行查阅相关文档。 详细的XMLHttpRequest，请看 W3C的xhr 标准; XMLHttpRequest发各种类型的数据，可以参考发送数据和html5rocks上的这篇文章 了解XMLHttpRequest的基本使用，可以参考MDN的XMLHttpRequest介绍； 想了解跨域请求，则可以参考W3C的 cors 标准; 2.1.2 send() 方法 发送请求， 通常发送的请求是异步方式，其中send的参数类型如下： /** * 发送 HTTP 请求。 * @param url 请求的地址。大多数浏览器实施了一个同源安全策略，并且要求这个 URL 与包含脚本的文本具有相同的主机名和端口。 * @param data (default = null)发送的数据。 * @param method (default = \"get\")用于请求的 HTTP 方法。值包括 \"get\"、\"post\"、\"head\"。 * @param responseType (default = \"text\")Web 服务器的响应类型，可设置为 \"text\"、\"json\"、\"xml\"、\"arraybuffer\"。 * @param headers (default = null) HTTP 请求的头部信息。参数形如key-value数组：key是头部的名称，不应该包括空白、冒号或换行；value是头部的值，不应该包括换行。比如[\"Content-Type\", \"application/json\"]。 */ send(url: string, data: any = null, method: \"get\" | \"post\" | \"head\" = \"get\", responseType: \"text\" | \"json\" | \"xml\" | \"arraybuffer\" = \"text\", headers: any[] | null = null): void { 2.1.3 支持的事件类型 我们常用的基本就是进度事件，完成事件，错误事件等 /** * 请求进度改变时调度。 * @eventType Event.PROGRESS * */ /*[Event(name = \"progress\", type = \"laya.events.Event\")]*/ /** * 请求结束后调度。 * @eventType Event.COMPLETE * */ /*[Event(name = \"complete\", type = \"laya.events.Event\")]*/ /** * 请求出错时调度。 * @eventType Event.ERROR * */ /*[Event(name = \"error\", type = \"laya.events.Event\")]*/ 2.1.4 在代码中怎么使用 laya引擎中用 HttpRequest 继承的是 EventDispatcher，具有事件派发的功能。加上本身具备发送请求的功能。我们写个简单的例子来看下用法： class LayaSample { constructor() { //创建HttpRequest对象 let http: Laya.HttpRequest = new Laya.HttpRequest(); //设置超时时间 http.http.timeout = 10000; //设置完成事件，添加回调方法 http.once(Laya.Event.COMPLETE, this, this.completeHandler); //设置错误事件，添加回调方法 http.once(Laya.Event.ERROR, this, this.errorHandler); //设置进度事件，添加回调方法 http.on(Laya.Event.PROGRESS, this, this.processHandler); //发送了一个简单的请求 http.send(\"res/data.data\", \"\", \"get\", \"text\"); } private processHandler(data:any): void { } private errorHandler(error:any): void { } private completeHandler(data:any): void { } } new LayaSample(); 2.2 GET 上面这个示例我们发送了一个简单的请求，方式是get方式。用来获取一个远端的文件，格式为文本的格式。假如我们动态请求远端数据可以改成如下格式： this.hr = new HttpRequest(); this.hr.once(Event.PROGRESS, this, this.onHttpRequestProgress); this.hr.once(Event.COMPLETE, this, this.onHttpRequestComplete); this.hr.once(Event.ERROR, this, this.onHttpRequestError); //发送了一个get请求，携带的参数为 name=myname 和 psword=xxx this.hr.send('http://xkxz.zhonghao.huo.inner.layabox.com/api/getData?name=myname&psword=xxx', null, 'get', 'text'); 这里的重点是send方法，这个send方法要和 XMLHttpRequest 的send区分开。 2.3 POST 下面用post方法请求一个数据方式如下： this.hr = new HttpRequest(); this.hr.once(Event.PROGRESS, this, this.onHttpRequestProgress); this.hr.once(Event.COMPLETE, this, this.onHttpRequestComplete); this.hr.once(Event.ERROR, this, this.onHttpRequestError); //发送了一个post请求，携带的参数为 name=myname 和 psword=xxx this.hr.send('http://xkxz.zhonghao.huo.inner.layabox.com/api/getData', 'name=myname&psword=xxx', 'post', 'text'); 注意：GET和POST请求是有区别的： GET请求参数是通过URL进行传递的，POST请求的参数包含在请求体当中。 GET请求比POST请求更不安全，因为参数直接暴露在URL中，所以，GET请求不能用来传递敏感信息。 GET请求在url中传递的参数是有长度限制的(在HTTP协议中并没有对URL的长度进行限制，限制是特定的浏览器以及服务器对他的限制，不同浏览器限制的长度不同)，POST对长度没有限制。 GET请求参数会完整的保留在浏览器的历史记录中，POST请求的参数不会保留。 GET请求进行url编码(百分号编码)，POST请求支持多种编码方式。 2.4 扩展HttpRequest 在开发过程中 HttpRequest 可能不能满足我们的需求，比如上传文件，比如设置超时时间，比如操作表单数据等等。扩展 HttpRequest 很简单，你继承HttpRequest，或者干脆自己重写 HttpRequest 这个类都可以，这个看开发者的需求，重写 HttpRequest 建议直接继承 EventDispatcher。重写就是重新包装 XMLHttpRequest 这个类。下面是一个简单的继承的示范： class HttpRequestExtension extends Laya.HttpRequest { constructor() { super(); } public send(url:string,data:any=null,method:string=\"get\", responseType:string=\"text\", headers:any=null):void{ super.send(url,data,method,responseType,headers); this._http.upload.onprogress= function(e:any):void { //上传进度 } this._http.upload.onload= function(e:any):void { } this._http.upload.onerror= function(e:any):void { } this._http.upload.onabort = function(e:any):void { } } } 上面是一个上传文件的示范，添加了 XMLHttpRequest 的upload的一些事件，这里的 super.send 简单的用了父类的方法，开发者可以不用，完全自己另写一套来满足自己的需求。 三、 WebSocket连接 WebSocket是一种基于ws协议的技术，它使得建立双全工连接成为可能。websocket常见于浏览器中，但是这个协议不受使用平台的限制。 websocket发送数据的格式一般为二进制和字符串。LayaAir引擎已经为我们封装好了 Socket 和 Byte 类，收发数据结合Byte类就可以完成。 3.1 Laya.Sokcet 在LayaAir引擎中 Socket 就是我们使用 WebSocket 的基本类。 Socket 封装了 HTML5 WebSocket ，允许服务器端与客户端进行全双工（full-duplex）的实时通信，并且允许跨域通信。在建立连接后，服务器和 Browser/Client Agent 都能主动的向对方发送或接收文本和二进制数据。我们先来了解下 Socket 的用法 3.1.1 Connect 服务器 Socket 连接服务器有三种方式： 方式 说明 构造函数传参 立即连接 比如 new Socket(“192.168.1.2”,8899)；注意这里的host参数没有ws前缀。 connect方法 传递url和端口号，连接服务器；socket.connect(“192.168.0.1.2”，8989)；注意这里的host参数没有ws前缀。 connectByUrl方法 传递整个url，比如 socket.connectByUrl(“ws://localhost:8989”)；这里有ws前缀。 3.1.2 发送数据 发送数据很简单，只需要调用Socket的send函数即可，参数可以是string或者是ArrayBuffer。 发送字符串格式： this.socket.send(\"hello world\");//这是发送字符串的形式。 发送二进制格式的数据： //写入一个字节 this.byte.writeByte(1); //写入一个int16的数据 this.byte.writeInt16(20); //写入一个32位的浮点数据 this.byte.writeFloat32(20.5); // 写入一个字符串； this.byte.writeUTFString(\"hello\"); //这里声明一个临时Byte类型 var by:Laya.Byte = new Laya.Byte(); //设置endian； by.endian = Laya.Byte.LITTLE_ENDIAN; //写入一个int32数据 by.writeInt32(5000); //写入一个uint16 数据 by.writeUint16(16); //把临时字节数据的数据写入byte中，这里注意写入的是by.buffer; this.byte.writeArrayBuffer(by.buffer); //这里是把字节数组的数据通过socket发送给服务器。 this.socket.send(this.byte.buffer); //清除掉数据;方便下次读写； this.byte.clear(); 上面我们看到，通过一个字节数组把我们需要的数据读入一个Byte数组，最后发送给服务器的是byte.buffer，这是一个ArrayBuffer的数据类型。这里一定要注意send的参数是 ArrayBuffer，很多开发者可能不注意，直接传递成了Byte，导致发送数据不正确。假如写成 this.socket.send(this.byte)；这是错误的，这点一定要注意。 3.1.3 接收数据 客户端从服务器接收到的数据都会派发到 Event.MESSAGE 监听函数中。receiveHandler的参数就是服务器发送回来的数据。可能是字符串，也可能是二进制ArrayBuffer。接收到的是字符串我们不用读，拿来直接用就可以。但是接收到的是二进制的话我们需要读取出来，转成我们需要的类型。 private receiveHandler(msg: any = null): void { ///接收到数据触发函数 //.............这里我们假设收到的是二进制ArrayBuffer this.byte.clear(); this.byte.writeArrayBuffer(msg);//把接收到的二进制数据读进byte数组便于解析。 this.byte.pos = 0;//设置偏移指针； ////下面开始读取数据，按照服务器传递过来的数据，按照顺序读取 var a:number = this.byte.getByte(); var b:number = this.byte.getInt16(); var c:number = this.byte.getFloat32(); var d:string = this.byte.getString(); var e:string = this.byte.getUTFString(); } 3.1.4 支持的事件类型 我们常用的基本就是连接建立成功，接收到数据，连接被关闭，出现异常后调度等 /** * 连接建立成功后调度。 * @eventType Event.OPEN * */ /*[Event(name = \"open\", type = \"laya.events.Event\")]*/ /** * 接收到数据后调度。 * @eventType Event.MESSAGE * */ /*[Event(name = \"message\", type = \"laya.events.Event\")]*/ /** * 连接被关闭后调度。 * @eventType Event.CLOSE * */ /*[Event(name = \"close\", type = \"laya.events.Event\")]*/ /** * 出现异常后调度。 * @eventType Event.ERROR * */ /*[Event(name = \"error\", type = \"laya.events.Event\")]*/ 3.1.5 在代码中怎么使用 我们举一个简单的发送和接收数据的 WebSocket 代码示例： private connect(): void { //创建Socket对象 this.socket = new Socket(); //对服务器建立连接 this.socket.connectByUrl(\"ws://echo.websocket.org:80\"); //表示需要发送至服务端的缓冲区中的数据 this.output = this.socket.output; //添加监听事件 this.socket.on(Event.OPEN, this, this.onSocketOpen); this.socket.on(Event.CLOSE, this, this.onSocketClose); this.socket.on(Event.MESSAGE, this, this.onMessageReveived); this.socket.on(Event.ERROR, this, this.onConnectError); } //连接建立成功回调 private onSocketOpen(e: any = null): void { console.log(\"Connected\"); // 发送字符串 this.socket.send(\"demonstrate \"); // 使用output.writeByte发送 var message: string = \"demonstrate \"; for (var i: number = 0; i 3.2 Laya.Byte 二进制读写 在开发项目中，二进制的操作是不可或缺的。在html5时代，对二进制的支持已经有了很大的突破。但是api的繁琐，对开发者开发项目来说不太方便。在页游时代，ActionScript3.0的二进制数组ByteArray，功能完善，api操作简单易懂，因此Laya的Byte在参考ByteArray的同时承接了html5的TypedArray类型化数组的特点。下面看下主要的用法 3.2.1 常用方法 构造方法 参数： length ：长度 当传入length参数时，一个内部数组缓冲区被创建,该缓存区的大小是传入的length大小。 typedArray：类型化数组 当传入一个包含任意类型元素的任意类型化数组对象(typedArray) (比如 Int32Array)作为参数时，typeArray被复制到一个新的类型数组。typeArray中的每个值会在复制到新的数组之前根据构造器进行转化。新的生成的类型化数组对象将会有跟传入的数组相同的length(译者注:比如原来的typeArray.length==2，那么新生成的数组的length也是2，只是数组中的每一项进行了转化)。 ArrayBuffer：二进制数据缓冲区。 上面的三种方法都可以实例化一个Byte，根据参数的不同创建二进制数据。 //实例化一个二进制数组Byte var byte:Laya.Byte = new Laya.Byte(); //或者传入一个类型化数组 var uint8Byte:Uint8Array = new Uint8Array(10); var byte:Laya.Byte = new Laya.Byte(uint8Byte); //或者传入一个ArrayBuffer类型 var buffer:ArrayBuffer = new ArrayBuffer(20); var byte:Laya.Byte = new Laya.Byte(buffer); writeArrayBuffer(arraybuffer:*, offset:number = 0, length:number = 0):void 写入指定的二进制缓冲数据。指定数据的偏移量和长度，如下： var byte:Laya.Byte = new Laya.Byte(); var byte1:Laya.Byte = new Laya.Byte(); byte1.writeFloat32(20.0);//写入一个四个字节的浮点数 byte1.writeInt16(16);//写入一个两个字节的整数 byte1.writeUTFString(\"hell world\");//写入一个字符串； byte.writeArrayBuffer(byte1.buffer,6);//把byte1的数据从第六个字节开始读入byte中。省略其中的浮点数20.0和整数16 byte.pos = 0;// console.log(byte.readUTFString())//从byte中读出字符串。 读取数据 getByte():number在字节流中读一个字节。 getInt16():number在当前字节偏移量位置处读取 Int16 值。 getInt32():number在当前字节偏移量位置处读取 Int32 值 getFloat32():number在指定字节偏移量位置处读取 Float32 值。 getFloat32Array(start:number, len:number):any从指定的位置读取指定长度的数据用于创建一个 Float32Array 对象并返回此对象。 getFloat64():number在指定字节偏移量位置处读取 Float64 值。 getInt16():number 在当前字节偏移量位置处读取 Int16 值。 getInt32():number在当前字节偏移量位置处读取 Int32 值。 getUint8():number在当前字节偏移量位置处读取 Uint8 值。 getUint16():number在当前字节偏移量位置处读取 Uint16 值。 getUint32():number在当前字节偏移量位置处读取 Uint32 值。 getInt16Array(start:number, len:number):any从指定的位置读取指定长度的数据用于创建一个 Int16Array 对象并返回此对象。 getString():string读取字符型值。 getUTFBytes(len:number = -1):string 读字符串，必须是 writeUTFBytes 方法写入的字符串。 getUTFString():string 读取 UTF-8 字符串。 写入数据 writeByte(value:number):void在字节流中写入一个字节。 var byte:Laya.Byte = new Laya.Byte(); byte.writeByte(10);//0-255之间 ​ writeFloat32(value:number):void在当前字节偏移量位置处写入 Float32 值。范围是$\\left[-2^{128}, 2^{127}\\right]$，约为-3.4E38—3.4E+38。 var byte:Laya.Byte = new Laya.Byte(); byte.writeFloat32(10.021); ​ writeFloat64(value:number):void写入float64位数值 其数值范围为-1.7E308～1.7E+308。 ​ writeInt16(value:number):void在当前字节偏移量位置处写入 Int16 值。范围-32768 到 +32767之间。 var byte:Laya.Byte = new Laya.Byte(); byte.writeInt16(120); ​ writeInt32(value:number):void在当前字节偏移量位置处写入 Int32 值。-2,147,483,648 到 +2,147,483,647 之间的有符号整数。 **writeUint16**(value:number):void在当前字节偏移量位置处写入 Uint16 值。 ​ writeUint32(value:number):void在当前字节偏移量位置处写入 Uint32 值。 ​ writeUint8(value:number):void在当前字节偏移量位置处写入 Uint8 值。 ​ writeUTFBytes(value:string):void写入字符串，该方法写的字符串要使用 readUTFBytes 方法读取。 ​ writeUTFString(value:string):void将 UTF-8 字符串写入字节流。 clear():void清除数据。 var byte:Laya.Byte = new Laya.Byte(); byte.writeInt16(120); byte.pos =0;//读取位置归零。 getSystemEndian():string[static] 获取系统的字节存储顺序。 console.log(Laya.Byte.getSystemEndian());//打印系统的字节顺序 3.2.2 属性 BIG_ENDIAN : string= bigEndian[static] 表示多字节数字的最高有效字节位于字节序列的最前面。 LITTLE_ENDIAN : string= littleEndian[static] 表示多字节数字的最低有效字节位于字节序列的最前面。 [pos] : number当前读取到的位置。 var byte:Laya.Byte = new Laya.Byte(); byte.writeInt16(120); byte.pos =0;//读取位置归零。 length: number字节长度。 endian : string字节顺序。 var byte:Laya.Byte = new Laya.Byte(); byte.endian = Laya.Byte.BIG_ENDIAN;//设置为大端； bytesAvailable : number[read-only] 可从字节流的当前位置到末尾读取的数据的字节数。 var byte:Laya.Byte = new Laya.Byte(); byte.writeFloat32(20.0); byte.writeInt16(16); byte.writeUTFString(\"hell world\"); byte.pos = 6; console.log(byte.bytesAvailable) 3.2.3 代码演示 下面我们通过一个完整的代码来演示下这个类的应用，比如网络连接中，我们接收和发送网络消息。 var msg:any ={name:\"xxx\",age:18,weight:65.5,height:175}; var byte:Laya.Byte = new Laya.Byte(); //实例化byte数组 byte.endian = Laya.Byte.LITTLE_ENDIAN; //设置大小端 byte.writeUTFString(msg.name); //写入数据 byte.writeByte(msg.age); byte.writeFloat32(msg.weight); byte.writeInt16(msg.height); 输出看下结果： //设置pos为0 开始从头开始按照写入的顺序读取读取 byte.pos = 0; console.log(byte.getUTFString()); console.log(byte.getByte()); console.log(byte.getFloat32()); console.log(byte.getInt16()); 3.2.4 类型化数组 Laya的byte封装的就是类型化数组，开发者可以参考mdn的官方api说明。来扩展自己的项目的应用。 DataView 视图提供了一个与平台中字节在内存中的排列顺序(字节序)无关的从ArrayBuffer读写多数字类型的底层接口。 Uint8Array 数组类型表示一个8位无符号整型数组，创建时内容被初始化为0。创建完后，可以以对象的方式或使用数组下标索引的方式引用数组中的元素。 Int8Array :类型数组表示二进制补码8位有符号整数的数组。内容初始化为0。 一旦建立，你可以使用对象的方法引用数组中的元素，或使用标准数组索引语法。 Int16Array();类型数组表示二进制补码16位有符号的数组。 Uint16Array();类型数组表示二进制补码16位无符号的数组 Int32Array();类型数组表示二进制补码32位有符号的数组 Uint32Array();类型数组表示二进制补码32位无符号的数组 Float32Array();类型数组表示32位浮点数数组。 Float64Array();类型数组表示64位浮点数数组。 四、ProtocolBuffer使用 protocolbuffer（以下简称PB）是google 的一种数据交换的格式，它独立于语言，独立于平台。类似于XML，JSON这样的数据表示语言，ProtocolBuffer是用于结构化数据串行化的灵活、高效、自动的方法，格式有点类似XML，可以自己定义数据格式，它是一种二进制格式允许你使用规范的语言定义一个模式。 ProtocolBuffer 作为网络通信的协议格式，是现在一种非常流行的方式，下来我们来了解一下。 4.1 Message 定义 这里简单的给出一个例子，是一个非常简单的请求的message格式 // awesome.proto package awesomepackage; //指定proto版本 syntax = \"proto3\"; //message包含多个种类的fields message AwesomeMessage { string awesome_field = 1; // becomes awesomeField } 上述例子中fields的种类是字符串型的（string），当然也可以指定更加复杂的fields，比如枚举类型enum，或者是嵌套的message类型 上述Message定义好之后，我们把协议文件保存到项目目录中 \"assets/res/protobuf/awesome.proto\"; 4.2 项目中添加protobuf 类库 我们可以从 https://github.com/protobufjs/protobuf.js 下载最新 protobuf 类库，并放到项目的bin目录中，同时在index.html 中引用到 protobuf.js 4.3 加载协议文件 protobuf 类库，通过 load 方法来加载协议文件 /** * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback. * @param {string|string[]} filename One or multiple files to load * @param {Root} root Root namespace, defaults to create a new one if omitted. * @param {LoadCallback} callback Callback function * @returns {undefined} * @see {@link Root#load} */ function load(filename, root, callback) { if (typeof root === \"function\") { callback = root; root = new protobuf.Root(); } else if (!root) root = new protobuf.Root(); return root.load(filename, callback); } 4.4 Message 方法 Message.verify(message: Object): null|string 验证一个Message对象是否满足有效消息的要求 Message.create(properties: Object): Message 对满足有效消息要求的一组Javascirpt数据创建新消息实例。 Message.encode(message: Message|Object [, writer: Writer]): Writer 对Message对象进行编码，用于网络通信传输 Message.decode(reader: Reader|Uint8Array): Message 网络通信传输数据中，解码获得Mesaage对象 Message.toObject(message: Message [, options: ConversionOptions]): Object 转换Message对象数据到一组Javascirpt数据 4.5 代码示例 onAwake(): void { var resPath: string = \"assets/res/protobuf/awesome.proto\"; // 加载protobuf文件 this.ProtoBuf.load(resPath, this.onAssetsLoaded); } private onAssetsLoaded(err: any, root: any): void { if (err) throw err; // 获得一个Message消息类型 var AwesomeMessage: any = root.lookupType(\"awesomepackage.AwesomeMessage\"); console.log(AwesomeMessage); // 初始化数据 var payload: any = { awesomeField: \"AwesomeString\" }; console.log(payload); // 验证数据是否有效 var errMsg: any = AwesomeMessage.verify(payload); // 如果有异常抛出异常并终止 if (errMsg) throw Error(errMsg); // 创建Message的实体 var message: any = AwesomeMessage.create(payload); console.log(message); // 编译Message实体成 Buffer 数据格式，等待发送数据 var buffer: any = AwesomeMessage.encode(message).finish(); console.log(buffer); } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"basics/common/adaptScreen/readme.html":{"url":"basics/common/adaptScreen/readme.html","title":"屏幕适配","keywords":"","body":"LayaAir屏幕适配及有效抗锯齿一、基础概念1.1 物理分辨率1.2 缩放因子与逻辑分辨率1.3 设备像素比1.4 逻辑宽高1.5 物理宽高（屏幕宽高）1.6 设计宽高1.7 画布宽高1.8 适配宽高1.9 舞台宽高二、抗锯齿相关介绍2.1 锯齿产生的原因2.2 引擎内置的抗锯齿2.3 开启抗锯齿，为什么还有锯齿感2.4 让画布使用物理分辨率三、LayaAir屏幕适配模式详解3.1 最容易理解的适配模式3.2 移动端推荐的适配模式3.3 其它适配模式3.4 刘海屏适配思路3.5 其它适配相关学习LayaAir屏幕适配及有效抗锯齿 Author: Charley 有的时候看到一些3D游戏锯齿感特别明显，与一些开发者沟通后发现，其实很多人并不清楚怎么能去掉明显的锯齿感，而这并不是只有新开发者才遇到的问题，很多游戏研发经验丰富的开发者，甚至是使用LayaAir引擎开发了很多游戏的开发者也会不清楚。另外，最近也遇到有开发者想了解刘海屏如何适配，所以通过本篇文章全面介绍一下。 为了兼顾新手开发者来理解这个事，本篇从基础概念入手，详细介绍LayaAir引擎的各个屏幕适配缩放模式，刘海屏适配思路，以及如何有效的抗锯齿。 一、基础概念 以下基础概念非常重要，会影响到后面引擎适配原理的理解，请大家认真阅读。 1.1 物理分辨率 物理分辨率简单理解就是硬件所支持的分辨率，以像素（px）为单位，所以我们称这个硬件上的每一个像素点为物理像素，也叫设备像素。将屏幕实际存在的像素以行数 × 列数这样的数学表达方式体现出来，就是物理分辨率。 而LayaAir引擎运行于浏览器或其它运行器环境上，进行屏幕适配时，物理分辨率实际上是指浏览器或运行环境上的屏幕分辨率。以屏幕宽的像素数量 × 屏幕高的像素数量这样来体现。因此，横屏与竖屏得到的物理分辨率宽高，会有所差别。 例如：iPhone8 在默认的竖屏状态下，物理分辨率宽高表达为750 × 1334。横屏状态下，物理分辨率宽高表达为1334 × 750 。 1.2 缩放因子与逻辑分辨率 1.2.1 缩放因子 起源 iOS绘制图形是以 point （pt）为单位，在早期的时候1 point=1 pixel。在2010年推出的iPhone4 开始采用 Retina(视网膜) 屏幕显示技术 ，物理分辨率提升了4倍，此时，如果iPhone4 还是1pt=1px这个方案，将会导致如下图一样的显示效果。 （图1） 在图1中，按 iPhone3GS的320 × 480进行全屏设计，那在iPhone4下的显示效果则如图1左侧，原来的满屏内容只占了四分之一，其余部分留空。而按iPhone4分辨率 640 × 960进行全屏设计，那在iPhone3GS的屏幕下显示效果则如图1右侧，大量内容超出可显示区。 很显然，apple不会让图1的事情发生。实际上，iPhone4的缩放因子为@2X，也就是在这个机型上1个point 用2×2的像素矩阵来表示，如图2中效果所示，完美解决图1中可能发生的问题。 （图2） 随着时代的发展，后续的机型物理分辨率也越来越高，1个point占用的物理像素也越来越多，见下图。 （图3） 缩放因子的概念在安卓机型中也适用 1.2.2 逻辑分辨率 逻辑分辨率简单理解就是软件所使用的分辨率，我们设计适配全靠他，也是用乘法数学表达方式来体现。为了更好的理解这个概念，我们先看一组数据表格。 （图4） 通过图4的数据，我们可以看出，随着手机设备的更新，物理分辨率已经越来越高，如果我们按物理分辨率来进行屏幕适配，先不算安卓，光iPhone的机型就很碎片化了，还好，在缩放因子的作用下，我们看到逻辑分辨率基本上变化不大，所以我们后面讲的引擎适配，主要是针对逻辑分辨率进行适配。 1.3 设备像素比 我们基于浏览器开发时，之前介绍的缩放因子概念对应的是DPR (Device Pixel Ratio)，中文叫设备像素比 。LayaAir引擎中通过 Laya.Browser.pixelRatio 可以获得浏览器的DPR值。 这里稍展开讲几句，在浏览器里，默认是由用户来控制缩放的，例如，我们在手机浏览器双指扩张，发现网页会放大，但清晰度并不减小。这就是用户自主缩放导致，并非是由DPR值来决定缩放。如果我们想和APP开发那样，通过逻辑分辨率来适配，让浏览器依据设备的DPR来决定一个CSS像素占用几个物理像素。那需要在入口HTML页面的的meta标签中用 viewport进行了相关的配置。代码如下： 以上代码LayaAir引擎中默认添加，并强制添加不得删除。 通过上面这段viewport的配置，那页面在禁止用户手动缩放的同时，也会按设备的DPR进行自动缩放。 1.4 逻辑宽高 逻辑宽高是指逻辑分辨率的宽高。浏览器里，可以缩放的逻辑分辨率像素是CSS像素，在设置了viewport的情况下，浏览器会根据DPR的值决定一个CSS占用多少个像素，例如DPR为3时，1个CSS像素就占用3×3个物理像素。 LayaAir引擎里可以通过Laya.Browser.clientWidth获取逻辑分辨率的宽，通过Laya.Browser.clientHeight获取逻辑分辨率的高。 在手机等移动设备的竖屏状态下，窄面为宽，长面为高。如果发生了屏幕翻转的横屏状态，则长的一面为宽，窄面为高。 在PC浏览器中，则是获取的浏览器窗口可视宽高。 1.5 物理宽高（屏幕宽高） 物理宽高对应的是之前介绍的物理分辨率概念，也称为屏幕宽高。开发者可以通过引擎封装的接口获得宽高值，通过Laya.Browser.width可以得到屏幕宽上有多少像素，通过Laya.Browser.height可以得到屏幕高上有多少像素。 只有在全屏的时候屏幕宽高是硬件屏幕宽高，开发者需要理解的是，屏幕宽高实际是指运行环境窗口宽高，例如在浏览器上运行就是浏览器显示窗口的宽高。 LayaAir引擎中的物理宽高是通过逻辑宽高*DPR计算而来。而奇葩的iPhone6/7/8各Plus机型，逻辑分辨率是736×414，DPR的值是3，相乘得到的结果显然与真实的各Plus机型物理分辨率1920×1080不符合。 讲到这里，开发者了解到有这回事即可，不用担心适配错误，由于LayaAir引擎在入口网页的meta标签中用 viewport进行了相关的配置，所以会按DPR自动进行缩放，最终会自动缩放到对应到实际的物理分辨率。 至于Plus机型为什么要这样奇葩的设置，这里就不展开讲了，有兴趣的同学可以自行百度搜索答案。 1.6 设计宽高 设计宽高是开发者在设计产品时采用的宽高，面对众多机型，选择哪个作为设计宽高，也是一些新手开发者有点迷茫的，这里简单多说几句。 （图5） 设计宽高，首先要考虑的是优先兼容多数的常用屏幕比例。通过上面图5的表格，我们看到去掉过时的机型，基本上手机屏幕就分两类，一类是宽高比约为1:1.78的非全面屏手机，另一类是宽高比约为1:2.17全面屏手机。各品牌的安卓机型屏幕比例，大多也是这两种或者接近这两种。 基于性能优先的原则，通常开发者都会选择分辨率小一些的作为主效果设计，然后向其它比例屏幕进行适配。比如：常见的宽750高1334或宽720高1280。 以上宽高描述是指竖屏模式设计，横屏需反过来。 打开LayaAir 3.0 IDE 的项目设置面板Project Settings面板，可以直接设置，效果如图6所示。 （图6） 1.7 画布宽高 众所周知，是HTML5中的画布，其 width、heigth 属性就是画布宽高。 画布宽高在noscale、exactfit、noborder这几个LayaAir引擎适配模式下会直接采用设计宽高值，其它适配模式下，会根据适配规则产生变化。画布宽高的值对画面最终的清晰度以及性能都会产生影响，甚至边缘锯齿或画面模糊也与此处画布宽高值有关。 我们在IDE里任意运行一个页面， 在打开的chrome里用F12进入调试模式后，入口页面中找到id为 layaCanvas的canvas标签。记住这个位置，图7中红圈标记的，就是画布的初始宽高，后面理解屏幕适配模式的时候，大家可以多关注这里。 （图7） 1.8 适配宽高 由于Canvas是基于位图像素绘图的，画布宽高对画面质量及性能有影响，又或者诸如plus特殊的分辨率等问题。所以不能通过直接改变画布宽高来适配，否则会出来一些适配问题。在LayaAir引擎中会根据不同的适配模式规则，计算出适配宽高需要缩放的比例，然后通过transform的matrix（矩阵）来对画布缩放至逻辑分辨率范围内，再通过viewport与DPR机制缩放还原。 基于以上种种，我们需要了解，适配宽高才是LayaAir引擎适配规则处理后的最终效果宽高，会直接影响通过DPR还原后的最终效果。 大家在理解各个适配模式的时候，可以在HTML入口页面中观察画布宽高与transform的matrix（矩阵）缩放效果来对比不同模式之间的差异。例如图8中红圈标记所示，适配宽高分别为249.99975和444.666222。还原至物理分辨率大小后，虽然有精度上的细微损失，但已经很难看出。 （图8） 1.9 舞台宽高 舞台宽高是指LayaAir引擎的stage宽高，引擎的节点对象都是在stage上进行添加与控制的，在stage范围内，可以控制显示、进行事件监听，碰撞检测等，所以对stage宽高的适配还是非常重要的。 在DevTools控制台，我们可以通过引擎API(Laya.stage.width和Laya.stage.height)，查看舞台宽高。 默认情况下，stage宽高直接等于设计宽高。在full、fixedwidth、fixedheight、fixedauto的适配模式下，stage宽高会根据适配规则产生变化。本篇第三节会详细介绍。 二、抗锯齿相关介绍 2.1 锯齿产生的原因 我们屏幕的像素点，是由行与列的矩阵序列组成。也就是说屏幕中是不存在斜线的。基于像素绘图的画布，要是画横竖的直线，那绝对是相当的平滑。可是画曲线和斜线怎么办。只能是由两个相邻的像素点不断重复延伸组成，如果这句话不好理解，我们想象一下楼梯，从侧面去看，大概就是这个样子。示意效果如图9-1所示。 （图9-1） 另外，3D模型的基础构成是三角面组成的多边形网格，绘制3D多边形构成的模型，这和我们矢量画斜线、画曲线、画圆，是一样的道理。所以非矩形的矢量图形和3D模型，产生锯齿这是正常的。 2.2 引擎内置的抗锯齿 LayaAir引擎内置了抗锯齿方法， 3D抗锯齿，可以在Camera里设置，LayaAir提供了精度高的MSAA抗锯齿方案，以及性能高的FXAA抗锯齿方案，如图9-2所示。 （图9-2） 了解更多3D抗锯齿参数的区别，可以阅读3D Camera文档。 2D抗锯齿，想开启的话可以在Project Settings里设置，如图9-3所示。 （图9-3） 开启抗锯齿后，边缘锯齿会变得平滑模糊，示意效果如图9-4所示。 （图9-4） 模糊后的锯齿相对会平滑一些，在像素密度比较高的屏幕上，肉眼很难看出。从而达到消灭锯齿感的目标。 2.3 开启抗锯齿，为什么还有锯齿感 有的开发者发现，抗锯齿功能开启了，为什么还会感觉到锯齿感呢？ 有两个原因， 第一，是抗锯齿的方案问题，比如3D抗锯齿的MSAA与FXAA在精度上存在着一些细小的差别。 第二，哪怕是精度再高的抗锯齿，也不可能真的去掉锯齿，只是通过一些算法，让边缘过渡的更平滑。从而减轻锯齿现象。在一些像素密度比较大的屏幕上，让肉眼难以识别，并非真的让锯齿消失。 所以，开发者如果想进一步减轻锯齿感，那就让画布保持与物理分辨率同步。否则拉伸缩放画布进行全屏适配的方案，可能会导致抗锯齿效果减弱。 2.4 让画布使用物理分辨率 LayaAir引擎的适配模式里，只有full模式，默认就让画布采用了物理分辨率。 full模式除了让画布保持物理分辨率，相当于没有做适配方案。对于UI布局来说，适配门槛较高，只适用纯3D游戏或UI布局非常简单的3D游戏。 所以，我们推荐另一种方案，通过开启视网膜画布模式useRetinalCanvas配置，让所有适配模式都采用物理分辨率作为画布的大小。 这两种方案，我们可以通过IDE的项目设置面板进行设置，效果如图10所示。 (图10) 2.5.1 动态开启视网膜画布模式 如果想动态控制视网膜画布模式的开和关，也可以在项目代码里添加配置代码。代码如下： if(条件){ Laya.stage.useRetinalCanvas = false; }else{ Laya.stage.useRetinalCanvas = true; } Laya.stage.alignH = \"left\"; 这里需要提醒一下的是，需要同步设置Stage的scaleMode、width、height、alignH、alignV中的任意一个，这样修改才会生效。 因为，设置上面这些属性，会调引擎适配方法，从而修改画布等相关适配数据。 2.5.2 开启视网膜画布模式的利弊 理论上讲，开启视网膜画布模式，在超出设计宽高的机型上，会产生更多的性能消耗。因为画布上的像素越多，性能消耗越大。所以很多2D游戏，都会采用相对小一些的分辨率作为游戏设计宽高。 但从实际应用来讲，物理宽高所带来的性能压力也并没有那么多风险。要知道，一些小游戏平台是强制要求必须物理分辨率的。因此，LayaAirIDE在导出某些小游戏平台版本的时候，会强行开启视网膜画布模式（useRetinalCanvas）。 另外，开启视网膜画布模式，除了能解决一些小游戏平台中的问题，以及可以减轻锯齿现象外，其实还可以让适配变的更简单。因为不使用视网膜画布模式，还想避免锯齿现象，移动端只能使用full模式，而full模式除了让画布和舞台采用了物理分辨率之外，并没有作任何适配，所以对于2D UI，全部需要开发者手工适配。 所以，建议开启视网膜画布模式，尤其是3D游戏。如果考虑某些机型的性能压力，开发者可以在存在压力的机型，或者有性能压力的功能上，通过逻辑控制，动态开启或关闭视网膜画布模式。 三、LayaAir屏幕适配模式详解 LayaAir引擎的适配模式有8种，为了让大家真正理解各适配模式的适配策略，以便更好的进行屏幕适配。本节以LayaAirIDE创建的2D示例项目为例，将设计宽高调整为750×1334的竖屏界面，分别就各个适配模式对比不同机型进行讲解。 在适配对比的机型选择方面，iPhone4的640 × 960代表老旧机型，宽高比为1.5，只是为了对比适配效果。iPhone8的750 × 1334是我们为设计宽高选定的机型，宽高比约为1.78，无论哪个模式都是完美的1：1适配。iPhone8 Plus代表着同样约为1.78宽高比，但物理分辨率和DPR都与iPhone8不同的同比例机型。iPhoneX代表着宽高比大于2的各种全面屏机型。 3.1 最容易理解的适配模式 3.1.1 默认的不缩放模式noscale noscale模式是引擎默认的模式。该模式下，在任何屏幕都会始终保持设计时的物理分辨率原样效果，相当于将不缩放的设计宽高画布直接贴在屏幕上。物理宽高和设计宽高相等的屏幕会全屏显示，物理宽高低于设计宽高的会显示不全，物理宽高超过设计宽高的会漏出屏幕背景（白屏）。 该模式通常不被使用，仅有少数不使用引擎适配方案，有着自定义适配规则的开发者来使用。 noscale模式，不同机型对比效果如图11-1中所示。 （图11-1） 3.1.2 物理分辨率画布模式full full模式表示着画布宽高和舞台宽高一定是完整的全屏状态，但和noscale模式一样，并没有对设计宽高做缩放处理。在full模式下，画布大小直接取值物理分辨率，物理宽高是多少，画布就有多大，该模式下设计宽高参数的设置无意义，直接设置0,0即可。 该模式仍需要自己定义适配规则，多用于3D游戏。如果有UI界面，不想自己定义适配规则的，后面还会介绍更优的3D适配方案。 full模式，不同机型对比效果如图11-2中所示。 （图11-2） 特别说明一下，背景屏幕颜色为黑色的是画布背景色，不是stage背景色。通过Project Settings可以改变默认的画布背景色。 （图11） 在noscale模式下的白屏背景那是浏览器默认的，说明画布就那么大，画布没覆盖到的地方就是白屏背景。 假如在noscale模式下，开启了视网膜画布模式，那显示效果将会与图11-2的full模式效果相同，但区别是，full模式舞台（stage）宽高也是物理宽高，所以在游戏画面覆盖到的地方仍然可以有点击等事件响应。而noscale开启视网膜画布模式，只是强行将画布改为物理宽高，并没有改变舞台宽高，所以游戏画面（设计宽高）外的部分并不会对点击等事件产生响应。 3.1.3 强行拉伸全屏模式exactfit exactfit是一种不等比的全屏拉伸适配模式，画布宽高与舞台宽高会等于游戏设计宽高 。然后完全不考虑比例强行缩放至逻辑宽高全屏。所以除非是设计宽高与物理宽高相等，否则就会有一些因拉伸产生的变形。屏幕分辨率宽高比与设计宽高比差距越大的，变形的越明显。 拉伸至物理宽高全屏，所以除非是设计宽高与物理宽高相等，否则就会有一些因拉伸产业的变形。不同机型的宽高比例差距越大，变形的越明显。 该模式是所有适配模式中，唯一不需要开发者作额外的适配调整，就能保障在任何机型下都可以全屏显示、不留空白、不被裁切的适配模式，缺点也很明显，就是当物理宽高比例与设计宽高比例不同时，会产生拉伸变形，适用于对界面产生形变没有严格要求的开发者。 exactfit模式，不同机型对比效果如图11-3中所示。 （图11-3） 3.2 移动端推荐的适配模式 在移动端，我们通常会需要保持设计宽高等比缩放的全屏适配方案。而以下几种模式正是我们推荐开发者优先采用的适配模式。如果是3D游戏，建议开启视网膜画布（useRetinalCanvas）模式。 3.2.1 保宽适配模式fixedwidth fixedwidth保宽模式就是在保障设计宽的内容一定全屏显示的等比缩放模式。这种模式推荐应用于竖屏游戏。 在这个模式下，画布宽和舞台宽会等于设计宽。但画布高和舞台高会按物理宽与设计宽的比例进行缩放后改变，不采用我们配置的设计高。所以，当改变后的画布和舞台高大于原来的设计高，底部就会露出画布背景色。如果改变后的画布和舞台高小于原来的设计高，那就会被裁剪掉多出的部分。 fixedwidth模式，不同机型对比效果，如图12-1所示。 （图12-1） 看到图12-1的黑色背景色，或者有开发者看到这里会想，我需要的是全屏适配，这个不适合。其实不用担心，这是为了让大家理解fixedwidth的适配规则，故意没有处理。由于在这个模式下，舞台的宽高已经被缩放拉满全屏，所以。开发者完全可以通过相对布局属性（top和bottom），把背景拉到全屏以及按钮拉到屏幕相对位置显示。实现各个屏幕下都做到完美的全屏适配。 3.2.2 保高适配模式fixedheight fixedheight保高模式就是在保障设计高的内容一定全屏显示的等比缩放模式。这种模式推荐应用于横屏游戏。 在这个模式下，画布高和舞台高会等于设计高。但画布宽和舞台宽会按物理高与设计高的比例进行缩放后改变，不采用我们配置的设计宽。所以，当改变后的画布和舞台宽小于原来的设计宽，那就会被裁剪掉多出的部分，如图12-2所示。如果改变后的画布和舞台宽大于原来的设计宽，底部就会露出画布背景色，如图12-3所示。 (图12-2) (图12-3) 图12-2和图12-3仍然是故意没有处理。通过相对布局属性（left和right），把背景拉到全屏以及按钮拉到屏幕相对位置显示。实现各个屏幕下都做到完美的全屏适配。 3.2.3 自动保宽高模式fixedauto fixedauto自动保宽高模式就是在保障设计宽高的内容，在任意机型的分辨率下一定都在全屏内显示。这是一种设计宽高永远不会被裁剪的等比缩放全屏适配模式，但有可能会留出画布的背景色，如图12-4所示。 所以还是需要通过相对布局属性，进行全屏适配。该模式横屏游戏和竖屏游戏都适合。 （图12-4） 这种模式，其实最终采用的是fixedwidth或者fixedheight，是通过物理宽高比和设计宽高比进行对比判断。物理宽高比小于设计宽高比的采用fixedwidth模式，否则就采用fixedheight。 3.3 其它适配模式 3.3.1 显示全部的高清模式showall showall模式的适配结果与fixedauto非常像，也是保障设计宽高一定会在屏幕内全部显示，但区别和问题是，showall模式的画布和舞台并未做到所有分辨率下的全屏适配，而是取（物理宽/设计宽）与（物理高/设计高）的最小比值，进行等比缩放，并且改变了舞台和画布大小。因此，留下的空白部分，就是舞台无法控制的部分，导致在与设计宽高比例不同的手机上，就真正的无法全屏适配了。 但也并非没有好处，好处就是都不需要用相对布局二次适配了，设计效果什么样就一定是什么样，肯定是全部显示，不变形，不被裁切。而且由于改变了画布的大小，在物理分辨率差异比较大的屏幕上，也不会因为设计分辨率小了而导致模糊，仍然是高清的。坏处就是做不到手机全屏适配，所以该模式，通常不会被用到手机适配上， 在PC浏览器运行的横屏页游，推荐使用该模式。 showall模式，不同机型对比效果，如图13-1所示。 （图13-1） showall模式由于画布宽高已经进行了缩放改变，本身就是高清的适配模式，所以这种模式无需使用视网膜画布模式（useRetinalCanvas），用了之后，画布采用了物理分辨率，反而不好。 3.3.2 肯定不留底边的模式noboder noboder的适配规则与showall，恰恰相反，是取（物理宽/设计宽）与（物理高/设计高）的最大比值进行缩放。会导致当分辨率宽高比与设计宽高比不同的屏幕上，设计效果一定会超出屏幕，被裁切掉一部分。所以也就无法留出画布或者舞台的底边了。 另外，该模式画布与舞台宽高会保持与设计宽高相同，所以全屏适配全靠对画布的缩放，没有使用视网膜模式的情况下，物理分辨率远超设计分辨率的时候，会因拉伸产生模糊。 noboder模式，不同机型对比效果，如图13-2所示。 （图13-2） 虽然说该模式，通过相对布局二次适配，也可以让被裁剪的按钮等回归到屏幕内容之中，但二次适配的方式要更加复杂。所以不推荐使用该模式。 3.4 刘海屏适配思路 自从推出iPhoneX全面屏手机以来，全面屏手机越来越多，但实际上绝大多数机型做不到真正的全面，所以就有了凹凸屏，刘海屏，水滴屏等叫法，这就给我们适配带来了麻烦。但找到规律之后，其实也并不是太复杂。下面分享一种常见的处理思路，大家根据这种适配思路来具体调节适配。 3.4.1 如何识别刘海屏 目前市面上的机型，虽然分辨率碎片化严重，但是仔细总结一下，可以发现一个规律，那就是分辨率的宽高比就那么几个。至少，全面屏的机型，宽高比肯定是大于2。所以，我们可以获取屏幕分辨率的宽高，然后计算出宽高比。大于2的，就当成刘海屏进行适配处理。 至于分的更细的，大家可以继续仔细研究。本节只是介绍一种思路。 3.4.2 相对布局 LayaAirIDE的UI组件中提供了基于父容器的相对布局属性，如top、bottom、left、right。我们可以把需要特别处理的按钮都统一放到一个容器组件中，例如box。然后，我们在场景Runtime类的onAwake生命周期中，控制这个容器的相对布局属性，就可以实现在刘海屏下进行特殊的位置处理了。 示例代码如下： onAwake():void{ //宽高比大于2为刘海屏 if((Browser.clientHeight/Browser.clientWidth)>2) { this.scaleGroup.top = 25; //回避顶部刘海示例代码 this.scaleGroup.bottom = 50;//回避底部线示例代码 } } 3.4.3 如何调试 由于Chrome的调试中没有提供刘海遮挡的虚拟机，除了真机调试外，可以在微信小游戏开发工具中进行模拟调试。 3.5 其它适配相关学习 除了适配模式外，还有一些其它适配相关的内容，例如横竖屏适配、画布对齐等。 可以前往IDE的基础文档查看《项目设置详解》。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"basics/common/Browser/readme.html":{"url":"basics/common/Browser/readme.html","title":"浏览器接口","keywords":"","body":"浏览器接口一、概述二、获得屏幕相关数据2.1 逻辑宽高2.2 物理宽高（屏幕宽高）2.3 设备像素比三、调用原生对象3.1 document Dom3.2 window 窗口3.3 container 画布四、判断运行环境浏览器接口 一、概述 在项目开发中，往往我们需要跟外部运行环境打交道，比如在浏览器运行或者在一些小游戏平台中运行，都需要获取设备信息等等，这些功能的接口，都是通过Laya.Browser 来调用的。Laya.Browser 是浏览器代理类，封装了浏览器及原生 JavaScript 提供的一些功能，也包括小游戏等运行环境的信息。本章将介绍 Laya.Browser 都有哪些功能： 获得屏幕相关数据 调用原生对象 判断运行环境 下面我们分别来详细讲解 二、获得屏幕相关数据 通常我们使用 Chrome 或者 MS Edge等浏览器开发项目，这些浏览器提供了非常方便的 DevTools 工具来调试。可以参考下面链接 https://learn.microsoft.com/zh-cn/microsoft-edge/devtools-guide-chromium/overview 如图2-1所示，浏览器提供了设备仿真模式，利于方便查看和调试 （图2-1） 上图中选择的是iphone 6/7/8 Plus设备，但是以iphone为例，随着型号的提升，屏幕设备的分辨率也在不断变化，如图2-2所示 （图2-2） 从图中看到，物理宽高，DPR，逻辑宽高是不同的 因此，要获得这些屏幕相关信息，Laya.Browser 类为我们提供了如下方法，我们来看下 Laya.Browser 相关API ： /** * 浏览器窗口可视宽度。 * 通过分析浏览器信息获得。浏览器多个属性值优先级为：window.innerWidth(包含滚动条宽度) > document.body.clientWidth(不包含滚动条宽度)，如果前者为0或为空，则选择后者。 */ static get clientWidth(): number { Browser.__init__(); return Browser._clientWidth || Browser._window.innerWidth || Browser._document.body.clientWidth; } static set clientWidth(value: number) { Browser._clientWidth = value; } /** * 浏览器窗口可视高度。 * 通过分析浏览器信息获得。浏览器多个属性值优先级为：window.innerHeight(包含滚动条高度) > document.body.clientHeight(不包含滚动条高度) > document.documentElement.clientHeight(不包含滚动条高度)，如果前者为0或为空，则选择后者。 */ static get clientHeight(): number { Browser.__init__(); return Browser._clientHeight || Browser._window.innerHeight || Browser._document.body.clientHeight || Browser._document.documentElement.clientHeight; } static set clientHeight(value: number) { Browser._clientHeight = value; } /** 浏览器窗口物理宽度。考虑了设备像素比。*/ static get width(): number { Browser.__init__(); return ((ILaya.stage && ILaya.stage.canvasRotation) ? Browser.clientHeight : Browser.clientWidth) * Browser.pixelRatio; } /** 浏览器窗口物理高度。考虑了设备像素比。*/ static get height(): number { Browser.__init__(); return ((ILaya.stage && ILaya.stage.canvasRotation) ? Browser.clientWidth : Browser.clientHeight) * Browser.pixelRatio; } /** 获得设备像素比。*/ static get pixelRatio(): number { if (Browser._pixelRatio -1) Browser._pixelRatio = 2; else { Browser._pixelRatio = (Browser._window.devicePixelRatio || 1); if (Browser._pixelRatio 2.1 逻辑宽高 LayaAir引擎里可以通过 Laya.Browser.clientWidth 获取逻辑分辨率的宽，通过 Laya.Browser.clientHeight 获取逻辑分辨率的高。 在手机等移动设备的竖屏状态下，窄面为宽，长面为高。如果发生了屏幕翻转的横屏状态，则长的一面为宽，窄面为高。 在PC浏览器中，则是获取的浏览器窗口可视宽高。 往往大部分浏览器是通过JavaScript 调用 window.innerWidth 来获得浏览器窗口可视宽度，但是某些特殊的浏览器有差异，因此 Laya.Browser 对这些问题做了很好的封装，只需要调用 Browser.clientWidth 和 Browser.clientHeight 即可。 2.2 物理宽高（屏幕宽高） 物理宽高也称为屏幕宽高。开发者可以通过 Laya.Browser.width 可以得到屏幕宽上有多少像素，通过Laya.Browser.height 可以得到屏幕高上有多少像素。 只有在全屏的时候屏幕宽高是硬件屏幕宽高，开发者需要理解的是，屏幕宽高实际是指运行环境窗口宽高，例如在浏览器上运行就是浏览器显示窗口的宽高。 LayaAir引擎中的物理宽高是通过逻辑宽高*DPR计算而来，DPR 就是下面要介绍的设备像素比。 2.3 设备像素比 图2-2中的DPR就是设备像素比，开发者可以通过 Laya.Browser.pixelRatio 可以得到 通过逻辑宽高。物理宽高，设备像素比 ，我们才能更好的做到屏幕适配，想了解更多详细的屏幕适配，请参考《屏幕适配》文档 三、调用原生对象 通常原生对象有如下几个： document Dom window 窗口 container 画布 Laya.Browser 也为我们封装了对这些对象的调用，看下API： /**浏览器原生 window 对象的引用。*/ static get window(): any { return Browser._window || Browser.__init__(); } /**浏览器原生 document 对象的引用。*/ static get document(): any { Browser.__init__(); return Browser._document; } /**画布容器，用来盛放画布的容器。方便对画布进行控制*/ static get container(): any { if (!Browser._container) { Browser.__init__(); Browser._container = Browser.createElement(\"div\"); Browser._container.id = \"layaContainer\"; Browser._document.body.appendChild(Browser._container); } return Browser._container; } static set container(value: any) { Browser._container = value; } 3.1 document Dom LayaAir引擎里可以通过 Laya.Browser.document 获取原生 document 对象。 同时 Laya.Browser 还提供了对于 Dom 节点元素的使用方法： /** * 创建浏览器原生节点。 * @param type 节点类型。 * @return 创建的节点对象的引用。 */ static createElement(type: string): any { Browser.__init__(); return Browser._document.createElement(type); } /** * 返回 Document 对象中拥有指定 id 的第一个对象的引用。 * @param type 节点id。 * @return 节点对象。 */ static getElementById(type: string): any { Browser.__init__(); return Browser._document.getElementById(type); } /** * 移除指定的浏览器原生节点对象。 * @param type 节点对象。 */ static removeElement(ele: any): void { if (ele && ele.parentNode) ele.parentNode.removeChild(ele); } 通过和原生Dom的交互，可以解决一些问题，例如 LayaAir 使用元素 iframe 在插入三方的一些网站的时候我们一般会用到 iframe，甚至三方的渠道基本都是用iframe嵌入一个应用。我们项目中也会遇到用iframe的情况。下面的例子就是演示在项目中应用iframe。 代码如下所示： var iframe:any = Laya.Browser.document.createElement(\"iframe\"); iframe.style.position =\"absolute\";//设置布局定位。这个不能少。 iframe.style.zIndex = 100;//设置层级 iframe.style.left =\"100px\"; iframe.style.top =\"100px\"; iframe.src = \"http://ask.layabox.com/\"; Laya.Browser.document.body.appendChild(iframe); 这里面需要提醒开发者的就是定位和层级要记得设置。很多开发者不注意导致 iframe 跑到游戏层的下面看不见了。 3.2 window 窗口 LayaAir引擎里可以通过 Laya.Browser.window 获取原生 window 对象。 比如我们想在项目中使用 window.open(url) 打开另一个网页传输数据，示例代码如下： //Get发送数据 Laya.Browser.window.open(url?a=b&c=d); //Post发送数据 let win2 = Laya.Browser.window.open(url); win2.postMessage(content, url);// 此处最好加延迟 //接受数据 Laya.Browser.window.addEventListener(\"message\", (event)=>{ // console.log(\"receive message == > \", event.data); }) 3.3 container 画布 LayaAir引擎里可以通过 Laya.Browser.container 获取画布容器。 比如，我们可以让画布不显示，只显示 Dom 的页面： Laya.Browser.container.style.display = \"none\"; 四、判断运行环境 在开发跨平台的项目中，往往要处理不同平台的兼容性问题，不同的运行环境，会有不同的处理方式。Laya.Browser 类针对这些运行环境进行了判断，对我们开发者来说，判断运行环境，只直接调用 Laya.Browser 类的接口即可，目前为止，这些接口都可以使用 /** 表示是否在移动设备，包括IOS和安卓等设备内。*/ static onMobile: boolean; /** 表示是否在 IOS 设备内。*/ static onIOS: boolean; /** 表示是否在 Mac 设备。*/ static onMac: boolean; /** 表示是否在 IPhone 设备内。*/ static onIPhone: boolean; /** 表示是否在 IPad 设备内。*/ static onIPad: boolean; /** 表示是否在 Android 设备内。*/ static onAndroid: boolean; /** 表示是否在 Windows Phone 设备内。*/ static onWP: boolean; /** 表示是否在 QQ 浏览器内。*/ static onQQBrowser: boolean; /** 表示是否在移动端 QQ 或 QQ 浏览器内。*/ static onMQQBrowser: boolean; /** 表示是否在 Safari 内。*/ static onSafari: boolean; /** 表示是否在 Chrome 内 */ static onChrome: boolean; /** 表示是否在 IE 浏览器内*/ static onIE: boolean; /** 表示是否在 微信 内*/ static onWeiXin: boolean; /** 表示是否在 PC 端。*/ static onPC: boolean; /** 微信小游戏 **/ static onMiniGame: boolean; /** 百度小游戏 **/ static onBDMiniGame: boolean; /** 小米戏小游戏 **/ static onKGMiniGame: boolean; /** OPPO小游戏 **/ static onQGMiniGame: boolean; /** VIVO小游戏 **/ static onVVMiniGame: boolean; /** 阿里小游戏 **/ static onAlipayMiniGame: boolean; /***手机QQ小游戏 */ static onQQMiniGame: boolean; /*** BILIBILI小游戏 */ static onBLMiniGame: boolean; /** 字节跳动小游戏*/ static onTTMiniGame: boolean; /** 华为快游戏 */ static onHWMiniGame: boolean; /** 淘宝小程序 */ static onTBMiniGame: boolean; /** @private */ static onFirefox: boolean;//TODO:求补充 /** @private */ static onEdge: boolean;//TODO:求补充 /** @private */ static onLayaRuntime: boolean; 例如，我们可以这样在代码中判断： //如果是微信小游戏 if (Laya.Browser.onMiniGame) { var wx = Laya.Browser.window.wx; wx.onShow(() => { console.log(\"wx OnShow\"); }); wx.onHide(() => { console.log(\"wx onHide\"); }); } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:15 "},"basics/common/device/readme.html":{"url":"basics/common/device/readme.html","title":"设备接口","keywords":"","body":"设备接口使用音频陀螺仪与加速计获取位置信息使用百度地图设备接口 设备接口是指与硬件设备交互的接口调用，这些部分通常为调用浏览器（或运行环境）的原生API进行封装。 使用音频 陀螺仪与加速计 获取位置信息 使用百度地图 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"basics/common/device/media/readme.html":{"url":"basics/common/device/media/readme.html","title":"使用音频","keywords":"","body":"音乐与音效的播放与控制一、音乐与音效的应用区别二、音频的兼容性准备三、音频音量的控制四、设备静音控制五、失去焦点的处理六、音乐与音效播放的完整示例音乐与音效的播放与控制 ​ HTML5的音频播放，在当前有两种主流的方式，一种是Audio标签播放,另一种是WebAudio二进制播放。 ​ Audio属于dom元素，带有ui界面，在移动端Audio属于边下载边播放，适合声音文件比较大的文件，但是Audio在移动端会有手势的限制，gesture-requirement-for-media-playback属性表明必须有用户的手势操作才可以播放。 ​ WebAudio是一种新的声音播放形式，可以加载多个声音进行合成，他是通过二进制文件解码成浏览器支持的格式进行播放。而且用这个接口甚至可以实现音频谱的动画效果，让声音有了合成的功能。 ​ 音乐与音效作为游戏中常用的基础元素，LayaAir引擎封装了WebAudio与Audio，在支持WebAudio的浏览器上，优先使用WebAudio，在不支持WebAudio的浏览器上使用Audio，最大化兼容所有浏览器对音频格式的支持，让开发者可以更加方便的，通过调用laya.media.SoundManager API接口就可以直接播放音频。 一、音乐与音效的应用区别 ​ 音乐：是指游戏用的背景音乐。采用laya.media.SoundManager音频管理类中的playMusic方法进行播放，由于是背景音乐，playMusic方法只能同时播放一个音频文件。 ​ 音效：采用的是laya.media.SoundManager音频管理类中的playSound方法，允许同时播放多个音频文件。 二、音频的兼容性准备 ​ 由于音频播放问题的各个浏览器兼容性不同，在开始应用前，我们要做好前期的兼容准备。 （1）使用“格式工厂”音频文件转换工具。选择 44100Hz，96kbps 进行转换。 （2）音频文件尽量小，不仅仅是带宽的限制，还有浏览器音频解码的效率问题。 三、音频音量的控制 ​ 声音音量的控制 可以通过laya.media.SoundManager音频管理类中的setSoundVolume方法来设置， ​ 如上图所示，我们可以看到，通过设置volume参数，可以有效控制url所对应声音文件的音量大小。初始值为1。音量范围从 0（静音）至 1（最大音量）。 四、设备静音控制 如果通过设备静音键让音频自动跟随设备静音。需要将useAudioMusic设置为false。 Laya.SoundManager.useAudioMusic = false; 五、失去焦点的处理 如果不是手机全屏游戏，或者在浏览器里交互。有可能会导致切出游戏后，失去焦点，而失去焦点后，音频也会停止播放，这是浏览器机制导致，开发者有两种方式，来避免。 一种是在入口文件中，将autoStopMusic设置为false。 …… //失去焦点后是否自动停止背景音乐。false不自动停止，一直播。true是自动停止 Laya.SoundManager.autoStopMusic = false; …… 如果不设置这个，当失去焦点停止的时候。需要开发者要自行在失去焦点和恢复的时候，通过侦听失去stage焦点和获得stage焦点进行控制，（在小游戏平台，也要看各小游戏的平台切出规则），浏览器中恢复的参考代码如下： …… //循环播放_sound _sound.play(0); //失去舞台焦点（切出游戏）的处理 Laya.stage.on(Laya.Event.BLUR, this, () => { _sound.stop(); }); //获得舞台焦点（切回游戏）的处理 Laya.stage.on(Laya.Event.FOCUS, this, () => { _sound.play(0); }); …… 六、音乐与音效播放的完整示例 该示例的完整代码地址为：https://layaair.ldc.layabox.com/demo/?2d&Sound&SimpleDemo Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"basics/common/device/motion/readme.html":{"url":"basics/common/device/motion/readme.html","title":"陀螺仪与加速计","keywords":"","body":"laya.device.motion详解：陀螺仪与加速计1、陀螺仪2、加速计2.1 获取设备物理方向运动信息2.2 获取设备显示方向运动信息laya.device.motion详解：陀螺仪与加速计 laya.device.motion中共有四个类供开发者使用，分别为加速信息AccelerationInfo、加速计Accelerator、陀螺仪Gyroscope、保存旋转信息RotationInfo。本节将详细描述laya.device.motion API的相关内容。 1、陀螺仪 ​ Gyroscope通过change事件对设备方向改变进行监听。该事件有两个回调参数： absolute —— 如果设备提供的方位是基于设备坐标系统和地球坐标系统间的差距，则是true；如果设备无法检测到地球坐标系统，absolute为false。 rotationInfo —— RotationInfo类型，包含alpha、beta、gamma三个值，将在下面详细讨论。 ​alpha、beta和gamma属性必须指示设备的方向，其表现形式为从固定在地球上的坐标系到固定在设备上的坐标系的转换。坐标系必须按照下面的描述调整。 ​地球坐标系是一个位于用户位置的“东、北、上”系。其拥有3个轴，地面相切与1984世界测地系统的spheriod的用户所在位置。 东（X）在地面上，垂直于北轴，向东为正。 北（Y）在地面上，向正北为正（指向北极）。 上（Z）垂直于地面，向上为正。 对于一个移动设备，例如电话或平板，设备坐标系的定义于屏幕的标准方向相关。如果在设备旋转或展开滑动键盘时屏幕方向发生变化，这不会影响关于设备的坐标系的方向。 x在屏幕或键盘平面上，屏幕或键盘的右侧为正。 y在屏幕或键盘屏幕上，屏幕或键盘的上方为正。 z垂直于屏幕或键盘屏幕，离开屏幕或键盘为正。 ​旋转必须使用右手规则，即正向沿一个轴旋转为从该轴的方向看顺时针旋转。从两个系重合开始，旋转应用下列规则： 以设备坐标系z轴为轴，旋转alpha度。alpha的作用域为[0, 360]。 （图1） 以设备坐标系x轴为轴，旋转beta度。beta的作用域为[-180, 180]。 （图2） 已设备坐标系y轴为轴，旋转gamma度。gamma的作用域为[-90, 90]。 （图3） 下面演示获取旋转方位信息： class Gyroscope_Sample { private info: Laya.Text; constructor() { Laya.init(550, 400); this.info = new Laya.Text(); this.info.fontSize = 50; this.info.color = \"#FFFFFF\"; this.info.size(Laya.stage.width, Laya.stage.height); Laya.stage.addChild(this.info); Laya.Gyroscope.instance.on(Laya.Event.CHANGE, this, this.onDeviceorientation); } private onDeviceorientation(absolute: Boolean, rotationInfo: Laya.RotationInfo): void { this.info.text = \"alpha:\" + Math.floor(rotationInfo.alpha) + '\\n' + \"beta :\" + Math.floor(rotationInfo.beta) + '\\n' + \"gamma:\" + Math.floor(rotationInfo.gamma); } } new Gyroscope_Sample(); 2、加速计 ​ Accelerator类定期发送设备的运动传感器检测的活动。此数据表示设备在三维轴上的运动。当设备移动时，传感器检测此移动并返回设备的加速坐标。即使静止的时候，也可以得到包含重力的加速坐标。 ​ change事件的回调函数拥有一个以下参数： acceleration —— AccelerationInfo类型。提供宿主设备相对于地球坐标系的加速信息，其表现形式为定义于陀螺仪章节的主坐标系，单位是m/s^2。 accelerationIncludingGravity —— AccelerationInfo 类型。对于不能提供排除重力影响的加速数据的实现（例如缺少陀螺仪），作为替代，可以提供受重力影响的加速数据。这对于许多应用来说并不好用，但提供这些信息意味着提供了最大力度的支持。在此情况下，accelerationIncludingGravity属性提供宿主设备的加速信息，并加上一个加速度相等方向相反的反重力加速度。其表现形式为定义于陀螺仪章节的主坐标系。加速信息的单位是m/s^2。 rotationRate —— RotationInfo类型。属性提供宿主设备在空间中旋转的速率，其表现形式为定义于陀螺仪章节的的角度变化速率，单位必须是deg/s。 interval —— 从硬件获得数据的间隔，单位是毫秒。 2.1 获取设备物理方向运动信息 加速计轴是设备的物理方向，这表示当你旋转了设备，加速计轴也会随之旋转。 下面演示获取设备运动信息： class Gyroscope_Sample { private info: Laya.Text; constructor() { Laya.init(550, 400); this.info = new Laya.Text(); this.info.fontSize = 50; this.info.color = \"#FFFFFF\"; this.info.size(Laya.stage.width, Laya.stage.height); Laya.stage.addChild(this.info); Laya.Accelerator.instance.on(Laya.Event.CHANGE, this, this.onMotoin); } private onMotoin(acceleration: Laya.AccelerationInfo, accelerationIncludingGravity: Laya.AccelerationInfo, rotationRate: Laya.RotationInfo, interval: number): void { this.info.text = 'acceleration:(' + acceleration.x.toFixed(3) + ', ' + acceleration.y.toFixed(3) + ', ' + acceleration.z.toFixed(3) + ')\\n' + 'accelerationIncludingGravity:(' + accelerationIncludingGravity.x.toFixed(3) + ', ' + accelerationIncludingGravity.y.toFixed(3) + ', ' + accelerationIncludingGravity.z.toFixed(3) + ')\\n' + 'rotationRate: alpha ' + Math.floor(rotationRate.alpha) + ', beta ' + Math.floor(rotationRate.beta) + ', gamma ' + Math.floor(rotationRate.gamma) + '\\n' + 'interval: ' + interval; } } new Gyroscope_Sample(); 2.2 获取设备显示方向运动信息 ​ 由于我们可能需要显示方向上的运行信息，这表示即使旋转了设备，加速计轴不随之改变，如y轴 始终保持着垂直。使用Accelerator.getTransformedAcceleration()即可获取到显示方向上的运行信息。 ​ 在上例的代码的onMotion函数中，使用AccelerationInfo前先使用Accelerator.getTransformedAcceleration()转换信息： private onMotoin(acceleration: Laya.AccelerationInfo, accelerationIncludingGravity: Laya.AccelerationInfo, rotationRate: Laya.RotationInfo, interval: number): void { acceleration = Laya.Accelerator.getTransformedAcceleration(acceleration); accelerationIncludingGravity = Laya.Accelerator.getTransformedAcceleration(accelerationIncludingGravity); ...... } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"basics/common/device/geolocation/readme.html":{"url":"basics/common/device/geolocation/readme.html","title":"获取位置信息","keywords":"","body":"用Geolocation获取地理位置信息地理位置1、获取当前定位2、监视位置改变用Geolocation获取地理位置信息 [TOC] 地理位置 如果设备支持Geolocation，并且所使用的浏览器支持，就可以使用Geolocation获取设备的当前地理位置。可以打开网页http://caniuse.com/#search=geolocation查看有哪些浏览器版本支持Geolocation。显示Supported表示支持。 ​ Geolocation返回的GeolocationInfo，包含以下信息： latitude —— 维度（度）。 longitude —— 经度（度）。 altitude —— 相对于海平面的海拔高度（米）。如果设备不提供海拔数据，altitude 的值为null。 accuracy —— 返回经纬度的精度，以米为单位。 altitudeAccuracy —— 返回海拔的精度，以米为单位。altitudeAccuracy 可能为null。 heading —— 返回设备的移动方向（角度），指示距离北方的角度。0度表示指向正北方，方向以顺时针旋转（这表示东方是90度，西方是270度）。如果speed是0，heading会是NaN。如果设备无法提供heading信息，值为null。 speed —— 返回设备每秒的移动速度（米）。speed可能为null。 timestamp —— 获取信息的时间戳。 ​ Geolocation静态属性值包含以下通用设置： enableHighAccuracy —— 布尔值，如果设为true并且设备能够提供更精确地位置，则应用尽可能获取最佳结果。注意着可能导致更长的响应时间和更大的电量消耗（如开启了移动设备的GPS）。 timeout —— 正整数，代表返回位置的最大时间（毫秒）限制。默认值是Infinity，意味着getCurrentPosition()直到位置可用时才会返回。 maximumAge —— 32位正整数，代表可返回的可用缓存位置的最大寿命。如果设置为0，意味着设备不使用缓存位置，始终尝试获取实时位置。如果设置为Infinity，设备必须返回缓存位置无论其寿命。默认值：0。 1、获取当前定位 使用静态方法Geolocation.getCurrentPosition()获取当前的位置，getCurrentPosition()只触发一次。 // 尝试获取当前位置 Geolocation.getCurrentPosition( Handler.create(this, onSuccess), Handler.create(this, onError) ); // 成功获取位置后触发 function onSuccess(info:GeolocationInfo):void { trace('经纬度: (' + info.longitude + '°, ' + info.latitude + '°)，精确度：' + info.accuracy + 'm'); if(info.altitude != null) trace('海拔：' + info.altitude + 'm' + (info.altitudeAccuracy != null ? ('，精确度：' + info.altitudeAccuracy + 'm') : '')); if(info.heading != null && !isNaN(info.heading)) trace('方向：' + info.heading + \"°\"); if(info.speed != null && !isNaN(info.speed)) trace('速度：' + info.speed + \"m/s\"); } // 获取位置失败后触发 function onError(err:Error):void { var errType:String; if (err.code = Geolocation.PERMISSION_DENIED) errType = \"Permission Denied\"; else if (err.code == Geolocation.POSITION_UNAVAILABLE) errType = \"Position Unavailable\"; else if (err.code == Geolocation.TIMEOUT) errType = \"Time Out\"; trace('ERROR(' + errType + '): ' + err.message); } 以上示例代码演示使用getCurrentPosition()获取当前的位置信息，成功时打印地理位置信息，失败时打印错误信息和错误原因。 2、监视位置改变 ​ 除了获取当前位置之外，还可以监视位置的改变。使用Geolocation.watchPosition()监视位置改变，该函数返回一个监视器ID值，可以使用Geolocation.clearWatch()并传入该ID值来取消由watchPosition()注册的位置监听器。 // Geolocation.watchPosition函数签名 Geolocation.watchPosition( Handler.create(this, updatePosition), Handler.create(this, onError)); function updatePosition(info:GeolocationInfo):void { } function onError(err:Error):void { } ​ watchPosition()具有和getCurrentPosition()一样的函数签名。更多关于watchPosition()的应用，可以查看文档《使用百度地图显示当前位置》 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"basics/common/device/baiduMap/readme.html":{"url":"basics/common/device/baiduMap/readme.html","title":"使用百度地图","keywords":"","body":"使用百度地图显示当前位置一、首先介绍成员变量：二、接着是构造函数：使用百度地图显示当前位置 本节一步步演示使用watchPosition()在百度地图上标注出当前所在位置。watchPosition方法来自于Geolocation API，学习本节前请先阅读Geolocation基础文档或Geolocation API文档。 在开始之前需要在index.html中引入百度地图的脚本文件，这个url在百度地图的官方网站可以免费获取到。演示中使用的url是http://api.map.baidu.com/api?v=2.0&ak=LIhOlvWfdiPYMCsK5wsqlFQD8wW4Bfy6 一、首先介绍成员变量： // 百度地图的API private map; // 地图引用 private marker; // 地图标注物 private BMap = Laya.Browser.window.BMap; // 百度地图命名空间 private convertor = new this.BMap.Convertor(); // 坐标转换接口 private mapDiv; // 包含百度地图的div容器 二、接着是构造函数： class WatchPosition { constructor() { Laya.init(1, 1); this.init(); // 使用高精度位置 Laya.Geolocation.enableHighAccuracy = true; Laya.Geolocation.watchPosition(Laya.Handler.create(this, this.updatePosition), Laya.Handler.create(this, this.onError)); // 绑定convertToBaiduCoord作用域 this.convertToBaiduCoord = this.convertToBaiduCoord.bind(this); } } new WatchPosition(); ​ 由于本例不需要使用LayaAir的显示元素，因此舞台尺寸设置为1。百度地图界面的初始化放在init()中。然后是监听设备位置的变化。最后需要注意，函数convertToBaiduCoord()是将获取到的坐标转换至百度地图坐标，由于它是作为convertor.translate()的参数，所以触发时作用域会被改变，因此在这里绑定了该函数的作用域。 2.1 init函数： private init(): void { this.mapDiv = Laya.Browser.createElement(\"div\"); Laya.Browser.document.body.appendChild(this.mapDiv); // 适应窗口尺寸 this.refit(); Laya.stage.on(Laya.Event.RESIZE, this, this.refit); // 初始化地图 this.map = new this.BMap.Map(this.mapDiv); // 禁用部分交互 //this.map.disableDragging(); this.map.disableKeyboard(); this.map.disableScrollWheelZoom(); this.map.disableDoubleClickZoom(); this.map.disablePinchToZoom(); // 初始地点北京，缩放系数15 this.map.centerAndZoom(new this.BMap.Point(116.32715863448607, 39.990912172420714), 15); // 创建标注物 this.marker = new this.BMap.Marker(new this.BMap.Point(0, 0)); this.map.addOverlay(this.marker); } init()函数初始化百度地图。关闭了大部分交互功能，只留下拖动地图。地图初始地点位于北京，缩放系数15。并且添加了一个地图标注物。 2.2 refit函数： private refit(): void { this.mapDiv.style.width = Laya.Browser.width / Laya. Browser.pixelRatio + \"px\"; this.mapDiv.style.height = Laya. Browser.height / Laya. Browser.pixelRatio + \"px\"; } refit()使百度地图充满整个窗口，由于侦听了resize事件，在窗口resize时也会重新填充窗口。 2.3 updatePosition函数： // 更新设备位置 private updatePosition(p: Laya.GeolocationInfo): void { // 转换为百度地图坐标 var point:any = new this.BMap.Point(p.longitude, p.latitude); // 把原始坐标转换为百度坐标，部分设备的浏览器可能获取到的是谷歌坐标，这时第三个参数改为3才是正确的。 this.convertor.translate([point], 1, 5, this.convertToBaiduCoord); } updatePosition()是Geolocation.watchPosition()的触发函数，在每次监测到位置改变后都需要把获取到的原始坐标转换到百度坐标，才能在百度地图上显示正确的位置。 注意有的设备浏览器获取到的坐标可能是谷歌坐标，这时convertor.translate的第三个参数就不是5，而是3。 2.4 convertToBaiduCoord函数： // 将原始坐标转换为百度坐标 private convertToBaiduCoord(data: any): void { if (data.status == 0) { var position: any = data.points[0]; // 设置标注物位置 this.marker.setPosition(position); this.map.panTo(position); } } 在转换完成后设置标注物的位置，并且把视角平移到以标注物为中心的视口中。 2.5 onError函数： private onError(e: any): void { var errType: string; if (e.code = Laya.Geolocation.PERMISSION_DENIED) errType = \"Permission Denied\"; else if (e.code == Laya.Geolocation.POSITION_UNAVAILABLE) errType = \"Position Unavailable\"; else if (e.code == Laya.Geolocation.TIMEOUT) errType = \"Time Out\"; alert('ERROR(' + errType + '): ' + e.message); } 完成以上步骤之后就可以在设备上的浏览器查看效果。如果位置错误，把获取到的坐标当成谷歌坐标试试。注意浏览器本身的安全限制可能需要用户手动允许网页使用地理位置，或者Chrome需要https协议的地址才能够使用地理位置。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"basics/common/Stat/readme.html":{"url":"basics/common/Stat/readme.html","title":"性能统计与优化","keywords":"","body":"性能统计面板介绍1、性能统计面板的调用2、FPS相关的介绍2.1 FPS概述3、DrawCall介绍4、NodeNums的数值说明5、Sprite3D数值说明6、TriangleFace数值说明7、RenderNode数值说明8、SkinRenderNode数值说明9、ParticleRenderNode数值说明10、FrustumCulling数值说明11、GPUMemory数值说明12、TextrueMemory数值说明13、RenderTextureMemory数值说明14、BufferMemory数值说明性能统计面板介绍 　　LayaAir 引擎设计之初，就以性能为第一目标，在引擎内做了大量的性能优化。合理运用好引擎，可以让游戏等引擎产品达到原生APP的体验。如果开发者不能发挥好引擎的优势，那么游戏最终的性能体验或将无从谈起。因此，在制作游戏过程中，掌握游戏以及引擎的优化技巧还是非常有必要的。 要了解引擎的性能，首先要看懂性能统计面板，下面将针对性能统计面板进行详细介绍。 1、性能统计面板的调用 LayaAir引擎内置的性能统计面板可实时检测当前性能。调用统计面板因开发语言的不同，会有所不同。 TS语言直接在代码中输入 Laya.Stat.show(0,0); 即可调出性能统计面板。 示例Demo.ts编写代码如下： //初始化舞台 Laya.init(1136, 640); //调用性能统计面板方法，(0,0)为面板位置坐标 Laya.Stat.show(0,0); Tips:要注意大小写。 2、FPS相关的介绍 2.1 FPS概述 FPS是每秒传输帧数(Frames Per Second)的缩写。假设游戏的帧速为60FPS，表明游戏运行时每个帧的执行时间为1/60 秒。帧速值越高，视觉上感觉越流畅。 （图1） 当前PC与手机等设备的满帧是60帧，如图1所示，但某些游戏对画面的流畅度要求并不高，也可以采用引擎的帧速限制方法Stage.FRAME_SLOW，将FPS帧速限制为最高30帧。 由于实际运行环境是在浏览器中，所以性能还取决于JavaScript解释器的效率，因此，同一款游戏的FPS值在不同的浏览器中可能会存在差异。这部分不是开发者能够决定的，开发者能作的是尽可能使用好引擎及优化项目，争取在低端设备或低性能浏览器中，提升FPS帧速。 2.2 WebGL模式下的FPS LayaAir引擎支持WebG的渲染模式。如图2所示；FPS(WebGL)是WebGL模式下的帧速， （图2） 2.3 FPS的数值说明 图1与图2中，FPS的第一个黄色值60为当前的FPS帧速，越高越好。 第二个黄色值16为每帧渲染所消耗的时间，单位为毫秒，这个值越小越好。 这两个值如果不能维持在满帧，会在产品操作过程中产生变化，如动图3所示。 (动图3) 3、DrawCall介绍 DrawCall的次数是决定性能的重要指标，位于统计面板的第三行，如图4所示。DrawCall在Canvas和WebGL渲染下代表不同的意义，但都是越少越好，建议开发者尽量限制在100之下。 (图4) WebGL模式下DrawCall表示渲染提交批次，每次准备数据并通知GPU渲染绘制的过程称为1次DrawCall，在每1次DrawCall中除了在通知GPU的渲染上比较耗时之外，切换材质与shader也是非常耗时的操作。 4、NodeNums的数值说明 NodeNums是性能统计面板中的一个指标，表示当前场景中渲染节点的数量。渲染节点是指需要进行渲染的节点，包括Sprite、MeshSprite3D、SkinnedMeshSprite3D等。 NodeNums的值越大，场景中需要渲染的节点数量越多，对于性能的影响也越大。因此，在开发中应尽量减少场景中的不必要的渲染节点，以提高游戏的性能表现。如图5所示。 （图5） 5、Sprite3D数值说明 Sprite3D是性能统计面板中的一个指标，表示当前场景中Sprite3D节点的数量。Sprite3D是3D节点的基础类，可以包含3D模型、材质、光照等属性，并且可以进行3D变换、动画等操作。 Sprite3D的数量是影响游戏性能的重要因素之一。Sprite3D数量过多，会导致渲染次数增加，从而影响游戏的帧率和性能表现。因此，在开发中应尽量减少场景中的Sprite3D节点数量，以提高游戏的性能表现。如图6所示。 （图6） 6、TriangleFace数值说明 TriangleFace是性能统计面板中的一个指标，表示当前场景中渲染的三角形面数。TriangleFace的值越大，表示场景中需要渲染的三角形面数越多，对于性能的影响也越大。 在3D渲染中，每个MeshRenderer（MeshSprite3D、SkinnedMeshSprite3D）都由多个三角形面组成。因此，在开发中应尽量减少需要渲染的三角形面数，以提高游戏的性能表现。如图7所示。 （图7） 7、RenderNode数值说明 RenderNode是性能统计面板中的一个指标，表示当前场景中渲染节点的数量。渲染节点是指需要进行渲染的节点，包括Sprite、MeshSprite3D、SkinnedMeshSprite3D等。 RenderNode的数量是影响游戏性能的重要因素之一。RenderNode数量过多，会导致渲染次数增加，从而影响游戏的帧率和性能表现。如图8所示 。 （图8） 8、SkinRenderNode数值说明 SkinRenderNode是性能统计面板中的一个指标，表示当前场景中骨骼动画渲染节点的数量。骨骼动画渲染节点是指需要进行骨骼动画渲染的节点，包括SkinnedMeshSprite3D等。如图9所示 。 SkinRenderNode的数量是影响游戏性能的重要因素之一。SkinRenderNode数量过多，会导致渲染次数增加，从而影响游戏的帧率和性能表现。 （图9） 9、ParticleRenderNode数值说明 ParticleRenderNode是LayaAir引擎3.0版本中性能统计面板中的一个指标，表示当前场景中粒子渲染节点的数量。粒子渲染节点是指需要进行粒子渲染的节点，包括ParticleSystem。如图10所示。 可以通过减少粒子数量，使用合理的粒子发射器设置，进行优化，避免粒子数量过大。 （图10） 10、FrustumCulling数值说明 Frustum Culling是性能统计面板中的一个指标，表示当前场景中开启视锥体裁剪的渲染节点数量。视锥体裁剪是指只对在视锥体内的物体进行渲染，超出视锥体的物体不进行渲染，从而减少不必要的渲染，提高游戏的性能表现。如图11所示。 Frustum Culling的数量越大，表示场景中开启视锥体裁剪的渲染节点数量越多，对于性能的影响也越大。 （图11） 在开发中，可以通过设置合适的视锥体大小和位置，避免视锥体过大或过小，从而减少不必要的渲染。 也可以通过合理的节点管理和视锥体裁剪设置，提高Frustum Culling的效率，进而提高游戏的性能表现。 11、GPUMemory数值说明 GPUMemory是性能统计面板中的一个指标，表示当前场景中占用GPU内存的大小。GPU内存是指用于存储GPU所需数据的内存，包括纹理、缓冲区等。如图12所示。 GPUMemory占用过多，会导致游戏卡顿、掉帧等问题。 （图12） 12、TextrueMemory数值说明 TextureMemory是LayaAir引擎3.0版本中性能统计面板中的一个指标，表示当前场景中占用纹理内存的大小。纹理内存是指用于存储纹理数据的内存，包括贴图、字体等。如图13所示 TextureMemory占用过多，会导致游戏卡顿、掉帧等问题。 （图13） 13、RenderTextureMemory数值说明 RenderTextureMemory是性能统计面板中的一个指标，表示当前场景中占用渲染纹理内存的大小。渲染纹理内存是指用于存储渲染纹理数据的内存，包括用于动态生成纹理的RenderTarget等。如图14所示 （图14） 14、BufferMemory数值说明 BufferMemory是性能统计面板中的一个指标，表示当前场景中占用缓冲区内存的大小。缓冲区内存是指用于存储缓冲区数据的内存，包括顶点缓冲区、索引缓冲区等。如图15所示。 （图15） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-31 16:50:10 "},"basics/3D/readme.html":{"url":"basics/3D/readme.html","title":"3D引擎基础","keywords":"","body":"3D引擎基础3D概念入门3D变换3D引擎基础 本章节部分，介绍引擎相关的基础概念与API使用 3D概念入门 3D变换 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:13 "},"basics/3D/beginner/readme.html":{"url":"basics/3D/beginner/readme.html","title":"3D概念入门","keywords":"","body":"零基础了解3D游戏开发基础概念一、场景与摄像机二、坐标系与坐标三、三角面、网格、模型四、材质五、纹理、贴图、面片六、灯光、阴影、反射光七、 加色法光效 、环境光、泛光、光照贴图八、Shader（着色器）九、天空、粒子、拖尾十、3D物理系统、3D动画系统十一、3D基础的常用数学概念写在最后零基础了解3D游戏开发基础概念 Author ：charley 学习最大的障碍就是未知，比如十八般兵器放在你面前都认不出来，又谈何驰骋沙场。更何况3D游戏开发本就是一个门槛不低的工作。本篇抛开引擎的结构，本着初次认知3D游戏世界的逻辑，让没有3D基础的开发者，通过本篇文章，对LayaAir 3D引擎的基础功能以及3D基础概念有一个概览性认识。 至少，我们要了解3D世界的基础都有哪些，然后再依据官方的文档逐个深入学习掌握。 一、场景与摄像机 场景就是游戏中的3D世界，有了场景，才可以在场景中添加一切物体，包括摄像机。 而摄像机相当于3D游戏世界的眼睛， 通过摄像机，玩家才能看到游戏中三维世界，看到场景中的各种物体。 所以，场景里最少要有一台摄像机。 当我们在写3D游戏的代码时，要先在舞台中添加3D场景，添加3D摄像机。再写其它代码。 摄像机在3D场景中，可以是唯一的，也可以放置多台摄像机，比如在3D场景中出现的弹窗换装面板，或者某些对战游戏的同屏需求时会用到多个摄像机。 这里再顺便提一下，摄像机成相效果，也分为透视和正交两种。LayaAir引擎的3D摄像机默认是透视模式，这是一种模拟了人眼的视觉效果，近大远小。 正交则没有透视感，常用于一些2D与3D混合的游戏或模型查看器等。 二、坐标系与坐标 坐标是3D空间世界的基础之一，干啥都离不开坐标，移动摄像机，定位，绘制图形等等。 在学习LayaAir 3D时，我们需要了解两个坐标，一个是位置坐标， 另一个是UV坐标。 而了解这两种坐标之前，我们先介绍一下空间笛卡尔直角坐标系。 空间笛卡尔直角坐标系是用经过相同原点的xyz三条互相垂直的坐标轴相交而构成。 坐标系的两个轴正方向一致的情况下，因第三轴正方向相反，所以将坐标系分为左手坐标系与右手坐标系。 这两种坐标系没有好或不好，都应用的都比较广泛，比如Unity等引擎采用的是左手坐标系，LayaAir等引擎采用的是右手坐标系。所以我们有必要理解什么是左手坐标系与右手坐标系，以及两者的区别。 两种3D坐标系之所以用左右手分别命名，是为了便于记忆，分别用左手和右手三根手指的朝向，来代表三个坐标轴的正方向，这三个手指分别是拇指、食指、中指。 无论是左手还是右手，我们要记住，大拇指朝向的方向是x轴正方向，食指的朝向是y轴的正方向，中指的朝向是z轴的正方向。 现在我们面向屏幕，准备好双手来摆造型。先将左右两个手的食指（y轴）指向天空方向（在房间的就指天花板），然后将中指（z轴）冲前（立正站立时眼睛平视的方向），此时两个手的中指应该都与食指保持90度垂直。然后，再伸出大拇指（x轴）与食指和中指都保持90度垂直。可以参照下图手势。 网络中有不同的左右手坐标系统的说法和介绍，如果图片和轴朝向与本篇介绍的不同，一般也都是摄像机角度的差异，不用管别的，学习LayaAir以本篇为准来理解记忆即可。 摆好后，我们会发现，在保持z轴和y轴正方向相同的情况下，x轴的正方向是相反的。这就是左手坐标系和右手坐标系的区别。LayaAir引擎unity导出插件就是以x轴取反来自动适配LayaAir引擎。所以，直接在unity里编辑导出，然后在LayaAir引擎中使用，是不需要手工对坐标进行转换的。如果开发者一定要在LayaAir引擎项目中手动来调坐标，那需要注意左手坐标系与右手坐标系在x轴正方向的差异。 了解完坐标系，我们了解一下顶点。顶点可以理解为3D空间中的任意一个带xyz坐标的位置点，但顶点不仅包含了坐标位置信息，还有UV、法线、颜色等信息。其它的先不讲，我们继续来了解UV。 UV其实也是坐标， 完整的说应该是UVW（由于xyz已经被顶点坐标轴占用，所以另选三个字母表示）， 这三个轴U是屏幕水平方向，V是屏幕垂直方向，W的方向是垂直于显示器表面的，到目前为止，一般游戏开发是用不上的，所以我们通常就会简称为UV。 去掉了W，那UV坐标就是一个2D平面坐标，UV坐标可用于模型纹理贴图等（后面介绍纹理的时候还会提及）。 UV坐标的贴图纹理向右和向下分别是U与V的坐标正方向。取值范围是0-1，不管纹理图片的像素是多少，3D美术制作软件导出的模型顶点数据都会对应贴图纹理的UV坐标，以保障渲染时的采样正确。 相对于UV坐标最终会对应贴图纹理上的像素点，顶点坐标则没有恒定的计量单位，最小的单位是点，无论是现实世界还是3D世界，点都是一个基础的抽象概念，他代表着一个单独的个体，可以无限大，也可以无限小。所以，点可以是1个像素，也可以是1毫米、1纳米、1千米等任意单位的基础单元。最终顶点之间用什么计量单位，通常由3D美术结合游戏设计而设定，3D游戏美术用的比较多的单位是米。所以程序的设定要与美术设定的单位保持统一，否则就会造成视觉效果上的过大或过小，出现与设计不符的效果。 三、三角面、网格、模型 模型是3D游戏中可见物的基础，比如人物，房屋，树木，山川，河流等等，几乎绝大多数可见物体都是以模型为基础构成。 要进一步了解模型，我们先从三角形平面（简称三角面）开始，三角面是由三个顶点构成，是显卡唯一能处理的基础多边形。之所以把三角面视为最基本的多边形，其中一个重要原因是，由三个点构成的三角面一定是在同一个平面上，而四个或更多点构成的多边形在三维空间中，不一定会在同一个平面上。 而网格（ Mesh）则是由一个三角面或多个三角面拼接形成，是构建模型形状的基础。在LayaAir引擎中， 构成各种图形形状的三角面顶点数据以及三角面的索引数据集合就是网格，所以网格在游戏运行时是不可见的，下图是使用像素线精灵来表现模型的网格构成。 模型是由网格（ Mesh）与材质（ Material）组成。材质展开内容太多，先放一边。从构成三维图形形状而言，我们可以理清以下关系，模型的基础是网格，网格的基础是三角面。三角面越多，模型可表现的细节越丰富。下图正是40000面和4000面及400面的模型细节表现差异。细节表现比较丰富的，通常被称为精模，细节表现相对较弱的，被称为简模。 到底使用精模还是简模，这需要研发技术结合整体效果和游戏硬件性能可承受的压力情况向美术提出需求，在这一点上，移动端H5及小游戏与手游APP标准可保持相等标准。 四、材质 之前讲过，网格只是三维形状的数据，网格形状本身是不可见的。怎么可见，那就需要材质（ Material）了。 顾名思义，材质就是材料的质感。例如，木头与金属、玻璃与毛发，从粗糙度、光泽度、反射、透明、颜色、纹理等等方面，不同的材料质感会明显不同。 根据这些物体的差异，我们可以将材质划分为很多种类，LayaAir引擎支持的材质分类为模型材质、天空材质、拖尾材质、粒子材质。（天空、拖尾、粒子尚未提及，我们先介绍模型材质。） LayaAir引擎的模型材质还可以继续划分，分别为光照材质（BlinnPhongMaterial） 、不受光材质（UnlitMaterial）、特效材质（EffectMaterail）、PBR标准材质（PBRStandardMaterial） 、PBR高光材质(PBRSpecularMaterial) 、 水材质（WaterPrimaryMaterial）。 BlinnPhong材质是默认使用的标准感光材质，而UnlitMaterial材质恰恰相反，并不受光照影响，只显示原贴图的外观图像效果。 下图中，图左是光照材质（ BlinnPhongMaterial）被光照射后的效果。图右是同样被光照射后的不受光材质（ UnlitMaterial ）效果。 特效材质（EffectMaterail） 是一种无需外部光照，通过混合模式让自身产生一种光效视觉效果的材质，常用于特殊效果的制作，所以称为特效材质。视觉效果如下图所示。 PBR材质是一种基于物理渲染 (Physicallly Based Rendering) 的材质，通过模拟自然界的物理规律可以让3D模型的质感更为真实，接近或还原现实世界中的质感。例如，下图中的桶采用了PBR材质。 LayaAir引擎中，PBR材质主要分两类，分别是PBR标准材质（PBRStandardMaterial）和PBR高光材质(PBRSpecularMaterial) 。PBR标准材质是金属流的PBR材质表达，PBR高光材质是高光流的PBR材质表达。 水材质（WaterPrimaryMaterial）比较容易理解，是一种可以设置水面反射与波纹等具有水特性属性的材质。如下图所示： 五、纹理、贴图、面片 纹理是指物体表面的外观效果，表现为2D位图形式。下图为3D地球仪表面的纹理。 贴图简单通俗的理解，就是将2D纹理贴到3D模型网格的过程。这个将3D顶点坐标与2D纹理的UV坐标映射对应的过程由引擎完成，开发者直接调用API，为材质设置对应的纹理即可。下图左侧为仅添加材质，而没有设置贴图的效果。下图右侧是对材质添加了纹理的已贴图效果。 通过效果图我们可以看出，尽管网格与材质已经可以让模型在3D游戏场景中可见了，但不对材质贴图，没有纹理的情况下，我们看到的只是不同质感的纯色模型。有了纹理才有了真实丰富的外观。所以纹理也是比较重要的一个知识点，如果展开讲，纹理可以介绍很多。本篇不再详述。 介绍到这里，我们已能初步理解到纹理与贴图的区别。然而，是很多时候，在文档或口述交流的时候，很多人会把用于贴图的纹理，也简称为贴图。所以我们应该能理解到贴图在某些应用场景下就是代指纹理。 之所以把面片放到纹理一起介绍，是因为对3D一知半解时，不少人会有一个误区，认为面片就是在3D空间中放了一个2D纹理位图。实际上，在三维空间中，哪怕只有一个三角形平面，也可以构成网格，可以设置材质，那这就是模型。所以面片，与其它多面体模型，本质上都是一样的。在下图中，我们在3D空间中看到的草地图片，其实是这个草地面片材质的贴图。 六、灯光、阴影、反射光 光源是3D场景中不可缺少的重要组成部分，网格和纹理决定了物体的形状和外观，光源则可以照明、可以产生阴影、还可以影响场景环境以及3D模型的颜色、亮度、氛围等等。 3D中的光源就是灯光，其它如泛光、环境光等都是光效，而非光源。3D灯光有三种， 平行光（DirectionLight），点光（PointLight），聚光（SpotLight），LayaAir引擎不仅支持这些光源的任意类型，还支持在同一场景下任意添加多个不同类型的光源。 下面简单介绍一下这三种光的区别。 平行光是一种模拟大自然太阳光的灯光，光源来自无穷远的位置，来自光源的光线始终都是平行的且没有衰减。引擎中可设定光源方向，用于给全场景照亮。 点光是一种以光源点为中心，向四周呈发射状的光源，光源点位于3D空间中的某个位置。类似于现实中的蜡烛光、篝火、家用电灯等发光的方式，这种光拥有照射范围和衰减半径。光照范围之外的地方则处于无光的黑暗之中。 聚光与点光类似，都属于位置光，也是位于3D空间的某个位置，也有照射范围和衰减半径，但是，与向四周发散的无方向点光不同，聚光则拥有光源方向，是一种呈锥形角度的光源，类似于现实中的手电洞、舞台聚光灯等光源效果。 阴影是灯光照射模型时产生的， 实时阴影随着灯光角度、灯光强度、模型位置等变化而变化。能产生更加强烈的立体感与真实感。 反射光，是指光源在照射到3D模型上，反射产生的光效。为了模拟自然反射现象，根据不同材质，引擎对反射光会使用不同的光照模型，比如，BlinnPhong材质中使用了漫反射和镜面反射模型。我们简单来理解一下两者的差异。 引擎中的漫反射主要是模拟材质表面粗糙不平的光学反射效果，理想的漫反射材质表面是完全不光滑且没有光泽的，当光源照射到这种材质上，呈现出发散的反射效果。 引擎中的镜面反射用于模拟光滑水平面的光学反射效果，是一种有方向反射，其反射方向以反射平面的法线为中心与入射方向的夹角对等。理想的高光反射材质是表面完全光滑的，比如像镜子一样。镜面反射常用于闪闪发光的视觉效果，且会产生高亮的点状光斑，所以镜面反射有的时候也叫镜面高光，如果LayaAir文档材质篇中提到高光颜色或者高光贴图，我们要能理解，这是指针对镜面反射效果的高光颜色和高光贴图。 基于漫反射和镜面反射的光学现象，引擎中使用了多个光照模型，用于模拟自然光中的反射现象。本篇先揭开一点。暂且先有一个初步的认知。我们继续来了解一些其它与光相关的概念。 七、 加色法光效 、环境光、泛光、光照贴图 上一小节是介绍的3D灯光以及与灯光息息相关的光效。这个小节还是介绍光，但这些光不属于照射光，只是看起来比较像是光的一些效果。我们将逐个了解LayaAir引擎中的一些其它光效。 首先是加色法光效，加色法光效可以让材质本身就会有发光的效果，这是一种通过加色法模拟出来的光感，并非是受光照产生，比如前文中介绍过的特效材质。这种的自发光效果不会对周围环境及其它模型产生影响，但会被背影色影响。 环境光类似于全局颜色滤镜。设置白色等亮色，即便没有光源，场景中也都能比较明亮。想表现阴天的感觉，也可以加入一些灰暗的环境光颜色。或者要表现夜视镜效果等等，都可以通过环境光来设置。 泛光在LayaAir引擎中属于后期效果。即便没有光源的照射，也可以产生一种类似光晕叠加的效果。 光照贴图是一种通过贴图的方式模拟游戏场景中的光影效果，也是游戏中为了节省性能而常用的一种伪光照视觉效果的制作方式。下图中的光效并非是通过灯光实现，是光照贴图的效果。 八、Shader（着色器） Shader 中文名为着色器， shader本质上是一段采用GLSL着色语言编写（着色语言好几种，基于webGL只能用GLSL语言）在GPU上运行的程序 ， 用于告诉图形软件如何计算和输出图像。Shader主要分两类：顶点着色器和片段着色器（也叫片元着色器） 。 顶点着色器是用来处理顶点数据的程序，如顶点坐标、法线、颜色和纹理坐标。 它在每个顶点上调用，可将几何图形（例如：三角形）从一个位置转换为另一个位置， 例如，用于顶点变换、纹理坐标生成、 纹理坐标变换等等。 片段着色器用来计算和填充每个像素的颜色，所以也称为像素着色器。可用于插值的运算、 纹理存取、纹理应用 、 雾 、 色彩计算等。 LayaAir提供了自定义Shader功能，可以让开发者实现一些引擎未曾提供的功能或者效果。Shader的实现有一定的门槛，新手先不要急着研究这个，先有个基础的认知即可。 九、天空、粒子、拖尾 基于网格与材质组成了模型这一概念，理论上一切可见的形状物体，都是模型。但依据开发的易用性，引擎会进一步对一些常用功能进行封装，本节将继续描述这些概念，比如天空、粒子系统、拖尾系统。 LayaAir模拟的3D天空，提供了两种现成的网格，一种是立方体网格，这种天空称为天空盒( SkyBox)。另一种是球形网格( SkyDome )，这种可称为天空球或球形天空，当然，开发者也可以自定义其它的天空网格。 基于立方体网格的天空， 以6张无缝连接的材质纹理贴图形成，类似盒子拆开平铺。例如下图的纹理， 球形网格的天空则采用1张纹理贴图形成，该技术方案相较于天空盒，可以制作出完全相同的视觉效果，但球形网格的顶点要多于天空盒，性能的消耗自然要大一些。如果只有一张贴图纹理的可以采用天空球的技术方案，否则建议采用天空盒方案。 另外，两种3D天空技术方案的使用差别也与材质有关，LayaAir引擎中自带了一个对应天空盒网格的天空盒材质（SkyBoxMaterial）、而天空球要么使用不需要贴图的程序化天空材质（SkyProceduralMaterial），要么就使用模型材质，因为天空不受光照影响，最好使用不受光材质。 粒子是一组分散的微小物体集合，通过让这些微小的物体按某种算法运动起来，从而实现诸如火焰、烟、爆炸、流水、等比较灵动的效果。粒子系统并不是一种绘制形式，而是一种动画方法，粒子系统的作用是在粒子产生、运动、变化以及消失这个生命周期内去控制它们。LayaAir引擎的粒子系统包括了粒子发射器、粒子动画器、和粒子渲染器等多个部分。 拖尾，顾名思义是拖在后面尾巴一样的效果，常用于带条状3D特效，比如，刀光拖尾，跑酷小球游戏的行动轨迹拖尾等。LayaAir引擎内置了拖尾系统和拖尾材质，方便开发者快捷使用3D拖尾。 十、3D物理系统、3D动画系统 3D物理系统是通过模拟真实物理属性的方式来计算重力、运动、旋转、碰撞反馈等，LayaAir引擎内置了bullet等3D物理引擎。官网中有详细的学习文档。 动画是交互式游戏不可缺少的组成部分。 LayaAir引擎中支持使用材质动画，刚体动画，摄像机动画，骨骼动画这几种动画类型。 其中，材质动画是以改变材质的颜色与贴图方式的动画。 刚体动画又称为变换动画，是指不改变模型顶点、材质的基础上，只对模型进行旋转、缩放、位移的动画，比如，脚底光环、刀光等。刚体动画也经常与材质动画结合使用。 骨骼动画也称为蒙皮动画，这种动画主要是以改变模型顶点的方式产生动画。 摄像机动画是指通过改变摄像机位置而产生的动画效果。 十一、3D基础的常用数学概念 在之前的10个小节中，我们已经可以对3D游戏和图形开发，有了一个基础的概念性认知。最后简单介绍一些3D数学的基础常用概念。例如： 向量、 矩阵、 欧拉角、四元数、射线、包围体。 1、向量 既有大小又有方向的量称之为向量（物理学叫矢量），向量也有维度，例如，2维、3维、4维。与向量对应的是数量（物理学叫标量），数量是只有大小没有方向的量。 有的文章把数量理解为1维向量，而我们通常所指的向量是2维或以上维度，不包括1维。 在LayaAir引擎中，针对2维、3维、4维向量的封装方法示例分别为： Vector2(1, 2) 、Vector3(1, 1, 3)、Vector4(1, 2, 3, 0.5) 。然而LayaAir引擎封装的Vector方法，不仅可以作为向量的使用，还可以用于顶点坐标位置，或者表达颜色的时候使用。比如原点坐标Vector3(0, 0, 0)，颜色值Vector3 (0.6, 0.6, 0.6) 、Vector4(0.9, 0.5, 0.1, 1)。 提到向量，再顺带理解一下分量，我们把一个向量分解成几个方向的向量之和，那这些分解的向量就叫做该向量的分量（也称为向量投影）。 例如，某个向量坐标u为（5，10），那分解的向量坐标w1（5，0）和w2（0，10）都是向量坐标u的分量。在引擎中，我们也可以把向量元素视为分量，比如 Vector3( 0.6, 0.6, 0.5) ，有3个分量，其中的0.5称为这个向量的第3个分量。 2、 矩阵 在线性代数中，矩阵是以行和列形式组织的矩形数字块。如果把向量定义为1维数组，那么矩阵就是2维数组。这里不要把2维理解为2D，是指来自数组的行与列形成2维。以数组的角度去理解，那向量是数量的数组，矩阵则是向量的数组。 矩阵是在显卡图形API中直接用于描述方位的形式，可立即进行向量的旋转。LayaAir引擎提供了3×3的旋转矩阵Matrix3x3() 和4×4的变换矩阵Matrix4x4()，变换矩阵可用于平移、旋转、缩放计算。 3、欧拉角、四元数 欧拉角与四元数都是用于旋转计算的数学方法，刚刚介绍的矩阵明明也可以用于旋转计算，为什么要介绍这两种呢？相对而言，3×3旋转矩阵需要9个数，欧拉角只需3个数（3维向量），四元数只需要4个数（4维向量），明显轻量了很多。那是不是欧拉角最优，也不尽然。尽管欧拉角内存占用小，也更加易用，但欧拉角也有他特有的问题，那就是可能会导致万向节死锁。而四元数则相对于矩阵内存占用小，也不受万向节死锁的困扰，而且在平滑插值方面只能是四元数才能完成。 4、射线 射线是只有一个端点无限延长形成的直的线，在LayaAir引擎中的射线 Ray是一个数据对象，拥有起点与发射方向两个属性。常用于基础的碰撞检测，也可以用于鼠标拾取。 5、包围体 包围体用于可见检测计算，基本思想是体积稍大且结构简单的包围体来替代结构复杂的被包围体，当进行检测的时候，达到提高检测效率的作用。比如，一旦检测到包围体被遮挡不可见，那无论包围体内是什么样的模型，那全部不可见。LayaAir引擎中提供了盒状包围体（ 包围盒 ）与球状包围体（包围球）。 写在最后 LayaAir在引擎官网中已经提供了大量的引擎文档，尤其是3D文档，示例DEMO，和API说明文档。然而还是会碰到一些开发者在学习3D的时候无从下手，因此产生了本篇这个更为基础的入门文档，应该已经覆盖了大多数基础概念。希望大家在此文启蒙性认知上，进一步学习引擎的使用，以及从本文中涉及到的未能充分理解的概念有针对性的深入研究学习。 本文仅作为一个基础入门的文档，尽可能去多覆盖一些基础概念，然而文档写作的过程中为了保持写作逻辑的延续，对于一些基础概念并没有完全都介绍全面，比如法线、八叉树、齐次坐标等概念并未讲到。开发者可以在官网文档的学习过程中，如果遇到一些陌生的词语，尽可能先购买基础的图形学书籍或者在搜索引擎中找到适合的文章来补补课。也可以找到官网中QQ群管理员进行反馈，我们会针对引擎使用的文档进行补充和完善。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:13 "},"basics/3D/Transform/readme.html":{"url":"basics/3D/Transform/readme.html","title":"3D变换","keywords":"","body":"LayaAir3D中的Transform变换LayaAir3D中的Transform变换 在前面讲过了LayaAir3D中的坐标系和几个基础数学工具，在示例代码中，transform是一个变换对象，他在3D的世界中非常的重要，所有有关显示对象变化的都会用到他。 在示例代码中已经用到了移动(translate)，旋转(rotate)这两种变换,并且用三维向量代表x，y，z的值。两种方法都可以在参数中设置是否为局部空间移动，旋转。 //移动摄像机 camera.transform.translate(new Laya.Vector3(0, 3, 3)); //旋转摄像机 camera.transform.rotate(new Laya.Vector3(-30, 0, 0), true, false); 关于旋转，在Transform3D中提供了两种旋转接口，一种是角度/弧度旋转rotate，还一种是欧拉角旋转localRotationEuler:Vector3。 (图1) 为了方便观察效果节选了官方示例（demo地址）代码，首先我们 克隆 两个猴子（克隆的知识点会在精灵Sprite3D的章节详细讲解），来看下效果，并且在克隆后为了方便观察我们2个猴子的位置。 //克隆sprite3dvar layaMonkey_clone1:Laya.Sprite3D = Laya.Sprite3D.instantiate(staticLayaMonkey, _scene, false, new Laya.Vector3(0.0, 0, 0.5));var layaMonkey_clone2:Laya.Sprite3D = Laya.Sprite3D.instantiate(staticLayaMonkey, _scene, false, new Laya.Vector3(0.0, 0, 0.5));var layaMonkey_clone3:Laya.Sprite3D = Laya.Sprite3D.instantiate(staticLayaMonkey, _scene, false, new Laya.Vector3(0.0, 0, 0.5));//平移layaMonkey_clone1.transform.translate(new Laya.Vector3(1.5, 0, 0.0));layaMonkey_clone2.transform.translate(new Laya.Vector3( -1.5, 0, 0.0));layaMonkey_clone3.transform.translate(new Laya.Vector3( 2.5, 0, 0.0)); (图2) 然后测试我们的旋转和 缩放 变换。我们对克隆体1 按Y轴旋转60度，克隆体3设置他的缩放值为（0.1，0.1，0.1）。再看下效果。（本次缩放使用的是局部缩放，世界缩放与局部缩放的原点相同，缩放参考的坐标系不同，且世界缩放的倍数是基于全局）。 //旋转layaMonkey_clone1.transform.rotate(new Laya.Vector3(0, 60, 0), false, false);//缩放var scale:Laya.Vector3 = new Laya.Vector3(0.1, 0.1, 0.1);layaMonkey_clone3.transform.localScale = scale; (图3) 除了上面介绍的3中变换，transform中还有一些其他常用的属性和方法： 方法 lookAt(target:Vector3, up:Vector3, isLocal:Boolean = false):void 观察目标位置。 属性 localPosition:Vector3 局部位置。 localScale:Vector3 缩放。 localMatrix:Matrix4x4 局部矩阵。 position:Vector3 世界位置。 localRotation:Quaternion 局部旋转。 scale:Vector3 世界缩放。 worldMatrix:Matrix4x4 世界矩阵 rotation:Quaternion 世界旋转。 right:Vector3 [read-only] 获取向右方向。 forward:Vector3 [read-only]获取向前方向。 3D世界中的子父关系 在3D世界中父节点变换，其子节点会跟着响应的变换。但是子节点发生变换并不会影响父物体。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:13 "},"IDE/uiEditor/readme.html":{"url":"IDE/uiEditor/readme.html","title":"UI编辑模块","keywords":"","body":"UI编辑模块UI编辑器基础交互2D基础显示对象UI组件UI继承类混合使用3DUI编辑模块 UI是User lnterface的简称，中文的意思就是用户界面。例如，游戏界面中的进度条、角色头像、排行榜、商城、游戏任务、功能按钮等等。 实际上，UI编辑所指的范围更为广泛，一切可见的2D显示对象布局，界面排版的行为，均属于UI编辑。 UI编辑模块是2D游戏与2D UI界面可视化操作的重要模块，可大幅提升2D游戏与2D UI制作的开发效率。 LayaAirIDE的UI编辑，可实现UI编辑与代码的分离，与可视化排版，使得无编程基础的美术与策划也可以学习与掌握。 也满足程序员用代码管理与控制UI，以及实现交互逻辑。 UI编辑主要包括层级面板、场景面板、UI编辑排版工具、2D预制体、UI小部件（基础显示对象、UI组件、骨骼动画）、等等。 我们可以分别查看各子模块的功能文档： UI编辑器基础交互 2D基础显示对象 UI组件 UI继承类 混合使用3D Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:52 "},"IDE/uiEditor/basic/readme.html":{"url":"IDE/uiEditor/basic/readme.html","title":"UI编辑器基础交互","keywords":"","body":"UI编辑器基础交互1、UI编辑器基础交互图标说明2、视窗摄像机模式3、平移模式4、对齐设置5、宽高设置6、行、列距、列数设置7、显示设置8、缩放设置UI编辑器基础交互 1、UI编辑器基础交互图标说明 先来看一下UI编辑器基础交互的图标，如图1所示。 （图1） ​ 从左至右依次为视窗摄像机模式、平移模式、左对齐、左右居中对齐、右对齐、上对齐、上下居中对齐、下对齐、相同宽度、相同高度、均匀行距、均匀列距、表格排列、显示设置、缩放设置。 2、视窗摄像机模式 ​ 在2D场景中点击小手图标即可进入视窗摄像机模式，也可以按住鼠标右键直接进入该模式，在该模式下，持续按住鼠标左键或右键，可以往任意方向拖动整个场景，效果如动图2-1所示。 （动图2-1） 3、平移模式 在2D场景中点击箭头图标即可进入平移模式，在该模式下持续按住鼠标左键即可往任意方向拖动所选中的控件。 如场景层级很多，拖动想要移动的组件会比较困难，这时候就可以从层级面板单击选中该组件然后进行拖动，效果如动图3-1所示。 （动图3-1） 如果想一次性移动多个控件，只需要在画布之外长按鼠标左键然后滑过画布就可以了，如动图3-2所示。 （动图3-2） 4、对齐设置 将控件在该控件的父节点上进行平移，可以只移动一个，也可一次性平移多个，方法为在画布之外长按鼠标左键然后滑过画布，点击自己需要的对齐设置即可。 名称 功能 左对齐 将所选中的控件以水平方向平移到该控件父节点的最左边。 左右居中对齐 将所选中的控件以水平方向平移到该控件父节点的水平中心。 右对齐 将所选中的控件以水平方向平移到该控件父节点的最右边。 上对齐 将所选中的控件以垂直方向平移到该控件父节点的最上方。 上下居中对齐 将所选中的控件以垂直方向平移到该控件父节点的垂直中心。 下对齐 将所选中的控件以垂直方向平移到该控件父节点的最下方。 5、宽高设置 相同宽度：以画布作为类比对象，对所选中的控件修改宽度，如动图5-1所示。 （动图5-1） 相同高度：以画布作为类比对象，对所选中的控件修改高度，如动图5-2所示。 （动图5-2） 6、行、列距、列数设置 均匀行距：以像素为单位，对所选控件进行均匀的行距排列,效果如动图6-1所示。 （动图6-1） 均匀列距：以像素为单位，对所选控件进行均匀的列距排列,效果如动图6-2所示。 （动图6-2） 表格排列：对所选控件进行整齐的表格式排列，直接输入数值即可完成，非常的方便，效果如动图6-3所示。 （动图6-3） 7、显示设置 显示设置功能用来修改编辑器场景视窗的背景颜色，开发者可自行选择，效果如图7-1所示。 （图7-1） canvas的设置选项，如图7-2所示。 （图7-2） 8、缩放设置 对当前场景进行缩放，开发者可自行选择。 如图8-1所示。 （图8-1） 缩放设置的快捷键。 按键 功能 ctrl + + 放大 ctrl + - 缩小 ctrl + 1 恢复到100% ctrl + 鼠标滚轮 自由缩放 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:52 "},"IDE/uiEditor/widgets/readme.html":{"url":"IDE/uiEditor/widgets/readme.html","title":"UI小部件","keywords":"","body":"UI小部件UI小部件 LayaAir引擎的UI小部件，分为三类。 分别是基础的显示对象：2D精灵、2D节点动画、HTML文本、文本 UI组件：图像、按钮、显示文本、文本输入、文本域、下拉框、多选框、单选框、单选框组、导航标签组、导航容器、位图切片、位图字体切片、 垂直滚动条、水平滚动条、进度条、垂直划动条、水平划动条、取色器、基础容器、列表、树状列表、面板容器 骨骼：Spine骨骼，内置骨骼 如图1所示： (图1) 在使用的时候，直接将小部件拖拽到场景视窗中即可。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:54 "},"2D/displayObject/readme.html":{"url":"2D/displayObject/readme.html","title":"2D基础显示对象","keywords":"","body":"2D基础显示对象2D基础显示对象 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:43 "},"2D/displayObject/Sprite/readme.html":{"url":"2D/displayObject/Sprite/readme.html","title":"精灵","keywords":"","body":"精灵一、概述二、IDE中使用2.1 创建精灵2.2 基础属性2.3 Sprite的特有属性2.4 其它属性2.5 脚本控制属性三、代码中使用3.1 创建Sprite3.2 显示图片3.3 基础属性3.4 其它属性精灵 一、概述 游戏中Sprite精灵是在屏幕中能够被控制的显示对象，如果屏幕中的显示对象不能被控制那就只是一个节点。准确来说，Sprite精灵是一个能够通过改变自身属性，比如角度、位置、缩放、颜色等，变为可控动画的2D图像。 Sprite 是基本的显示图形的显示列表节点。 通过 graphics 可以绘制图片或者矢量图，支持旋转，缩放，位移等操作。Sprite同时也是容器类，可用来添加多个子节点。Sprite针对不同的情况做了渲染优化，所以保证一个类实现丰富功能的同时，又达到高性能。 另外，在LayaAir 2D UI中，Sprite是所有节点对象的基础类，如图1-1所示，Sprite 类的基础功能会被继承到所有继承的节点对象中（由于篇幅有限，图中只列出了Sprite类部分的子类，全部的继承关系请参考API文档），因此本篇会详解介绍 Sprite 类的基础功能，后续的节点对象重复的将不再介绍。 （图1-1） 二、IDE中使用 2.1 创建精灵 2.1.1 Scene2D中创建 在一个Scene2D的层级窗口中，任何节点下，或者是空白位置，都可以通过鼠标右键来创建精灵，如动图2-1所示： （动图2-1） 此时创建的精灵，是看不到任何效果的，实际上就是创建了一个空的2D精灵节点。 2.1.2 控件中创建 在小部件的2D标签下，可以在任何节点下，创建精灵，如动图2-2所示： （动图2-2） 2.2 基础属性 如图2-3所示，精灵有如下基础属性: （图2-3） 基础属性 功能说明 Position 精灵的位置坐标 Size 精灵的宽高 Anchor 精灵的锚点 Scale 精灵的缩放 Skew 精灵的倾斜角度 Rotation 精灵的旋转度 Visible 精灵是否可见 Alpha 精灵的透明度 我们通过一组操作，来看看这些属性是如何操作的，如动图2-4： （动图2-4） 由于此时的精灵只是一个空节点，没有显示对象，因此 Visible 和 Alpha 的调整是没有任何显示变化的，我们先来看看几个常用的基础属性： 2.2.1 位置Position 精灵的位置说的是精灵锚点/轴心点所处画布的位置。Position有x和y两个参数，以画布的左上角为原点，从左指向右为x轴正向，从上指向下为y轴正向。 2.2.2 大小Size 精灵的大小是指精灵的宽（W）和高（H），单位是像素。 2.2.3 锚点 Anchor 在讲解锚点之前需要先知道轴心点Pivot的概念。一个Sprite精灵对象默认的轴心点位于自身的左上角，设置Sprite精灵的位置时默认是以左上角为基准进行定位的。 轴心点是基准点，决定着Sprite在舞台的位置。轴心点以像素为单位，默认X、Y坐标为(0,0)表示图片左上角作为基准点。当修改了Sprite对象设置默认轴心点，对Sprite对象设置位置Position、缩放Scale、旋转Rotation时，都是以轴心点为基准，而并非默认的Sprite对象左上角的坐标值。改变轴心点可以控制旋转和缩放的中心，还会影响对象位置、缩放中心、旋转中心。 锚点anchor和轴心点pivot都是基准点，决定着Sprite在舞台的位置。锚点则是以Sprite的宽和高的倍数为单位，取值范围是0~1。 改变锚点anchor的同时，轴心点pivot也会随着改变，因此说明修改锚点anchor是改变轴心点pivot的另外一种简单方式。 2.2.4 缩放大小Scale Scale的X和Y是以锚点/轴心点为中心进行水平、垂直大小缩放。 默认为1，不缩放；正数值越大，缩放尺寸越大。 缩放到0，不可见； -1为镜像。负数值越大，镜像后缩放尺寸越大。 2.2.5 倾斜角度Skew Skew的X和Y是以锚点/轴心点为中心进行水平、垂直角度倾斜。 2.2.6 旋转角度Rotation 旋转以锚点/轴心点为中心，正数代表顺时针旋转，负数代表逆时针旋转。 2.2.7 可见性Visialble 这是一个布尔型的值。勾选代表true，表示可见。不勾选代表false，表示不可见，此时如果精灵加载了图片，那么就不会显示到画布上了。 2.2.8 透明度Alpha 如果精灵加载了图片，透明度可以设置图片的透明度，范围为0~1。 2.3 Sprite的特有属性 （图2-5） 如图2-5所示，精灵的自身属性有： Texture：绘制一个图片或者渲染纹理。 Graphics：绘制一个或者一组图形。 2.3.1 Image的Texture 首先，Sprite的Texture是支持通过拖入或者加载一张图片作为纹理Texture绘制的。 如动图2-6所示，来了解下拖入一张图片到Texture属性中的过程： （动图2-6） 注意：在实现项目开发过程中，如果只是绘制一张图片，那么尽量使用Spirte对象通过Texture的方式绘制，性能是最高的。在2D界面开发中，需要将图片编辑成“精灵纹理”，详细请参考《项目资源面板说明》。 2.3.2 RenderTexture的Texture 渲染纹理 （Render Texture）是在运行时不断更新渲染的一种特殊类型纹理 。渲染纹理的一个典型用法是将其设置为摄像机的“目标纹理”属性，这将使摄像机渲染到纹理， 而不是渲染到屏幕。随后可以如同普通纹理 (Texture) 一样在Sprite对象中使用。 如动图2-7所示，是把一张创建好的渲染纹理（制作方法参看混合使用3D）拖入到Sprite的Texture属性中的。 （动图2-7） 注意：只有通过Sprite的Texture属性才能设置渲染纹理，其它任何显示对象组件中设置渲染纹理的方式都是不正确的 2.3.3 Graphics属性 通过使用Graphics属性，我们可以绘制矩形，圆形，多边形等图形，如动图2-8所示 ： （动图2-8） 具体每一种图形的绘制介绍和代码使用方法，请开发者参考《绘制图形》一篇。 2.4 其它属性 杂项属性面板中包括了精灵的其它属性，如图2-9所示： （图2-9） 其它属性 功能说明 Z Order Z排序，更改此值，则会按照值的大小对同一容器的所有对象重新排序。值越大，越靠上。默认都为0，若不更改则会根据添加顺序排序 Blend Mode 指定要使用的混合模式。目前只支持\"lighter\" Mouse Enabled 是否接受鼠标事件 Mouse Through 鼠标事件与此对象的碰撞检测是否可穿透 Hit Test Prior 指定鼠标事件检测是优先检测自身，还是优先检测其子对象 DrawCallOptimize 是否开启DrawCall优化 Cache As 是否开启静态缓存优化 Mask 设置遮罩节点对象 Hit Area 点击区域 Filters UI滤镜效果 其中Mouse Enabled、Mouse Through、Hit Test Prior、Hit Area统一放在“2.4.6鼠标操作相关属性”中讲解 2.4.1 设置Z Order 如动图2-10所示，我们在IDE中设置了两个Sprite的Z Order的值，默认都是0，后添加的在上面。更改后，看看运行的效果，说明值越大，越靠上。 （动图2-10） 2.4.2 设置BlendMode 如动图2-11所示，我们在IDE中设置了两个Sprite，原本Sprite2是覆盖Sprite1的，当使用BlendMode为“lighter”后，看看运行的效果，两个Sprite的图的颜色叠加了。 （动图2-11） 注意：在IDE中，只支持lighter模式，原有图形和新图形都显示，交集部分做颜色叠加 2.4.3 设置Draw Call Optim 如果为true，代表开启DrawCall优化。 DrawCall的内容请参考《性能统计与优化》。 2.4.4 设置Cache As （图2-12） 如图2-12所示，可以设置两种类型的静态缓存，我们来看看静态缓存的一些说明： 当游戏中有大量的UI，并且一个UI有多个节点，变化较小时，推荐使用cacheAs（大部分UI都可以使用）。 例如我们使用的LayaAir IDE，软件中的很多面板，例如属性设置器、资源管理器、项目管理器等，它们的节点子对象很多，但不是很频繁的改动，因此我们都使用了cacheAs进行缓存，提高了渲染效率。 对于经常变化的复杂UI，可以把UI分成两层，较少变化的一层使用cacheAs，经常变化的层不使用。例如有“倒计时”显示的UI，我们也可以把它分成倒计时部分和其他部分，其他部分进行cacheAs，倒计时部分不进行cacheAs。 开发时使用cacheAs需认真学习理解，错误的理解和使用缓存机制反而会降低性能。下列是两个主要属性的详细说明： cacheAs：缓存组件，是否缓存为静态图像，合理作用能提高性能 。它有”无”，”正常”和”位图”三个值可选。 “无”： 表示不做任何缓存。 “正常”： canvas模式下进行画布缓存 ：它相当于把由多个子对象组成的UI缓存成一张位图，游戏每帧渲染时，只是渲染缓存的位图，而不是把所有子对象全部渲染一次，因此节省了渲染开销，提高了性能。 webgl模式下进行命令缓存：它相当于只缓存了子对象遍历过程及程序命令组织，未缓存成一张位图，在游戏每帧渲染时，不用再次去遍历子对象，而是直接把子对象按照遍历好的层级进行显卡渲染，它不会减少drawcall，不会增加内存损耗。渲染性能中等。 Tips： cacheAsBitmap属性功能等同cacheAs属性的normal模式，cacheAsBitmap属性为兼容旧版本IDE而保留，当前如果有相关需求，建议使用cacheAs的normal进行设置。 “位图”： canvas模式下依然是画布缓存。 webgl模式下进行renderTarget缓存：它相当于把多个子对象组成的UI 缓存成一张位图并提交给显卡进行每帧渲染，减少了drawcall。渲染性能最高。需注意的是缓存的位图会额外增加一部分内存开销，缓存的位图越大，内存开销越大。且缓存位图大小不能超过2048。这种模式在不断重绘时也会增加CPU的开销。 Tips：当cacheAs选择”正常”和”位图”时，子对象发生变化，会自动重新缓存，同时也可以手动调用reCache方法更新缓存。 2.4.5 设置Mask 根据对象（支持位图和矢量图）的形状进行遮罩显示，遮罩对象坐标系是相对于遮罩对象本身的。 如动图2-13所示，我们来看看设置mask的操作过程，比如我们在Sprite1绘制的图形上设置一个圆形的遮罩Sprite2，其中Sprite2是Sprite1的子节点。 （动图2-13） 2.4.6 鼠标操作相关属性 鼠标操作相关属性说明如下： 属性 功能说明 MouseEnabled 设为true表示接受鼠标事件，设为false不接受鼠标事件（以下属性均将失效） Hit Area 点击区域，自定义区域只支持圆形、矩形、多边形 MouseThrough 默认值为false，如果设置为true，则点击空白区域（不设置Texture、Image等）可以穿透过去，只针对自身有效 Hit Test Piror 当值为true时，并且不穿透（Mouse Through为false）时，会优先检测本节点。当值为false时，会优先检测子节点，一直到stage上的全部节点都递归检测完毕。 1. Mouse Enabled： 默认为false，如果在脚本代码中监听鼠标事件，则会自动设置本对象及父节点的MouseEnabled属性值都为 true。但若将父节点的MouseEnabled的值手动设置为false，即使进行了鼠标事件监听，父节点的MouseEnabled值也是false。 下面来举一个例子说明这一特殊情况。如图2-14所示，“Sprite1”为父节点，“Sprite2”为子节点，在IDE中默认MouseEnabled属性值为false。 （图2-14） 此时，可以在Scene2D下添加一个自定义组件脚本，并添加如下代码： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { //declare owner : Laya.Sprite3D; @property({ type: Laya.Sprite }) public sprite1: Laya.Sprite; @property({ type: Laya.Sprite }) public sprite2: Laya.Sprite; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { this.sprite2.on(Laya.Event.MOUSE_DOWN, this, this.test2);//设置监听，sprite1或sprite2均可 console.log(this.sprite1.mouseEnabled);//打印父节点sprite1的MouseEnabled的值：true console.log(this.sprite2.mouseEnabled);//打印子节点sprite2的MouseEnabled的值：true } test2(e: Laya.Event) { console.log('mouseSprite2') } } 虽然默认的MouseEnabled属性值为false，但是由于在脚本中设置了监听鼠标事件this.sprite2.on，所以此时父节点“Sprite1“和子节点”Sprite2”的MouseEnabled值会自动变为true。代码执行效果如下： （动图2-15） 可以看到，设置监听后，打印的MouseEnabled值变为true。 但如果在代码中给父节点“Sprite1”的MouseEnabled赋值为false，那么即使给“Sprite1”设置了监听也不会改变它的值了： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { //declare owner : Laya.Sprite3D; @property({ type: Laya.Sprite }) public sprite1: Laya.Sprite; @property({ type: Laya.Sprite }) public sprite2: Laya.Sprite; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { this.sprite1.mouseEnabled = false;//父节点的MouseEnabled赋值为false this.sprite1.on(Laya.Event.MOUSE_DOWN, this, this.test1);//设置监听,sprite1 this.sprite2.on(Laya.Event.MOUSE_DOWN, this, this.test2);//设置监听,sprite2 console.log(this.sprite1.mouseEnabled);//打印父节点sprite1的MouseEnabled的值：false console.log(this.sprite2.mouseEnabled);//打印子节点sprite2的MouseEnabled的值：true } test1(e: Laya.Event) { console.log('mouseSprite1') } test2(e: Laya.Event) { console.log('mouseSprite2') } } 但是要注意，此时“sprite2”的MouseEnabled并没有被手动赋值，仍然只有默认初始值，所以给“sprite2”设置监听会让其MouseEnabled值变为true。 事件监听方法参考《事件与交互》。 2. Hit Area： 如果我们对一个图片设置点击事件，那么这个Sprite的长宽所组成的矩形就是它的点击区域。也可以用HitArea为其设置自定义的点击区域Hit（圆形、矩形、多边形）和非点击区域UnHit，如动图2-16设置点击区域： （动图2-16） 3. Mouse Through： 以一个例子来说明这个属性。如图2-17所示，场景中有两个Sprite节点，为了方便观察效果，给Sprite1的”Graphics”加一个矩形并设为白色。Sprite2在Sprite1的上层，它的大小比Sprite1稍小一点，不给它设置“Texture”、“Graphics”等，即Sprite2就是一个空白区域。 （图2-17） 此时，先不勾选“Mouse Through”，在代码中监听鼠标按下事件： onAwake(): void { this.sprite1.on(Laya.Event.MOUSE_DOWN, this, this.test1);//设置监听,sprite1 this.sprite2.on(Laya.Event.MOUSE_DOWN, this, this.test2);//设置监听,sprite2 } test1(e: Laya.Event) { console.log('mouseSprite1') } test2(e: Laya.Event) { console.log('mouseSprite2') } 在运行时，由于Sprite2是空白区域，所以我们无法观察到，但是，Sprite2覆盖在Sprite1的上层，如果点击Sprite2的点击区域，是会被监听到的，效果如动图2-18所示： （动图2-18） 可以看到，控制台打印了mouseSprite2这个日志，但是它没有监听到Sprite1，因为点击的地方，是Sprite2覆盖在了Sprite1的上面。 勾选Sprite2的“Mouse Through”，再次运行，效果如下： （动图2-19） 点击的是Sprite2的区域，但是控制台打印的是mouseSprite1，原因就是这个事件穿过（Mouse Through）了Sprite2，作用在了下层的Sprite1。 4. Hit Test Prior： 如果鼠标不在节点的鼠标碰撞区域内，则会直接中断此节点以及其子节点的检测，这样能减少鼠标碰撞，提高性能。但也因如此，会导致子节点在其父节点的碰撞区域外时，无法响应鼠标事件。 下面以一个例子来说明，如图2-20所示，Sprite1是父节点，绘制了一个白色矩形，子节点Sprite2在父节点的外面，绘制了一个红色矩形。 （图2-20） 上述“3. Mouse Through”中的脚本代码不变，先不勾选Sprite1的“Hit Test Prior”，点击子节点Sprite2，控制台打印Sprite1和Sprite2的两个日志，效果如下： （图2-21） 图2-21的效果表明，当父节点的“Hit Test Prior”值为false时，会优先检测子节点，并一直递归检测到父节点也会响应。 再勾选Sprite1的“Hit Test Prior”，这时，子节点Sprite2不在父节点Sprite1的鼠标碰撞区域内，如果鼠标放在子节点Sprite2上，就会直接中断Sprite1和Sprite2的检测，无法响应鼠标事件，效果如动图2-22所示。 （动图2-22） 可以看到，点击Sprite2没有响应鼠标事件。 2.4.7 设置Filters 滤镜主要是用来实现图像的各种特殊效果，使图像取得最佳艺术效果。滤镜的类型有很多，但是营造不同的效果需要不同的滤镜功能。关于滤镜有单独的一篇进行讲解，请参考《UI滤镜效果》。 2.5 脚本控制属性 在Scene2D的属性设置面板中，增加一个自定义组件脚本。然后，将Sprite节点拖入到其暴露的属性入口中，如动图2-23所示。 （动图2-23） 接着，就可以在组件脚本中用代码对Sprite进行控制了，示例代码如下： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { //declare owner : Laya.Sprite3D; @property({ type: Laya.Sprite }) public sprite: Laya.Sprite; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { this.sprite.loadImage(\"atlas/comp/image.png\"); //纹理：图片路径 this.sprite.pos(Laya.stage.width >> 1, Laya.stage.height >> 1); //位置：屏幕中心 this.sprite.x = Laya.stage.width/2; //x、y分别设置位置 this.sprite.y = Laya.stage.height/2; this.sprite.size(512, 313); //大小 this.sprite.width = 512; //宽、高分别设置大小 this.sprite.height = 313; this.sprite.pivot(this.sprite.width/2, this.sprite.height/2); //轴心点：sprite的中心 this.sprite.pivotX = this.sprite.width/2; //x、y分别设置轴心点 this.sprite.pivotY = this.sprite.height/2; this.sprite.anchorX = 0.5; //锚点:sprite的中心 this.sprite.anchorY = 0.5; this.sprite.scale(0.5, 0.5); //缩放大小 this.sprite.scaleX = 2; //x、y分别设置缩放 this.sprite.scaleY = 2; this.sprite.skew(5, 5); //倾斜度 this.sprite.skewX = 5; //x、y分别设置倾斜度 this.sprite.skewY = 5; this.sprite.rotation = 45; //旋转角度 this.sprite.visible = true; //是否可见：可见 this.sprite.alpha = 0.5; //透明度 } } 三、代码中使用 Laya.Sprite 类位于Core核心类库中，是 laya.display.Sprite 类封装后形成的。LayaAir引擎API设计精简巧妙，核心显示类只有一个Sprite。 3.1 创建Sprite 创建Sprite对象实例，代码如下： onAwake(): void { let sprite = new Laya.Sprite(); // 添加到舞台 Laya.stage.addChild(sprite); } 3.2 显示图片 图片的显示是游戏开发的基础，Sprite类中用于显示图片是 Sprite.loadImage 和 Sprite.texture。 3.2.1 loadImage /** * 加载并显示一个图片。相当于加载图片后，设置texture属性 * 注意：2.0改动：多次调用，只会显示一个图片（1.0会显示多个图片）,x,y,width,height参数取消。 * @param url 图片地址。 * @param complete （可选）加载完成回调。 * @return 返回精灵对象本身。 */ loadImage(url: string, complete?: Handler): Sprite; 我们来看看代码示例： let sprite = new Laya.Sprite(); // 加载并显示一个图片，居中显示 sprite.loadImage(\"atlas/comp/image.png\", null); sprite.pos(Laya.stage.width >> 1, Laya.stage.height >> 1); // 添加到舞台 Laya.stage.addChild(sprite); 3.2.2 set texture /** * 设置一个Texture实例，并显示此图片（如果之前有其他绘制，则会被清除掉）。 * 等同于graphics.clear();graphics.drawImage()，但性能更高 * 还可以赋值一个图片地址，则会自动加载图片，然后显示 */ get texture(): Texture; set texture(value: Texture); 我们来看看代码示例： Laya.loader.load(\"atlas/comp/image.png\").then(() => { let sprite = new Laya.Sprite(); //精灵设置纹理并居中显示 let res = Laya.loader.getRes(\"atlas/comp/image.png\"); sprite.pos(Laya.stage.width >> 1, Laya.stage.height >> 1); sprite.texture = res; // 添加到舞台 Laya.stage.addChild(sprite); }); 3.2.1和3.2.2这两个示例代码的运行效果是一样的，如图3-1所示，开发者可以根据自己的需要来使用。 （图3-1） 3.3 基础属性 我们通过一些代码示例来看看： let sprite = new Laya.Sprite(); // 加载并显示一个图片 sprite.loadImage(\"atlas/comp/image.png\", null); //设置图片的起始位置 sprite.pos(20, 20); //设置锚点 sprite.anchorX = 0.5; sprite.anchorY = 0.5; //设置缩放 sprite.scale(2, 2); //旋转 sprite.rotation = 30; // 添加到舞台 Laya.stage.addChild(sprite); 运行效果如图3-2所示： （图3-2） 3.4 其它属性 3.4.1 设置zOrder 设置 zOrder 的示例代码如下： let sp1 = new Laya.Sprite(); Laya.stage.addChild(sp1); sp1.pos(200, 190); // 加载并显示一个图片1 sp1.loadImage(\"resources/layabox.png\", null); //需要在resources文件夹下放入layabox.png图片 let sp2 = new Laya.Sprite(); Laya.stage.addChild(sp2); // 加载并显示一个图片2 sp2.loadImage(\"atlas/comp/image.png\", null); // 设置zOrder sp1.zOrder = 1; sp2.zOrder = 0; 我们来看看运行结果： （图3-3） 可以看到，sp1原本是先添加的子节点，sp2是后添加的子节点，原本sp2是会覆盖掉sp1的，但是通过修改zOrder，会让sp1在显示最上层。 3.4.2 设置BlendMode 设置 BlendMode 的示例代码如下： let sp1 = new Laya.Sprite(); Laya.stage.addChild(sp1); // 加载并显示一个图片1 sp1.loadImage(\"atlas/comp/image.png\", null); let sp2 = new Laya.Sprite(); Laya.stage.addChild(sp2); // 加载并显示一个图片2 sp2.loadImage(\"resources/layabox.png\", null); sp2.pos(200, 190); // 设置blendMode sp2.blendMode = \"lighter\"; 我们来看看运行结果： （图3-4） 与图3-3对比可以看到，使用“lighter”的blendMode后，sp2图片的颜色和sp1的颜色叠加了。 3.4.3 设置autoSize 指定是否自动计算宽高数据。默认值为 false 。Sprite宽高默认为0，并且不会随着绘制内容的变化而变化，如果想根据绘制内容获取宽高，可以设置本属性为true。示例代码如下： let sprite = new Laya.Sprite(); // 添加到舞台 Laya.stage.addChild(sprite); sprite.autoSize = true; 3.4.4 缓存为静态图像 示例代码如下： let sprite = new Laya.Sprite(); Laya.stage.addChild(sprite); //缓存为静态图像 sprite.cacheAs = \"bitmap\" 3.4.5 设置遮罩mask 代码示例如下： let sprite = new Laya.Sprite(); Laya.stage.addChild(sprite); sprite.loadImage(\"atlas/comp/image.png\", null); //创建遮罩 let mask = new Laya.Sprite(); sprite.addChild(mask); mask.graphics.drawCircle(200, 200, 100, \"#FFFFFF\"); //图片添加遮罩 setTimeout(() => { sprite.mask = mask;//等待1秒执行遮罩 }, 1000); 运行效果如下： （动图3-5） 3.4.6 设置点击区hitArea 鼠标操作相关属性较多，但是代码的使用都类似，这里以hitArea为例，示例代码如下： let sp = new Laya.Sprite(); Laya.stage.addChild(sp); // 加载并显示一个图片 sp.loadImage(\"atlas/comp/image.png\", null); //设置图片的点击事件 sp.on(\"click\", this, () => { Laya.Tween.to(sp, { scaleX: 0.5, scaleY: 0.5 }, 100); }); //设置鼠标点击区域 let hitArea: Laya.HitArea = new Laya.HitArea(); hitArea.hit.drawRect(0, 0, 100, 100, \"#00ff00\"); sp.hitArea = hitArea; 我们来看看运行结果： （动图3-6） 可以看到，点击区域是有点击效果的，其他区域是没有效果的，而如果不设置hitArea，只要是图片范围，都可以接受点击事件。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-05-26 16:45:25 "},"2D/displayObject/Animation/readme.html":{"url":"2D/displayObject/Animation/readme.html","title":"动画节点","keywords":"","body":"动画节点（Animation）1. 初步认知Animation节点2. 通过LayaAir IDE创建Animation节点2.1 创建Animation2.2 接收动画数据源2.3 设置自动播放（autoPlay）2.4 控制动画的播放模式（wrapMode）2.5 动画播放的帧间隔时间(interval)2.6 设置播放的起始位置（index）2.7 脚本控制Animation3. 代码创建Animation动画节点（Animation） 1. 初步认知Animation节点 Animation是节点动画，可以方便的创建图集动画、多帧动画。如动图1-1所示，就是由Animation创建的动画效果。Animation节点的API请参考Animation API。 （动图1-1） Animation节点的常用属性 属性 功能说明 images 添加动画图像。 source 添加动画图集。 autoplay 动画图集是否自动播放，默认为false。如果设置为true，则动画被创建并添加到舞台后自动播放。 wrapmode 播放类型：默认为0是正序播放（POSITIVE），1为倒序播放（REVERSE），2为pingpong播放（PINGPONG）。 interval 动画播放间隔，单位为毫秒，默认值为50毫秒。 index 播放位置。 2. 通过LayaAir IDE创建Animation节点 2.1 创建Animation 如动图2-1所示，可以在层级面板中创建Animation节点，点击+或通过右键点击创建。 （动图2-1） 也可以从小部件里直接拖入Animation到IDE的场景编辑器或层级面板中，如动图2-2所示。 （动图2-2） 2.2 接收动画数据源 接收动画数据源有设置Images和Source两种方式。 2.2.1 Images 第一种方法是Images，可以摁住键盘 ↓ 方向键快速选择图片，也可以单击图片进行添加，如动图2-3所示。 （动图2-3） 2.2.2 Source 第二种方法更为简单快捷，直接将打包好的图集放入Source属性中即可，如图2-4所示。 （图2-4） 2.2.3 制作图集 虽然添加图集的方式较为快捷，但是上述的“图集”资源需要开发者自己制作。LayaAir IDE提供了制作图集的工具，如图2-5所示，在导航栏的工具菜单栏中选择制作图集。 （图2-5） 点击后打开的制作图集工具如图2-6所示。 （图2-6） 制作图集时，要将需要放入图集的一系列图片，存放在一个文件夹中（这里存放在了文件夹“role”中）。然后将参数图片所在文件夹设置为存放图片的文件夹“role”中，如图2-7所示。 （图2-7） 勾选二次幂限制，则生成的图集图片宽高将会是2的整次幂。 勾选裁剪图片周边空白，生成图集的图片将会更加密集一些。 点击制作按钮，如图2-8所示，选择图集文件存放的路径，并对图集文件进行命名，然后点击保存。 （图2-8） 图集制作完成后，会显示“成功！”字样的提示（如图2-9）。 （图2-9） 最终生成的图集文件为同名的.atlas文件和.png文件（role.atlas和role.png）。其中，.atlas是LayaAir IDE特有的图集格式，仅用于图集。 2.3 设置自动播放（autoPlay） autoPlay属性可以设置是否自动播放，默认为false，不自动播放。如果设置为true，即勾选状态下，动画被创建并添加到舞台后自动播放。 2.4 控制动画的播放模式（wrapMode） 动画播放模式属性wrapMode有三个值可选。默认值是0，正序播放（POSITIVE）。选1时，倒序播放（REVERSE）。选2时，pingpong（乒乓）模式（PINGPONG），直白一些就是来回播放。下面以加载图集的方式演示三种播放模式。 注意：播放时要勾选AutoPlay参数，即将其设为true。 2.4.1 正序模式播放 默认不设置wrapMode属性或是将wrapMode属性值设为0时，为正序播放模式（POSITIVE）。也就是序列图从前到后的顺序进行播放，如动图2-10所示。 （动图2-10） 2.4.2 倒序模式播放 将wrapMode属性值设为1时，为倒序播放模式（REVERSE）。也就是序列图从后到前的顺序进行播放，与正序播放模式完全相反，如动图2-11所示。 (动图2-11) 2.4.3 pingpong（乒乓）模式播放 将wrapMode属性值设为2时，为pingpong播放模式（PINGPONG）。在这个模式下，同一套动作，正序播放完了，并不是直接回到图集设置的第一帧重头播放，而是从倒序的倒数第二帧播放，从而让动作更加平滑和完整。因此，pingpong模式也是游戏中经常使用的模式之一，在保障效果的前提下，还可以大幅减少美术资源量。效果如动图2-12所示。 (动图2-12) 2.5 动画播放的帧间隔时间(interval) interval属性可以设置动画播放的帧间隔时间(单位：毫秒)，默认值为50毫秒。例如，我们将刚刚播放的动画，放慢一倍，设置为100毫秒。效果如动图2-13所示。 （动图2-13） Tips：如果动画正在播放，设置后会重置帧循环定时器的起始时间为当前时间，也就是说，如果频繁设置interval，会导致动画帧更新的时间间隔会比预想的要慢，甚至不更新。 2.6 设置播放的起始位置（index） index属性可以指定动画的帧索引，默认的索引是0，可以设置为动画中的任意一帧。设置后，将会跳到设定的动画帧，效果如动图2-14所示。 （动图2-14） Tips：该属性仅用于静态指定，比如通过代码或点击事件来手动切换动画帧。如果设置为自动播放，仍会从第0帧开始播放，与索引的设置没有关系。 2.7 脚本控制Animation 在Scene2D的属性设置面板中，增加一个自定义的组件脚本，命名为“Animation.ts”。然后，按照动图2-15，将Animation节点拖入到“Animation.ts”暴露的属性入口中。 （动图2-15） 接着，就可以在脚本文件“Animation.ts”中用代码对Animation进行控制了，示例代码如下： const { regClass, property } = Laya; @regClass() export class Animation extends Laya.Script { //declare owner : Laya.Sprite3D; @property({ type: Laya.Animation }) //在IDE面板中显示属性 ani: Laya.Animation; constructor() { super(); } //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { this.ani.source = \"resources/role.atlas\"; //接收动画数据源为图集 this.ani.autoPlay = true; //开启自动播放 this.ani.wrapMode = 0; //播放模式为正序播放模式（POSITIVE） this.ani.interval = 50; //动画播放的帧间隔时间为50毫秒 } } 运行效果如动图2-16所示： （动图2-16） 3. 代码创建Animation 有时，不想让动画节点一开始就在舞台上，而是在要用的时候才添加，这就要通过代码来创建了。在Scene2D的属性设置面板中，增加一个自定义的组件脚本，在代码中创建Animation。示例代码如下： const { regClass, property } = Laya; @regClass() export class UI_Animation extends Laya.Script { //declare owner : Laya.Sprite3D; constructor() { super(); } //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { this.setup(); } private setup(): void { var Animation: Laya.Animation = new Laya.Animation(); Animation.pos(200, 200); //设置节点位置 Animation.source = \"resources/role.atlas\"; //接收动画数据源为图集 Animation.size(600, 275); //设置节点大小 Animation.interval = 100; //动画播放的帧间隔时间为100毫秒 Animation.autoPlay = true; //开启自动播放 Animation.wrapMode = 2; //播放模式为pingpong播放模式（PINGPONG） this.owner.addChild(Animation) //添加节点 } } 效果如动图3-1所示： （动图3-1） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-05-16 20:26:42 "},"2D/displayObject/Text/readme.html":{"url":"2D/displayObject/Text/readme.html","title":"基础文本","keywords":"","body":"基础文本Text1. LayaAir IDE中使用Text1.1 创建Text1.2 属性介绍1.3 Syntax属性1.4 脚本控制Text2. 代码创建Text基础文本Text Text继承于Sprite，是静态文本的基础组件。这里我们介绍一下Text专属的组件属性。 1. LayaAir IDE中使用Text 1.1 创建Text 如图1-1所示，可以在层级窗口中右键进行创建，也可以从小部件窗口中拖拽添加。 （图1-1） 1.2 属性介绍 在IDE中，我们将Text组件添加到场景编辑的视图区后，属性面板中Text组件的专属属性如下图所示： （图1-2） 下面我们分别对这些属性进行介绍说明： 属性名 属性说明 text 文本的实际内容 font 文本字体，例如：Microsoft YaHei，这里可以手动输入常用的字体 fontSize 文本字体大小，例如： 50，直接填写正整数 color 文本的颜色，可以直接输入颜色值，例如：#ffffff，也可以点击输入条右侧的拾色器选取颜色 style “B”(bold)是否为粗体，“I”(italic)是否为斜体，“U”是否有下划线 syntax 多样式混排，支持部分HTML语法和UBB语法。还可以勾选模版，能够在字符串中使用变量。 align 对齐方式，水平对齐(align)分别是left（居左对齐）、center（居中对齐）、right（居右对齐）;垂直对齐(valign)分别是top（居顶对齐）、middle（居中对齐）、bottom（居底对齐） bgColor 背景颜色，勾选后可以直接输入颜色值，例如：#ffffff，也可以点击输入条右侧的拾色器选取颜色 borderColor 文本边框颜色，勾选后可以直接输入颜色值，例如：#ffffff，也可以点击输入条右侧的拾色器选取颜色 overflow 文本溢出处理，共有三种模式。visible（默认模式）：不进行任何裁切。hidden:不显示超出文本域的字符。scroll:不显示文本域外的字符像素，并且支持scroll接口 wordWrap 是否自动换行，布尔值选项，默认为false，选择true可以开启自动换行 leading 垂直行间距，当开启自动换行时，文本内容多行时有效。间距以像素为单位，输入正整数即可 padding 文本边距，以像素为单位，由4个整数值组成。“U”表示距上边框的距离、”R“表示距右边框的距离、”D“表示距下边框的距离、”L”表示距左边框的距离 underlineColor 下划线颜色，可以直接输入颜色值，例如：#ffffff，也可以点击输入条右侧的拾色器选取颜色 stroke 描边宽度，范围为0~100 strokecolor 描边颜色，可以直接输入颜色值，例如：#ffffff，也可以点击输入条右侧的拾色器选取颜色 以上属性都比较容易理解，开发者只需调整参数便可在IDE中看到对应的效果。以下只详细介绍一下“syntax”属性。 1.3 Syntax属性 1.3.1 HTML和UBB 如果勾选HTML，则支持部分HTML语法；如果勾选UBB，则支持UBB语法，UBB语法比HTML更简洁一点；如果两个都勾选，则两种语法都支持。 支持的UBB语法如下表所示： 语法结构 示例代码 语句说明 [img]image_url[/img] [img]atlas/comp/image.png[/img] 显示一张图片 [url=link_href]text[/url] [url='www.layabox.com']蓝亚盒子[/url] 显示一个超级链接 [b]text[/b] [b]这些字是粗体[/b] 设置文本为粗体 [i]text[/i] [i]这些字是斜体[/i] 设置文件为斜体 [u]text[/u] [u]这些字有下划线[/u] 设置文本下划线 [color=#FFFFFF]text[/color] [color=#FF0000]这是红色的字[/color] 设置文本颜色 [size=10]text[/size] [size=60]这是字体大小为60的字[/size] 设置文本的字体大小 UBB支持标签之间的嵌套，可以将上表中多个标签嵌套使用，例如，[color=#FF0000][size=60]红色且大小为60的字[/size] [/color]。 支持的HTML语法如下表所示： 语法结构 示例代码 语句说明 Text 这是粗体字 定义粗体字 Text 这是斜体字 定义斜体字 Text 这是下划线文本 定义下划线 Text1 Text2 Text3 苹果 香蕉 橘子 定义列表 显示一张图片，还可以使用百分比指定图片的大小 link text 蓝亚盒子 显示一个超级链接 Text 文本的最外层 div容器标签 Text 多个span之间不会自动换行，除非是达到了宽度限制 行内元素 Text 多个p标签之间会自动换行，每个完整的p标签是一个单独的段落 段落 Text1Text2 换行后面的就换行了 换行 &nbsp; 这里&nbsp;空一格 空格 下面来看一个具体的例子，如图1-3所示，勾选HTML和UBB后，就可以在Text属性中输入符合语法的语句： （图1-3） Text中输入的示例语句如下： [url='www.layabox.com']蓝亚盒子[/url] [size=60]text[/size] [color=#FF0000]text[/color] [u]text[/u] [color=#FF0000][size=60]text[/size][/color] 上述这6条语句分别对应图1-3所示的6种效果：加载图片、显示链接、字体大小为60、字体颜色为红色、下划线、嵌套（大小和颜色）。每条语句之间可以不空行，示例中有空行是为了方便观察效果。 1.3.2 模版 “syntax”属性还可以勾选模版选项，勾选后，就可以在字符串中使用变量了。比如，在Text属性中输入Text{n=100}，效果如图1-4所示： （图1-4） 变量n还可以是字符串，例如，输入Text{n=你好},显示的效果就是图1-5所示的了。当然，这个变量不一定必须是n，开发者可以自定义变量名。 （图1-5） 还可以在代码中使用setVar方法动态调节变量n，可以结合1.3节的脚本控制，在脚本中输入如下代码： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { //declare owner : Laya.Sprite3D; @property({ type: Laya.Text }) txt: Laya.Text; constructor() { super(); } onAwake(): void { this.txt.text = \"第{n=1}页\"; //显示文本的初始化内容 } onStart(): void { let page: number = 1; Laya.timer.frameLoop(10, this, () => { page += 1; //在定时器中让变量page每次自增1 this.txt.setVar(\"n\", page); //使用setVar方法，让text文本中变量n的值动态改变 }); } } 效果如动图1-6所示： （动图1-6） 注：变量n还可以是从.json文件中获取的文本，开发者可以自己写一个.json文件，然后在脚本中进行加载，最后利用setVar方法赋值给变量n。 在游戏中比较常用的情况就是，如图1-7所示，当每个玩家进入游戏，都会遇到一段对白，只有不同玩家的角色名称不同。那么，采用文本模板功能之后，无需再去整体修改文本，直接改变文本模板中的变量即可。让局部文本的动态改变更加易用。 （图1-7） 1.4 脚本控制Text 在Scene2D的属性设置面板中，增加一个自定义组件脚本。然后，将Text拖入到其暴露的属性入口中。下面给出一个示例代码，实现脚本控制Text： const { regClass, property } = Laya; @regClass() export class TextControl extends Laya.Script { //declare owner : Laya.Sprite3D; @property( { type : Laya.Text } ) public txt: Laya.Text; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { this.txt.pos(Laya.stage.width >> 1, Laya.stage.height >> 1); //位置 this.txt.size(500, 30); //大小 this.txt.pivot(this.txt.width/2, this.txt.height/2); //轴心点 this.txt.text = \"大家好，欢迎各位开发者使用LayaAir IDE，这里是Text的文本内容，您可以基于此文本进行调试\"; //文本内容 this.txt.font = \"宋体\"; //字体 this.txt.fontSize = 50; //字体大小 this.txt.color = \"#ff0000\"; //字体颜色 this.txt.bold = true; //加粗 this.txt.italic = true; //斜体 this.txt.underline = true; //下划线 this.txt.underlineColor = \"#ff0000\"; //下划线颜色 this.txt.stroke = 5; //描边宽度 this.txt.strokeColor = \"#000000\" ; //描边颜色 this.txt.wordWrap = true; //自动换行 this.txt.leading = 20; //垂直行间距 // this.txt.padding = [10, 10, 10, 10]; //文本边距 this.txt.align = \"center\"; //水平对齐方式 this.txt.valign = \"top\"; //垂直对齐方式 this.txt.overflow = \"visible\"; //文本溢出 } } 2. 代码创建Text 有时，不想让Text节点一开始就在舞台上，而是在要用的时候才添加，这就要通过代码来创建了。在Scene2D的属性设置面板中，增加一个自定义组件脚本，示例代码如下： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { //declare owner : Laya.Sprite3D; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { let txt = new Laya.Text(); // 添加到舞台 Laya.stage.addChild(txt); txt.pos(Laya.stage.width >> 1, Laya.stage.height >> 1); //位置 txt.size(500, 30); //大小 txt.pivot(txt.width/2, txt.height/2); //轴心点 txt.text = \"大家好，欢迎各位开发者使用LayaAir IDE，这里是Text的文本内容，本方法是代码创建Text\"; //文本内容 txt.wordWrap = true; //自动换行 } } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-06-07 20:45:33 "},"IDE/uiEditor/uiComponent/readme.html":{"url":"IDE/uiEditor/uiComponent/readme.html","title":"UI组件详解","keywords":"","body":"UI组件详解一、什么是UI组件1.1 基础UI组件1.2 容器组件二、UI组件的创建2.1 直接使用组件2.2 右键菜单2.3 通过组件资源命名规则，直接被IDE识别2.4 容器组件的创建与解除三、UI组件详解UI组件详解 Author: Charley UI组件是2D编辑中的基础组件，我们日常开发的2D UI界面的编辑，都是基于UI组件。 一、什么是UI组件 从引擎类的结构上看，UIComponent类是UI组件的基类，也就是说UI组件有一个共性，都是继承于UIComponent类而实现的组件。 UI组件，又分成基础UI组件和容器UI组件。比较容易理解和识别的方式为，Box和继承于Box的都属于容器类组件。其它的都是基础UI组件。 1.1 基础UI组件 基础UI组件显示对象，一共有16个，直接或间接继承于UIComponent，如图1的高亮部分所示。 （图1） 1.2 容器组件 继承于Box的组件，加上Box容器本身，容器对象一共有9个。如图2的高亮部分所示。 (图2) 这些容器单单自己是没有意义的，必须要包括基础的UI组件作为子节点，才能使得组件功能完整。 例如，List必须要有基础UI组件作为列表的渲染单元，单选框组（RadioGroup）是多个单选框（Radio）组件的容器。 二、UI组件的创建 UI组件的创建有三种方式：分别是从UI小部件（Widgets）面板里拖拽UI组件使用、从层级管理（Hierarchy）面板的右键菜单里创建、通过组件资源命名规则为资源命名，然后直接被IDE识别。 2.1 直接使用组件 UI小部件（Widgets）面板里包括了基础节点，也包括了UI组件，使用时直接拖拽到层级面板或场景编辑窗口内即可。效果如动图3所示。 (动图3) 2.2 右键菜单 层级管理（Hierarchy）面板的2D节点下，右键菜单里也可以直接创建UI组件，效果如图4所示。 (图4) 2.3 通过组件资源命名规则，直接被IDE识别 对于一些常用的UI组件，LayaAir引擎与IDE，提供了资源命名的规则。 当图像资源文件按照LayaAir引擎UI组件命名规则命名时，会直接被IDE识别为基础UI组件。 组件资源的命名有两类， 一类是，一个资源就对应一个UI组件的常规资源，例如，img_layabox.png，会被识别为Image组件。 另一类是，多个资源对应一个UI组件的组合资源，例如，progress_loading.png与progress_loading$bar.png组合形成一个progress组件，progress_loading.png为组件名是进度条的背景资源，另一个在progress_loading后面带了一个$bar的是进度条的进度资源。 总结以上，我们会发现两点规律： 无论是哪种资源，下划线_之前是组件规则名称，并且必须要放到文件名的开头。 组合资源，在主资源名称的后面，再通过美元符号$相隔，带一个辅助标识名，方便IDE与引擎识别。 常规资源命名规则如下： 组件名 中文组件名 资源文件名前缀 资源文件名前缀缩写 Image 图像 image_ img_ Button 按钮 button_ btn_ ComboBox 下拉框 comboBox_ combo_ TextInput 文本输入 textInput_ input_ TextArea 文本域 textArea_ area_ CheckBox 多选框 checkBox_ check_ Label 显示文本 label_ 无缩写 RadioGroup 单选框 radioGroup_ 无缩写 Radio 单选框组 radio_ 无缩写 Tab 导航标签组 tab_ 无缩写 Clip 位图切片 clip_ 无缩写 FontClip 位图字体切片 fontClip_ 无缩写 资源前缀不区分大小写 组合资源命名规则如下： 组件名 中文组件名 资源文件名前缀 资源文件名前缀缩写 辅助标识名 VScrollBar 垂直滚动条 vscrollbar_ vscroll_ 垂直划动条$bar、上点击按钮$up 、下点击按钮$down HScrollBar 水平滚动条 hscrollbar_ hscroll_ 水平划动条$bar、左点击按钮$up 、右点击按钮$down ProgressBar 进度条 progressbar_ progress_ 进度条$bar VSlider 垂直划动条 vslider_ 无缩写 垂直划动按钮$bar HSlider 水平划动条 hslider_ 无缩写 水平划动按钮$bar 资源前缀不区分大小写 示例说明： 垂直滚动条aa，由四个资源文件构成。分别是vscroll_aa.png、vscroll_aa$bar.png、vscroll_aa$up.png、vscroll_aa$down.png。 进度条bb，由两个资源文件构成。分别是progress_bb.png、progress_bb$bar.png。 2.4 容器组件的创建与解除 了解完资源命名规则后发现，除了继承于UI组(UIGroup)的RadioGroup与Tab组件，是可以通过资源前缀规则命名识别的。其它的容器组件均不支持通过资源名称直接识别创建。 除了采用2.1与2.2的方式创建外，还可以在IDE里将一个或多个选中的基础组件通过Ctrl+B快捷键转化为容器组件。如果不想要容器组件了，也可以通过Ctrl+U解除当前选中的容器。 此处有个印象即可，在介绍具体的容器组件时，还会详细描述创建方法与流程。 三、UI组件详解 至此，我们对UI组件已有了基础的了解，我们将开始对全部的UI组件进行详细介绍。 为避免文档的标题过长，对UI组件根据使用的特点进行分类介绍，并不按组件类的继承关系。 在阅读顺序上，如果是首次接触LayaAir引擎的开发者，一定要阅读图像组件，因为在这里不仅会介绍Image特有的属性，还会介绍UI组件基类UIComponent的属性，以及介绍UIComponent父类Sprite的属性。 在其它的UI组件里，这些基础和通用的属性，将不再重复介绍。 下面，通过左侧导航点开UI组件文档了解更多吧~ Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-05-11 21:27:15 "},"IDE/uiEditor/uiComponent/Image/readme.html":{"url":"IDE/uiEditor/uiComponent/Image/readme.html","title":"图像组件","keywords":"","body":"Image 组件参考一、通过LayaAirIDE创建Image组件1.1 创建image1.2 Image 组件的常用属性二、通过代码创建Image组件Image 组件参考 一、通过LayaAirIDE创建Image组件 1.1 创建image Image 是 UI 里最常见的显示图像的组件，用来显示位图图像。可以设置 Image 组件的 skin 属性来改变 Image 组件呈现的图像。Image 组件支持九宫格数据设定，用于实现图像放大后图像显示不失真的效果。 点击资源面板里的 Image 组件，拖放到页面编辑区，即可添加 Image组件到页面上。单击选中 Image ，可以在属性面板里设置 Image 的常用属性的值。 Image 组件的脚本接口请参考 Image API。 Image 组件的资源示例： ​ ​ （图1） Image 组件拖放到编辑区后显示效果： (图2) 1.2 Image 组件的常用属性 （图3） 属性 功能说明 sizeGrid 位图的有效缩放网格数据（九宫格数据）。 skin 位图的资源。 Group 加载分组，设置后可以按组管理资源。 添加 Image 组件之后，可以通过从资源面板中拖拽图片资源到 Image 的 skin 属性框，来修改 Image 组件的显示资源图像。 二、通过代码创建Image组件 在我们进行书写代码的时候，免不了通过代码控制UI，创建UI_Image类，通过代码设定Image相关的属性。 运行示例效果: ​ ​ (图4)通过代码创建Image Image的其他属性也可以通过代码来设置，下述示例代码演示了如何通过代码创建不同皮肤（样式）的Image，有兴趣的读者可以自己通过代码设置Image，创建出符合自己需要的图片。 示例代码： const { regClass, property } = Laya; @regClass() export class UI_Image extends Laya.Script { constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { this.setup(); } private setup(): void { var dialog: Laya.Image = new Laya.Image(\"resources/res/ui/dialog (3).png\"); dialog.pos(165, 62.5); this.owner.addChild(dialog); } } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-24 14:53:15 "},"IDE/uiEditor/uiComponent/Label/readme.html":{"url":"IDE/uiEditor/uiComponent/Label/readme.html","title":"显示文本组件","keywords":"","body":"Label 组件参考一、通过LayaAirIDE创建Label组件1.1 创建Label1.2 Label 属性二、通过代码创建Label组件Label 组件参考 一、通过LayaAirIDE创建Label组件 1.1 创建Label ​ Label 组件用来显示一段文字，文字可以是系统字体或者 BMFont 字体。 ​ 点击资源面板里的 Label 组件，拖放到页面编辑区，即可添加 Label 组件到页面上。 ​ Label 组件的脚本接口请参考 Label API。 ​ Label 组件的资源示例： ​ ​ （图1） ​ Label组件拖放到编辑区后，设置 text 属性的值为 LayaAir IDE 后的显示效果如下： ​ ​ （图2） 1.2 Label 属性 ​ ​ （图3） 属性 功能说明 text 文本内容字符串。 align 文本的对齐方式。 color 文本的颜色值。默认为黑色。 bgColor 文本背景颜色。 font 文本的字体名称。 fontSize 文本的字体大小。 style 文本是否为粗体字显示。 italic 文本是否显示为斜体。 wordWrap 文本是否换行，默认为false，不可自动换行。 stroke 文本的描边宽度。 strokeColor 文本的描边颜色。 leading 文本的垂直行间距。 padding 文本的边距。 overflow 文本超出文本域后的行为。visible：不进行任何裁剪。hidden：不显示超出文本域后的字符。scroll：不显示文本域外的字符像素，并且支持scroll接口。 bordercolor 文本边框颜色。 underlinecolor 下划线颜色。 二、通过代码创建Label组件 在我们进行书写代码的时候，免不了通过代码控制UI，创建UI_Label类，通过代码设定Label相关的属性。 运行示例效果: ​ ​ (图5) 通过代码创建Label Label的其他属性也可以通过代码来设置，下述示例代码演示了如何通过代码创建不同皮肤（样式）的Label，有兴趣的读者可以自己通过代码设置Label，创建出符合自己需要的文字效果。 更多的文字效果可以去查看2D基础篇中的文本部分。 示例代码： const { regClass, property } = Laya; const Label = Laya.Label; @regClass() export class UI_Label extends Laya.Script { constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { this.setup(); } private setup(): void { this.createLabel(\"#FFFFFF\", null).pos(30, 50); this.createLabel(\"#00FFFF\", null).pos(290, 50); this.createLabel(\"#FFFF00\", \"#FFFFFF\").pos(30, 100); this.createLabel(\"#000000\", \"#FFFFFF\").pos(290, 100); this.createLabel(\"#FFFFFF\", \"#00FFFF\").pos(30, 150); this.createLabel(\"#0080FF\", \"#00FFFF\").pos(290, 150); } private createLabel(color: string, strokeColor: string): Laya.Label { const STROKE_WIDTH: number = 4; var label: Laya.Label = new Label(); label.font = \"Microsoft YaHei\"; label.text = \"SAMPLE DEMO\"; label.fontSize = 30; label.color = color; if (strokeColor) { label.stroke = STROKE_WIDTH; label.strokeColor = strokeColor; } this.owner.addChild(label); return label; } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-24 14:53:15 "},"IDE/uiEditor/uiComponent/TextInput/readme.html":{"url":"IDE/uiEditor/uiComponent/TextInput/readme.html","title":"输入文本组件","keywords":"","body":"TextInput组件介绍1、TextInputAPI参数2、TextInput相关属性：3、Textinput代码创建TextInput组件介绍 1、TextInputAPI参数 文本输入框是游戏中经常会用到的一个UI组件，任何时候需要输入的时候都要使用到textInput这个类，我们先看一下TextInput这个类的API。 laya.ui.textInput中所有的API参数 editable : Boolean 设置可编辑状态。 TextInput focus : Boolean 表示焦点是否在显示对象上。 TextInput height : Number 表示显示对象的高度，以像素为单位。注：当值为0时，高度为自适应大小。 TextInput inputElementXAdjuster:int 设置原生inputs输入框的x坐标偏移。 TextInput inputElementYAdjuster:int 设置原生inputs输入框的y坐标偏移。 TextInput maxChars : int 字符数量限制，默认为100000。设置字符数量限制时，小于等于0的值将会限制字符数量为100000。 TextInput multiline : Boolean 指示当前是否是文本域。值为true表示当前是文本域，否则不是文本域。 TextInput prompt : String 设置输入提示符。 TextInput promptColor : String 设置输入提示符颜色。 TextInput restrict : String 限制输入的字符 TextInput sizeGrid : String 当前实例的背景图(AutoBitmap)实例的有效缩放网格数据。数据格式：\"上边距，右边距，下边距，左边距，是否重复填充（值为0：不重复填充，1：重复填充）\"，以逗号分隔。例如：\"4,4,4,4,1\" TextInput skin : String 对象的皮肤地址，以字符串表示。如果资源未加载，则先加载资源，加载完成后应用于此对象。注意：资源加载完成后，会自动缓存至资源库中。 TextInput type : String 输入框类型为Input静态常量之一。 TextInput width : Number [override]表示显示对象的宽度，以像素为单位。注：当值为0时，宽度为自适应大小。 TextInput 2、TextInput相关属性： （图1） 属性名 功能说明 type 输入框类型，共有十三种类型：text、password、email、url、number、range、date、month、week、time、dateime、dateime—local、search maxchars 最大字符数，默认为100000。 restrict 限制输入的字符，输入到这里的是只能输入这些。不建议开启，适用于简单的文本，不支持反斜杠。 prompt 输入前提示文本。 promptcolor 输入前提示文本的颜色。 editable 设置可编辑状态，默认为true。 multiline 是否是文本域，值为true表示当前是文本域，可多行输入，否则不是文本域。默认为false 3、Textinput代码创建 const { regClass, property } = Laya; @regClass() export class UI_Input extends Laya.Script { private SPACING: number = 100; private INPUT_WIDTH: number = 300; private INPUT_HEIGHT: number = 50; private Y_OFFSET: number = 50; private skins: any[]; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { this.skins = [\"resources/res/ui/input (1).png\", \"resources/res/ui/input (2).png\", \"resources/res/ui/input (3).png\", \"resources/res/ui/input (4).png\"]; Laya.loader.load(this.skins).then( ()=>{ this.onLoadComplete(); } ); } private onLoadComplete(e: any = null): void { for (var i: number = 0; i 运行结果： （图2） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-05-11 21:27:15 "},"IDE/uiEditor/uiComponent/TextArea/readme.html":{"url":"IDE/uiEditor/uiComponent/TextArea/readme.html","title":"多行输入文本组件","keywords":"","body":"TextArea组件详解1、创建TextArea组件2、TextArea组件属性介绍3、通过代码创建TextAreaTextArea组件详解 由于TextArea继承于Textinput，两者相同点太多这篇文章只介绍两者不同的地方，Textinput介绍到的点这里不再过多讲解。 1、创建TextArea组件 使用LayaAirIDE创建TextArea非常简单，通过IDE的可视化操作，完全不需要程序基础，即可实现组件的创建与布局，也是推荐使用的组件创建方式。可以从层级面板创建，步骤是右键单击Scene2D，找到UI，点击TextArea即可创建完毕，如图1所示。 （图1） 我们也可以从IDE资源管理右侧组件面板的UI文件夹中，将TextArea组件拖拽到UI页面中，如动图2所示。 （动图2） 2、TextArea组件属性介绍 （图3） 属性 功能说明 vscrollbarskin 添加垂直滚动条皮肤。 hscrollbarskin 添加水平滚动条皮肤。 scrolltype 文本域的滚动类型，需要配合对应的滚动条皮肤使用，共有四种类型，默认不滚动。none：不滚动，horizontal：水平滚动，vertical：垂直滚动，both：水平滚动和垂直滚动都支持。 TextArea是一个用于多行的文本域，相较于Textinput的区别是它可以添加垂直滚动条皮肤和水平滚动条皮肤。效果如动图4、5所示。 （动图4） （动图5） 3、通过代码创建TextArea const { regClass, property } = Laya; @regClass() export class UI_TextArea extends Laya.Script { private skin: string = \"resources/res/ui/textarea.png\"; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { Laya.loader.load(this.skin).then( ()=>{ this.onLoadComplete(); } ); } private onLoadComplete(e: any = null): void { let ta: Laya.TextArea = new Laya.TextArea(\"\"); ta.skin = this.skin; ta.font = \"Arial\"; ta.fontSize = 18; ta.bold = true; ta.color = \"#3d3d3d\"; ta.pos(100, 15); ta.size(375, 355); ta.padding = \"70,8,8,8\"; this.owner.addChild(ta); } } 运行结果： Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-04-18 21:03:42 "},"IDE/uiEditor/uiComponent/Clip/readme.html":{"url":"IDE/uiEditor/uiComponent/Clip/readme.html","title":"位图切片组件","keywords":"","body":"Clip 组件参考一、通过LayaAirIDE创建Clip组件1.1 创建Clip1.2 Clip 组件的常用属性二、通过代码创建Clip组件Clip 组件参考 一、通过LayaAirIDE创建Clip组件 1.1 创建Clip Clip 组件可用于显示位图切片动画。Clip 可以将一张图片，按横向分隔数量 ClipX、竖向分隔数量 ClipY，或横向分割每个切片的宽度 ClipWidth、竖向分割每个切片的高度 ClipHeight，从左向右，从上到下，分割组合为一个切片动画。 Clip 组件可以用来播放切片动画，和显示切片动画的某一帧图片。 点击资源面板里的 Clip 组件，拖放到页面编辑区，即可添加 Tab 组件到页面上。 Clip 的脚本接口参考Clip API Clip 组件的资源示例： （图1） ​ 设置 ClipX 属性的值为10后的显示效果： ​ ​ （图2） ​ 设置 index 属性的值为 1后的显示效果： ​ ​ （图3） 1.2 Clip 组件的常用属性 ​ ​ （图4） 属性 功能说明 autoPlay 布尔值，表示是否自动播放当前切片动画。 clipWidth 横向分割图片资源时，每个切片的宽度。 clipHeight 纵向分割图片资源时，每个切片的高度。 clipX 横向分割图片资源时，等宽切割的份数。 clipY 纵向分割图片资源时，等高切割的份数。 index 切片动画当前显示动画帧索引。 interval 切片动画的播放时间间隔。 sizeGrid 图像资源的有效网格数据（九宫格数据）。 skin 选项卡按钮图像资源。 二、通过代码创建Clip组件 在我们进行书写代码的时候，免不了通过代码控制UI，创建UI_Clip类，通过代码设定Clip相关的属性。 运行示例效果: ​ ​ (图5)通过代码创建计数器 ​ ​ (图6) ​ Clip的其他属性也可以通过代码来设置，上述示例演示了如何通过计时器获取每一秒更新clip.clipX切片，通过每秒更新数字实现计时器的功能，有兴趣的读者可以自己通过代码设置Clip，创建出符合自己项目中需要的Clip。 注：需要将图片资源预乘Alpha 示例代码： const { regClass, property } = Laya; @regClass() export class UI_Clip extends Laya.Script { private buttonSkin: string = \"resources/res/ui/button-7.png\"; private clipSkin: string = \"resources/res/ui/num0-9.png\"; private bgSkin: string = \"resources/res/ui/coutDown.png\"; pageHeight: any; pageWidth: any; counter: any; controller: any; currFrame: any; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { Laya.loader.load([this.buttonSkin, this.clipSkin, this.bgSkin]).then( ()=>{ this.onSkinLoaded(); } ); } private onSkinLoaded(e: any = null): void { this.showBg(); this.createTimerAnimation(); this.showTotalSeconds(); this.createController(); } private showBg(): void { var bg: Laya.Image = new Laya.Image(this.bgSkin); bg.size(200, 200); bg.pos(Laya.stage.width - bg.width >> 1, Laya.stage.height - bg.height >> 1); this.owner.addChild(bg); } private createTimerAnimation(): void { this.counter = new Laya.Clip(this.clipSkin, 10, 1); this.counter.autoPlay = true; this.counter.interval = 1000; this.counter.x = (Laya.stage.width - this.counter.width) / 2 - 35; this.counter.y = (Laya.stage.height - this.counter.height) / 2 - 40; this.owner.addChild(this.counter); } private showTotalSeconds(): void { var clip: Laya.Clip = new Laya.Clip(this.clipSkin, 10, 1); clip.index = clip.clipX - 1; clip.pos(this.counter.x + 60, this.counter.y); this.owner.addChild(clip); } private createController(): void { this.controller = new Laya.Button(this.buttonSkin, \"暂停\"); this.controller.labelBold = true; this.controller.labelColors = \"#FFFFFF,#FFFFFF,#FFFFFF,#FFFFFF\"; this.controller.size(84, 30); this.controller.on('click', this, this.onClipSwitchState); this.controller.x = (Laya.stage.width - this.controller.width) / 2; this.controller.y = (Laya.stage.height - this.controller.height) / 2 + 110; this.owner.addChild(this.controller); } private onClipSwitchState(e: any = null): void { if (this.counter.isPlaying) { this.counter.stop(); this.currFrame = this.counter.index; this.controller.label = \"播放\"; } else { this.counter.play(); this.counter.index = this.currFrame; this.controller.label = \"暂停\"; } } } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-24 14:53:15 "},"IDE/uiEditor/uiComponent/FontClip/readme.html":{"url":"IDE/uiEditor/uiComponent/FontClip/readme.html","title":"字体切片组件","keywords":"","body":"FontClip组件参考1、创建Fontclip2、Fontclip属性介绍2.1 Fontclip sheet和value属性使用方法2.2 Fontclip SpaceX和SpaceY属性使用方法3、Fontclip代码创建FontClip组件参考 FontClip组件本质上是对位图从方向上进行等比切割，FontClip继承于Clip。 1、创建Fontclip 创建Fontclip非常简单，通过IDE的可视化操作，只需要用鼠标就可以实现。右键单击Scence2D，找到UI，点击FontClip即可创建成功。如图1所示。 （图1） 我们也可以从IDE资源管理右侧组件面板的UI文件夹中，将FontClip组件拖拽到UI页面中，如动图2所示。 （动图2） 2、Fontclip属性介绍 （图3） 属性 功能说明 sheet 位图内容范围，位图内容在有换行时需要在换行的位置添加空格。 value 位图数字内容。 align 水平对齐方式，共有三种方式。left：居左对齐，center：居中对齐，right：居右对齐。 spacex X方向间隔，以像素为单位。 spacey Y方向间隔，以像素为单位。 direction 位图内容排列方向，共有两个选项。horizontal：水平方向排列，vertical：垂直方向排列。 FontClip相比于Clip更适用于字体切片，所以叫FontClip。FontClip在游戏中比Clip用的更多更广，FontClip也是我们推荐使用的，一些特殊的文本或者字体就会用到FontClip。 2.1 Fontclip sheet和value属性使用方法 Fontclip如果位图内容是图形的话，可以将其当成数字，按索引处理。 演示一下sheet属性的使用方法，按照位图内容填上对应的字符，在value中输入想要显示的内容就可以将其显示出来如动图4所示。 （动图4） sheet就相当于一个位图切片样板，value会直接对比sheet中的内容，取值非常方便和灵活。 2.2 Fontclip SpaceX和SpaceY属性使用方法 SpaceX用来调节X方向的间隔，需要配合Direction来使用，如图5所示。 （图5） SpaceY用来调节Y方向的间隔，需要配合Direction来使用，如图6所示。 （图6） 3、Fontclip代码创建 代码运行示例： const { regClass, property } = Laya; @regClass() export class UI_FontClip extends Laya.Script { private TestClipNum: string = \"resources/res/comp/fontClip_num.png\"; private _ClipNum: string = \"resources/res/comp/fontClip_num.png\"; private _ClipNum1: string = \"resources/res/comp/fontClip_num.png\"; private TestFontClip: string = \"resources/res/comp/fontClip.png\"; private _FontClip: string = \"resources/res/comp/fontClip.png\"; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { Laya.loader.load([this.TestClipNum, this.TestFontClip, this._ClipNum, this._FontClip, this._ClipNum1]).then( ()=>{ this.ShowContent(); } ); } private ShowContent(): void { var clipnum: Laya.FontClip = new Laya.FontClip(this._ClipNum); var fontClip: Laya.FontClip = new Laya.FontClip(this._FontClip); var testFontClip: Laya.FontClip = new Laya.FontClip(this.TestFontClip); var testClipNum: Laya.FontClip = new Laya.FontClip(this.TestClipNum); var clipnum1: Laya.FontClip = new Laya.FontClip(this._ClipNum1); clipnum.pos(240, 400); clipnum.size(250, 50); clipnum.sheet = \"0123456789\"; clipnum.value = \"114499\"; clipnum.spaceY = 10; testClipNum.pos(200, 300); testClipNum.sheet = \"0123456789\"; testClipNum.value = \"0123456789\"; clipnum1.pos(150, 100); clipnum1.direction = \"vertical\"; clipnum1.sheet = \"0123456789\"; clipnum1.value = \"223388\"; fontClip.pos(240, 200); fontClip.sheet = \"鼠牛虎兔龙蛇马羊 猴鸡狗猪年快乐\"; fontClip.value = \"猪年快乐\"; fontClip.spaceY = 10; testFontClip.pos(200, 100); testFontClip.sheet = \"鼠牛虎兔龙蛇马羊猴鸡狗猪年快乐\"; testFontClip.value = \"鼠牛虎兔龙蛇马羊猴鸡狗猪年快乐\"; testFontClip.spaceY = 10; this.owner.addChild(clipnum); this.owner.addChild(fontClip); this.owner.addChild(testFontClip); this.owner.addChild(testClipNum); this.owner.addChild(clipnum1); } } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-04-18 21:03:42 "},"IDE/uiEditor/uiComponent/Button/readme.html":{"url":"IDE/uiEditor/uiComponent/Button/readme.html","title":"按钮组件","keywords":"","body":"Button 组件详解1、创建Button组件1.1用引擎直接创建Button组件1.2.使用LayaAirIDE创建Button2、Button组件的属性介绍2.1 按钮皮肤（skin）2.2 指定按钮皮肤的切割状态（stateNum）2.3 指定按钮选中状态(selected)2.4 是否切换按钮的显示状态（toggle）2.5 根据状态设置Button的描边文本颜色（StrokeColor）Button 组件详解 1、创建Button组件 按钮（Button）组件是最常用的组件之一，可以显示文本标签、图标或者两者同时显示。在LayaAirIDE里的按钮图片资源（按钮皮肤）命名通常是以btn为前缀，如图1所示。 （图1） 1.1用引擎直接创建Button组件 使用LayaAir引擎创建一个Button组件比较简单，通常只需要几个步骤，加载资源，创建一个Button实例，将Button添加到当前场景上，设置Button组件的属性。具体实现参考下面的代码与注释。 编写如下代码： const { regClass, property } = Laya; @regClass() export class UI_Button extends Laya.Script { constructor() { super(); } private COLUMNS: number = 2; private BUTTON_WIDTH: number = 147; private BUTTON_HEIGHT: number = 165 / 3; private HORIZONTAL_SPACING: number = 200; private VERTICAL_SPACING: number = 100; private xOffset: number; private yOffset: number; private skins: any[]; /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { this.skins = [\"resources/res/ui/button-1.png\", \"resources/res/ui/button-2.png\", \"resources/res/ui/button-3.png\", \"resources/res/ui/button-4.png\", \"resources/res/ui/button-5.png\", \"resources/res/ui/button-6.png\"]; // 计算将Button至于舞台中心的偏移量 this.xOffset = (Laya.stage.width - this.HORIZONTAL_SPACING * (this.COLUMNS - 1) - this.BUTTON_WIDTH) / 2; this.yOffset = (Laya.stage.height - this.VERTICAL_SPACING * (this.skins.length / this.COLUMNS - 1) - this.BUTTON_HEIGHT) / 2; Laya.loader.load(this.skins).then( ()=>{ this.onUIAssetsLoaded(); } ); } private onUIAssetsLoaded(e: any = null): void { for (var i: number = 0, len: number = this.skins.length; i 上述代码运行效果如动图2所示： (动图2) Tips: Button 组件的属性接口介绍请参考 Button API。 1.2.使用LayaAirIDE创建Button 使用LayaAirIDE创建Button更加简单，通过IDE的可视化操作，完全不需要程序基础，即可实现组件的创建与布局，也是推荐使用的组件创建方式。 第一步：鼠标右键单击Scene2D，然后找到UI，鼠标左键点击Button，如图3所示。 （ 图3） 第二步：设置组件属性，如图4所示 (图4) 设置完上面的两步后，直接就可以在IDE中看到如动图2的效果。在这个过程不需要任何程序编码，完全可以交给美术或策划实现。从而减少了与程序员的沟通成本，加快了游戏的开发效率。 2、Button组件的属性介绍 下面的文档，将围绕Button组件的基础常用属性以及通过文字难以理解的属性给予重点介绍。而对比较容易理解的属性，本文将不会提及，开发者可以将鼠标放到IDE属性管理器的属性名上停留，将会出现属性的Tips中文说明。 2.1 按钮皮肤（skin） 按钮的皮肤因切割方式不同，分成三态，两态、单态。这里的态指的是按钮皮肤（skin）的状态。 三态是将皮肤图片按竖直方向以等比分割的形式分为3部分，如图1所示，从上至下依次为弹起或离开状态皮肤、 经过状态皮肤、 按下和选中（保持按下）状态皮肤，三态常用于PC浏览器中。 在移动设备上，通常只采用两态，图片以竖直方向被等比切割为两部分，上面的部分为弹起或离开状态状态皮肤，下面的部分为 经过和按下以及选中状态（保持按下）皮肤。 单态按钮不切割图片，无论什么状态，按钮的皮肤只有一种，保持不变。 2.2 指定按钮皮肤的切割状态（stateNum） stateNum的属性值决定皮肤资源图片的切割方式。默认值为3，也就是说默认按3态按钮进行切割，等比分割为3部分。如果是两态按钮，需要将stateNum的属性值设为2，等比切割为2部分。单态按钮设置为1，不进行切割。 这里需要注意的是，指定按钮状态，需要与按钮皮肤对应好。如果是三态的按钮皮肤，stateNum设置为2，切割后如图5所示，是错误的。 (图5) 2.3 指定按钮选中状态(selected) selected属性默认为未选中的false状态。一旦我们将selected属性设置为true。那按钮将会一直保持选中（持续按下）的状态，而不会再对其它状态产生变化（除非代码中进行状态改变）。 2.4 是否切换按钮的显示状态（toggle） toggle属性默认为未选中的false状态。一旦我们将toggle属性设置为true。当点击按钮组件后，按钮会保持在选中（持续按下）状态。再次点击可以还原。 2.5 根据状态设置Button的描边文本颜色（StrokeColor） labelStrokeColor可以为Button的文本描边设置一个统一的颜色（不同状态的颜色一致）。而StrokeColor属性可以根据不同的状态设置Button的描边文本颜色。 StrokeColor颜色的先后设置顺序为格式: upColor（弹起或离开状态状态的颜色）,overColor（经过状态的颜色）,downColor（按下和选中状态的颜色）,disableColor（被禁止使用时的颜色）。如图6所示。 (图6) Tips:如果想要更清晰的感受描边颜色的变化，可以将描边宽度labelStroke属性值设置大一些。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-24 14:53:15 "},"IDE/uiEditor/uiComponent/scroll/readme.html":{"url":"IDE/uiEditor/uiComponent/scroll/readme.html","title":"滚动条组件","keywords":"","body":"滚动条组件滚动条组件 滚动条组件主要包括水平滚动条与垂直滚动条组件 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:53 "},"IDE/uiEditor/uiComponent/HScrollBar/readme.html":{"url":"IDE/uiEditor/uiComponent/HScrollBar/readme.html","title":"水平滚动条组件","keywords":"","body":"HScrollBar 组件参考一、通过LayaAirIDE创建HScrollBar组件1.1创建HscrollBar1.2 HScrollBar 组件常用属性二、通过代码创建HScrollBar组件HScrollBar 组件参考 一、通过LayaAirIDE创建HScrollBar组件 1.1创建HscrollBar ​ HScrollBar 组件是一个水平方向滚动条组件。 ​ 当数据太多以至于显示区域无法容纳时，最终用户可以使用 HScrollBar 组件控制所显示的数据部分。 ​ 滚动条由四部分组成：一个轨道图、一个滑块按钮和两个箭头按钮。 ​ 点击选择资源面板里的 HScrollBar 组件，拖放到页面编辑区，即可添加 HScrollBar 组件到页面上。 ​ HScrollBar 组件的脚本接口请参考 HScrollBar API。 ​ HScrollBar 组件的图像资源示例： ​ ​ （图1） ​ ​ （图2） ​ ​ （图3） ​ ​ （图4） ​ HScrollBar 拖放到编辑器区后，显示效果： ​ ​ （图5） ​ 设置 HScrollBar 的属性 max 的值为 10、属性 min 的值为0、属性 value 的值为3后，显示效果如下： ​ ​ （图6） ​ 在程序中运行时，可以拖动滑块或点击箭头按钮控制进度条的值： ​ ​ （图7） ​ 设置 HScrollBar 的属性 showButtons 的值为 false时的显示效果： ​ ​ （图8） ​ 在程序里运行时的效果： ​ ​ （图9） 1.2 HScrollBar 组件常用属性 ​ ​ （图10） 属性 功能说明 skin 滚动条的图像资源地址。 sizeGrid 滚动条轨道图资源的有效缩放网格数据（九宫格数据）。 value 表示当前滚动位置的数字。 min 表示最低滚动位置的数字。 max 表示最高滚动位置的数字。 scrollSize 表示按下滚动条轨道时页面滚动的增量。 mouseWheelEnable 一个布尔值，指定是否滑轮滚动，默认值为true。 touchScrollEnable 一个布尔值，指定是否开启触摸，默认值为true。 autoHide 一个布尔值，指定是否自动隐藏滚动条(无需滚动时)，默认值为false。 showButtons 一个布尔值，指定是否显示向上、向下按钮，默认值为true。 rollratio 滚动衰减系数，默认为0.95。 二、通过代码创建HScrollBar组件 ​ 在我们进行书写代码的时候，免不了通过代码控制UI，创建UI_ScrollBar类，通过代码设定HScrollBar相关的属性。 运行示例效果: ​ ​ (图11) 通过代码创建HScrollBar ​ HScrollBar的其他属性也可以通过代码来设置，下述示例演示了如何通过代码创建的HScrollBar，有兴趣的读者可以自己通过代码设置HScrollBar，创建出符合自己需要的HScrollBar。 示例代码： const { regClass, property } = Laya; @regClass() export class UI_HScrollBar extends Laya.Script { constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { var skins: any[] = []; skins.push(\"resources/res/ui/hscroll.png\", \"resources/res/ui/hscroll$bar.png\", \"resources/res/ui/hscroll$down.png\", \"resources/res/ui/hscroll$up.png\"); Laya.loader.load(skins).then( ()=>{ this.onLoadComplete(); } ); } private onLoadComplete(e: any = null): void { this.placeHScroller(); } private placeHScroller(): void { var hs: Laya.HScrollBar = new Laya.HScrollBar(); hs.skin = \"resources/res/ui/hscroll.png\"; hs.width = 300; hs.pos(50, 170); hs.min = 0; hs.max = 100; hs.changeHandler = new Laya.Handler(this, this.onChange); this.owner.addChild(hs); } private onChange(value: number): void { console.log(\"滚动条的位置： value=\" + value); } } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-24 14:53:15 "},"IDE/uiEditor/uiComponent/VScrollBar/readme.html":{"url":"IDE/uiEditor/uiComponent/VScrollBar/readme.html","title":"垂直滚动条组件","keywords":"","body":"VScrollBar 组件参考一、通过LayaAirIDE创建VScrollBar 组件1.1 创建VScrollBar1.2 VScrollBar 组件常用属性二、通过代码创建VScrollBar组件VScrollBar 组件参考 一、通过LayaAirIDE创建VScrollBar 组件 1.1 创建VScrollBar VScrollBar 组件是一个垂直方向滚动条组件。 当数据太多以至于显示区域无法容纳时，最终用户可以使用 VScrollBar 组件控制所显示的数据部分。 滚动条由四部分组成：一个轨道图、一个滑块按钮和两个箭头按钮。 点击选择资源面板里的 VScrollBar 组件，拖放到页面编辑区，即可添加 VScrollBar 组件到页面上。 VScrollBar 组件的脚本接口请参考 VScrollBar API。 VScrollBar 组件的图像资源示例： ​ ​ （图1） ​ ​ （图2） ​ ​ （图3） ​ ​ （图4） ​ VScrollBar 拖放到编辑器区后，显示效果： ​ ​ （图5） ​ 设置 VScrollBar 的属性 max 的值为 10、属性 min 的值为0、属性 value 的值为3后，显示效果如下： ​ ​ （图6） ​ 在程序中运行时，可以拖动滑块或点击箭头按钮控制进度条的值： ​ ​ （图7） ​ 设置 VScrollBar 的属性 showButtons 的值为 false时的显示效果： ​ ​ （图8） ​ 在程序里运行时的效果： ​ ​ （图9） 1.2 VScrollBar 组件常用属性 ​ ​ （图10） 属性 功能说明 skin 滚动条的图像资源地址。 sizeGrid 滚动条轨道图资源的有效缩放网格数据（九宫格数据）。 value 表示当前滚动位置的数字。 min 表示最低滚动位置的数字。 max 表示最高滚动位置的数字。 scrollSize 表示按下滚动条轨道时页面滚动的增量。 mouseWheelEnable 一个布尔值，指定是否滑轮滚动，默认值为true。 touchScrollEnable 一个布尔值，指定是否开启触摸，默认值为true。 hide 是否隐藏滚动条，不显示滚动条，但是可以正常滚动，默认为false。 autoHide 一个布尔值，指定是否自动隐藏滚动条(无需滚动时)，默认值为false。 showButtons 一个布尔值，指定是否显示向上、向下按钮，默认值为true。 rollratio 滚动衰减系数，默认为0.95。 elasticdistance 橡皮筋效果极限距离，0为没有橡皮筋效果。 elasticbacktime 橡皮筋回弹时间，单位为毫秒。 二、通过代码创建VScrollBar组件 在我们进行书写代码的时候，免不了通过代码控制UI，创建UI_ScrollBar 类，并通过代码设定VScrollBar 相关的属性。 运行示例效果: ​ ​ (图11)通过代码创建VScrollBar VScrollBar 的其他属性也可以通过代码来设置，下述示例代码演示了如何通过代码创建的VScrollBar ，有兴趣的读者可以自己通过代码设置VScrollBar ，创建出符合自己需要的滚动条。 示例代码： const { regClass, property } = Laya; @regClass() export class UI_VScrollBar extends Laya.Script { constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { var skins: any[] = []; skins.push(\"resources/res/ui/vscroll.png\", \"resources/res/ui/vscroll$bar.png\", \"resources/res/ui/vscroll$down.png\", \"resources/res/ui/vscroll$up.png\"); Laya.loader.load(skins).then( ()=>{ this.onLoadComplete(); } ); } private onLoadComplete(e: any = null): void { this.placeVScroller(); } private placeVScroller(): void { var vs: Laya.VScrollBar = new Laya.VScrollBar(); vs.skin = \"resources/res/ui/vscroll.png\"; vs.height = 300; vs.pos(400, 50); vs.min = 0; vs.max = 100; vs.changeHandler = new Laya.Handler(this, this.onChange); this.owner.addChild(vs); } private onChange(value: number): void { console.log(\"滚动条的位置： value=\" + value); } } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-24 14:53:15 "},"IDE/uiEditor/uiComponent/slider/readme.html":{"url":"IDE/uiEditor/uiComponent/slider/readme.html","title":"划动条组件","keywords":"","body":"划动条组件划动条组件 划动条组件包括水平划动条与垂直划动条两种 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:54 "},"IDE/uiEditor/uiComponent/HSlider/readme.html":{"url":"IDE/uiEditor/uiComponent/HSlider/readme.html","title":"水平划动条组件","keywords":"","body":"HSlider 组件参考1、了解HSlider组件1.1 HSlider的作用与效果演示1.2 HSlider组件的皮肤（skin）规范1.3 HSlider组件的API介绍2、通过LayaAirIDE创建HSlider组件1.1 创建HSlider1.2 HSlider 组件常用属性1.3 HSlider 组件特殊其他属性HSlider 组件参考 1、了解HSlider组件 1.1 HSlider的作用与效果演示 HSlider与VSlider组件都是Slider组件的子类，它们分别表示横向滑动条与纵向滑动条。用户可以通过在滑块轨道之间移动滑块来选择值。常用于如播放器进度控制、音量大小控制，一些UI上的数值调整等。 ​ HSlider 组件采用水平方向。滑块轨道从左向右扩展，而显示滑动块位置数值的标签位于轨道的上部，可隐藏。 ​ ​ （图1） 1.2 HSlider组件的皮肤（skin）规范 ​ HSlider资源命名规以hsliser为前缀名，它的默认资源总共3个，分别为滑块资源hslider$bar、进度条资源hslider$progress 及底图资源hslider。 ​ 资源至少应当有两个，一个底图资源，一个滑块资源，否则无法实现滑动功能。缺少了进度条资源组件不会报错，只是不显示进度。 tips：进度条资源`hslider$progress`可以与底图资源`hslider`互换，互换后进度可以反向显示。 （图2） 1.3 HSlider组件的API介绍 2、通过LayaAirIDE创建HSlider组件 1.1 创建HSlider ​ 点击选择资源面板里的 HSlider 组件资源，拖放到页面编辑区，即可添加 HSlider 组件到页面上。 ​ HSlider 拖放到编辑器区后，设置sizeGrid九宫格属性，使之放大后不会拉伸，缩放后显示效果如下： ​ ​ （图2） 1.2 HSlider 组件常用属性 ​ 设置 HSlider 的属性 max 的值为 20、属性 min 的值为0、属性 value 的值为5后，显示效果如下： ​ ​ （图3） max：HSlider滑块拖动到最右边时的最大值，默认数值为100； min：HSlider滑块拖动到最左边时的最小值，默认为0； value：滑块目前所处的数值，应当等于max或min，或在它们之间的值。 ​ ​ （图4） 发布后编译运行，显示效果如下，可以拖动滑块来选择值： ​ ​ （图5） 1.3 HSlider 组件特殊其他属性 通用其他属性在”属性设置器“中已有详细介绍，下列为关于HSlider组件相关的特殊属性。 属性 功能说明 allowClickBack 一个布尔值，指定是否允许通过点击滑动条改变 value 属性值。 showLabel 一个布尔值，指定是否隐藏在滑块上方显示value值的标签。 tick 刻度值最小单位，指滑块每次拖动的value值改变量，默认值为1。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-24 14:53:15 "},"IDE/uiEditor/uiComponent/VSlider/readme.html":{"url":"IDE/uiEditor/uiComponent/VSlider/readme.html","title":"垂直划动条组件","keywords":"","body":"VSlider 组件参考1、了解VSlider组件1.1 VSlider的作用与效果演示1.2 VSlider组件的皮肤（skin）规范1.3 VSlider组件的API介绍2、通过LayaAirIDE创建VSlider组件1.1 创建VSlider1.2 VSlider 组件常用属性1.3 用VSlider制作音量控制条1.4 VSlider 组件特殊其他属性VSlider 组件参考 1、了解VSlider组件 1.1 VSlider的作用与效果演示 HSlider与VSlider组件都是Slider组件的子类，它们分别表示横向滑动条与纵向滑动条。用户可以通过在滑块轨道之间移动滑块来选择值。常用于如播放器进度控制、音量大小控制，一些UI上的数值调整等。 VSlider 组件采用纵向排列。滑块轨道从上向下扩展，而显示数值的标签位于轨道的右边部分，可隐藏。 （图1） 1.2 VSlider组件的皮肤（skin）规范 VSlider资源命名规以vsliser为前缀名，它的默认资源总共3个，分别为滑块资源vslider$bar.png、进度条资源vslider$progress.png 及底图资源vslider.png。 资源至少应当有两个，一个底图资源，一个滑块资源，否则无法实现滑动功能。缺少了进度条资源组件不会报错，只是不显示进度。 tips：进度条资源`vslider$progress.png`可以与底图资源`vslider.png`互换，互换后进度可以反向显示。 （图2） 1.3 VSlider组件的API介绍 2、通过LayaAirIDE创建VSlider组件 1.1 创建VSlider 点击选择资源面板里的 VSlider 组件资源，拖放到页面编辑区，即可添加 VSlider 组件到页面上。 VSlider 拖放到编辑器区后，设置sizeGrid九宫格属性，使之放大后不会拉伸，缩放后显示效果如下： （图2） 1.2 VSlider 组件常用属性 VSlider组件与HSlider组件属性全部相同，只是组件的方向上有所变化。 同样设置 VSlider 的属性 max 的值为 20、属性 min 的值为0、属性 value 的值为5后，显示效果如下： （图3） max：VSlider滑块拖动到最右边时的最大值，默认数值为100； min：VSlider滑块拖动到最左边时的最小值，默认为0； value：滑块目前所处的数值，应当等于max或min，或是它们之间的值。 （图4） 在程序中运行时，可以拖动滑块来选择值： （图5） 1.3 用VSlider制作音量控制条 在游戏开发或一些其他软件中，用VSlider制作音量控制器很常见。但是如图5所示，并不是我们所需要的效果，进度条方向和大小值全部反过来了。正常的是音量最大值应当在最上方，最小值应当为最下方，进度条也应当是由下向上变化。 其实要达到正常的效果非常简单，首先就是max与min属性可以反过来设置，例如我们设置max为0，min为20，然后value值默认设置为最大20，如图6所示。 （图6） 其次是进度条的方向，把进度条资源和底图资源的命名交换一下如图7，动图8所示，刷新IDE并发布，编译运行后我们可以看到进度的方向就是由下而上了！也达到了我们需要的音量控制器效果。 （图7） （动图8） 1.4 VSlider 组件特殊其他属性 通用其他属性在”属性设置器“中已有详细介绍，下列为关于HSlider组件相关的特殊属性。 属性 功能说明 allowClickBack 一个布尔值，指定是否允许通过点击滑动条改变 value 属性值。 showLabel 一个布尔值，指定是否隐藏在滑块上方显示value值的标签。 tick 滑动条的刻度值，是指滑块每次拖动的value值改变量。默认值为1。 max 滑块上允许的最大值。 min 滑块上允许的最小值。 value 当前所在刻度。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-24 14:53:15 "},"IDE/uiEditor/uiComponent/ProgressBar/readme.html":{"url":"IDE/uiEditor/uiComponent/ProgressBar/readme.html","title":"进度条组件","keywords":"","body":"ProgressBar 组件参考一、通过LayaAirIDE创建ProgressBar组件1.1 创建ProgressBar1.2 ProgressBar 组件的常用属性二、通过代码创建ProgressBarProgressBar 组件参考 一、通过LayaAirIDE创建ProgressBar组件 1.1 创建ProgressBar ​ ProgressBar 经常被用于显示游戏中某个操作的进度，例如加载资源的进度、角色经验或血量的进度。 ​ 点击选择资源面板里的 ProgressBar 组件，拖放到页面编辑区，即可添加 ProgressBar 组件到页面上。 ​ ProgressBar 的脚本接口参考 ProgressBar API。 ​ ProgressBar 组件的资源示例： ​ ​ （图1） ​ ​ （图2） ​ 设置 ProgressBar 组件的属性 value 的值为 0.3 后，显示效果如下所示： ​ ​ （图3） 1.2 ProgressBar 组件的常用属性 ​ ​ （图4） 属性 功能说明 sizeGrid 进度条的图像资源的有效缩放网格数据。 skin 进度条的图像资源。 value 进度条的进度值，0到1之间。 二、通过代码创建ProgressBar ​ 在我们进行书写代码的时候，免不了通过代码控制UI，创建UI_ProgressBar类，在代码中导入laya.ui.ProgressBar的包，并通过代码设定ProgressBar相关的属性。 运行示例效果: ​ ​ (图5)通过代码创建ProgressBar ​ ProgressBar的其他属性也可以通过代码来设置，上述示例演示了如何通过代码创建不同皮肤（样式）的ProgressBar，有兴趣的读者可以自己通过代码设置ProgressBar，创建出符合自己需要的进度条。 示例代码： const { regClass, property } = Laya; @regClass() export class UI_ProgressBar extends Laya.Script { private progressBar: Laya.ProgressBar; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { Laya.loader.load([\"resources/res/ui/progressBar.png\", \"resources/res/ui/progressBar$bar.png\"]).then( ()=>{ this.onLoadComplete(); } ); } private onLoadComplete(e: any = null): void { this.progressBar = new Laya.ProgressBar(\"resources/res/ui/progressBar.png\"); this.progressBar.width = 400; this.progressBar.sizeGrid = \"5,5,5,5\"; this.progressBar.changeHandler = new Laya.Handler(this, this.onChange); this.owner.addChild(this.progressBar); Laya.timer.loop(100, this, this.changeValue); } private changeValue(): void { if (this.progressBar.value >= 1) this.progressBar.value = 0; this.progressBar.value += 0.05; } private onChange(value: number): void { console.log(\"进度：\" + Math.floor(value * 100) + \"%\"); } } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-24 14:53:15 "},"IDE/uiEditor/uiComponent/Box/readme.html":{"url":"IDE/uiEditor/uiComponent/Box/readme.html","title":"容器组件","keywords":"","body":"Box容器一、什么是容器二、容器有哪些三、Box的属性四、Box与Sprite容器的使用差异Box容器 Author : Charley 一、什么是容器 所谓容器，便是可以包容或装载物品的贮存器。 在LayaAir引擎里，是指本身并不独立使用，用于装载其它显示对象的组件。 不独立使用是常见的情况，某些情况下，容器也可以只用于填充背景色，但这种情况并非容器真正的作用。 例如，List容器组件，没有了其装载的渲染单元子组件，List本身就没有了意义。 又比如，单选框组，没有了单选框的子组件，那这个组本身也失去了意义。 所以，每一个容器主要的作用，都是为了包容或装载其它子组件才能发挥其独有的作用。 二、容器有哪些 容器组件的基类是Box，Box自身与继承自Box的组件，都属于容器。 开发者直接使用的容器对象一共有9个。如图1的黄字高亮部分所示。 (图1) 三、Box的属性 由于Box继承于UI组件的基类UIComponent，所以父类的属性这里就不再重复介绍。 由于Box是个比较纯粹的容器对象，本身没有什么作用，其作用主要用于装载其它子节点。 如果说唯一可以独立使用的作用，那就是填充背景颜色。 在IDE里的操作，如图2所示，先勾选设置背景色状态选框，再点击取色器输入栏，然后在取色器窗口里拾取或输入颜色之后，关闭取色器窗口即可。 （图2） 四、Box与Sprite容器的使用差异 Sprite与Box都属于比较常用的基础容器。 由于Sprite更底层，所以对比之下，Sprite的性能消耗要更低于Box。 在没有海量使用的前提下，也没有太大的差距。但是性能至上的原则上，能使用Sprite的时候，当然优先使用Sprite。 那什么时候使用Box呢？ 由于Box属于UI组件，所有UI组件都有一个共同的特性，那就是相对布局与设置数据源。 对于容器，我们考虑是否使用Box，取决于是否有相对布局的需求。 如果有相对布局的需求，就使用Box作为容器，否则就使用Sprite。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:52 "},"IDE/uiEditor/uiComponent/HBox/readme.html":{"url":"IDE/uiEditor/uiComponent/HBox/readme.html","title":"水平布局容器组件","keywords":"","body":"HBox组件参考1、HBox组件创建2、HBox属性介绍2.1 Align属性2.2 Space属性HBox组件参考 HBox其本质是容器类组件，所有的容器类组件都继承自Box，HBox也不例外。 HBox是常用于水平布局的容器组件，相较于Box它增加了绝对布局的功能。 1、HBox组件创建 通过IDE的可视化操作可以直接在层级面板对HBox进行创建，步骤为鼠标右键单击Scence2D，找到UI，点击HBox即可完成创建，如图1所示。 （图1） 也可以从IDE资源管理右侧组件面板的UI文件夹中，将HBox组件拖拽到UI页面中，如动图2所示。 （动图2） 2、HBox属性介绍 （图3） 属性 功能 space 子对象的间隔，以像素为单位。 align 布局元素的垂直对齐，共有四个选项。none：不进行垂直对齐，top：居顶垂直对齐，middle：居中垂直对齐，bottom：居底垂直对齐，默认为none。 2.1 Align属性 HBox的子节点无论在IDE中怎样排列，在设置了Align选项后都会变成相对应的垂直排序，如动图4所示。 （动图4） 2.2 Space属性 Space属性就是设置子对象的间隔，以像素为单位，可以自行输入数字，也可以通过鼠标左键长按滑动来输入数值，非常的容易操作与理解，如动图5所示。 （动图5） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-24 14:53:15 "},"IDE/uiEditor/uiComponent/VBox/readme.html":{"url":"IDE/uiEditor/uiComponent/VBox/readme.html","title":"垂直布局容器组件","keywords":"","body":"VBox组件参考1、VBox组件创建2、VBox属性介绍2.1 Align属性2.2 Space属性VBox组件参考 Author： 诗换花 VBox是容器类组件，继承自Box，VBox是常用于垂直布局的容器组件，对比Box它增加了绝对布局的功能。 1、VBox组件创建 通过IDE的可视化操作可以直接在层级面板对VBox进行创建，步骤为鼠标右键单击Scence2D，找到UI，点击VBox即可完成创建，如图1所示。 （图1） 也可以从IDE资源管理右侧组件面板的UI文件夹中，将VBox组件拖拽到UI页面中，如动图2所示。 (动图2) 2、VBox属性介绍 （图3） 属性 功能 spac 子对象的间隔，以像素为单位。 align 布局元素的水平对齐，共有四个选项。none：不进行水平对齐，left：居左水平对齐，center：居中水平对齐，right：居右水平对齐，默认为none。 （图3） 2.1 Align属性 VBox的子节点无论在IDE中怎样排列，在设置了Align选项后都会变成相对应的水平排序，如动图4所示。 动图（4） 2.2 Space属性 Space属性就是设置子对象的间隔，以像素为单位，可以自行输入数字，也可以通过鼠标左键长按滑动来输入数值，非常的容易操作与理解，如动图5所示。 （动图5） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-24 14:53:15 "},"IDE/uiEditor/uiComponent/Panel/readme.html":{"url":"IDE/uiEditor/uiComponent/Panel/readme.html","title":"面板容器组件","keywords":"","body":"Panel组件参考一、通过LayaAirIDE创建Panel组件二、通过代码创建Panel组件Panel组件参考 Panel是一个带有裁剪功能的面板容器类，常用来设置元素的显示区域。可以直接将要显示的元素添加到Panel容器中，Panel的宽高就是元素将要显示的宽高。 一、通过LayaAirIDE创建Panel组件 1.1 以拖拽的形式将Panel组件拖拽到页面编辑区 从IDE资源管理右侧组件面板的UI文件夹中，将Panel组件拖拽到UI页面中。如动图1所示： (图1) 给Panel设置宽高（例如：100*100）。双击UI界面中的Panel组件，放入一张图片。显示效果以及层级结构图如图2所示： (图2) 由图2可以看出放入的图片被裁剪了，图片最终所显示的宽高就是Panel容器的宽高。这样我们就可以直接调整图片的坐标让其显示的内容发生改变了。 1.2 添加滚动条显示 Panel组件还可以设置滚动条；除list组件外，Panel是唯一一个可以设置滚动条的容器组件。在此我们可以对Panel设置一个滚动条看下效果。为Panel设置滚动条，如图3所示： （图3） 二、通过代码创建Panel组件 panel组件除了可以直接在UI界面中可视化的操作之外，在代码中实现出上面的效果也是很简单的。 示例代码： const { regClass, property } = Laya; @regClass() export class UI_Panel extends Laya.Script { constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { this.setup(); } private setup(): void { var panel: Laya.Panel = new Laya.Panel(); panel.hScrollBarSkin = \"resources/res/ui/hscroll.png\"; panel.size(600, 275); this.owner.addChild(panel); var img: Laya.Image; for (var i: number = 0; i Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-24 14:53:15 "},"IDE/uiEditor/uiComponent/List/readme.html":{"url":"IDE/uiEditor/uiComponent/List/readme.html","title":"列表组件","keywords":"","body":"List 组件参考一、IDE创建List组件1.1 创建 List 组件1.2 List 组件常用属性二、通过代码创建List组件List 组件参考 一、IDE创建List组件 List 组件可显示项目列表。默认为垂直方向列表。可通过UI编辑器自定义列表。List 列表的每一个列表通常是一样的，也可以使用编辑器自定义不同样式的列表内容项。 List 通常由两个部分组成：列表渲染项（单元格）、滚动条。 List 组件的脚本接口请参考 List API。 1.1 创建 List 组件 1.添加List组件 点击Scene2D节点，用鼠标右键打开菜单，选择UI，点击List，完成List组件的添加，调整好List的Size，如图1所示 （图1） 2.添加列表项 列表项可以是 Box 对象或 View（页面） 或其它自定义页面对象。此处以Box 对象为例。 a. 点击List节点，用鼠标右键打开菜单，选择UI，点击Box，完成Box的添加，调整好Box的高度为30。 b. 从资源面板里选择拖入一个 Label 组件，拖入到层级中Box的节点下，设置一下 Label 的显示相关属性使它更好看一些。 （图2） 3.指定 List 的列表item模板 LayaAir3.0与2.0的区别是已经去掉了renderType属性，方式做了改变 在3.0中，List组件下的属性Item模板，可以指定List的列表item模板。因此我们将List节点下的Box节点拖入到List的Item模板属性中，如图3所示 （图3） 4.为 List 添加滚动条组件 LayaAir3.0与2.0的区别是List增加了Scroll Type属性，用Scroll Type去控制是否有滚动条。而是否有皮肤，已经与是否滚动脱钩。选择List组件，查看右侧属性面板 a.先选择List的属性Scroll Type为vertical b.V Scroll Bar Skin属性用来设置垂直滚动条的皮肤，从资源面板里选择并拖拽一个vscroll组件到这个skin属性中，会立即生成滚动条皮肤 （图4） 注意：当Scroll Type为none时，即时设置了滚动条皮肤，在运行时也不会有滚动效果 5.拖动设置 List 的宽高 设置属性 repeatX 的值为 1，设置 repeatY 的值为6。如图5所示 （图5） 6.在代码里给 List 对象赋值 var data: Array = []; for(var m:number =0; m 7.在程序里运行查看效果。 （图6） 8.在代码里添加脚本，隐藏滚动条，设置拖拽的橡皮筋效果 m_list.scrollType = Laya.ScrollType.Vertical;//设置列表使用垂直滚动 m_list.vScrollBarSkin = \"\";//隐藏列表的滚动条皮肤 m_list.elasticEnabled = true;//设置橡皮筋为ture m_list.scrollBar.elasticBackTime = 200;//设置橡皮筋回弹时间。单位为毫秒。 m_list.scrollBar.elasticDistance = 50;//设置橡皮筋极限距离。 1.2 List 组件常用属性 （图8） 属性 功能说明 repeatX 水平方向显示的单元格数量。 repeatY 垂直方向显示的单元格数量。 elasticEnabled 是否开启橡皮筋效果 spaceX 水平方向显示的单元格之间的间距（以像素为单位）。 spaceY 垂直方向显示的单元格之间的间距（以像素为单位）。 scrollType 是否开启滚动 vScrollBarSkin 垂直方向滚动条皮肤。 hScrollBarSkin 水平方向滚动条皮肤。 selectenable 是否可以选中。 selectindex 当前选择的项索引。 disablestopscroll 禁用滚动条停止，用于控制array更新时是否停止滚动条，默认在更新数据时会停止滚动条，当通过滑动滚动条，进行动态更新，list的cell时，设置为true，不停止滚动条会让列表滚动的平滑流畅。 二、通过代码创建List组件 在我们进行书写代码的时候，免不了通过代码控制UI，创建UI_List类，通过代码设定List相关的属性。 运行示例效果: (图9) List的其他属性也可以通过代码来设置，下述示例代码演示了如何通过代码创建List，有兴趣的读者可以自己通过代码设置List，创建出符合自己需要的列表。 示例代码： const { regClass, property } = Laya; @regClass() export class UI_List extends Laya.Script { public _list: Laya.List; constructor() { super(); } onAwake(): void { this.setup(); } private setup(): void { var list: Laya.List = new Laya.List(); list.itemRender = Item; list.repeatX = 1; list.repeatY = 4; list.x = (Laya.stage.width - Item.WID) / 2; list.y = (Laya.stage.height - Item.HEI * list.repeatY) / 2; // 设置List的垂直滚动 list.scrollType = Laya.ScrollType.Vertical; // 设置List的垂直滚动皮肤，不设置或者\"\"就没有滚动条皮肤 list.vScrollBarSkin = \"\"; // 是否开启橡皮筋效果 list.elasticEnabled = true; // 设置橡皮筋回弹时间。单位为毫秒。 list.scrollBar.elasticBackTime = 300; // 设置橡皮筋极限距离。 list.scrollBar.elasticDistance = 50; list.selectEnable = true; list.selectHandler = new Laya.Handler(this, this.onSelect); list.renderHandler = new Laya.Handler(this, this.updateItem); this.owner.addChild(list); // 设置数据项为对应图片的路径 var data: any[] = []; for (var i: number = 0; i Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-04-03 21:03:24 "},"IDE/uiEditor/uiComponent/Tree/readme.html":{"url":"IDE/uiEditor/uiComponent/Tree/readme.html","title":"树状列表组件","keywords":"","body":"Tree 组件参考一、通过LayaAirIDE创建Tree组件1.1 Tree 组件主要由两个部分组成：1.2 Tree 组件的单元格通常由四部分组成：1.3 Tree 组件的图像资源示例1.4创建 Tree 组件8. Tree 组件常用属性二、通过代码创建Tree组件Tree 组件参考 一、通过LayaAirIDE创建Tree组件 ​ Tree 组件用来显示树状结构。用户可以查看排列为可扩展树的层次结构数据。 ​ Tree 组件的脚本接口请参考 Tree API。 1.1 Tree 组件主要由两个部分组成： 项单元格（可以是 Box 、页面 View、自定义页面）； 纵向滚动条 VScrollBar； 1.2 Tree 组件的单元格通常由四部分组成： 一个单元格选择状态切片动画 Clip； 一个折叠箭头切片动画 Clip ； 一个文件状态切片动画 Clip ； 单元格其他内容元素； 1.3 Tree 组件的图像资源示例 1.3.1单元格选择状态切片动画 Clip 资源： 切片数为2，切片索引从0开始依次代表：单元格未被选中状态图、单元格选中或悬停状态图。 ​ ​ （图1） 1.3.2折叠箭头切片动画 Clip 资源： 切片数为2，切片索引从0开始依次代表：文件夹节点折叠状态图、文件夹节点展开状态图。 ​ （图2） 1.3.3文件状态切片动画 Clip 资源： 如果切片数是3，则切片索引从0开始依次代表：文件夹节点折叠状态图、文件夹节点展开状态图、非文件夹节点状态图； 如果切片数是2，则切片索引从0开始依次代表：文件夹节点状态图、非文件夹节点状态图； ​ （图3） 1.4创建 Tree 组件 1. 编辑 Tree 组件的列表项。 首先在Scence2D中创建一个Clip组件，设置此Clip 组件对象的 name 属性值为 selectBox，设置属性 ClipY 的值为2，然后从项目资源面板里将一个单元格选择状态的切片动画（ clip_selectBox.png），拖入刚刚创建的Clip组件的Skin属性中，如图4所示。 注意：此处的选择状态切片动画 （Clip 组件）对象的 name 属性值必须设置为 selectBox，只有这样程序才能识别它，并实现此 Clip 组件对象的显示状态跟随单元项的选择状态而改变的功能，否则此 Clip 对象将会被识别为此单元项的普通显示对象。 ​ ​ （图4） 在Scence2D中创建一个Clip组件，设置此Clip 组件对象的 name 属性值为 arrow，设置属性 ClipY 的值为2，然后从项目资源面板里将一个单元格的折叠箭头切片动画（clip_tree_arrow.png），拖入刚刚创建的Clip组件的Skin属性中，如图5所示。 注意：此处的折叠箭头切片动画 （Clip 组件）的 name 属性值必须设置为 arrow，只有这样程序才能识别它，并实现点击此 Clip 对象打开或折叠树形节点的功能。否则此 Clip 对象将会被识别为此单元项的普通显示对象。 （图5） 在Scence2D中创建一个Clip组件，设置此Clip 组件对象的 name 属性值为 folder，设置属性 ClipY 的值为 3，然后从项目资源面板里将一个单元格的文件状态切片动画（clip_tree_folder.png），拖入刚刚创建的Clip组件的Skin属性中，如图6所示。 注意：此处的文件状态切片动画（Clip 组件）的 name 属性值必须设置为 folder，只有这样程序才能识别它，并实现此 Clip 组件对象的显示状态跟随单元项的折叠、展开、节点类型（是否有字节点）而改变的功能。否则此 Clip 对象将会被识别为此单元项的普通显示对象。 （图6） 拖入此单元项的普通显示对象。 此处以 Label 为例，从资源面板里选择并拖入一个 Label 组件对象，在此给这个 Label 对象设置一下属性 name 值为 label ，方便在脚本中对它进行赋值，此name 属性值自定义即可。再设置一下 Label 对象显示相关的属性，使它看起来更美观。 ​ ​ （图7） 然后拖入一个Box容器组件，并将之前创建好的Clip组件全部放入Box容器组件中。 ​ ​ （图8） ​ 2. 转化为 Tree 容器。 选择列表渲染项对象，右键单击调出设置面板，点击change Type，点击UI，点击Tree，完成 Tree 容器的添加。 ​ ​ （图9） 3. 指定 Tree 组件的列表渲染项。 点击 Tree 组件对象，设置 Tree 组件的属性 name 的值为 render。 注意：此处列表渲染项属性 name 的值必须为 render，否则程序将无法识别。 ​ ​ （图10） 4.为 Tree 组件添加滚动条。 从资源面板里选择一个 VScrollBar 组件，将VScrollBar 组件的资源地址（skin 属性值）设置为 Tree 组件属性scrollBarSkin 的值。 ​ （图11） 5. 调整 Tree 的宽高。 设置 Tree 对象的属性 var（全局引用名）的值为 render，此处名字可以自定义，目的是在脚本中对此 Tree 组件对象赋值。 ​ （图12） 6.在代码里给 Tree 对象赋值 var xmlString:string=\"\"+ \"\"+ \"\"+ \"\"+ \"\"+ \"\"+ \"\"+ \"\"+ \"\"+ \"\"+ \"\"+ \"\"+ \"\"+ \"\"+ \"\"+ \"\"; //解析xml字符。 var xml:any = domParser.parseFromString(xmlString, \"text/xml\"); //设置 render 的数据源。 render.xml =xml; 7.在程序中运行查看效果 （动图13） 8. Tree 组件常用属性 （图14） 属性 功能说明 scrollBarSkin 滚动条皮肤。 spaceBottom 每一项之间的间隔距离。单位是像素。 spaceLeft 左侧缩进距离。单位是像素。 selectedindex 当前选择的项索引。 keepstatus 数据源发生变化后，是否保持之前打开状态，默认为true。true：保持之前打开状态。false：不保持之前打开状态。 二、通过代码创建Tree组件 在我们进行书写代码的时候，免不了通过代码控制UI，创建UI_Tree类，在代码中导入laya.ui.Tree的包，并通过代码设定Tree相关的属性。 运行示例效果： ​ ​ (动图15) Tree的其他属性也可以通过代码来设置，下述示例代码演示了如何通过代码创建不同皮肤（样式）的Tree，有兴趣的读者可以自己通过代码设置Tree，创建出符合自己需要的文件夹。 示例代码： const { regClass, property } = Laya; @regClass() export class UI_Tree extends Laya.Script { constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { var res: any[] = [\"resources/res/ui/vscroll.png\", \"resources/res/ui/vscroll$bar.png\", \"resources/res/ui/vscroll$down.png\", \"resources/res/ui/vscroll$up.png\", \"resources/res/ui/tree/clip_selectBox.png\", \"resources/res/ui/tree/clip_tree_folder.png\", \"resources/res/ui/tree/clip_tree_arrow.png\"]; Laya.loader.load(res).then( ()=>{ this.onLoadComplete(); } ); } private onLoadComplete(e: any = null): void { // 组装tree的数据 var treeData:string = \"\"; for (var i: number = 0; i \"; for (var j: number = 0; j \"; } treeData += \"\"; } treeData += \"\"; // 解析tree的数据 var xml: any = Laya.Utils.parseXMLFromString(treeData); var tree: Laya.Tree = new Laya.Tree(); tree.scrollBarSkin = \"resources/res/ui/vscroll.png\"; tree.itemRender = Item; tree.xml = xml; tree.size(300, 300); tree.x = (Laya.stage.width - tree.width) / 2; tree.y = (Laya.stage.height - tree.height) / 2; this.owner.addChild(tree); } } // 此类对应的json对象： // {\"child\": [{\"type\": \"Clip\", \"props\": {\"x\": \"13\", \"y\": \"0\", \"left\": \"12\", \"height\": \"24\", \"name\": \"selectBox\", \"skin\": \"ui/clip_selectBox.png\", \"right\": \"0\", \"clipY\": \"2\"}}, {\"type\": \"Clip\", \"props\": {\"y\": \"4\", \"x\": \"14\", \"name\": \"folder\", \"clipX\": \"1\", \"skin\": \"ui/clip_tree_folder.png\", \"clipY\": \"3\"}}, {\"type\": \"Label\", \"props\": {\"y\": \"1\", \"text\": \"treeItem\", \"width\": \"150\", \"left\": \"33\", \"height\": \"22\", \"name\": \"label\", \"color\": \"#ffff00\", \"right\": \"0\", \"x\": \"33\"}}, {\"type\": \"Clip\", \"props\": {\"x\": \"0\", \"name\": \"arrow\", \"y\": \"5\", \"skin\": \"ui/clip_tree_arrow.png\", \"clipY\": \"2\"}}], \"type\": \"Box\", \"props\": {\"name\": \"render\", \"right\": \"0\", \"left\": \"0\"}}; class Item extends Laya.Box { constructor() { super(); this.right = 0; this.left = 0; var selectBox: Laya.Clip = new Laya.Clip(\"resources/res/ui/tree/clip_selectBox.png\", 1, 2); selectBox.name = \"selectBox\";//设置 selectBox 的name 为“selectBox”时，将被识别为树结构的项的背景。2帧：悬停时背景、选中时背景。 selectBox.height = 32; selectBox.x = 13; selectBox.left = 12; this.addChild(selectBox); var folder: Laya.Clip = new Laya.Clip(\"resources/res/ui/tree/clip_tree_folder.png\", 1, 3); folder.name = \"folder\";//设置 folder 的name 为“folder”时，将被识别为树结构的文件夹开启状态图表。2帧：折叠状态、打开状态。 folder.x = 14; folder.y = 4; this.addChild(folder); var label: Laya.Label = new Laya.Label(\"treeItem\"); label.name = \"label\";//设置 label 的name 为“label”时，此值将用于树结构数据赋值。 label.fontSize = 20; label.color = \"#FFFFFF\"; label.padding = \"6,0,0,13\"; label.width = 150; label.height = 30; label.x = 33; label.y = 1; label.left = 33; label.right = 0; this.addChild(label); var arrow: Laya.Clip = new Laya.Clip(\"resources/res/ui/tree/clip_tree_arrow.png\", 1, 2); arrow.name = \"arrow\";//设置 arrow 的name 为“arrow”时，将被识别为树结构的文件夹开启状态图表。2帧：折叠状态、打开状态。 arrow.x = 0; arrow.y = 5; this.addChild(arrow); } } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-24 14:53:15 "},"IDE/uiEditor/uiComponent/optionBox/readme.html":{"url":"IDE/uiEditor/uiComponent/optionBox/readme.html","title":"选项框","keywords":"","body":"选项框选项框 常见的选项框包括下拉选项框、单选框、单选框组、多选框。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:53 "},"IDE/uiEditor/uiComponent/ComboBox/readme.html":{"url":"IDE/uiEditor/uiComponent/ComboBox/readme.html","title":"下拉选项框组件","keywords":"","body":"ComboBox 组件参考一、通过LayaAirIDE创建ComboBox组件1.1 创建ComboBox1.2 ComboBox 组件的常用属性1.3 ComboBox 组件下拉选项相关属性1.4 ComboBox 组件下拉按钮相关属性二、通过代码创建ComboBox组件ComboBox 组件参考 一、通过LayaAirIDE创建ComboBox组件 1.1 创建ComboBox ​ ComboBox 是一个下拉列表选项框组件。 ​ 点击选择资源面板里的 ComboBox 组件，拖放到页面编辑区，即可添加 ComboBox 组件到页面上。 ​ ComboBox 的脚本请接口参考 ComboBox API。 ​ ComboBox 组件的图像资源示例： ​ ​ （图1） ​ 设置 ComboBox 的属性 labels 的值为 “label1,label2” 后，显示效果如下： ​ 常态： ​ ​ （图2） ​ 点击后显示下拉选项列表： ​ ​ （图3） ​ 在下拉选项中选择 lable1 后： ​ ​ （图4） 1.2 ComboBox 组件的常用属性 ​ ​ （图5） 属性 功能说明 labels 下拉选框的标签文本内容集合字符串，以逗号分隔。 visibleNum 下拉列表中可显示的最大行数。 statenum 按钮的状态值。 scrollBarSkin 下拉列表的滚动条图像资源。 selectedIndex 表示当前选择的项的索引。 selectedlable 按标签文本设置下拉列表默认选项值。 defaultlable 未设置下拉列表选项值时，在显示框中用于提示的文本。 sizeGrid 下拉列表图像资源的有效缩放网格数据（九宫格数据）。 skin 下拉列表图像资源。 itemcolors 下拉选项列表的各种颜色。 itemsize 项字体大小 itempadding 下拉框单元项的文本边距。 1.3 ComboBox 组件下拉选项相关属性 ​ ​ （图6） ​ ​ （图7） 属性 功能说明 itemColors 下拉列表项的各状态的标签文本颜色值集合。详细请参考API。 itemSize 下拉列表项的标签文本的字体大小。 1.4 ComboBox 组件下拉按钮相关属性 ​ ​ （图8） ​ ​ （图9） 属性 功能说明 labelBold 下拉按钮的标签文本是粗体显示。 labelColor 下拉按钮的各状态下的文本颜色值集合。详细请参考API。 labelFont 下拉按钮的文本字体。 labelPadding 下拉按钮的文本边距。详细请参考API labelSize 下拉按钮的文本字体大小。 二、通过代码创建ComboBox组件 在我们进行书写代码的时候，免不了通过代码控制UI，创建UI_ComboBox类，通过代码设定ComboBox相关的属性。 运行示例效果： ​ （图10） ComboBox的其他属性也可以通过代码来设置，下述示例演示了如何通过代码创建选中框中的下拉选项，并通过点击获取到自己的点击是哪一条选项。有兴趣的读者可以自己通过代码设置ComboBox，创建出符合自己需要的下拉框。 const { regClass, property } = Laya; @regClass() export class UI_ComboBox extends Laya.Script { private skin: string = \"resources/res/ui/combobox.png\"; pageWidth: number; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { Laya.loader.load(this.skin).then( ()=>{ this.onLoadComplete(); } ); } private onLoadComplete(e: any = null): void { var ComboBox: Laya.ComboBox = this.createComboBox(this.skin); ComboBox.autoSize = true; } private createComboBox(skin: string): Laya.ComboBox { var ComboBox: Laya.ComboBox = new Laya.ComboBox(skin, \"item0,item1,item2,item3,item4,item5\"); ComboBox.labelSize = 30; ComboBox.itemSize = 25 this.owner.addChild(ComboBox); return ComboBox; } private onSelect(cb: Laya.ComboBox, e: any = null): void { console.log(\"选中了： \" + cb.selectedLabel); } } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-24 14:53:15 "},"IDE/uiEditor/uiComponent/Radio/readme.html":{"url":"IDE/uiEditor/uiComponent/Radio/readme.html","title":"单选框组件","keywords":"","body":"Radio组件参考1、创建Radio组件2、Radio组件属性介绍3、代码创建RadioRadio组件参考 Author： 诗换花 Radio继承自Buttn，前面Buttn中介绍过的这里就不再过多讲述。 1、创建Radio组件 使用LayaAirIDE创建Radio非常简单，通过IDE的可视化操作，就可以实现组件的创建与布局，也是推荐使用的组件创建方式。可以从层级面板创建，步骤是右键单击Scene2D，找到UI，点击Radio即可创建完毕，如图1所示。 （图1） 我们也可以从IDE资源管理右侧组件面板的UI文件夹中，将Radio组件拖拽到UI页面中，如动图2所示。 （动图2） 2、Radio组件属性介绍 （图3） 属性 功能说明 selected 是否为选中状态，默认为不选中。 lable 按钮的文本标签。 strokecolors 鼠标在元素释放时（抬起移开）、鼠标移动到元素时、鼠标按下时各个状态下的描边颜色。 Radio承于Buttn，是一个单选框组件，单选框组件的特性是点中之后不会恢复状态，如动图4所示。 （动图4） Radio与RadioGroup不同的是Radio并不能通过修改lable属性来增加单选框。 3、代码创建Radio 代码运行示例如动图5所示 （动图5） const { regClass, property } = Laya; @regClass() export class UI_Radio extends Laya.Script { //declare owner : Laya.Sprite3D; @property( { type : String } ) public text: string = \"\"; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { this.setup(); } private setup():void{ var Radio:Laya.Radio = new Laya.Radio(); Radio.pos(200,200); Radio.size(600,275); Radio.stateNum = 3; Radio.selected = false; Radio.skin = 'atlas/comp/radio.png'; Radio.sizeGrid = '13,14,23,8,0'; Radio.label = 'Layabox'; Radio.labelFont = 'Arial'; Radio.labelSize = 20; Radio.labelBold = false; Radio.labelAlign = 'center'; this.owner.addChild(Radio); } } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-04-06 12:04:09 "},"IDE/uiEditor/uiComponent/RadioGroup/readme.html":{"url":"IDE/uiEditor/uiComponent/RadioGroup/readme.html","title":"单选框组组件","keywords":"","body":"RadioGroup 组件详解1、了解RadioGroup组件1.1 RadioGroup组件的作用1.2 RadioGroup组件的皮肤（skin）规范1.3 RadioGroup组件的API介绍2、通过LayaAirIDE创建RadioGroup组件2.1 创建RadioGroup2.2 通过labels增加单选框2.3 改变单选框组RadioGroup的布局方向与间距2.4 设置单选框组RadioGroup的默认选项3、创建自定义的RadioGroup组件3.1 准备美术资源3.2 在IDE中创建Radio组件3.3 转换成RadioGroup容器4、代码创建RadioGroupRadioGroup 组件详解 由于很多组件属性是通用的，常用及通用的组件属性在属性设置器文档中已进行介绍。阅读本篇内容前请先阅读《属性设置器》文档。 1、了解RadioGroup组件 1.1 RadioGroup组件的作用 RadioGroup是单选框按钮组，按钮组之内的组件选项互相排斥，用户每次只能选择一个单选框（Radio）组件。如动图1所示。 （动图1） 1.2 RadioGroup组件的皮肤（skin）规范 RadioGroup组件的皮肤是以RadioGroup或以RadioGroup_为前缀进行命名，在皮肤设计规范方面，是竖向等分的两态图或三态图，如图2所示。 (图2)三态RadioGroup皮肤 Tips：RadioGroup组件的皮肤无法使用九宫格属性，所以要在资源设计的时候就确定好实际应用时的大小。 1.3 RadioGroup组件的API介绍 2、通过LayaAirIDE创建RadioGroup组件 2.1 创建RadioGroup ​ 点击选择资源管理器里的 RadioGroup 组件资源，拖拽到场景编辑器，即在页面中成功的创建了一个 RadioGroup 组件。如动图3所示。 ​ （动图3） 2.2 通过labels增加单选框 如动图3中所示，默认的单选框组中只有两个单选框。如想增加单选框，只需在labels属性中增加新的标签即可，修改标签内容也在该属性中设置，操作如动图4-1所示。 （动图4-1） 2.3 改变单选框组RadioGroup的布局方向与间距 RadioGroup 默认是水平布局（horizontal），通过更改direction属性，实现垂直布局（vertical）。设置间距可以通过space属性实现。如图4-2所示。 （图4-2） 2.4 设置单选框组RadioGroup的默认选项 selectedIndex属性是用于改变单选框组的索引值，默认不设置时，不勾选任何选项，如果要设置RadioGroup的默认勾选，可以设置selectedIndex的属性值，0为第1个单选框，1为第2个单选框……以此类推。 假设我们将属性值设置为0时，运行效果如动图4-3所示。 (图4-3) 3、创建自定义的RadioGroup组件 ​ 在上例中，我们使用了同一种单选框资源通过设置labels生成了三个子项目的单选框组。然而在实际的游戏中，在同一个RadioGroup组件中对单选框样式有不同的需求，那么通过labels设置的方式是无法达到效果的，这个时候就需要使用自定义RadioGroup组件的方式。 3.1 准备美术资源 ​ 我们用两张不同的radio单选框美术资源来组成自定义RadioGroup组件，资源如 图5 所示。 ​ ​ （图5 ） Tips： 这里要特别注意一下皮肤图片的命名规则，在自定义的RadioGroup组件中，我们不能使用RadioGroup或RadioGroup_为前缀命名。因为要使用Radio单选框组件来作为它的子项组件，所以本例中的图片资源命名使用radio_为前缀。 3.2 在IDE中创建Radio组件 将资源拷贝到项目的资源管理器文件夹，然后在IDE中，将制作的radio组件从资源管理器中逐个拖拽到场景编辑器，从左到右（或从上到下）将每个Radio组件的name属性，按先后顺序依次修改成“item0、item1、item2.....”，（不按此规则增加名字属性，生成的RadioGroup组件为无效组件，不能正常运行。） 当设置完label属性的文本、label标签的字体颜色、大小、位置关系等，以及调整好位置后，效果如 图6、图7 所示。 ​ ​ （图6） ​ ​ （图7） ​ Tips：自定义的RadioGroup组件的name属性中，命名规则为英文字符+数字，英文字符后不能加下划线，数字要按先后顺序从0开始。。 3.3 转换成RadioGroup容器 ​ 当修改好子项属性后，全选组件右键单击调出设置面板，点击change Type点击UI，选择转换成RadioGroup容器类型，如图8所示。 ​ ​ （图8） 转换成功后，调整默认选择的索引selectedIndex为0（第一个Radio），如图9所示，单选框间距space、方向direction可以不调节，在场景编辑器中通过鼠标调整也可以。 （图9） ​ 通过以上几个步骤可以看到自定义RadioGroup组件制作成功。默认选择了第一个选框并切换到它的第三帧选择状态，其他选框则是第一帧未选择状态。 4、代码创建RadioGroup 代码运行结果： const { regClass, property } = Laya; @regClass() export class UI_RadioGroup extends Laya.Script { private SPACING: number = 150; private X_OFFSET: number = 200; private Y_OFFSET: number = 80; private skins: any[]; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { this.skins = [\"resources/res/ui/radioButton (1).png\", \"resources/res/ui/radioButton (2).png\", \"resources/res/ui/radioButton (3).png\"]; Laya.loader.load(this.skins).then( ()=>{ this.onLoadComplete(); } ); } private onLoadComplete(e: any = null): void { for (var i: number = 0; i Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-05-11 21:27:15 "},"IDE/uiEditor/uiComponent/CheckBox/readme.html":{"url":"IDE/uiEditor/uiComponent/CheckBox/readme.html","title":"多选框组件","keywords":"","body":"CheckBox 组件详解1、创建CheckBox组件1.1 准备资源1.2 用引擎直接创建CheckBox组件二、通过LayaAirIDE创建CheckBox组件2.1 创建CheckBox2.2 设置CheckBox常用属性CheckBox 组件详解 由于很多组件属性是通用的，常用及通用的组件属性在属性设置器文档中已进行介绍。阅读本篇内容前请先阅读《属性设置器》文档。 1、创建CheckBox组件 CheckBox （多选框）组件由两部分组成，选择状态框及内容说明标签label。其中选择状态框必须是图片资源，标签为文本。在使用 CheckBox组件的时候，可以只使用选择状态框，也可以只设置一个标签label。 1.1 准备资源 CheckBox组件的选择框图片是CheckBox组件的皮肤（skin），图片资源命名通常是check、checkbox或以check_为前缀，如图1所示。CheckBox组件资源通常是由三态或两态的skin图片组件。 （图1） Tips:关于组件皮肤skin以及多态切割stateNum相关请查看《属性设置器》文档。 1.2 用引擎直接创建CheckBox组件 使用LayaAir引擎创建一个CheckBox组件比较简单，通常只需要几个步骤，加载资源，创建一个CheckBox实例，将CheckBox添加到舞台，设置CheckBox组件的属性。具体实现参考下面的代码与注释。 创建一个入口类GameMain.ts，编写如下代码： const { regClass, property } = Laya; @regClass() export class UI_CheckBox extends Laya.Script { private COL_AMOUNT: number = 2; private ROW_AMOUNT: number = 3; private HORIZONTAL_SPACING: number = 200; private VERTICAL_SPACING: number = 100; private X_OFFSET: number = 100; private Y_OFFSET: number = 50; private skins: any[] = [ \"resources/res/ui/checkbox (1).png\", \"resources/res/ui/checkbox (2).png\", \"resources/res/ui/checkbox (3).png\", \"resources/res/ui/checkbox (4).png\", \"resources/res/ui/checkbox (5).png\", \"resources/res/ui/checkbox (6).png\" ]; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { Laya.loader.load(this.skins).then( ()=>{ this.onCheckBoxSkinLoaded(); } ); } private onCheckBoxSkinLoaded(e: any = null): void { var cb: Laya.CheckBox; for (var i: number = 0; i 代码运行效果如动图2所示： (动图2) Tips: CheckBox 组件的属性接口介绍请参考 CheckBox API。 二、通过LayaAirIDE创建CheckBox组件 2.1 创建CheckBox 创建一个ui的DEMO页，点击选择资源管理器里的 CheckBox 组件资源，拖到场景编辑器，即成功添加 CheckBox 组件到页面上，如图3-1所示。 （图3-1） 2.2 设置CheckBox常用属性 创建完组件，可以通过属性设置器，为组件设置属性。例如，CheckBox组件的默认文本为“label”，我们将默认文本修改为“我的多选框”，并设置label标签的颜色、状态、字体、大小等。如图3-2、3-3所示。 （图3-2） （图3-3） 2.2.1 Label相关的其他属性 属性名 功能说明 labelAlign 标签对齐模式，默认为居左对齐。注：在CheckBox中无效 labelColors 表示标签各个状态下的文本颜色。 格式: \" UpColor，OverColor，DownColor，DisableColor “。默认为“蓝色，绿色”。 labelBold 表示标签文本标签是否为粗体字。 labelFont 表示文本标签的字体名称，以字符串形式表示。IDE中可选择。 labelPadding 表示文本标签的边距。 格式：\"上边距,右边距,下边距,左边距\"。 labelSize 表示文本标签的字体大小。 labelStroke 文字描边宽度（以像素为单位）。 默认值0，表示不描边。 labelStrokeColor 文字描边颜色，以字符串表示。 默认值为 \"#000000\"（黑色）; strokeColor 表示各个状态下的描边颜色。 格式: \"upColor，overColor，downColor，disableColor\"。 2.2.2 关于多选框大小与九宫格 需要特别说明的是九宫格（sizeGrid）在CheckBox组件中无效，多选框的大小需美术资源制作的时候去设置。 2.2.3 skin与stateNum配合换皮肤资源 skin：选择框的图像资源。与按钮类似，可两态或三态美术资源。IDE或程序中俱可修改。 stateNum：表示选择框的状态，多选框组件默认为三个状态，如果多选框美术资源改为两态，如图4所示，需设置状态值为2，正常情况下多选框至少应当有2个状态。 （图4）两态美术资源图 Tips：特殊情况下，也可以使用单态。比如仅由label文本组成的CheckBox组件。 两态CheckBox调整示例： 下面我们上例的多选框换成另一个两态的“音乐开关”多选框。从资源管理器中拖拽一个两态资源到skin属性上，并把stateNum设置为2，修改label文本为音乐，并调整label标签的字体大小与边距，如图5-1、5-2所示。 （图5-1） （图5-2） 2.2.4 默认勾选 selected 布尔值，表示多选框是否被选中，可通过程序调用或IDE设置，设置 CheckBox 的 selected 属性的值为 true 后，显示效果如图6所示： （图6） 2.2.5 不能设置的属性toggle toggle决定按下时是否切换组件的显示状态。这里需要特别的注意的是，该属性在CheckBox组件时不要改成false，否则会变成按钮模式，永远都选不中。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-24 14:53:15 "},"IDE/uiEditor/uiComponent/navigationMenu/readme.html":{"url":"IDE/uiEditor/uiComponent/navigationMenu/readme.html","title":"导航菜单组件","keywords":"","body":"导航菜单组件导航标签组组件导航容器组件导航菜单组件 导航菜单是由两个容器组件构成，分别是导航标签组组件与导航容器组件。 导航标签组组件 导航容器组件 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:53 "},"IDE/uiEditor/uiComponent/Tab/readme.html":{"url":"IDE/uiEditor/uiComponent/Tab/readme.html","title":"导航标签组组件","keywords":"","body":"Tab 组件详解1、了解Tab组件1.1 Tab组件的作用1.2 Tab组件的皮肤（skin）规范1.3 Tab 组件的API介绍2、通过LayaAirIDE创建Tab组件2.1 创建Tab2.2 通过labels增加标签2.3 改变Tab组件的布局方向与间距2.4 设置单选框组Tab的默认选项3、代码创建Tab组件Tab 组件详解 由于很多组件属性是通用的，常用及通用的组件属性在属性设置器文档中已进行介绍。阅读本篇内容前请先阅读《属性设置器》文档。 1、了解Tab组件 1.1 Tab组件的作用 Tab 组件用于定义选项卡按钮组，例如多页面切换显示。如动图1所示。 （动图1） 1.2 Tab组件的皮肤（skin）规范 Tab组件的皮肤是以tab或以tab_为前缀进行命名，在皮肤设计规范方面，是竖向等分的两态图或三态图，如图2所示。 (图2)三态Tab皮肤 Tips：Tab组件的皮肤无法使用九宫格属性，所以要在资源设计的时候就确定好实际应用时的大小。 1.3 Tab 组件的API介绍 2、通过LayaAirIDE创建Tab组件 2.1 创建Tab 点击选择资源管理器里的 Tab 组件资源，拖拽到场景编辑器，即在页面中成功的创建了一个 Tab组件。如动图3所示。 （动图3） 2.2 通过labels增加标签 如动图3中所示，默认的Tab组件中只有两个标签。如想增加标签，只需在labels属性中增加新的标签即可，修改标签中的文本内容也在该属性中设置，操作如动图4-1所示。 (动图4-1) 2.3 改变Tab组件的布局方向与间距 Tab组件 默认是水平布局（horizontal），通过更改direction属性，实现垂直布局（vertical）。设置间距可以通过space属性实现。如动图4-2所示。 （动图4-2） 2.4 设置单选框组Tab的默认选项 SelectedIndex属性是用于改变Tab组件的索引值，默认不设置时，不选择任何选项，如果要设置Tab组件的默认标签选项，可以设置SelectedIndex的属性值，0为第1个标签，1为第2个标签……以此类推。运行效果如动图4-3所示。 （动图4-3） 3、代码创建Tab组件 代码运行结果： const { regClass, property } = Laya; @regClass() export class UI_Tab extends Laya.Script { private skins: any[] = [\"resources/res/ui/tab1.png\", \"resources/res/ui/tab2.png\"]; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { Laya.loader.load(this.skins).then( ()=>{ this.onLoadComplete(); } ); } private onLoadComplete(e: any = null): void { var tabA: Laya.Tab = this.createTab(this.skins[0]); tabA.pos(40, 120); tabA.labelColors = \"#000000,#d3d3d3,#333333\"; var tabB: Laya.Tab = this.createTab(this.skins[1]); tabB.pos(40, 220); tabB.labelColors = \"#FFFFFF,#8FB299,#FFFFFF\"; } private createTab(skin: string): Laya.Tab { var tab: Laya.Tab = new Laya.Tab(); tab.skin = skin; tab.labelBold = true; tab.labelSize = 20; tab.labelStrokeColor = \"#000000\"; tab.labels = \"Tab Control 1,Tab Control 2,Tab Control 3\"; tab.labelPadding = \"0,0,0,0\"; tab.selectedIndex = 1; this.onSelect(tab.selectedIndex); tab.selectHandler = new Laya.Handler(this, this.onSelect); this.owner.addChild(tab); return tab; } private onSelect(index: number): void { console.log(\"当前选择的标签页索引为 \" + index); } } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-24 14:53:15 "},"IDE/uiEditor/uiComponent/ViewStack/readme.html":{"url":"IDE/uiEditor/uiComponent/ViewStack/readme.html","title":"导航容器组件","keywords":"","body":"ViewStack 组件详解1、了解ViewStack组件1.1 ViewStack组件的作用1.2 ViewStack组件的资源（skin）规范1.3 ViewStack组件的API介绍2、通过LayaAirIDE创建ViewStack组件2.1 创建ViewStack页面2.2 设置ViewStack的页面索引selectedIndex2.3 创建控制用Tab标签3、通过代码控制ViewStack组件切换显示ViewStack 组件详解 由于很多组件属性是通用的，常用及通用的组件属性在属性设置器文档中已进行介绍。阅读本篇内容前请先阅读《属性设置器》文档。另外，本篇中会涉及一些Tab组件知识，请先阅读Tab组件详解的文档。 1、了解ViewStack组件 1.1 ViewStack组件的作用 ViewStack组件主要用于多页面视图切换。它包含多个子页面，但默认只显示一个，可以通过子页面索引进行显示切换。一般情况我们用它与Tab标签组合制作标签切换页面。如动图1所示。 （动图1） 1.2 ViewStack组件的资源（skin）规范 ViewStack组件是容器类组件，没有独立的组件资源规范。本例中直接采用的是image组件资源，在实际的游戏开发中，可以根据实际开发需求使用各种UI组件。 1.3 ViewStack组件的API介绍 2、通过LayaAirIDE创建ViewStack组件 2.1 创建ViewStack页面 2.1.1 准备美术资源 准备好页面背景图以及需要切换的页面美术资源，放到LayaAirIDE资源管理器对应的项目目录中。 2.1.2 为页面背景图片设置九宫格 弹出框的页面背景通常会采用九宫格，这里我们先将背景的九宫格属性设置好。如动图2-1所示。 (动图2-1) 2.1.3 创建页面背景 将刚刚设置过九宫格的背景图拖拽到场景编辑器中。如动图2-2所示。 (动图2-2) 2.1.4 创建ViewStack页面 将页面中涉及的UI基础组件拖拽到ui文件的场景编辑器。如动图3-1所示。 (动图3-1) 2.1.5 设置ViewStack组件的子页面name属性 ViewStack子页面name属性的命名规则为item0、item1、item2.....”如果有更多页面以此类推，如动图3-2所示，不按此规则增加name属性，生成的ViewStack组件为无效组件，不能正常运行。 (动图3-2) Tips：Dectare Var属性那里字符必须为item,不能改为其它。当修改完退出ViewStack子页面后，默认只显示item0时为正常，否则ViewStack组件没有生效。 2.1.6 调整页面的UI布局 设置好Dectare Var属性后，可以双击进入veiwStack组件内，先把子页面的UI布局调整好。本例中，我们仅将不同页面用到的资源大小、位置调整好，并让三个子页面居中对齐。效果如图3-3所示。 （图3-3） 2.2 设置ViewStack的页面索引selectedIndex ViewStack组件默认显示name属性为item0的图片，因为控制默认索引的属性selectedIndex默认值为0。我们可以通过调整selectedIndex属性值来改变ViewStack组件的默认显示页面。效果如动图4所示。 （动图4） Tips： ViewStack组件的Var值必须要设置，在编写代码时需要通过Var声名的全局变量来控制ViewStack组件，从而改变selectedIndex的属性，实现页面的切换。本例中采用的是viewStack，如动图4右上角所示，开发者也可以取别的名字。 2.3 创建控制用Tab标签 ​ 通常，ViewStack组件需要一个相应的控制标签，我们创建一个Tab标签来控制ViewStack的子页面切换显示。 ​ 点击选择资源面板里的 Tab 组件，拖拽到UI页面的场景编辑器生成 Tab 组件。 Tab 组件的美术资源如图5所示，它与上图中的背景风格配套。 ​ ​ （图5） ​ Tab 组件拖拽到编辑器后，调位置与背景图适配对齐。设置公用属性var为tab，用于程序调用控制。设置常用属性labels为“雪人,糖罐,绿树”， 选择的按钮索引selectedIndex 为0。再设置其他属性中的字体大小、粗体、字体状态颜色等。 ​ 显示效果如图6所示： ​ ​ （图6） 3、通过代码控制ViewStack组件切换显示 ​ 在上面几个制作步骤中，我们完成了在IDE里的组件创建与组合，下面我们通过程序代码把Tab标签和ViewStack的子页面切换显示关联起来。 ​ 保存页面，按F12发布页面，发布后生成在layaUI.max.all.ts文件中，我们直接使用它。 创建ComponentDemo.ts并设置默认程序，编写代码如下： // 程序入口 class ComponentDemo{ /**包含tab与viewStack组件的测试页面**/ private comp:ui.ComponentDemoUI; constructor() { Laya.init(1334,750, Laya.WebGL); Laya.stage.scaleMode = \"full\"; Laya.stage.bgColor = \"#ffffff\"; //加载图集成功后，执行onLoaded回调方法 Laya.loader.load(\"res/atlas/comp.atlas\",Laya.Handler.create(this,this.onLoaded)); } private onLoaded():void{ //创建一个UI实例 this.comp = new ui.ComponentDemoUI(); //添加到舞台上显示 Laya.stage.addChild(this.comp); //点击Tab选择按钮的处理 this.comp.tab.selectHandler = new Laya.Handler(this,this.onSelecte); } /**根据选择tab的索引切换页面**/ private onSelecte(index:number):void{ //切换ViewStack子页面 this.comp.viewStack.selectedIndex=index; } } new ComponentDemo(); 运行示例代码，效果如动图10所示。 （动图10） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-24 14:53:15 "},"IDE/uiEditor/uiComponent/ColorPicker/readme.html":{"url":"IDE/uiEditor/uiComponent/ColorPicker/readme.html","title":"取色器组件","keywords":"","body":"ColorPicker组件参考1、ColorPicker组件创建2、ColorPicker属性介绍3、代码创建ColorPickerColorPicker组件参考 Author: 诗换花 ColorPicker继承自UIComponent，ColorPicker组件将显示包含多个颜色样本的列表，用户可以从中选择颜色，如动图1所示。 1、ColorPicker组件创建 使用LayaAirIDE创建ColorPicker，步骤：鼠标右键单击Scene2D，然后找到UI，鼠标左键点击ColorPicker即可创建完毕，如图2所示。 （图2） 也可以从IDE资源管理右侧组件面板的UI文件夹中，将ColorPicker组件拖拽到UI页面中，如动图3所示。 （动图3） 2、ColorPicker属性介绍 （图4） 属性 功能 bgcolor 面板背景颜色。 bordercolor 面板边框颜色。 inputbgcolor 面板文本背景颜色。 inputcolor 面板文本字体颜色。 selectedcolor ColorPicker当前所选择的颜色。 ColorPicker组件在拿到颜色值后，就可以项目里进行赋值，在IDE的可视化操作下非常的简单，点击所需要调整的颜色，在颜色面板中自行选择即可，如图5所示。 （图5） 可以在颜色面板中输入所获得的颜色的值，如图6所示。 （图6） 3、代码创建ColorPicker 代码运行结果： const { regClass, property } = Laya; @regClass() export class UI_ColorPicker extends Laya.Script { private skin: string = \"resources/res/ui/colorPicker.png\"; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { Laya.loader.load(this.skin).then( ()=>{ this.onColorPickerSkinLoaded(); } ); } private onColorPickerSkinLoaded(e: any = null): void { var colorPicker: Laya.ColorPicker = new Laya.ColorPicker(); colorPicker.selectedColor = \"#ff0033\"; colorPicker.skin = this.skin; colorPicker.pos(100, 100); colorPicker.changeHandler = new Laya.Handler(this, this.onChangeColor, [colorPicker]); this.owner.addChild(colorPicker); this.onChangeColor(colorPicker); } private onChangeColor(colorPicker: Laya.ColorPicker, e: any = null): void { console.log(colorPicker.selectedColor); } } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-24 14:53:15 "},"IDE/uiEditor/View/readme.html":{"url":"IDE/uiEditor/View/readme.html","title":"UI视图","keywords":"","body":"View组件参考1、创建View组件2、View属性介绍View组件参考 View是视图组件， 常用于预制体场景的根节点。 1、创建View组件 创建View组件非常简单，步骤是右键单击Scene2D，找到UI，点击View即可创建完毕，如图1所示。 （图1） 也可以从IDE资源管理右侧组件面板的UI文件夹中，将View组件拖拽到UI页面中，如动图2所示。 （动图2） 如果想将view作为根节点使用，可以在项目面板鼠标右键单击assets，找到Create，点击2D Prefab即可创建完毕，如图3所示。 （图3） 2、View属性介绍 View并没有自己专属的属性。 （图4） View作为视图组件，在创建面板时会用到，与Scence不同的是View增加了相对布局，所以在需要屏幕适配和相对布局时推荐使用View。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:52 "},"IDE/uiEditor/View/Dialog/readme.html":{"url":"IDE/uiEditor/View/Dialog/readme.html","title":"UI弹窗","keywords":"","body":"Dialog组件参考1、Dialog组件创建2、Dialog属性介绍2.1 Drag Area属性2.2 Is Modal属性2.3 Is Show Effect 属性2.4 Is Popup Center属性3、代码创建Dialog组件Dialog组件参考 Dialog继承于View，主要用于弹窗面板， 1、Dialog组件创建 Dialog组件可以通过IDE的可视化操作直接进行创建，步骤为右键单击Scene2D，找到UI，点击Dialog即可创建完毕，如图1所示。 （图1） 也可以从IDE资源管理右侧组件面板的UI文件夹中，将Dialog组件拖拽到UI页面中，如动图2所示 （动图2） Dialog的弹窗效果需要将它作为根节点使用，可以在项目面板鼠标右键单击assets，找到Create，点击Prefab 2D，右键单击View，点击Change Type点击UI，点击Dialog即可创建完毕，如图3、动图4所示。创建完毕之后，需要用代码将Dialog与所需要用到该Dialog的场景管关联起来，以下代码块为例。 Laya.Scene.open(\"Prefab2D.lh\"); （图3） （动图4） 2、Dialog属性介绍 (图5) 属性 功能 dragarea 拖动区域（格式：x，y，width，height），默认值为\"0,0,0,0\"。 ismodal 是否是模式窗口，默认为不开启状态。 isshoweffect 是否显示弹出效果，默认为开启状态。 ispopupcenter 指定对话框是否居中弹出，默认为开启状态。 group 组名称。 2.1 Drag Area属性 在设置Drag Area属性后，可以在设置的数值范围内对Dialog进行拖动，默认为不设置，不设置即为不可拖动，如动图6所示。 （动图6） 在设置后只可以在设置的数值内拖动，在超出数值内的区域拖动是无效的，如动图6所示。 2.2 Is Modal属性 因为Dialog是弹窗，所以要设置弹窗的下层级是否可以进行点击，默认情况下是可以点击的，如果不想开启可自行关闭，关闭后即为不可点击状态（即不可穿透）。 2.3 Is Show Effect 属性 在开启Is Show Effect 属性后，就可以实现Dialog组件的弹窗效果了，下面我们来展示下它的弹窗效果，如动图7所示。 （动图7） 2.4 Is Popup Center属性 在开启 Is Popup Center 属性后，我们的弹窗就会居中显示，来看下效果，如动图8所示。 （动图8） 3、代码创建Dialog组件 代码运行结果： const { regClass, property } = Laya; @regClass() export class UI_Dialog extends Laya.Script { private DIALOG_WIDTH: number = 220; private DIALOG_HEIGHT: number = 275; private CLOSE_BTN_WIDTH: number = 43; private CLOSE_BTN_PADDING: number = 5; private assets: any[]; private dialog: Laya.Dialog; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { this.assets = [\"resources/res/ui/dialog (1).png\", \"resources/res/ui/close.png\"]; Laya.loader.load(this.assets).then( ()=>{ this.onSkinLoadComplete(); } ); } private onSkinLoadComplete(e: any = null): void { this.dialog = new Laya.Dialog(); var bg: Laya.Image = new Laya.Image(this.assets[0]); this.dialog.addChild(bg); var button: Laya.Button = new Laya.Button(this.assets[1]); button.name = Laya.Dialog.CLOSE; button.pos(this.DIALOG_WIDTH - this.CLOSE_BTN_WIDTH - this.CLOSE_BTN_PADDING, this.CLOSE_BTN_PADDING); this.dialog.addChild(button); this.dialog.dragArea = \"0,0,\" + this.DIALOG_WIDTH + \",\" + this.DIALOG_HEIGHT; this.dialog.show(); } onDestroy(): void { if (this.dialog) { this.dialog.close(); } } } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:52 "},"IDE/uiEditor/uiComponent/skeleton/readme.html":{"url":"IDE/uiEditor/uiComponent/skeleton/readme.html","title":"骨骼动画","keywords":"","body":"骨骼动画骨骼动画 LayaAir引擎的骨骼动画包括两大类， 一种是将第三方的骨骼（龙骨与Spine）转换为引擎内置的骨骼动画文件格式。 另一种是直接封装Spine的骨骼动画动行库。 内置的骨骼动画性能更佳，但受转换工具的版本限制，仅支持3.8以前的spine版本。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:53 "},"IDE/uiEditor/uiComponent/skeleton/spine/readme.html":{"url":"IDE/uiEditor/uiComponent/skeleton/spine/readme.html","title":"Spine骨骼动画","keywords":"","body":"Spine骨骼动画一、概述二、IDE中使用Spine动画2.1 将spine资源复制到项目中2.2 在场景中添加spine动画组件2.3 设置动画资源2.4 IDE中预览动画2.5 动画基础操作三、代码中Spine动画Spine骨骼动画 一、概述 Spine骨骼动画，是游戏中经常使用的骨骼动画之一，使用Spine工具通过将图片绑定到骨骼上，然后再控制骨骼实现动画。 如何制作Spine骨骼动图，在这里就不介绍了，感兴趣的开发者可以到 Spine 官网查看。http://zh.esotericsoftware.com/ LayaAir IDE中支持Spine骨骼动画的添加，预览和运行。使用之前，需要在 IDE 中勾选类库，和选择 Spine 的版本 （图1-1） 1，勾选 laya.ani 类库 2，勾选 laya.spine 类库 3，选择此项目使用的 Spine 版本 目前LayaAir 支持 3.7，3.8和4.0版本，接下来我们会通过使用3.8版本的Spine动画来讲解IDE中的使用 二、IDE中使用Spine动画 2.1 将spine资源复制到项目中 如图2-1所示，我们将做好的Spine动画资源放入 assets 目录下，这里我们用Spine官网下载的示例展示 （图2-1） 2.2 在场景中添加spine动画组件 IDE中通过两种方式，可以在场景中添加Spine动画组件 1，直接拖入Spine动画组件，如动图2-2所示 （动图2-2） 2，通过Scene2D或者任何节点下，创建Spine动画组件，如动图2-3所示 （动图2-3） 此时 Spine 动画组件就准备好了，下一步可以拖入动画资源了 2.3 设置动画资源 我们先来看看Spine动画组件，都有什么属性，如图2-4所示 （图2-4） Source：spine动画的配置文件，也就是 .skel 文件 Skin Name：骨骼动画名称 Animation Name：播放动画名称 Loop：是否循环播放 Preview：在IDE中预览 首先，我们把 .skel 文件拖入 Source 属性中，在IDE中将会看到动画，如动图2-5所示 （动图2-5） 2.4 IDE中预览动画 通过勾选Preview选项，我们就可以在IDE中直接预览Spine动画效果，如动图2-6所示 （动图2-6） 同时，勾选Loop可以设置是否循环动画，也可以选择动画名字来切换动画 2.5 动画基础操作 在IDE中，可以对动画的位置，大小，缩放进行基础操作，如动图2-7所示 （动图2-7） 三、代码中Spine动画 在代码中使用时，我们在使用Spine时需要引用指定的类有Laya.SpineSkeleton、Laya.SpineTemplet 其中，Laya.SpineSkeleton是spine骨骼动画必须要引用的类，这里封装了spine的runtime库。Laya.SpineTemplet是用于资源处理。 代码示例： const { regClass, property } = Laya; @regClass() export class Main extends Laya.Script { private skeleton: Laya.SpineSkeleton; private index: number = -1; onStart() { console.log(\"Game start\"); //加载Spine动画资源 Laya.loader.load(\"spine/spineboy-pma.skel\", Laya.Loader.SPINE).then((templet: Laya.SpineTemplet) => { //创建SpineSkeleton对象 this.skeleton = new Laya.SpineSkeleton(); this.skeleton.templet = templet; this.owner.addChild(this.skeleton); this.skeleton.pos( Laya.stage.width / 2, Laya.stage.height / 2 + 100); this.skeleton.scale(0.4, 0.4); this.skeleton.on(Laya.Event.STOPPED, this, this.play); this.play(); }); } //播放Spine动画 private play(): void { if (++this.index >= this.skeleton.getAnimNum()) { this.index = 0 } this.skeleton.play(this.index, false, true) } } 具体效果大家可以在LayaAir 2D入门示例中查看。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:54 "},"IDE/uiEditor/uiComponent/skeleton/sk/readme.html":{"url":"IDE/uiEditor/uiComponent/skeleton/sk/readme.html","title":"内置骨骼动画","keywords":"","body":"内置骨骼动画一、概述二、IDE中使用内置骨骼动画2.1 将动画资源复制到项目中2.2 在场景中添加内置骨骼动画组件2.3 设置动画资源2.4 IDE中预览动画2.5 动画基础操作三、代码中内置骨骼动画内置骨骼动画 一、概述 Spine骨骼动画，DragonBones（龙骨）骨骼动画，都是游戏中经常使用的骨骼动画，使用LayaAir内置骨骼转换工具，可以将这两种格式转换为LayaAir引擎支持的骨骼动画格式。 LayaAir IDE中支持骨骼动画的添加，预览和运行。使用之前，需要在 IDE 中勾选 laya.ani 类库，如图1-1所示 （图1-1） 二、IDE中使用内置骨骼动画 2.1 将动画资源复制到项目中 如图2-1所示，我们将做好的动画资源放入 assets 目录下 （图2-1） 2.2 在场景中添加内置骨骼动画组件 IDE中通过两种方式，可以在场景中添加内置骨骼动画组件 1，直接拖入骨骼动画组件，如动图2-2所示 （动图2-2） 2，通过Scene2D或者任何节点下，创建骨骼动画组件，如动图2-3所示 （动图2-3） 此时骨骼动画组件就准备好了，下一步可以拖入动画资源了 2.3 设置动画资源 我们先来看看骨骼动画组件，都有什么属性，如图2-4所示 （图2-4） Source：骨骼动画的配置文件，也就是 .sk 文件 Skin Name：骨骼动画名称 Animation Name：播放动画名称 Loop：是否循环播放 Preview：在IDE中预览 首先，我们把 .sk 文件拖入 Source 属性中，在IDE中将会看到动画，如动图2-5所示 （动图2-5） 2.4 IDE中预览动画 通过勾选Preview选项，我们就可以在IDE中直接预览骨骼动画效果，如动图2-6所示 （动图2-6） 同时，勾选Loop可以设置是否循环动画，也可以选择动画名字来切换动画 2.5 动画基础操作 在IDE中，可以对动画的位置，大小，缩放进行基础操作，如动图2-7所示 （动图2-7） 三、代码中内置骨骼动画 在代码中使用时，我们在使用骨骼动画时需要引用指定 Laya.Skeleton 和 Laya.Templet 类 其中，Laya.Skeleton 是骨骼动画必须要引用的类，Laya.Templet 是用于处理资源 代码示例： const { regClass, property } = Laya; @regClass() export class Main extends Laya.Script { private mCurrIndex: number = 0; private mArmature: Laya.Skeleton; onStart() { console.log(\"Game start\"); //加载内置骨骼动画资源 Laya.loader.load(\"skeleton/Dragon/Dragon.sk\").then((templet: Laya.Templet) => { //创建模式为1，可以启用换装 this.mArmature = templet.buildArmature(0); this.mArmature.x = 300; this.mArmature.y = 350; this.mArmature.scale(0.5, 0.5); this.owner.addChild(this.mArmature); //设置动画播放完成后，调用completeHandler继续播放下一个动画 this.mArmature.on(Laya.Event.STOPPED, this, this.completeHandler); this.play(); }); } private completeHandler(): void { this.play(); } //播放骨骼动画 private play(): void { //每次到下一个动画 this.mCurrIndex++; if (this.mCurrIndex >= this.mArmature.getAnimNum()) { this.mCurrIndex = 0; } this.mArmature.play(this.mCurrIndex, false); } } 运行效果如下 （动图3-1） 具体效果大家可以在LayaAir 2D入门示例中查看。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:53 "},"IDE/uiEditor/graphics/readme.html":{"url":"IDE/uiEditor/graphics/readme.html","title":"绘制图形","keywords":"","body":"绘制图形一、IDE中绘制图形二、绘制矩形与圆角矩形2.1 IDE绘制矩形2.2 代码绘制矩形2.3 用drawPath绘制矩形2.4 用drawPath绘制圆角矩形三、绘制圆形与扇形3.1 IDE绘制圆形3.2 代码绘制圆形3.3 代码绘制扇形四、绘制三角形、多边形及根据数据绘制图案4.1 IDE绘制三角形，多边形4.2 代码绘制三角形4.3 代码绘制多边形4.4 根据指定的路径数据绘制出图案五、绘制直线与折线5.1 IDE绘制直线5.2 IDE绘制折线5.3 代码绘制直线5.4 代码绘制折线六、绘制曲线6.1 贝塞尔曲线的基础6.2 代码绘制二次贝塞尔曲线七、消除矢量图绘制7.1 开启锯齿消除设置绘制图形 一、IDE中绘制图形 LayaAir 中可以在Sprite对象中通过使用图形组件来绘制各种图形，我们来看一下，如动图1-1所示 （动图1-1） 在IDE中我们可以通过这些选项来绘制图形，如图1-2所示，下面将对这些图形进行讲解 （图1-2） 二、绘制矩形与圆角矩形 2.1 IDE绘制矩形 在Sprite对象的 Graphics 组件中，可以通过点击 + 来创建一个绘制图形命令，如图2-1所示，第一个选项 DrawRectCmd 为绘制矩形 （图2-1） Offset：矩形相对于Sprite对象，X轴，Y轴的偏移量 Size：矩形的尺寸 Percent：当勾选时，矩形的尺寸为Sprite对象尺寸的百分比，当不勾选时，矩形的尺寸为像素大小 Line Width：矩形线的宽度 Line Color：矩形线的颜色 Fill Color：矩形填充的颜色 通过动图2-2，我们来看看这些属性的操作过程 （动图2-2） 2.2 代码绘制矩形 Laya引擎中 laya.display.Graphics 类可以查看到该API的各种矢量绘图方法。 drawRect drawPath drawCircle drawPie drawLine drawLines drawPoly drawCurves 其中 drawRect() 方法用于绘制矢量矩形。该方法的详细说明如下 /** * 绘制矩形。 * @param x 开始绘制的 X 轴位置。 * @param y 开始绘制的 Y 轴位置。 * @param width 矩形宽度。 * @param height 矩形高度。 * @param fillColor 填充颜色，或者填充绘图的渐变对象。 * @param lineColor （可选）边框颜色，或者填充绘图的渐变对象。 * @param lineWidth （可选）边框宽度。 * @param percent 位置和大小是否是百分比值。 */ drawRect(x: number, y: number, width: number, height: number, fillColor: any, lineColor: any = null, lineWidth: number = 1, percent?: boolean): DrawRectCmd { return this.addCmd(DrawRectCmd.create(x, y, width, height, fillColor, lineColor, lineWidth, percent)); } 代码示例： let sp = new Laya.Sprite(); //画矩形 sp.graphics.drawRect(20, 20, 100, 50, \"#ffff00\", \"#00ff00\", 5, false); this.owner.addChild(sp); 示例中的 20，20 是矩形起始点坐标，100是向右的宽度，如果是负数则是向左的宽度。50是向下的高度，如果是负数则是向上的高度。大家可以在编写代码中，自行调整参数进行体验。 运行效果： （图2-3） 2.3 用drawPath绘制矩形 LayaAir引擎 laya.display.Graphics 类的绘制路径的方法 drawPath() 可以根据路径绘制矢量图形，来看下方法描述 /** * 绘制路径。 * @param x 开始绘制的 X 轴位置。 * @param y 开始绘制的 Y 轴位置。 * @param paths 路径集合，路径支持以下格式：[[\"moveTo\",x,y],[\"lineTo\",x,y],[\"arcTo\",x1,y1,x2,y2,r],[\"closePath\"]]。 * @param brush （可选）刷子定义，支持以下设置{fillStyle:\"#FF0000\"}。 * @param pen （可选）画笔定义，支持以下设置{strokeStyle,lineWidth,lineJoin:\"bevel|round|miter\",lineCap:\"butt|round|square\",miterLimit}。 */ drawPath(x: number, y: number, paths: any[], brush: any = null, pen: any = null): DrawPathCmd { return this.addCmd(DrawPathCmd.create(x, y, paths, brush, pen)); } 代码示例： //自定义路径 var path:Array = [ [\"moveTo\", 0, 0], //画笔移到A点 [\"lineTo\", 100, 0],//画到B点 [\"lineTo\", 100, 50],//再画到C点 [\"lineTo\", 0, 50], //继续画到D点 [\"closePath\"] //闭合路径 ]; //绘制矩形 sp.graphics.drawPath(20, 20, path, {fillStyle: \"#ff0000\"}); drawPath 第一和第二位的坐标点“20,20”是控制整体位置的起始位置，第三位是路径参数。描述信息 MoveTo 是将画笔移动初始位置，此时并没有开始画。”0,0”是相对于”20,20”这个起始位置的，所以A点还是在起始位置原点。描述信息 lineto 是绘制到路径点坐标，“100，0”这个就是绘制到B点位置的坐标。C点和D点以此类推，最后通过描述信息 closePath 与MoveTo的起点位置闭合，否则是不会被闭合的。 从绘制矩形来看，drawPath 方法肯定没有 drawRect 方法更加方便。但是大家可以通过这个示例理解相关的参数用法。至于其它非圆角的图形，大家可自行编码，通过调整参数体验。 运行效果： （图2-4） 2.4 用drawPath绘制圆角矩形 LayaAir引擎中可以使用 graphics 的 drwaPath 方法绘制圆角或弧线，具体的操作需要三步，指定绘制路径的起始点 [\"moveTo\", x, y]、绘制一条水平直线[\"lineTo\", x, y]、绘制弧线 [\"arcTo\", p1.x, p1.y, p2.x, p2.y, r]。 2.4.1 参数示例 [\"moveTo\", 50, 50],[\"lineTo\", 150, 50],[\"arcTo\", 200, 50, 200, 100, 50], 上述参数运行效果图如2-5所示： （图2-5） 通过图2-5我们可以看出，[\"moveTo\", 50, 50] 将画笔的起始点定位于\"50,50\"这个位置。[\"lineTo\", 150, 50] 绘制了一条由于起始点到当前端点（”150, 50“）的直线。[\"arcTo\", 200, 50, 200, 100, 50] 绘制了一段r（半径）为50弧线。 2.4.2 弧线绘制原理 在制作这段弧线时，这个弧其实是利用当前端点\"150, 50\"、端点1\"200, 50\"、端点2\"200, 100\"，这三个端点所形成的夹角，制作一条半径为50px并且与两边相切的圆上的一段弧线。 如果我们已经理解了弧线的绘制原理，我们还会发现，构成弧线的核心要素为两条边和与两边形成夹角的顶点（上例中的端点1），图2-5中的端点2与端点1形成的x轴边比较好理解，那当前端点与端点1已经构成了y轴边，那与当前端点在同一个y轴的起始点是不是可以去掉呢，事实并不可以，画笔的起始点必须存在，但是绘制直线的lineTo可以去掉，如果[\"lineTo\", 150, 50],被注释掉，那么arcTo绘制弧线的时候，会视起始点为当前端点，arcTo找不到lineTo绘制的直线时，会自动添加一条由起始点到弧线起点的直线，因此，绘制圆角矩形时，lineTo可以省略。 2.4.3 绘制圆角矩形示例 下面我们绘制一个圆角弧线半径为30的圆角矩形，示例代码如下： //自定义路径 var path:any[] = [ [\"moveTo\", 0, 0], //画笔的起始点， [\"lineTo\",400,0], [\"arcTo\", 500, 0, 500, 30, 30], //p1（500,0）为夹角B，（500,30）为端点p2 [\"lineTo\",500,200], [\"arcTo\", 500, 300, 470, 300, 30],//p1（500,300）为夹角C，（470,300）为端点p2 [\"lineTo\",30,300], [\"arcTo\", 0, 300, 0, 270, 30], //p1(0,300)为夹角D，（0,270）为端点p2 [\"lineTo\",0,100], [\"arcTo\", 0, 0, 30, 0, 30],//p1(0,0)为夹角A，（30,0）为端点p2 ]; //绘制圆角矩形 sp.graphics.drawPath(100, 100, path, {fillStyle: \"#ff0000\"}); 代码运行效果： （图2-6） 在上面的代码里，看起来没有任何问题，其实moveTo的起始点，需要在圆弧之间的直线上，下面我们只需要在 drawPath 绘制时，增加一个边框线，就可以清楚的看出错误。绘制方法 graphics.drawPath 修改为： //绘制圆角矩形 this.sp.graphics.drawPath(100, 100, path, {fillStyle: \"#ff0000\"},{\"strokeStyle\":\"#ffffff\",\"lineWidth\":\"10\"}); 修改后运行效果如图2-7所示，由于画线的时候，从画笔的起始点0,0开始的，所以并不是我们想要的结果。 （图2-7） 下面我们将示例修改为正确的代码： //自定义路径 var path:any[] = [ [\"moveTo\", 30, 0], //画笔的起始点， [\"lineTo\",400,0], [\"arcTo\", 500, 0, 500, 30, 30], //p1（500,0）为夹角B，（500,30）为端点p2 [\"lineTo\",500,200], [\"arcTo\", 500, 300, 470, 300, 30],//p1（500,300）为夹角C，（470,300）为端点p2 [\"lineTo\",30,300], [\"arcTo\", 0, 300, 0, 270, 30], //p1(0,300)为夹角D，（0,270）为端点p2 [\"lineTo\",0,100], [\"arcTo\", 0, 0, 30, 0, 30],//p1(0,0)为夹角A，（30,0）为端点p2 ]; //绘制圆角矩形 sp.graphics.drawPath(100, 100, path, {fillStyle: \"#ff0000\"},{\"strokeStyle\":\"#ffffff\",\"lineWidth\":\"10\"}); 运行效果如图2-8所示： （图2-8） 三、绘制圆形与扇形 3.1 IDE绘制圆形 绘制圆形的操作与绘制矩形一样，只不过在Graphics组件下点击 DrawCircleCmd ，如图3-1所示 （图2-1） Offset：圆形相对于Sprite对象，X轴，Y轴的偏移量 Radius：圆形相对于Sprite对象的尺寸 Percent：当勾选时，圆形的Offset和Radius为Sprite对象尺寸的百分比，当不勾选时，圆形的尺寸为像素大小 Line Width：圆形线的宽度 Line Color：圆形线的颜色 Fill Color：圆形填充的颜色 3.2 代码绘制圆形 drawCircle() 方法用于绘制矢量圆形。该方法的详细说明如下 /** * 绘制圆形。 * @param x 圆点X 轴位置。 * @param y 圆点Y 轴位置。 * @param radius 半径。 * @param fillColor 填充颜色，或者填充绘图的渐变对象。 * @param lineColor （可选）边框颜色，或者填充绘图的渐变对象。 * @param lineWidth （可选）边框宽度。 */ drawCircle(x: number, y: number, radius: number, fillColor: any, lineColor: any = null, lineWidth: number = 1): DrawCircleCmd { return this.addCmd(DrawCircleCmd.create(x, y, radius, fillColor, lineColor, lineWidth)); } 代码示例： //画圆 sp.graphics.drawCircle(80,80,50,\"#ff0000\"); 圆形绘制比较简单，“80，80”是圆形中心点坐标。50是半径，”#ff0000”是圆形填充颜色值。 运行效果： （图3-2） 3.3 代码绘制扇形 下面继续延伸，介绍一下比圆形稍复杂一点的扇形绘制方法 drawPie() 该方法的详细说明如下 /** * 绘制扇形。 * @param x 开始绘制的 X 轴位置。 * @param y 开始绘制的 Y 轴位置。 * @param radius 扇形半径。 * @param startAngle 开始角度。 * @param endAngle 结束角度。 * @param fillColor 填充颜色，或者填充绘图的渐变对象。 * @param lineColor （可选）边框颜色，或者填充绘图的渐变对象。 * @param lineWidth （可选）边框宽度。 */ drawPie(x: number, y: number, radius: number, startAngle: number, endAngle: number, fillColor: any, lineColor: any = null, lineWidth: number = 1): DrawPieCmd { return this.addCmd(DrawPieCmd.create(x, y, radius, Utils.toRadian(startAngle), Utils.toRadian(endAngle), fillColor, lineColor, lineWidth)); } 代码示例： //画扇形 sp.graphics.drawPie(80,80,50,90,180,\"#ff0000\"); 代码运行效果如下图所示： （图3-3） 绘制扇形与圆形类似，前三个参数的用法也是一样的，只是增加了绘制开始与结束的角度。为了让大家更好的理解，扇形的绘制代码与参数沿用圆形代码示例，除了方法名的改变，只增加了90与180两个角度参数。大家可在编码过程中通过调整参数，再深入理解。 四、绘制三角形、多边形及根据数据绘制图案 4.1 IDE绘制三角形，多边形 绘制三角形的操作与绘制矩形一样，只不过在Graphics组件下点击 DrawPolyCmd ，如图4-1所示 （图4-1） Offset：多边形相对于Sprite对象，X轴，Y轴的偏移量，单位是像素 Points：多边形的点集合，三角形也是一个多边形，只不过是3个点 Line Width：多边形的宽度 Line Color：多边形的颜色 Fill Color：多边形填充的颜色 通过动图4-2，我们来看以下如何创建一个多边形 （动图4-2） 4.2 代码绘制三角形 在绘制三角形、多边形以及根据指定的路径数据绘制出图案均可使用LayaAir引擎中 laya.display.Graphics 类的 drawpoly() 方法实现。该方法的详细说明如下 /** * 绘制多边形。 * @param x 开始绘制的 X 轴位置。 * @param y 开始绘制的 Y 轴位置。 * @param points 多边形的点集合。 * @param fillColor 填充颜色，或者填充绘图的渐变对象。 * @param lineColor （可选）边框颜色，或者填充绘图的渐变对象。 * @param lineWidth （可选）边框宽度。 */ drawPoly(x: number, y: number, points: any[], fillColor: any, lineColor: any = null, lineWidth: number = 1): DrawPolyCmd { return this.addCmd(DrawPolyCmd.create(x, y, points, fillColor, lineColor, lineWidth)); } 代码示例： //画三角形 sp.graphics.drawPoly(30, 28, [0, 100, 50, 0, 100, 100], \"#ffff00\"); 运行效果： （图4-3） 通过代码，我们可以看出，drawPoly 第三位参数的“0，100”是A点坐标。“50，0”是B点坐标。“100, 100”是C点坐标，将三个坐标点连接后填充第四位参数的颜色值，即绘制出上图的黄色三角形。但是这里需要大家理解和注意的是，第三位参数中所有的坐标都是相对坐标，都会受到第一位和第二位坐标参数“30，28”的影响。一旦“30，28”产生改变，整体形状位置都会受到影响。 4.3 代码绘制多边形 我们继续用上面的代码示例，通过增加 drawPoly 第三位参数的坐标，来实现多边形的绘制，修改的代码如下： //画多边形 sp.graphics.drawPoly(30, 28, [0, 100, 50, 0, 100, 100, 75, 150, 25, 150], \"#ffff00\"); 代码运行效果如下图所示： （图4-4） 在修改的代码中，新增了D点坐标”75，150“与E点坐标”25，150“。通过将各个坐标点连接填充颜色后，即绘制出我们想要的多边形。要绘制更多边的多边形，按上述方式增加坐标点即可。 4.4 根据指定的路径数据绘制出图案 通过上面的三角形和多边形，我们已经掌握了 drawPoly 的绘图用法，下面再通过示例深入介绍一下，如何指定路径绘制一个五角星。示例代码如下： //画五角星 var path: Array = []; path.push(0, -130);//五角星A点坐标 path.push(33, -33);//五角星B点坐标 path.push(137, -30);//五角星C点坐标 path.push(55, 32);//五角星D点坐标 path.push(85, 130);//五角星E点坐标 path.push(0, 73);//五角星F点坐标 path.push(-85, 130);//五角星G点坐标 path.push(-55, 32);//五角星H点坐标 path.push(-137, -30);//五角星I点坐标 path.push(-33, -33);//五角星J点坐标 sp.graphics.drawPoly(Laya.stage.width / 2, Laya.stage.height / 2, path, \"#FF7F50\"); 代码运行效果如下图所示： （图4-5） 通过上面的示例代码的写法，是不是感觉代码的可读性得到了增强，大家也可以将之前的三角形或多边形改成这种方式去体验一下，掌握了这些基础，可以衍生出很多灵活的用法。 五、绘制直线与折线 5.1 IDE绘制直线 绘制直线的操作与绘制矩形一样，只不过在Graphics组件下点击 DrawLineCmd ，如图5-1所示 （图5-1） From：线的起始点，相对于Sprite对象，X轴，Y轴的偏移量 To：线的终点，相对于Sprite对象，X轴，Y轴的偏移量 Percent：当勾选时，线的起始点和终点为Sprite对象尺寸的百分比，当不勾选时，线的起始点和终点为像素点 Line Width：线的宽度 Line Color：线的颜色 5.2 IDE绘制折线 绘制折线的操作与绘线一样，只不过在Graphics组件下点击 DrawLinesCmd ，如图5-2所示 （图5-2） Offset：线段相对于Sprite对象，X轴，Y轴的偏移量，单位是像素 Points：线段的点集合 Line Width：线的宽度 Line Color：线的颜色 5.3 代码绘制直线 Laya引擎中 laya.display.Graphics 类中 drawLine() 方法用于绘制直线。该方法的详细说明如下 /** * 绘制一条线。 * @param fromX X轴开始位置。 * @param fromY Y轴开始位置。 * @param toX X轴结束位置。 * @param toY Y轴结束位置。 * @param lineColor 颜色。 * @param lineWidth （可选）线条宽度。 */ drawLine(fromX: number, fromY: number, toX: number, toY: number, lineColor: string, lineWidth: number = 1): DrawLineCmd { return this.addCmd(DrawLineCmd.create(fromX, fromY, toX, toY, lineColor, lineWidth)); } 代码示例： //画直线 sp.graphics.drawLine(10, 58, 146, 58, \"#ff0000\", 3); 运行效果： （图5-3） 5.4 代码绘制折线 那么如何绘制折线呢？直接使用 drawLines() 方法即可。该方法与 drawLine 比较像，编码时千万不要漏掉了末尾的“s”。drawLines 的参数详细说明如下 /** * 绘制一系列线段。 * @param x 开始绘制的X轴位置。 * @param y 开始绘制的Y轴位置。 * @param points 线段的点集合。格式:[x1,y1,x2,y2,x3,y3...]。 * @param lineColor 线段颜色，或者填充绘图的渐变对象。 * @param lineWidth （可选）线段宽度。 */ drawLines(x: number, y: number, points: any[], lineColor: any, lineWidth: number = 1): DrawLinesCmd | null { if (!points || points.length 代码示例： //画折线 sp.graphics.drawLines(20, 88, [0, 0, 39, -50, 78, 0, 120, -50], \"#ff0000\", 3); 运行效果： （图5-4） 通过代码，我们可以看出，画折线与画直线的参数区别是从第三位开始，第三位参数是Array类型的折线点集合，其中的“0，0”是折点A的起始坐标。“39，-50”是折点B的起始坐标。“78, 0”是折点C的起始坐标，“120, -50”是终点D的坐标。但是这里需要大家理解和注意的是，第三位参数中所有的坐标都是相对坐标，都会受到第一位和第二位参数的“20，88”而影响。一旦“20，88”产生改变，整体折线都会受到影响。 大家可以在实际编码的过程中，通过手动调整参数去感受区别。 六、绘制曲线 相对于直线而言，曲线的绘制与坐标关系更难理解一些。由于LayaAir引擎绘制的是贝塞尔曲线，所以本文中先针对贝塞尔曲线的基础进行说明，然后再结合引擎的API进行讲解。 6.1 贝塞尔曲线的基础 贝塞尔曲线在港澳台等地称为貝茲曲線，新加坡马来西亚等地称为贝济埃曲线。一般的矢量图形软件通过它来精确画出曲线，贝塞尔曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋，我们在绘图工具上看到的钢笔工具就是来做这种矢量曲线的。 贝塞尔曲线是应用于二维图形应用程序的数学曲线。曲线的定义有四个点：起始点、终止点（也称锚点）以及两个相互分离的中间点。滑动两个中间点，贝塞尔曲线的形状会发生变化。 基于线性、二次方、三次方等公式的不同，贝塞尔曲线也被称为一次、二次……五次贝塞尔曲线，有些文章也称为一阶、二阶……说的是一回事。下面通过动图让大家直观的理解一下： 6.1.1 一次贝塞尔曲线 （动图6-1） 说明：上图是由 P0 至 P1 的连续点， 描述的是一条线性的贝赛尔曲线。线性贝塞尔曲线函数中的 t 会经过由 P0 至 P1 的 B(t) 所描述的曲线。例如当 t=0.25 时，B(t) 即一条由点 P0 至 P1 路径的四分之一处。就像由 0 至 1 的连续 t，B(t) 描述一条由 P0 至 P1 的直线。 6.1.2 二次贝塞尔曲线 （动图6-2） （动图6-3） 说明：为建构二次贝塞尔曲线，上图由 P0 至 P1 的连续点 Q0，描述一条线性贝塞尔曲线。由 P1 至 P2 的连续点 Q1，描述一条线性贝塞尔曲线。由 Q0 至 Q1 的连续点 B(t)，描述一条二次贝塞尔曲线。 6.1.3 三次贝塞尔曲线 （动图6-4） （动图6-5） 说明：对于三次曲线，可由线性贝塞尔曲线描述的中介点 Q0、Q1、Q2，和由二次曲线描述的点 R0、R1 所建构。 6.1.4 高阶贝塞尔曲线 由于高阶贝塞尔曲线并不常见，本文将不再详细说明，想对贝塞尔曲线原理了解更多的可以查看其它相关文章。 （动图6-6） 四次贝塞尔曲线 （动图6-7） 五次贝塞尔曲线 6.2 代码绘制二次贝塞尔曲线 LayaAir引擎的曲线绘制采用的是二次贝塞尔曲线，开发者可以用 laya.display.Graphics 类的 drawCurves() 方法来绘制曲线。该方法的详细说明如下 /** * 绘制一系列曲线。 * @param x 开始绘制的 X 轴位置。 * @param y 开始绘制的 Y 轴位置。 * @param points 线段的点集合，格式[controlX, controlY, anchorX, anchorY...]。 * @param lineColor 线段颜色，或者填充绘图的渐变对象。 * @param lineWidth （可选）线段宽度。 */ drawCurves(x: number, y: number, points: any[], lineColor: any, lineWidth: number = 1): DrawCurvesCmd { return this.addCmd(DrawCurvesCmd.create(x, y, points, lineColor, lineWidth)); } 下面我们用LayaAir引擎绘制矢量曲线，示例代码如下： //画折线 sp.graphics.drawCurves(10, 58, [0, 0, 19, -100, 39, 0], \"#ff0000\", 3); 运行效果如下 （图6-8） 通过增加 drawCurves 的第三位points点集合的参数，我们可以让曲线更复杂一些，修改的示例代码如下： //增加58, 100与78, 0坐标让曲线更复杂一些 sp.graphics.drawCurves(10, 58, [0, 0, 19, -100, 39, 0, 58, 100, 78, 0], \"#ff0000\", 3) ; 运行效果如下 （图6-9） 如果想绘制更复杂的曲线，可自行调整 drawCurves 中的参数，再结合二次贝赛尔曲线原理进行理解。 最后提醒一下，与绘制折线一样，第三位参数中所有的坐标都是相对坐标，都会受到第一位和第二位参数的“10，58”而影响。一旦“10，58”产生改变，整体曲线都会受到影响。 七、消除矢量图绘制 在PC电脑的浏览器上，我们经常发现LayaAir引擎绘制的矢量图会有一些锯齿，这是由于LayaAir引擎基于性能的考虑，做的优化处理，由于移动手机端的像素密度比较大，所以在PC上看起来明显的锯齿问题，其实在移动设备上基本上看不出来。 7.1 开启锯齿消除设置 如果有追求完美的开发者，可以通过开启 Laya.Config.isAntialias=true 开设置，也可以在Project Settings 中开启，如图7-1所示 （图7-1） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:52 "},"IDE/uiEditor/Filter/readme.html":{"url":"IDE/uiEditor/Filter/readme.html","title":"UI滤镜效果","keywords":"","body":"UI滤镜效果一、概述1.1 IDE中创建滤镜1.2 同时生效二、颜色滤镜2.1 基础属性2.2 代码实现三、模糊滤镜3.1 基础属性3.2 代码实现四、发光滤镜4.1 基础属性4.2 代码实现UI滤镜效果 一、概述 滤镜，主要是用来实现图像的各种特殊效果，使图像取得最佳艺术效果。滤镜的类型有很多，但是营造不同的效果需要不同的滤镜功能。 LayaAir 引擎提供了颜色滤镜、发光(或阴影)滤镜、模糊滤镜三种效果，其中颜色滤镜支持 Canvas 与 WebGL 模式，而发光滤镜与模糊滤镜由于对性能的消耗较大，因此仅支持 WebGL 模式。 1.1 IDE中创建滤镜 在LayaAir 3.0中，除了Sprite 对象以外，你可以将滤镜应用于任何显示对象，通常我们对Image组件使用最多。如动图1.1所示，我们来看看如何在Image上使用滤镜 （动图1-1） 如图1-2所示，我们可以创建这三种滤镜 （图1-2） 1.2 同时生效 如图1-3所示，三种滤镜效果可以同时生效，开发者可以根据需要设置 二、颜色滤镜 ColorFilter 是颜色滤镜，颜色滤镜是图像后期处理中非常重要的一部分，它可以改变原有图像中的各种参数，从而在不改变图像大体的前提下，使其呈现出不同的风格。在实际操作时，颜色滤镜主要改变的参数为亮度、对比度、饱和度、色调等，整体来讲只改变颜色，并不对图像进行任何变形处理。正确地使用颜色滤镜，可以修正图像非正常曝光、缓解图片失真现象，从而突出主要细节，弱化掉一些不太好的部分。在艺术领域，颜色滤镜还被用来呈现不同的美学风格。 2.1 基础属性 如图2-1所示，颜色滤镜有5个属性 （图2-1） Color：设置滤镜色 （动图2-2） Brightness：调整亮度 （动图2-3） Contrast：调整对比度 （动图2-3） Saturation：调整饱和度 （动图2-5） Hue：调整色调 （动图2-6） 2.2 代码实现 可以直接创建 ColorFilter 类实现 import { MainBase } from \"./Main.generated\"; const { regClass, property } = Laya; @regClass() export class Main extends MainBase { onAwake() { //创建一个颜色滤镜对象 var colorFilter: Laya.ColorFilter = new Laya.ColorFilter(); //设置滤镜 this.Image.filters = [colorFilter]; //设置颜色 colorFilter.color( 0.5, 0.5, 0.5, 1 ); //设置亮度 colorFilter.adjustBrightness(-50); //设置对比度 colorFilter.adjustContrast(8); //设置饱和度 colorFilter.adjustSaturation(30); //设置对比度 colorFilter.adjustHue(-15); } } 也可以在IDE中添加 ColorFilter 后，通过组件获取 import { MainBase } from \"./Main.generated\"; const { regClass, property } = Laya; @regClass() export class Main extends MainBase { onAwake() { console.log(\"Game start\"); //获得Image的颜色滤镜对象 var colorFilter: Laya.ColorFilter = this.Image.filters[0]; //设置颜色 colorFilter.color( 0.5, 0.5, 0.5, 1 ); //设置亮度 colorFilter.adjustBrightness(-50); //设置对比度 colorFilter.adjustContrast(8); //设置饱和度 colorFilter.adjustSaturation(30); //设置对比度 colorFilter.adjustHue(-15); } } 三、模糊滤镜 BlurFilter 是模糊滤镜，就是产生模糊的效果 3.1 基础属性 如图3-1所示，模糊滤镜有1个属性 （图3-1） Strength：模糊滤镜的强度值 （动图3-2） 3.2 代码实现 直接创建 BlurFilter 类的实现方式 var blurFilter: BlurFilter = new BlurFilter(); //设置模糊强度 blurFilter.strength = 5; ape.filters = [blurFilter]; 四、发光滤镜 GlowFilter 是发光滤镜，就是创建放光效果或者阴影的效果，比如外发光 4.1 基础属性 如图4-1所示，发光滤镜有3个属性 （图4-1） Offset：X轴，Y轴方向的偏移 （动图4-2） Blur：边缘模糊的大小 （动图4-3） Color：滤镜的颜色 （动图4-4） 4.2 代码实现 直接创建 GlowFilter 类的实现方式 var glowFilter: GlowFilter = new GlowFilter(\"#ffff00\", 10, 0, 0); Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-04-18 21:03:42 "},"IDE/uiEditor/runtime/readme.html":{"url":"IDE/uiEditor/runtime/readme.html","title":"UI运行时","keywords":"","body":"UI继承类一、概述1.1 功能划分方式1.2 UI管理方式二、UI继承类2.1 IDE自动生成代码2.2 勾选UI组件声明2.3 代码中使用UI组件三、与自定义组件脚本区别3.1 继承类不同3.2 不同的生命周期3.3 不同的使用UI组件方式四、UI继承类和自定义组件脚本的混合使用4.1 简单用法4.2 高级用法UI继承类 一、概述 在项目开发过程中，开发者往往对UI的开发思路不够清晰，开发方式也多种多样，对项目的结构和使用方式会造成一定的混乱。这篇文章可以帮助开发者理清一些思路，我们会从这几个方面来展开： UI组件脚本（UI继承类、Runtime类） UI组件脚本和自定义组件脚本的区别 UI组件脚本和自定义组件脚本混合使用的高级用法 本篇之前已经介绍了所有的UI小部件，并且在《ECS组件系统》中讲解了自定义的组件脚本管理UI小部件的方式。其实还有一种UI管理方式，就是之前在《项目入口说明》中和自定义组件脚本一起介绍的UI组件脚本，虽然已经告诉大家它在IDE中创建的方式，但是并没有介绍在哪种情况下使用这种方式，所以我们先来聊一聊2D开发UI过程中会遇到的情况，再引入UI组件脚本的深入讲解。 1.1 功能划分方式 首先，我们的项目不止一套UI，就比如游戏开发来说，有登陆界面，加载界面，英雄属性界面，背包界面，战斗界面等等，那么对于这些界面的合理规划，我们建议是通过划分场景或者预制体来解决。如图1-1所示，这里有很多UI场景，因为这些UI的功能是不一样的，所以将它们划分到场景里。 （图1-1） 如图1-2所示，这里有很多Prefab（预制体），因为这些UI的功能是一样的，可以重复利用，所以划分到预制体中。 （图1-2） 所以，通常我们把每一套不同功能的UI，用场景（Scene）来规划；把能复用的功能性UI，用预制体（Prefab）来规划 。 1.2 UI管理方式 在UI开发过程中，我们会使用Image，Box，Tab等等这些LayaAir 提供的UI组件。对于一套相对复杂的UI界面来说，大量的UI组件，用自定义组件脚本的方式管理并不方便，需要每个组件都拖拽到自定义属性中，繁琐而费力。因此我们建议开发者，使用UI组件脚本来管理UI组件，后面我们再说UI组件脚本和自定义组件脚本的区别。UI组件脚本设计的目的就是在场景或者是预制体的根节点创建，能对其内部所有的组件进行更加方便的管理。 如图1-3所示，这是一套复杂的UI的预制体，是通过UI组件脚本（Runtime）进行管理的。 （图1-3） 从图1-3中可以看到，这套UI并没有使用自定义的组件脚本，而是使用UI组件脚本（Runtime），是在预制体的根节点 View上的 Runtime 属性里添加“ BagListRT.ts”代码来管理的。 二、UI继承类 UI组件脚本只能添加在Scene2D节点或2D预制体根节点的属性设置面板上的Runtime入口。如果添加在Scene2D上，它的父类就继承于Laya.Scene；如果添加在2D预制体的根节点，它的父类就继承于UI小部件的类（根据2D预制体根节点的节点类型而定）。因此，UI组件脚本就是UI继承类，也叫做 Runtime 类，可以对场景或预制体内部所有UI组件进行方便的管理。 在《项目入口说明》中已经介绍了IDE中创建UI组件脚本，下面介绍它的使用。 2.1 IDE自动生成代码 如图2-1所示，创建UI组件脚本以后，除了生成RuntimeScript.ts之外，在项目工程中看到还多了一个 RuntimeScript.generated.ts。 （图2-1） 图2-2展示了RuntimeScript.ts默认生成的代码，其类名RuntimeScript就是创建时的文件名，它在生成时自动继承于RuntimeScriptBase 类。 （图2-2） 图2-3展示了RuntimeScript.generated.ts默认生成的代码，这个类的名字为RuntimeScriptBase ，它继承了“Laya.Scene”，说明它是有场景管理能力的。 （图2-3） 注意：请不要修改这个代码，随着我们开发过程中不断添加新的UI组件、删除UI组件，这个代码会自动更新。 这个类是以runtime类名字xxx为基础进行命名，命名后的文件名就是xxx.generated.ts，类名为xxxBase。 2.2 勾选UI组件声明 在UI组件脚本中管理UI组件，需要先关联UI组件。 新建一个场景，创建一个UI组件脚本，并在场景中先添加几个UI组件（如图2-4）。 （图2-4） 要想管理这几个UI组件，需要对这些组件勾选 定义变量 选项，如动图2-5所示。 （动图2-5） 勾选 定义变量 选项后，保存场景，此时IDE会自动识别出组件的声明有变化，再看 RuntimeScript.generated.ts 代码（如图2-6），多了几个属性，正是对应于刚刚勾选的组件。 （图2-6） 通过这样操作，UI组件和代码就自动关联了。 2.3 代码中使用UI组件 此时，我们可以在UI组件脚本中，使用此场景中已经勾选过的UI组件，直接使用this.即可使用。例如下面的代码： onAwake(): void { // Button添加鼠标事件，让Image不显示 this.Button.on( Laya.Event.MOUSE_DOWN, this, ()=>{ this.Image.visible = false; }); } 运行此场景来看看效果，如动图2-7所示。 （动图2-7） UI组件脚本就已经介绍完了，再复杂的UI都可以通过勾选组件声明，让IDE自动创建关联关系，提供给 Runtime 类来使用。不需要像自定义组件脚本的方式建立关联关系，因此UI组件脚本在管理场景方面会更加方便。 三、与自定义组件脚本区别 3.1 继承类不同 UI组件脚本如果添加在Scene2D上，它的父类就继承于Laya.Scene（如图3-1）；如果添加在2D预制体的根节点，它的父类就继承于UI小部件的类，例如Laya.Box（如图3-2）。而自定义的组件脚本继承于Laya.Scirpt（如图3-3）。 （图3-1） （图3-2） （图3-3） 3.2 不同的生命周期 自定义的组件脚本的生命周期，如图3-4所示。 （图3-4） 而UI组件脚本的生命周期只有如下方法： /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 * 此方法为虚方法，使用时重写覆盖即可 */ onAwake(): void { } /** * 组件被启用后执行，比如节点被添加到舞台后 * 此方法为虚方法，使用时重写覆盖即可 */ onEnable(): void { } /** * 组件被禁用时执行，比如从节点从舞台移除后 * 此方法为虚方法，使用时重写覆盖即可 */ onDisable(): void { } /** * 销毁时执行 * 此方法为虚方法，使用时重写覆盖即可 */ onDestroy(): void { } /** * 关闭完成后，调用此方法（如果有关闭动画，则在动画完成后执行） * @param type 如果是点击默认关闭按钮触发，则传入关闭按钮的名字(name)，否则为null。 */ onClosed(type: string = null): void { } /**场景打开完成后，调用此方法（如果有弹出动画，则在动画完成后执行）*/ onOpened(param: any): void{ } 注意1：不论是Scene2D节点还是2D预制体的根节点，它们的Runtime是没有onStart、onUpdate、onLateUpdate方法的。 注意2：onOpened、onClosed方法是只有Scene2D节点的Runtime有，其它情况是没有的。 3.3 不同的使用UI组件方式 相比自定义的组件脚本，UI组件脚本可以直接使用UI定义的属性（通过IDE内勾选定义变量，因此它也不需要@property装饰器暴露属性），然后直接通过“this.”的方法使用，比如 this.Button，this.Image，具有代码提示效果。而自定义的组件脚本获取只能通过代码定义属性，再在IDE中拖入节点获取节点或组件。 因此建议开发者：一般情况下使用自定义脚本的方式。只有当页面内需要管理较多的组件时，使用UI组件脚本能够更加方便的进行管理。 四、UI继承类和自定义组件脚本的混合使用 4.1 简单用法 在上述示例中（图2-4），已经在Scene场景中创建好了UI组件脚本，而后添加的代码如图4-1所示。 （图4-1） 其次，可以在Scene2D节点下添加自定义的组件脚本，如图4-2所示。 （图4-2） 此时Scene场景中既有UI组件脚本（Runtime），又有自定义的组件脚本。通过在自定义的组件脚本“NewScript.ts”中添加如下代码，来看看如何在自定义的组件脚本中使用Runtime的功能。 import { RuntimeScript } from \"./RuntimeScript\"; const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { private ui : RuntimeScript; onStart() { // 获得场景的Runtime对象 this.ui = this.owner.scene as RuntimeScript; // Button添加鼠标事件，让Image不显示 this.ui.Button.on( Laya.Event.MOUSE_DOWN, null, ()=>{ this.ui.Image.visible = false; }); } } ui 属性直接从脚本中通过 this.owner.scene as RuntimeScript 这句代码拿到了Runtime对象，那么Runtime下的UI组件也就可以直接获取了（this.ui.）。 将图4-1添加的“Button添加鼠标事件”代码注释后，运行项目，效果依然是动图2-7所展示的效果。说明以上这段代码的运行效果与图4-1所示代码的运行效果是一致的。通过UI组件脚本和自定义组件脚本的混合使用，开发者可以在自定义组件脚本中方便的使用UI组件了。 4.2 高级用法 上述方案中，自定义的组件脚本已经可以拿到场景的Runtime对象，那么在复杂的项目中，如果有很多的UI界面，我们是否可以对所有的UI界面做统一的管理呢？比如，统一找到和处理所有UI相关的Button，让所有Button点击时自动缩放。再比如更高级的用处，统一做所有UI的自适应功能。我们通过下面的方式来看看。 4.2.1 创建多个场景 那么以“统一找到和处理所有UI的Button，让所有Button点击时自动缩放” 为例，我们需要再创建一个有多个Button的UI场景，命名为“Button_Scene”，如图4-3所示。 （图4-3） 因为不同的UI，所持有的UI组件是不一样的，比如A场景有a1，a2组件，B场景有b1，b2，b3组件，那么不同的场景就需要有不同的 Runtime来关联每个UI的组件。那么下一步，针对这个Button_Scene的场景，再在Runtime入口创建一个UI组件脚本，并重命名为“ButtonRuntime.ts” ，如动图4-4所示。 （动图4-4） 接下来，我们需要把Button_Scene中的Button1，Button2，Button3都勾选定义变量属性，然后保存场景。这个操作和动图2-5类似，就不再详细介绍了。 最后，我们还需要给Button_Scene再添加一个自定义的组件脚本，命名为“ButtonScript.ts”，如图4-5所示。 （图4-5） 4.2.2 创建脚本父类 在上述操作后，两个场景都有UI组件脚本和自定义组件脚本了，那么如何做统一处理呢？我们发现Runtime类是用来关联UI组件的，因为它们都是继承于各自生成的脚本（RuntimeScript继承于RuntimeScriptBase、ButtonRuntime继承于ButtonRuntimeBase），就不能再统一继承某个类了。 而自定义的组件脚本类（NewScript、ButtonScript）都继承自Laya.Script，那么我们再多继承一层，可以让NewScript和ButtonScript都继承自一个新的类“Main”（这个类就是创建项目时默认生成的Main.ts），Main类再继承自Laya.Script（图4-6），从而实现统一处理的目的。 （图4-6） 另外在Main类加一个方法baseUI()： const { regClass, property } = Laya; @regClass() export class Main extends Laya.Script { //用来统一处理ui的事情，比如自适应，缩放所有Button public baseUI(ui: Laya.Scene){ } } 接下来，修改NewScript和ButtonScript都继承自Main，获得Runtime对象，并调用Main的baseUI()方法，传入runtime对象，如下： import { Main } from \"./Main\"; import { RuntimeScript } from \"./RuntimeScript\"; const { regClass, property } = Laya; @regClass() export class NewScript extends Main { private ui: RuntimeScript; onStart() { console.log(\"Game start\"); this.ui = this.owner.scene as RuntimeScript; super.baseUI(this.ui); } } import { Main } from \"./Main\"; import { ButtonRuntime } from \"./ButtonRuntime\"; const { regClass, property } = Laya; @regClass() export class ButtonScript extends Main { private ui: ButtonRuntime; onStart() { console.log(\"Game start\"); this.ui = this.owner.scene as ButtonRuntime; super.baseUI(this.ui); } } 最后，在 Main中加入点击缩放Button的代码，如下： const { regClass, property } = Laya; @regClass() export class Main extends Laya.Script { //用来统一处理ui的事情，比如自适应，缩放所有Button public baseUI(ui: Laya.Scene) { this.searchButton(ui); } //找出所有ui下的Button包括子节点下 searchButton(ui: Laya.Node) { for (let i = 0; i 分别运行两个场景看看效果： （动图4-7）Scene的Button可以点击缩放 （动图4-8）Button_Scene的三个Button都可以点击缩放 到此，我们了解了什么是UI继承类，UI继承类和自定义组件脚本类的区别，以及混合使用的方式，统一管理UI的高级用法，开发者可以更深一步研究，有更多的混合用法欢迎和我们交流~ Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-05-16 15:05:03 "},"IDE/uiEditor/use3D/readme.html":{"url":"IDE/uiEditor/use3D/readme.html","title":"混合使用3D","keywords":"","body":"混合使用3D一、概述二、IDE中混合使用3D2.1 IDE中创建RenderTexture文件2.2 3D场景添加渲染物2.3 设置摄像机的目标纹理2.4 设置Sprite的Texture2.5 修改渲染纹理属性三、代码中混合使用3D混合使用3D 一、概述 在我们2D项目开发过程中，开发者往往需要在UI界面显示3D场景或者3D物体，比如游戏开发中，3D人物在2D背景地图上跑动，英雄属性界面里会展示3D的英雄模型等等，如动图1-1所示， （动图1-1） 动图1-1，是LayaAir创建的2D入门示例中的“混合3D”示例 首先，利用LayaAir引擎中的 RenderTexture 可以很方便的实现这个功能。渲染纹理 （Render Texture）是在运行时不断更新渲染的一种特殊类型纹理 。渲染纹理的一个典型用法是将其设置为摄像机的“目标纹理”属性，这将使摄像机渲染到纹理， 而不是渲染到屏幕。随后可以如同普通纹理 (Texture) 一样在2D UI下的Sprite对象中使用。 现在我们分别讲解在IDE和代码中是如何利用渲染纹理混合使用3D的 二、IDE中混合使用3D 2.1 IDE中创建RenderTexture文件 如图2-1所示，我们先在IDE的 assets 资源中创建一个RenderTexture文件 （动图2-1） 点击新创建的RenderTexture文件，在属性面板中，会显示属性信息，如图2-2所示 （图2-2） Width：渲染纹理的像素宽度 Height：渲染纹理的像素高度 Color Format：渲染纹理的颜色格式 Depth Format：渲染纹理的深度格式 Generate Mipmap：如果勾选了，则自动生成多级渐进纹理级别 Multi Samples：多重采样 sRGB：此渲染纹理是否使用sRGB读/写转换（只读） 对本篇来说，渲染纹理的宽度，高度，颜色格式和深度格式，对效果有一定影响，暂时我们使用默认设置 2.2 3D场景添加渲染物 在IDE中的3D场景中，添加我们希望显示的3D物体，此例中把LayaMonkey添加到3D场景中，如图2-3所示 （图2-3） 摄像机正对LayaMonkey，同时把摄像机的 Render 组件中的Clear Color定义为“#000000” 然后如图2-4所示，改摄像机为正交投影，并调整好摄像机的显示比例 （图2-4） 2.3 设置摄像机的目标纹理 把之前创建好的渲染纹理文件，拖入摄像机的目标纹理属性中，此时摄像机渲染到纹理， 而不是渲染到屏幕了。如动图2-5所示 （动图2-5） 2.4 设置Sprite的Texture 在Scene2D中创建一个Sprite，作为显示3D物体的载体，把之前创建的渲染纹理拖入Sprite的Texture属性中，如图2-6所示 （动图2-6） 可以看到，LayaMonkey已经显示在2D Sprite中了，不过背景是黑色的，需要再次对渲染纹理的颜色格式修改，支持透明色 2.5 修改渲染纹理属性 如动图2-7所示，修改渲染纹理的颜色格式为R16G16B16A16，背景黑色变成透明了 （动图2-7） 仔细观察LayaMonkey，图像比较粗糙，主要原因是渲染纹理的分辨率是256x256的，分辨率太低导致，下面修改分辨率为1024x1024，如动图2-8所示 （动图2-8） 这样，LayaMonkey一下变清晰了，到此我们就把3D对象通过渲染纹理的方式，混合到UI界面了。运行效果如动图2-9所示 （动图2-9） 三、代码中混合使用3D LayaAir引擎提供的2D入门示例中有完整的3D混合使用代码示例，如下： const { regClass, property } = Laya; import KeyBoardManager = Laya.InputManager; import Keyboard = Laya.Keyboard; import Vector3 = Laya.Vector3; @regClass() export default class D3Main extends Laya.Script { /**3D 场景 */ private scene3D: Laya.Scene3D = new Laya.Scene3D(); /** dudu的节点精灵 */ private spDude: Laya.Sprite; /** 程序猿的节点精灵 */ private spMonkey: Laya.Sprite; /** 拖尾的节点精灵 */ private spTrail: Laya.Sprite; /** 拖尾的当前转向 */ private turnLeft: boolean = true; /** 当前所处的旋转方位 */ private _rotation: Vector3 = new Vector3(0, 0, 0); private rotationW: Vector3 = new Vector3(0, 180, 0); private rotationS: Vector3 = new Vector3(0, 0, 0); private rotationA: Vector3 = new Vector3(0, -90, 0); private rotationD: Vector3 = new Vector3(0, 90, 0); private sp3Role: Laya.Sprite3D = new Laya.Sprite3D(); /** 记录上次播放的跑动动画名称，用于去重播放 */ private lastRunAniName: string; private _animator: Laya.Animator; onEnable(): void { //在场景中找到对应的节点 this.spDude = this.owner.getChildByName(\"spDude\") as Laya.Sprite; this.spMonkey = this.owner.getChildByName(\"spMonkey\") as Laya.Sprite; this.spTrail = this.owner.getChildByName(\"spTrail\") as Laya.Sprite; //初始化设置 this.sceneInit(); Laya.timer.frameOnce(1, this, () => { //加载3D精灵（模型），添加到2D精灵上 this._3Dto2D(\"3d/girl/girl.lh\", this.spDude, 1, true); //设置2D精灵坐标位置 this.spDude.pos(30, 768); this._3Dto2D(\"3d/LayaMonkey/LayaMonkey.lh\", this.spMonkey, 2); this.spMonkey.pos(150, 110); this._3Dto2D(\"3d/trail/Cube.lh\", this.spTrail, 5); this.spTrail.pos(100, 500); }); } /** 初始化场景 */ sceneInit(): void { //添加3D场景到舞台上 Laya.stage.addChild(this.scene3D); //创建场景里的平行光 let directionLight = new Laya.DirectionLight(); //添加平行光到场景上 this.scene3D.addChild(directionLight); //设置平行光的强度 directionLight.intensity = 0.9; } /** 加载3D精灵画到2D Texture上 * @param lh 模型的字符串路径 * @param sp 2D精灵节点，用于画3D的texture * @param layer 手动指定层ID * @param isRole 是否是可以被控制的主角 */ _3Dto2D(lh: string, sp: Laya.Sprite, layer: number, isRole: boolean = false): void { //加载指定的模型，并画到2D精灵上 Laya.loader.load(lh).then(res => { //把指定的模型节点添加3D到场景上 let sp3 : Laya.Sprite3D = res.create(); this.scene3D.addChild(sp3); //创建一个3D摄像机 let _camera = new Laya.Camera(0, 0.1, 1000); //把摄像机添加到3D场景上 this.scene3D.addChild(_camera); //设置摄像机旋转角度 _camera.transform.rotate(new Vector3(-45, 0, 0), false, false); //设置摄像机清除颜色 _camera.clearColor = new Laya.Color(0, 0, 0, 0); //把摄像机设置为正交模式，2\\3D混合游戏一般不使用透视模式 _camera.orthographic = true; //近大远小， _camera.orthographicVerticalSize = 10; //清除其它层，避免几个层混合到一起 _camera.removeAllLayers(); //设置摄像机的层 _camera.addLayer(layer); //一定要给对应的渲染对象节点设置层与摄像机一样的层，如果不清楚是哪个节点，就写个循环，把所有节点都遍历设置一下，否则会影响显示结果 if( isRole ) (sp3.getChildAt(0).getChildAt(1)).layer = layer; else (sp3.getChildAt(0).getChildAt(0)).layer = layer; //临时坐标，用于2D转3D的输出 let _tempPos = new Vector3(0, 0, 0); //把想显示在2D位置的屏幕坐标转换为3D空间坐标 _camera.convertScreenCoordToOrthographicCoord(new Vector3(220, 900, 0), _tempPos); //把转换后的坐标设置在3D场景中，以便吻合2D屏幕的观察 sp3.transform.position = _tempPos; //缩放值为1 if( isRole ) sp3.transform.localScale = new Vector3(3, 3, 3); else sp3.transform.localScale = new Vector3(1, 1, 1); //把3D摄像机视图画到256宽高的纹理上 _camera.renderTarget = new Laya.RenderTexture(256, 256, Laya.RenderTargetFormat.R8G8B8A8, Laya.RenderTargetFormat.DEPTHSTENCIL_24_8); // 再将离屏3D画到2D节点上，至此，就完成把3D画到2D的基础渲染流程 sp.texture = new Laya.Texture(_camera.renderTarget); //根据参数决定是否要控制哪个节点 isRole && (this.sp3Role = sp3); if( isRole ) { this._animator = sp3.getChildAt(0).getComponent(Laya.Animator); Laya.stage.on( Laya.Event.KEY_UP , this, ()=>{ this.switchAni(\"Idle\"); } ); } }); } onUpdate(): void { //调整拖尾转向 if (this.spTrail.x (Laya.stage.width - 200) && !(this.turnLeft)) this.turnLeft = true; //控制拖尾的自动移动 if (this.turnLeft) this.spTrail.x -= 1; else this.spTrail.x += 1; //侦听键盘事件，让用户来控制主角移动 if (KeyBoardManager.hasKeyDown(Keyboard.W)) { this.spDude.y -= 1; this.rotateRole(this.rotationW); } else if (KeyBoardManager.hasKeyDown(Keyboard.S)) { this.spDude.y += 1; this.rotateRole(this.rotationS); } else if (KeyBoardManager.hasKeyDown(Keyboard.A)) { this.spDude.x -= 1; this.rotateRole(this.rotationA); } else if (KeyBoardManager.hasKeyDown(Keyboard.D)) { this.spDude.x += 1; this.rotateRole(this.rotationD); } } /** 改变角色的朝向 * @param r Vector3旋转值 */ private rotateRole(r: Vector3): void { this.switchAni(\"Run\"); if (r === this._rotation) return; //按世界坐标改变到指定的方位 this.sp3Role.transform.rotationEuler = r; //纪录当前方位，避免重复改变 this._rotation = r; } switchAni(aniType: string): void { if (aniType == \"Run\") { if (aniType !== this.lastRunAniName) { this._animator.play(aniType); } } else { this._animator.play(aniType); } this.lastRunAniName = aniType; } onDisable(): void { //页面关闭后，清除3D场景 this.scene3D.destroy(); } } 运行效果如动图1-1所示 （动图1-1） 核心代码是通过使用 Laya.RenderTexture 来创建渲染纹理，并把渲染纹理分别应用到摄像机对象和Sprite对象中 // 把3D摄像机视图画到256宽高的纹理上 _camera.renderTarget = new Laya.RenderTexture(256, 256, Laya.RenderTargetFormat.R8G8B8A8, Laya.RenderTargetFormat.DEPTHSTENCIL_24_8); // 再将离屏3D画到2D节点上，至此，就完成把3D画到2D的基础渲染流程 sp.texture = new Laya.Texture(_camera.renderTarget); 至此，在IDE中混合使用3D和代码中把3D画到2D的基础渲染流程就介绍完了，欢迎开发者相互交流~ Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:54 "},"IDE/uiEditor/textureCompress/readme.html":{"url":"IDE/uiEditor/textureCompress/readme.html","title":"压缩纹理","keywords":"","body":"纹理压缩一、概述1.1 纹理压缩的目的1.2 总结二、IDE中使用纹理压缩2.1 图片纹理压缩2.2 图集纹理压缩三、代码加载纹理压缩3.1 3D纹理的使用3.2 2D纹理的使用3.3 2D图集的使用四、优化效果到底怎么样纹理压缩 一、概述 纹理是指物体表面的纹路样式和细腻程度等外观效果。在计算机图形学中，常用于描述三维模型表面图案的二维图形。 我们日常见到和使用的图片格式，主要为PNG和JPG，虽然在三维和二维的某些情况下，也会把这些图片称为纹理，但他们并不是纹理格式，不能被GPU直接读取并显示。因此，这些图片文件要先经过CPU解码成纹理格式，再传送到GPU进行使用。 而纹理格式，自然就是可以被GPU直接读取并显示的格式。所以，一方面，避免CPU解码可以减少运算带来的性能压力。另一方面，就是直接读取并渲染，也可以避免图像解压到内存的占用开销。 1.1 纹理压缩的目的 1，降低内存，特别是移动端应用，内存占用不应过大，否则低端机很容易崩溃 2，降低带宽，手游类应用，在渲染时会有大量贴图传输到GPU，不限制的话不仅会严重影响渲染性能，同时会带来很严重的发热 那纹理格式有哪些？ ASTC ASTC（Adaptive Scalable Texture Compression）是一种世界领先的新型纹理压缩格式。ASTC由ARM和AMD联合开发，2012年发布。是一种基于块的有损压缩算法。它的压缩分块从4x4到12x12最终可以压缩每个像素占用1bit以下，并且ASTC格式支持RGBA。以ASTC 4x4 Block Size为例，可以看到每个像素占用8bits即1个字节。因此一张1024x1024的RGBA图片按照该格式压缩后占用的内存大小为1MB。如果你的纹理是选择了生成mipmap的话，那么最终的资源大小还需要乘以1.333也就是大约1.333MB。而相对应的如果采用了ASTC 8x8的格式进行压缩的话，最终纹理资源的大小就应该是 1024 × 1024 × 2 × 1.333333 ÷ 8 ≈ 341K。所以如果想要使用10x10或12x12这种更小的压缩格式的话，选用这两种格式基本也就意味着放弃对画质的基本要求了。因此我们推荐使用6x6的压缩格式。 适配机型： iOS 苹果从A8处理器开始支持ASTC，即iPhone6和iPad mini 4及以上的设备都支持，ASTC格式在iOS设备上的显示效果比PVRTC的效果要好很多(PVRTC格式存在两个大问题：首先是透明贴图在iOS上显示比较模糊，失真；另一点是对于颜色比较丰富的图，特别是UI，颜色过渡大的区域会出现色阶问题，目前的方案一般是拆分Alpha通道，见这里：IOS下拆分Unity图集的透明通道（不用TP）),Unity 分离贴图 alpha 通道实践。因此在当前情况下iOS上可以全部使用ASTC作为纹理格式。 安卓 安卓中所有支持OpenGL ES 3.1及以上的设备，和大部分支持OpenGL ES 3.0的设备都支持ASTC。因此在安卓上需要根据具体情况来设置纹理压缩格式，一般而言若项目依旧要考虑低端机型，就要退而求其次使用ETC2格式进行压缩。 ETC ETC（Ericsson Texture Compression）最初为移动设备开发，如今它是安卓的标准压缩方案，ETC1在OpenGL和OpenGL ES中都有支持。 RGB ETC1 4 bit：4 bits/pixel，对RGB压缩比6:1，不支持Alpha，绝大部分安卓设备都支持。 RGB ETC2 4 bit：4 bits/pixel，对RGB压缩比6:1。不支持Alpha，ETC2兼容ETC1，压缩质量可能更高，但对于色度变化大的块误差也更大，需要在OpenGL ES 3.0和OpenGL 4.3以上版本。 RGBA ETC2 8bit：8 bits/pixel，对RGBA压缩比4:1。支持完全的透明通道，版本要求同上。 PVR PVRTC（PowerVR Texture Compression）由Imagination公司专为PowerVR显卡核心设计，由于专利原因一般它只被用于苹果的设备，仅iPhone、iPad和部分PowerVR的安卓机支持。 1.2 总结 ASTC在压缩率、图像质量、种类上都挺不错的，也正在逐步代替ETC和PVR，最大的缺点可能就是兼容性还不够完善和解码时间较长，但以现在移动端的发展趋势来看，GPU计算能力越来越难成为瓶颈，因此非常有希望在以后能成为统一的压缩格式。 整理网络上的一些资料： 安卓：用ETC2没有什么问题；ASTC在Android 5.0/OpenGL ES 3.1后支持，市场大部分机型都支持，可以考虑选择 iOS：在iPhone6以上（包含）都支持ASTC，6以下可以选择PVRTC2。 LayaAir 3.0引擎及工具也更新了这一情况，全面支持ASTC标准，也仍然支持ETC1和ETC2_RGB，ETC2_RGBA，同时不再支持PVR。 所以我们建议使用ASTC 6x6作为安卓和iOS统一的压缩纹理格式，而且两个平台只需要一个压缩纹理文件，也节省了项目的使用空间。 二、IDE中使用纹理压缩 2.1 图片纹理压缩 LayaAir3.0 对纹理压缩功能做了很好的改进，不用像2.0那样需要通过纹理压缩工具来使用，而是可以在IDE中直接操作图片做纹理压缩的转换，而且开发者也不用关心图片的使用途径是2D还是3D。如图2-1所示 （图2-1） 图2-1中，点击Layabox.png图片，可以在右边的属性面板中，看到默认是使用Default选项，Format是带透明通道的位图(32位)。在没有纹理压缩前，图片在所有平台都使用此格式。如果我们想针对iOS平台使用ASTC 6x6，对安卓平台使用ETC2_RGB，如动图2-2所示 （动图2-2） 分别对Andorid和iOS选择ASTC6x6纹理压缩格式并点击应用后，在assets目录下实际上是不会生成对应的压缩文件的。也就是说在预览模式下，也无法使用。只有在发布后，才可以使用压缩纹理。如图2-3所示，通过发布web平台，我们来看看发布后的结果 （图2-3） LayaAir 3.0 IDE会发布出layabox.jpg.json和layabox@1.ktx两个文件。 其中layabox@1.ktx就是上述操作生成的纹理压缩文件，因为都使用了ASTC 6x6，所以只生成一个压缩纹理文件。如果Android和iOS平台分别配置为不同的格式，那么就会生成两个不同的文件。 另外IDE会对每个图片资源生成一份json属性文件，也就是layabox.jpg.json，文件中记录一些对图片属性设置信息，其中包括使用纹理压缩信息，打开json文件如下： { \"sRGB\": true, \"wrapMode\": 0, \"filterMode\": 1, \"anisoLevel\": 0, \"readWrite\": false, \"mipmap\": true, \"pma\": false, \"hdrEncodeFormat\": 0, \"files\": [ { \"file\": \"\", \"ext\": \"jpg\", \"format\": 1 }, { \"file\": \"1\", \"ext\": \"ktx\", \"format\": 19 } ], \"platforms\": { \"0\": 0, \"1\": 1, \"2\": 1 } } platforms表示图片使用的平台，1和2分别指向Android和iOS平台，两个平台都使用files信息中的ktx为后缀的纹理压缩文件。 接下来通过Android手机来看实际运行效果，如图2-4所示 （图2-4） 通过使用chrome手机调试模式，可以看到正在使用layabox@1.ktx，测试成功！LayaAir 引擎会识别当前运行的平台，根据layabox.jpg.json中对应的平台信息找到压缩纹理。 注意：在PC平台的Chrome的使用手机模式，是无法使用到纹理压缩的，虽然使用了手机模式，但是LayaAir引擎会判断当前运行的平台依然是win32，而不是ua数据中的设备信息。 （图2-5） 2.2 图集纹理压缩 不仅图片可以纹理压缩，通常我们在2D开发中使用的图集也可以使用压缩纹理，如图2-6所示 （图2-6） 例如在LayaAir IDE创建项目后自带的图集配置文件，进行纹理压缩配置，发布后可以看到图集也可以使用压缩纹理了，如图2-7所示 （图2-7） 再用Android手机来看看运行时的情况，图集压缩纹理comp@1.ktx成功使用了，如图2-8所示 （图2-8） 到此，在IDE中配置图片纹理压缩和图集的纹理压缩就介绍完了，开发者可以自己来试一试！ 三、代码加载纹理压缩 通过IDE配置压缩纹理后，本身LayaAir引擎是可以自动识别运行平台来使用对应的压缩纹理的，这个改进对开发者来说是非常方便的，不用像2.0那样，在代码中判断平台了。如果开发者希望用代码来动态加载压缩纹理也是一样的。 3.1 3D纹理的使用 要使用纹理压缩格式，则需要使用Laya.loader.load()来加载纹理资源。 示例代码如下所示： Laya.loader.load(\"resources/CompressTexture/Assets/layabox.jpg\").then((texture: Texture2D)=> { this.mat.albedoTexture = texture; }); 3.2 2D纹理的使用 对于2D纹理，需要先预加载纹理文件，然后就可以直接使用。 示例代码如下所示： Laya.loader.load(\"resources/bg2.png\").then((texture: Texture)=> { this.img.texture = texture; }); 3.3 2D图集的使用 对于2D图集，预加载图集atlas文件即可，引擎在加载图集的时候，会检测是否包含了纹理压缩转换的信息，如果包含，会自动识别平台并加载对应的纹理压缩格式文件，不需要开发者在代码里判断平台。 示例代码如下所示： Laya.loader.load([\"atlas/comp.atlas\"], Laya.Handler.create(this, () => { this.img.skin = \"atlas/comp/image.png\"; })); 通过示例代码，我们可以看到，图集的纹理压缩的代码使用是无感的，和普通的图集使用方式完全相同。 四、优化效果到底怎么样 由于纹理压缩格式不需要CPU解码，那因解码而产生的瞬间性能压力就没有了，不过如果不是特别多的处理，这个过程并不是持续的，所以并不明显。 比较显著的优化还是在显存上。我们仍然举个例子来说明。 还是之前IDE里自带的那张图，我们将宽高改成512*512后， 当舞台上什么显示也没有的时候，初始显存占用是2.31M，使用纹理压缩格式，只增加170K，加上初始大小最终为2.48M。而原图则增加1024K，达到3.31M。如图3-1所示。所以显存优化效果还是非常明显的，减少约83%。 （图3-1） 有一些开发者，还不太理解显存的占用与文件的关系。我这里告诉大家一个简单的计算依据。如果是非纹理压缩的图片，比如PNG和JPG，你直接用图片像素的宽*高*4就是显存的占用。 所以有一些游戏，为了减少显存的占用，把图片的宽高像素做小，然后用缩放的方式，再显示放大。不过这种方式，虽然显存占用小了，但是质量的损失也大了。纹理压缩虽然也是有损压缩，但同样质量的情况下，显存占用更小，甚至和原图质量差不多的情况下，也比拉伸的方式内存占用小。所以纹理压缩是开发者比较常用的一种节省显存的方案。 那纹理压缩的显存占用，怎么计算呢，除了统计面板上的信息外，也有一种比较简单的统计方案。你直接查看纹理压缩文件的大小就好了，比如纹理压缩文件是170k，那显存占用也是170k。例如图3-2所示。 （图3-2） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-05-11 21:35:28 "},"IDE/uiEditor/3DUI/readme.html":{"url":"IDE/uiEditor/3DUI/readme.html","title":"使用3DUI","keywords":"","body":"使用3D UI一、概述1.1 3D UI的本质1.2 3D UI的分类二、IDE中使用UI3D组件2.1 创建一个2D的Prefab2.2 创建Sprite3D，添加UI3D组件2.3 添加2D Prefab资源2.4 更改UI3D属性2.5 调整UI3D位置2.6 脚本控制UI3D使用3D UI 一、概述 2D UI都是纯粹的2D图片按层次显示，不会出现三维立体效果，所以都是直接紧贴着视窗上。而3D UI的原理是，创建的UI控件都在一个三维立体空间中，摄像机是一个透视的摄像机，这和2D UI有着截然不同的区别，因为2D UI是一个正交摄像机。因此如果要出现UI有三维变换的效果，就必须用3D UI 1.1 3D UI的本质 3D UI也是UI，就需要承担UI的交互职能。例如，当我们点击UI上的按钮时，按钮会带来交互反馈，并触发设定的事件，以达到逻辑运行的目的。 （动图1-1） 1.2 3D UI的分类 场景化UI 3D UI是位于3D场景中，不跟随窗口运动而运动的UI。它更像是一个位于3D场景中的物件，并带有UI的交互特征。 （动图1-2） 透视UI 3D UI是始终位于窗口上，和常规的UI一样。但3D UI可以进行XYZ三个轴上的运动，带来明显的透视变化。 （动图1-3） 二、IDE中使用UI3D组件 2.1 创建一个2D的Prefab 在IDE中使用3D UI，首先需要我们创建一个用于在3D场景中展示的2D UI，这里必须使用Prefab2D来实现。首先，我们先创建一个Prefab2D，在Prefab2D中搭建一个希望实现的2D UI，例如，我们要做一个游戏中人物战斗中头顶的血条，如图2-1所示 （图2-1） 在Prefab2D中，创建一个Progress组件，因为血条有当前血量和总体血量构成，因此Progress正好符合我们的要求。并且血条上面使用Label显示人物的名字。另外注意Prefab的根节点Box的size最好改为2的N次幂，这符合纹理的2的N次幂原则。 2.2 创建Sprite3D，添加UI3D组件 在IDE的Scene3D节点下，创建一个Sprite3D对象，添加UI3D组件，如动图2-2所示 （动图2-2） 在Sprite3D节点属性面板中，点击添加组件，选择渲染，选择UI3D组件。可以看到，当添加UI3D组件后，场景中在Sprite3D节点的位置，多了一个白色的纹理，这个纹理就是用来显示UI的。 2.3 添加2D Prefab资源 准备好UI3D组件后，下一步就是要把之前做好的2D Prefab UI拖入到UI3D组件的Prefab属性中，如动图2-3所示 （动图2-3） 拖入Prefab后，纹理会立即显示2D UI。但是默认是OPAQUE渲染模式，纹理有黑色的背景色。下面会介绍UI3D的属性，来调整纹理效果 2.4 更改UI3D属性 对于UI3D组件，如图2-4所示，有如下一些属性： （图2-4） Render Mode：渲染模式，通常我们使用 Transparent 模式，也就是支持透明色，如图2-5所示，血条背景变成我们期望的透明了 （图2-5） Prefab：需要显示的2D Prefab资源文件 Scale：纹理的缩放值 Resolution Rate：纹理的分辨率，当拖入Prefab时，会自动识别Prefab下节点的size，来动态调整纹理的分辨率 Billboard：是否总是朝向摄像机，如果不选的话，会朝向Z轴方向，也就是可以实现UI在场景中的透视效果 Enable Hit：是否响应鼠标点击，默认是不勾选。如果勾选后，可以实现按钮的响应，滑动条的拖动，List组件的滑动等等 2.5 调整UI3D位置 我们的需求是做人物的血条，那首先把我们做好的但丁人物拖入到场景中，并设置为（0,0,0）点，如图2-6所示 （图2-6） 但是可以看到，由于之前创建的Sprite3D也在（0,0,0）点，那么位置就会在人物脚下，这时需要调整Sprite3D的位置，来符合血条的效果，如动图2-7所示 （动图2-7） 这时来看看运行的效果： （动图2-8） 可以看到随着人物在摄像机前拉进和拉远，血条也在变大变小，很符合实际的效果 。如果用2D UI来实现的话，就需要动态去计算人物相对摄像机的位置来缩放UI的大小，效果肯定不好。 当然，我们也可以不勾选UI3D的 Billboard 属性，调整XYZ轴的旋转，让血条随着人物的旋转而改变朝向。 （动图2-9） 2.6 脚本控制UI3D 通常我们需要对UI中的内容进行操作，此例中血条中血量比例的变化，有向上飘动的伤害数等等，这些都是通过对2D Prefab中UI组件控制来实现的。而UI3D组件通常是用来控制显示效果，比如透视效果，位置信息等。 就像处理2D UI的操作一样，我们再次打开Prefab2D，在根节点上添加Runtime类，添加逻辑代码如下： import { BloodBarBase } from \"./BloodBar.generated\"; import { Main } from \"./Main\"; const { regClass, property } = Laya; @regClass() export class BloodBar extends BloodBarBase { //declare owner : Laya.Sprite3D; constructor() { super(); } onAwake(): void { this.bar.value = 1; this.value.visible = false; Laya.stage.on( Laya.Event.CLICK, this, this.onHurt ); } onHurt(): void { this.bar.value = this.bar.value - 0.1; this.value.y = 35; this.value.visible = true; Main.player.getComponent(Laya.Animator).play(\"Stun\"); Laya.Tween.to( this.value, { y : -20 }, 500, null, Laya.Handler.create(this, this.end)) } private end(): void { this.value.visible = false; } } 最后来看看运行效果： （动图2-10） 到此为止，UI3D组件已经介绍完了，开发者可以在项目中通过使用UI3D组件来实现更多的3D UI效果。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:52 "},"IDE/sceneEditor/readme.html":{"url":"IDE/sceneEditor/readme.html","title":"3D场景编辑模块","keywords":"","body":"3D场景编辑器3D场景编辑基础交互使用3D精灵3D基础显示对象使用3D摄像机3D灯光与阴影3D场景环境设置3D模型与动画的导入使用3D场景编辑器 Author: Charley 3D场景编辑器，是3D可视化编辑的核心模块，主要包括3D场景的环境设置、模型的导入与使用、3D节点对象的变换、摄像机、灯光等等3D基础组成部分的可视化使用。 3D场景编辑基础交互 使用3D精灵 3D基础显示对象 使用3D摄像机 3D灯光与阴影 3D场景环境设置 3D模型与动画的导入使用 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:49 "},"IDE/sceneEditor/basic/readme.html":{"url":"IDE/sceneEditor/basic/readme.html","title":"3D场景编辑基础交互","keywords":"","body":"3D场景编辑的基础交互3.1 操作视窗摄像机3.2 操作模型3D场景编辑的基础交互 Author: Charley 3D场景中的基础交互，主要是两大类基础操作， 一是，改变场景视窗的摄像机位置与角度，让开发者如同自己的眼睛一样观察3D场景世界。 二是，改变模型的位置与角度，将模型摆放到场景中适当位置。 我们可以使用如图1所示的基础工具， （图1） 也可以使用快捷键切换到对应的工具。 本篇我们逐个分解示意，让大家了解全部的3D场景编辑的交互基础操作。 3.1 操作视窗摄像机 3.1.1 旋转视窗摄像机：鼠标右键 在3D场景中，只要持续按住鼠标右键即进入视窗摄像机的旋转模式，松开鼠标右键即退出视窗摄像机旋转模式。 在该模式下，在屏幕方向上移动鼠标，可以改变视窗摄像机的角度，对整个场景的任意角度进行观察，效果如动图2-1所示。 (动图2-1) 3.1.2 空间位移视窗摄像机： 当按住鼠标右键 + 键盘功能键，可以让摄像机按上下左右前后，具体功能键如下： 功能说明 操作 摄像机向上位移 鼠标右键 + E 摄像机向下位移 鼠标右键 + Q 摄像机向左位移 鼠标右键 + A 摄像机向右位移 鼠标右键 + D 摄像机向前位移 鼠标右键 + W 摄像机向后位移 鼠标右键 + S 位移视窗摄像机的效果如动图2-2所示。 (动图2-2) 上下前后左右，是一个相对的方向，无论旋转到任何角度，都会按这个相对的方向进行位移。 位移视窗摄像机加速： 在位移视窗摄像机的基础上，按住Shift叠加，可以在原功能基础上进行加速移动。 操作按键为：鼠标右键 + shift + (E、Q、A、D、W、S) 3.1.3 屏幕内位移视窗摄像机：Q \\ 鼠标中键 除了采用鼠标右键 + 键盘功能键（E、Q、A、D）实现视窗摄像机上下左右的位移外，还可以通过快捷键Q或鼠标中键来启动屏幕任意方向位移。 使用快捷键Q时，鼠标左键按下并拖拽，即可实现视窗摄像机在屏幕任意方向位移，效果如动图2-3所示。 (动图2-3) 要想退出该模式，则需要通过其它模式的快捷键，除非是需要持续不断的采用该模式位移视窗摄像机。否则更建议采用鼠标中键来启动屏幕任意方向位移。 鼠标中键的方式，只有在按下并拖拽时才会进入该模式，松开鼠标中键会自动回到其它模式。 3.1.4 视窗摄像机缩放：鼠标滚轮 视窗摄像机缩放本质上就是视窗摄像机的前后位移，只因在位移过程中，观察目标时基于近大远小的透视原理，有种缩放的错觉，所以称为缩放视窗摄像机。效果如动图2-4所示， (动图2-4） 3.1.5 视窗摄像机绕焦点中心旋转：Alt + 左键拖拽 在观察或操作具体某个模型时，我们可能需要找一个非正面的合适角度。此时，之前介绍的方式都不太方便。所以围绕目标进行任意旋转是最适合的操作。 要旋转视窗摄像机之前，我们首先要做的事，就是聚焦（选中3D对象，快捷键F），将模型处于视窗摄像机的中心位置。 聚焦后，通过Alt + 左键的组合，左键向任意角度拖拽，即可实现绕焦点中心旋转，效果如动图2-5所示， (动图2-5) 3.2 操作模型 操作模型的工具有四种，分别是位移、旋转、缩放、混合使用。可以通过快捷键 W、E、R、T进行启动不同的工具模式。 快捷键名称 按键 模型位移工具 W 模型旋转工具 E 模型缩放工具 R 混合编辑模型 T 3.2.1 模型位移工具：W 通过快捷键W进入模型位移工具模式后，模型上会出现红绿蓝三色的轴和片。 红绿蓝三个轴分别代表X、Y、Z三个方向，轴的颜色与右上角的坐标轴对应。 箭头所指的方向为正方向，拖动其中一个轴，可使该模型按该轴的正负方向进行位移，效果如动图3-1所示。 (动图3-1) 留意属性面板，如果该模型没有任何旋转（rotation都为0），拖动其中一个轴，只有该轴的属性值会发生变化 。如果有旋转，则会影响其它轴属性值。 三个相邻的面，蓝色为XY面、绿色XZ面、红色为YZ面。 拖动其中一个面，可使该模型在该面范围内任意位移，效果如动图3-2所示。 (动图3-2) 3.2.2 模型旋转工具：E 通过快捷键E进入模型旋转工具模式后，模型上出现红绿蓝三色的交叉弧线和外层白圈，当鼠标划到模型上时，还会出现一个半透明圆。 红绿蓝三色的弧线分别代表X、Y、Z三个轴的方向，颜色与右上角的坐标轴对应。 选中其中一个弧线后，会变成完整的圆圈，代表按该该轴方向进行旋转，效果如动图4-1所示。 (动图4-1) 外层白圈，是基于屏幕的垂直旋转，效果如动图4-2所示。 (动图4-2) 如果鼠标在半透明圆拖拽，则可以任意角度旋转，效果如动图4-3所示。 (动图4-3) 3.2.3 模型缩放工具：R 通过快捷键R进入模型缩放工具模式后，模型上不仅有红绿蓝三色轴，还有中心白块和外层白色圆圈。 红绿蓝三色轴分别代表X、Y、Z三个轴的方向，拉动其中一个轴，可在该轴对模式进行缩放，效果如动图5-1所示。 (动图5-1） 中心的白块与外层白色圆圈均是三轴同时缩放，两者的区别仅是缩放速率差异，效果如动图5-2所示。 (动图5-2） 3.2.4 模型工具集合：T 通过快捷键T进入模型工具集合后，前文介绍的模型操作工具，都会集合到一起。 唯一需要注意的是，混合模式下，中心块缩放不再保留，只能通过外层白色圆圈整体缩放，以及通过拉动各轴的方块从单轴方向缩放，效果如动图6所示。 (动图6) 3.2.5 模型的多选 多选的方式分别是框选、Shift、Ctrl这几种方式。 模型的框选，就是通过鼠标拉起屏幕矩形区，只要在矩形区内，无论远近都会被选中。 除了框选，也可以通过Shift或Ctrl结合鼠标点击，进行连续多选。 无论是单选，还是多选，选中的模型都会出现红色边框。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:48 "},"3D/Sprite3D/readme.html":{"url":"3D/Sprite3D/readme.html","title":"使用3D精灵","keywords":"","body":"精灵 Sprite3D一、概述二、 属性和功能三、子父级关系四、 克隆五、 添加组件六、 添加脚本七、 各种渲染精灵简介精灵 Sprite3D 一、概述 Sprite3D 是3D的基本节点对象，就像Sprite是2D的基本节点对象一样，是LayaAir3D中所有3D节点的父类，包含很多3D精灵基本的功能属性，除此之外还是所有3D组件和脚本的容器。 在LayaAir 3.0编辑器中，我们可以通过鼠标右键来创建一个Sprite3D，如动图1-1所示 （动图1-1） 创建好的Sprite3D，在编辑器场景中，Scene3D下会是一个空节点，如图1-2所示 （图1-2） 基本上我们创建一个Sprite3D空节点的最重要的目的是作为一个根节点，一个项目中会有很多不同功能的根节点，来方面我们管理。另外也可以用Sprite3D来添加组件，下面我们会详细介绍Sprite3D的用途。 二、 属性和功能 （图2-1） 图2-1中，可以看到Sprite3D作为一个最基础的3D节点，都具备哪些属性，其它更丰富的3D节点都具备这些属性 2.1节点的名字 （图2-2） 图2-2中，任何一个节点都有名字，通过名字可以方便的来查找一个节点下是否存在某个名字的字节的，通常我们调用如下方法来获取 getChildByName(\"xxx\") /** * 根据子节点的名字，获取子节点对象。 * @param name 子节点的名字。 * @return 节点对象。 */ getChildByName(name: string): Node { for (let child of this._children) { if (child && child.name === name) return child; } return null; } 当我们找到子节点时，也可以对节点做一些基础操作，比如删除掉自己方法 removeSelf() /** * 从父容器删除自己，如已经被删除不会抛出异常。 * @return 当前节点（ Node ）对象。 */ removeSelf(): Node { this._parent && this._parent.removeChild(this); return this; } 具体一个Sprite3D都有哪些基础方法，我们可以去参考Node节点的基础属性 2.2 是否激活 （图2-3） 图2-3中，任何节点，都可以通过勾选是否激活来作用于场景中，当不激活某个节点时，下面的所有字节的也会随着根节点处于不激活状态。当然我们也可以哦通过代码来控制 /** * 获取自身是否激活。 * @return 自身是否激活。 */ get active(): boolean /** * 设置是否激活。 * @param value 是否激活。 */ set active(value: boolean) 2.3 是否为静态 （图2-4） 图2-4所示，是否为静态。在游戏场景中，每一个Sprite3D都有静态或者动态的两种状态，当一个物体标记为static后，就确保这个物体在游戏场景中为静态的、不会移动的物体，进而在游戏的运行过程中让游戏有更加流畅的运行体验。一般而言，在场景中完全静止的物体标记成static是比较好的。这个静止指在游戏运行过程中没有发生移动或者缩放或者旋转等。 标记成 static 往往是为了提高效率，比如静态物体的碰撞检测要更快，同时多个使用同一材质的静态物体在绘制的时候只使用一个drawcall，进而节省了CPU。在光照计算上，static的物体也更快一些。 另外，当勾选Static时，编辑器会询问是否同时改变所有子对象的静态标志，如图2-5所示 （图2-5） 当然也可以用代码来控制 /** * 是否为静态。 */ get isStatic(): boolean /** * 是否设为静态。 */ set isStatic(value: boolean) 2.4 蒙版层 （图2-6） 图2-6中，是精灵所在的图层 Layer。渲染相机可进行可视遮罩层的控制，对精灵的渲染与否进行控制，可以参考摄像机文档，其中有对设置不同物体蒙版层后，摄像机选择不同蒙版层的示例。如动图2-1所示 （动图2-1） 如图2-7所示，通过点击Layer，可以选择编辑器已经自定义好的Default，Layer1等等，也可以再次编辑Layer层 （图2-7） 也可以通过代码来设置 /** * 蒙版层。 */ get layer(): number set layer(value: number) //添加显示图层(为相机添加一个蒙版) this.camera.addLayer(5); 2.5 变换 变换组件确定场景中每个精灵的位置，旋转和缩放。同时和Node节点一样具备子父节点的关联关系，使变换操作更灵活，每个精灵都有一个Transform3D。 （图2-8） 我们也可以在编辑器里手动调整精灵的变换 （图2-9） （图2-10） 图2-9用来调整精灵的旋转，图2-10用来调整精灵的缩放 （图2-11） 图2-11可同时用来调整精灵的位置，旋转和缩放 通过代码，来做变换 //平移 this.position1.setValue(-1.5, 0, 0.0); this.sprite3d.translate(this.position1); //旋转 this.rotate1.setValue(0, 60, 0); this.sprite3d.rotate(this.rotate1, false, false); //缩放 var scale = this.sprite3d.localScale; scale.setValue(0.1, 0.1, 0.1); this.sprite3d.localScale = scale; 三、子父级关系 Sprite3D继承自Node节点，是LayaAir3D中所有3D对象的父类。通过一些示例，我们可以了解子父级关系。 （动图3-1） 通过点击按钮，让父节点移动，同时可以看到子节点也跟随移动 this.layaMonkeyParent.transform.translate(new Laya.Vector3(-0.2, 0, 0); （动图3-2） 通过点击按钮，让子节点移动，可以看到父节点并没有移动 this.layaMonkeySon.transform.translate(new Laya.Vector3(-0.2, 0, 0); 四、 克隆 关于克隆，LayaAir3D中提供了几种接口。比较常用的是clone方法 /** * 克隆。 * @return 克隆副本。 */ clone(): Node { var dstSprite3D: Node = Sprite3D._createSprite3DInstance(this); Sprite3D._parseSprite3DInstance(this, dstSprite3D, this, dstSprite3D); return dstSprite3D; } （动图4-1） 通过代码来克隆一个猴子 //克隆一个猴子 let sp = this.layaMonkeyParent.clone() as Laya.Sprite3D; //设置克隆猴子的坐标 sp.transform.position = new Laya.Vector3(1,0,0); //添加到场景中 this.scene.addChild(sp); 其次，这里详细讲解下Sprite3D中特有的克隆接口instantiate /** * 创建精灵的克隆实例。 * @param original 原始精灵。 * @param parent 父节点。 * @param worldPositionStays 是否保持自身世界变换。 * @param position 世界位置,worldPositionStays为false时生效。 * @param rotation 世界旋转,worldPositionStays为false时生效。 * @return 克隆实例。 */ static instantiate(original: Sprite3D, parent: Node = null, worldPositionStays: boolean = true, position: Vector3 = null, rotation: Quaternion = null): Sprite3D { var destSprite3D: Sprite3D = (original.clone()); (parent) && (parent.addChild(destSprite3D)); var transform: Transform3D = destSprite3D.transform; if (worldPositionStays) { var worldMatrix: Matrix4x4 = transform.worldMatrix; original.transform.worldMatrix.cloneTo(worldMatrix); transform.worldMatrix = worldMatrix; } else { (position) && (transform.position = position); (rotation) && (transform.rotation = rotation); } return destSprite3D; } original ：原始精灵。 parent：父节点。 worldPositionStays：是否保持自身世界变换。 position：世界位置，worldPositionStays为false时生效。 rotation：世界旋转，worldPositionStays为false时生效。 该方法可以在克隆时携带父节点信息，世界位置信息和世界旋转信息。 （动图4-2） 通过代码来instantiate克隆一个猴子 //sprite3d的instantiate克隆方法 let layaMonkey_clone1 = Laya.Sprite3D.instantiate(this.layaMonkeyParent, this.scene, false, new Laya.Vector3(-2, 0, 0), new Laya.Quaternion(0, -90, 0)); this.scene.addChild(layaMonkey_clone1); 五、 添加组件 LayaAir中，可以对任何3D对象添加Component 组件，如动图所示 （动图5-1） Component 组件，是附加到所有3D对象的内容的基类。 通过代码也可以添加组件，需要物体使用addComponent方法 //添加Rigidbody3D组件 let rigidBody = this.layaMonkeyParent.addComponent(Laya.Rigidbody3D) as Laya.Rigidbody3D; //创建盒子形状碰撞器 var boxShape = new Laya.BoxColliderShape(1, 1, 1); //设置盒子的碰撞形状 rigidBody.colliderShape = boxShape; //使用重力 rigidBody.overrideGravity = true; //重力为向下-10 rigidBody.gravity = new Laya.Vector3(0,-10,0); （动图5-2） 如动图5-2，添加 Rigidbody3D 组件，并且设置重力的效果 六、 添加脚本 Laya.Script3D 这是3D世界中的脚本，继承自组件，是组件的一种。该类被定义为 ‘抽象类’ ，不允许实例。该类提供了一系列虚方法。 在3D世界的开发中脚本类会在很多地方被使用，该组件将会在后面的脚本篇中详细的讲解，在本篇只是简单的讲解如何给Sprite3D添加一个脚本。如动图6-1所示。 （动图6-1） 我们可以给Main Camera添加一个通过鼠标和键盘来控制摄像机的脚本，这个脚本在实际开发过程中非常的实用，图6-2中，显示摄像机添加了这个脚本 （图6-2） 脚本的代码为： const { regClass, property } = Laya; @regClass() export class CameraMoveScript extends Laya.Script3D { /** @private */ protected _tempVector3: Laya.Vector3 = new Laya.Vector3(); protected lastMouseX: number = 0; protected lastMouseY: number = 0; protected yawPitchRoll: Laya.Vector3 = new Laya.Vector3(); protected resultRotation: Laya.Quaternion = new Laya.Quaternion(); protected tempRotationZ: Laya.Quaternion = new Laya.Quaternion(); protected tempRotationX: Laya.Quaternion = new Laya.Quaternion(); protected tempRotationY: Laya.Quaternion = new Laya.Quaternion(); protected isMouseDown: boolean = false; protected rotaionSpeed: number = 0.00006; protected camera: Laya.BaseCamera = new Laya.Camera; protected scene: Laya.Scene3D = new Laya.Scene3D; speed: number = 0.01; constructor() { super(); } /** * @private */ protected _updateRotation(): void { if (Math.abs(this.yawPitchRoll.y) this.owner); } /** * 监听键盘事件 */ onUpdate(): void { var elapsedTime: number = Laya.timer.delta; if (!isNaN(this.lastMouseX) && !isNaN(this.lastMouseY) && this.isMouseDown) { Laya.InputManager.hasKeyDown(87) && this.moveForward(-this.speed * elapsedTime);//W Laya.InputManager.hasKeyDown(83) && this.moveForward(this.speed * elapsedTime);//S Laya.InputManager.hasKeyDown(65) && this.moveRight(-this.speed * elapsedTime);//A Laya.InputManager.hasKeyDown(68) && this.moveRight(this.speed * elapsedTime);//D Laya.InputManager.hasKeyDown(81) && this.moveVertical(this.speed * elapsedTime);//Q Laya.InputManager.hasKeyDown(69) && this.moveVertical(-this.speed * elapsedTime);//E var offsetX: number = Laya.stage.mouseX - this.lastMouseX; var offsetY: number = Laya.stage.mouseY - this.lastMouseY; var yprElem: Laya.Vector3 = this.yawPitchRoll; yprElem.x -= offsetX * this.rotaionSpeed * elapsedTime; yprElem.y -= offsetY * this.rotaionSpeed * elapsedTime; this._updateRotation(); } this.lastMouseX = Laya.stage.mouseX; this.lastMouseY = Laya.stage.mouseY; } /** * 释放监听 */ onDestroy(): void { Laya.stage.off(Laya.Event.MOUSE_DOWN, this, this.mouseDown); Laya.stage.off(Laya.Event.MOUSE_UP, this, this.mouseUp); } protected mouseDown(e: Laya.Event): void { this.camera.transform.localRotation.getYawPitchRoll(this.yawPitchRoll); this.lastMouseX = Laya.stage.mouseX; this.lastMouseY = Laya.stage.mouseY; this.isMouseDown = true; } protected mouseUp(e: Laya.Event): void { this.isMouseDown = false; } protected mouseOut(e: Laya.Event): void { this.isMouseDown = false; } /** * 向前移动。 * @param distance 移动距离。 */ moveForward(distance: number): void { this._tempVector3.x = this._tempVector3.y = 0; this._tempVector3.z = distance; this.camera.transform.translate(this._tempVector3); } /** * 向右移动。 * @param distance 移动距离。 */ moveRight(distance: number): void { this._tempVector3.y = this._tempVector3.z = 0; this._tempVector3.x = distance; this.camera.transform.translate(this._tempVector3); } /** * 向上移动。 * @param distance 移动距离。 */ moveVertical(distance: number): void { this._tempVector3.x = this._tempVector3.z = 0; this._tempVector3.y = distance; this.camera.transform.translate(this._tempVector3, false); } } 运行时效果如动图6-3所示 （动图6-3） 七、 各种渲染精灵简介 7.1 MeshSprite3D精灵 MeshSprite3D 是引擎中最常用的 静态网格精灵，可根据于美术软件预制作或自定义的网格数据渲染模型。例如图7-1场景中的各种建筑模型、山体岩石一般均为MeshSprite3D （图7-1） 通常我们在实践中会创建简单的Mesh网格3D对象，如图7-2所示 （图7-2） 也可以通过代码添加这些Mesh网格 //正方体 var box = new Laya.MeshSprite3D(Laya.PrimitiveMesh.createBox(0.5, 0.5, 0.5)); this.scene.addChild(box); box.transform.position = new Laya.Vector3(2.0, 0.25, 0.6); box.transform.rotate(new Laya.Vector3(0, 45, 0), false, false); //球体 var sphere = new Laya.MeshSprite3D(Laya.PrimitiveMesh.createSphere(0.25, 20, 20)); this.scene.addChild(sphere); sphere.transform.position = new Laya.Vector3(1.0, 0.25, 0.6); //圆柱体 var cylinder = new Laya.MeshSprite3D(Laya.PrimitiveMesh.createCylinder(0.25, 1, 20)); this.scene.addChild(cylinder); cylinder.transform.position = new Laya.Vector3(0, 0.5, 0.6); //胶囊体 var capsule = new Laya.MeshSprite3D(Laya.PrimitiveMesh.createCapsule(0.25, 1, 10, 20)); this.scene.addChild(capsule); capsule.transform.position = new Laya.Vector3(-1.0, 0.5, 0.6); //圆锥体 var cone = new Laya.MeshSprite3D(Laya.PrimitiveMesh.createCone(0.25, 0.75)); this.scene.addChild(cone); cone.transform.position = new Laya.Vector3(-2.0, 0.375, 0.6); //平面 var plane = new Laya.MeshSprite3D(Laya.PrimitiveMesh.createPlane(6, 6, 10, 10)); this.scene.addChild(plane); 7.2 SkinnedMeshSprite3D精灵 SkinnedMeshSprite3D 是引擎中的 蒙皮动画网格精灵，可根据美术软件预制作的网格数据和Animator组件的动画数据产生动作形变。常用于带蒙皮动画的角色、怪物等。和MeshSprite3D相比具产生网格形变的能力。 （图7-3） 7.3 Particle3D 精灵 Particle3D 是引擎中的 3D粒子精灵,可根据美术人员编辑的粒子参数产生奇妙炫酷的粒子特效。一般用于各种角色技能特效或火焰、烟雾等场景特效。 （动图7-4） 7.4 PixelLine 精灵 PixelLine 是引擎中的 像素线精灵,可根据脚本的绘制数据产生任意颜色的像素线。一般用于场景中的引导效果或项目调试数据用途。 （图7-5） 7.5 Trail 精灵 Trail 是引擎中的 拖尾精灵,可根据精灵运动轨迹产生动态的拖尾特效。一般用于各种轨迹拖尾效果的展示。 （动图7-6） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-05-10 20:43:01 "},"3D/displayObject/readme.html":{"url":"3D/displayObject/readme.html","title":"3D基础显示对象","keywords":"","body":"3D基础显示对象一、概述二、IDE中创建与使用2.1 创建对象2.2 基础变换使用2.3 属性设置2.4 添加组件2.5 添加材质和纹理三、 代码创建与使用3.1 代码创建3.2 基础变换使用3.3 属性设置3.4 添加组件3.5 添加材质和纹理3D基础显示对象 一、概述 3D基础显示对象，在3D开发环境中是非常重要的辅助工具，是能够帮助开发者在3D场景中学习和使用的基础，往往对于初学者来说，通过创建和操作3D基础显示对象，可以快速了解3D基础知识，熟悉3D开发环境，同时在没有其它模型资源的情况下，可以快速建立概念，搭建场景，添加不同的组件，也可以快速熟悉代码开发。对于熟练的开发者来说，通过3D基础显示对象，可以方便的模拟和实现一些开发需求，或者用来展示一些开发逻辑，可以大大提高工作效率。 目前LayaAir IDE中可以创建的3D基础显示对象种类有： Cube（立方体） Sphere（球体） Cylinder（圆柱体） Capsule（胶囊体） Cone（锥体） Plane（平面） （图1-1） 如图1-1所示，下面我们来看看在IDE和代码中是如何创建和使用这些3D基础对象的 二、IDE中创建与使用 对于初级开发者来说，在IDE中学会简单的创建和使用3D基础对象是非常重要的一步！ 2.1 创建对象 在一个3D场景的Hierarchy窗口中，任何节点下，或者是空白位置，都可以通过鼠标右键来创建3D显示对象，如动图2-1所示 （动图2-1） 创建这六种基础对象就不一一演示了，我们可以通过菜单来选择创建，如图2-1 （图2-1） 2.2 基础变换使用 移动，旋转，缩放是对3D对象来说最基础的变换操作，如动图2-2所示 （动图2-2） 2.3 属性设置 每个3D基础对象，都具有 MeshRenderer 组件，通过给接收阴影的面片设置 Receive Shadow 和给产生阴影的立方体设置 Case Shadow 来创建阴影效果，如动图2-3所示 （动图2-3） 2.4 添加组件 每个3D基础对象，都可以添加组件来实现高级的功能，通过对立方体添加3D物理组件 Rigidbody3D ，勾选重力属性，最后添加碰撞盒，可以实现模拟自由落体的效果，如动图2-4所示 （动图2-4） 运行时可以看到立方体下落的效果 （动图2-5） 2.5 添加材质和纹理 每个3D基础对象，都可以通过创建 Material，并在 MeshRenderer 组件中指定新创建的材质，来设置 albedo Texture 纹理 ，如动图2-6所示 （动图2-6） 三、 代码创建与使用 通过代码来创建和使用3D基础对象，也是我们了解和熟悉LayaAir引擎的过程 3.1 代码创建 3.1.1 PrimitiveMesh 类用于创建简单网格 注意：这里还不是最终场景中看到的 Sprite3D。 用 createBox 来举例，看下API是如何创建网格的： /** * 创建Box网格。 * @param long 半径 * @param height 垂直层数 * @param width 水平层数 * @return */ static createBox(long: number = 1, height: number = 1, width: number = 1): Mesh 可以看到，通过 createBox 方法，可以创建Box网格，而且还可以创建不同的垂直和水平高度 因此，可以通过代码创建不同类型的Mesh网格： //正方体 let box = Laya.PrimitiveMesh.createBox(0.5, 0.5, 0.5); //球体 let sphere = Laya.PrimitiveMesh.createSphere(0.25, 20, 20); //圆柱体 let cylinder = Laya.PrimitiveMesh.createCylinder(0.25, 1, 20); //胶囊体 let capsule = Laya.PrimitiveMesh.createCapsule(0.25, 1, 10, 20); //圆锥体 let cone = Laya.PrimitiveMesh.createCone(0.25, 0.75); //平面 let plane = Laya.PrimitiveMesh.createPlane(6, 6, 10, 1)); 创建好的对象是Mesh网格，如果想要创建出场景中能看到的Sprite3D对象，我们还需要使用 Laya.MeshSprite3D 类 3.1.2 MeshSprite3D 使用 MeshSprite3D 类，可以通过构造方法，传入 Mesh 对象，创建出场景能看到的 Sprite3D 对象，同时是带有 Mesh 形状的 Sprite3D 构造方法如下： /** * 创建一个 MeshSprite3D 实例。 * @param mesh 网格,同时会加载网格所用默认材质。 * @param name 名字。 */ constructor(mesh: Mesh = null, name: string = null) { super(name); this._meshFilter = this.addComponent(MeshFilter); this._render = this.addComponent(MeshRenderer); (mesh) && (this._meshFilter.sharedMesh = mesh); } MeshSprite3D 对象是会创建 MeshFilter （网格过滤器）和 MeshRenderer （网格渲染器）组件的。 最后，我们通过 MeshSprite3D 来创建并添加到场景中，代码如下： //创建Box网络 let boxMesh: Laya.Mesh = Laya.PrimitiveMesh.createBox(0.5, 0.5, 0.5); //创建MeshSprite3D网络 let boxMeshSprite3D: Laya.MeshSprite3D = new Laya.MeshSprite3D(boxMesh); //添加到场景中 let box = this.scene.addChild( boxMeshSprite3D ); 运行时效果如下： （图3-1） 3.2 基础变换使用 使用 Transform3D 类，可以对3D基础对象做基础变换，代码示例如下： //改变立方体的世界坐标 cube.transform.position = new Laya.Vector3(0, 0, 0); //立方体的平移 cube.transform.translate( new Laya.Vector3(1, 1, 1)); //立方体的旋转 cube.transform.rotate(new Laya.Vector3(0, 45, 0), false, false); //立方体的缩放 cube.transform.setWorldLossyScale( new Laya.Vector3(2, 2, 2)); 3.3 属性设置 通过对 MeshRenderer 组件的属性设置，可以给接收阴影的面片设置 Receive Shadow 和给产生阴影的立方体设置 Case Shadow 来创建阴影效果，代码示例如下： //立方体产生阴影 cube.meshRenderer.castShadow = true; //创建平面 var plane = this.scene.addChild(new Laya.MeshSprite3D(Laya.PrimitiveMesh.createPlane(6, 6, 10, 10))); //平面接收阴影 plane.meshRenderer.receiveShadow = true; 3.4 添加组件 每个3D基础对象，都可以通过代码添加组件来实现高级的功能，通过对立方体添加3D物理组件 Rigidbody3D ，设置重力属性，最后添加碰撞盒，可以实现模拟自由落体的效果，代码示例如下： //添加Rigidbody3D组件 let rigidbody3D : Laya.Rigidbody3D = cube.addComponent(Laya.Rigidbody3D); //设置重力 rigidbody3D.overrideGravity = true; //创建盒子形状碰撞器 let boxShape: Laya.BoxColliderShape = new Laya.BoxColliderShape(1, 1, 1); //设置盒子的碰撞形状 rigidbody3D.colliderShape = boxShape; 3.5 添加材质和纹理 每个3D基础对象，都可以通过代码添加材质和纹理，代码示例如下： //预加载纹理资源 let resource: string = \"layabox.png\"; Laya.loader.load(resource).then( ()=>{ //创建BlinnPhong材质 let materialBill: Laya.BlinnPhongMaterial = new Laya.BlinnPhongMaterial; cube.meshRenderer.material = materialBill; //为材质加载纹理 var tex = Laya.Loader.getTexture2D(\"layabox.png\"); //设置贴图 materialBill.albedoTexture = tex; } ); 运行时效果如下： （图3-2） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:44 "},"3D/Camera/readme.html":{"url":"3D/Camera/readme.html","title":"使用3D摄像机","keywords":"","body":"一篇学会使用3D摄像机一、概述二、 摄像机参数三、 移动和旋转四、 清除标志五、 正交投影和透视投影六、 裁剪七、 视图矩形八、高动态光照渲染九、 如何从摄像机创建一条射线十、 可视遮罩层Layer十一、 捕捉目标十二、 横纵比十三、目标纹理十四、其它一些参数一篇学会使用3D摄像机 一、概述 我们都知道，电影是通过摄像机将故事与画面呈现给观众。 虚拟的3D世界，也需要通过虚拟的摄像机，将三维画面及情节呈现给用户或者玩家。在3D游戏中，Camera相当于眼睛，通过他来看世界，一切景象都通过Camera来渲染。也就是说如果场景内没有摄像机，那么游戏画面内就不会显示任何物体。场景中的摄像机还可以放置在场景中的子节点中，比如添加到主角角色模型中，同样可以呈现3D画面。 在LayaAir引擎中，我们可以有一个摄像机，也可以有多个摄像机同时工作，这取决于我们开发者的实际需求。 本篇，我们来学习如何控制LayaAir引擎3D摄像机，以及日常使用摄像机的功能介绍。 二、 摄像机参数 下面我们先来了解一个3D场景中的摄像机的参数都有哪些，通过创建3D-RPG项目来参考，如图2-1所示 （图2-1） 当我们创建一个新的3D场景时，引擎会自动添加一个主摄像机 Main Camera 在Scene3D节点下。当然也还可以添加更多的摄像机。当我们如图2-1所示，选中主摄像机时，Scene窗口中会出现一个Camera Preview窗口，用来显示主摄像机所看到的视野，这样方便我们来预览，当我们移动或者旋转摄像机时，预览中的视野会随着改变，当然其他的参数设置也会有所变化，后面我们会详细讲解。 通过图2-2所示，LayaAir中摄像机具备如下一些参数设置，这些参数能够很好的满足项目的需要，红色的参数会是我们常用的设置 （图2-2） 三、 移动和旋转 如图2-2所示，最上面的红色区域内的参数，就是摄像机的位置和旋转，区别于其他场景内的物体，摄像机的位置和旋转，不只是自己的参数，而是能够对我们的视野做出改变。 （动图3-1） 通常我们可以通过Scene窗口下的移动和旋转，来调整摄像机的位置，如动图3-1所示 （动图3-2） 也可以用另外一种方式定位摄像机，如动图3-2所示， 先在Scene窗口中移动场景， 找到合适你的位置和角度，点Main Camera节点，同时按下 Ctrl+Shift+F ，此时摄像机的位置和角度就会变更到你所定位的点。 当然这只是在编辑器中调整摄像机的位置，可能是初始化场景时摄像机的初始位置。在3D游戏中，往往我们需要通过代码来调整摄像机的位置，比如摄像机一直跟随主角的移动和旋转来做调整，如动图3-3所示 （动图3-3） 我们可以通过代码来处理，在Main Camera节点下添加CameraControll 脚本，随着主角的移动，摄像机的位置也同步移动，如下 const { regClass, property } = Laya; @regClass() export default class CameraControll extends Laya.Script { @property( { type: Laya.Sprite3D } ) public target: Laya.Sprite3D; private camera: Laya.Camera; public distanceUp: number = 0.5;//相机与目标的竖直高度参数 public distanceAway: number = 10;//相机与目标的水平距离参数 public smooth: number = 2;//位置平滑移动插值参数值 public camDepthSmooth: number = 20 public curpos: Laya.Vector3; private delatpos: Laya.Vector3; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 * 此方法为虚方法，使用时重写覆盖即可 */ onAwake(): void { this.curpos = new Laya.Vector3(); } /** * 第一次执行update之前执行，只会执行一次 * 此方法为虚方法，使用时重写覆盖即可 */ onStart(): void { this.camera = this.owner as Laya.Camera; if (this.target) { this.target.transform.position.cloneTo(this.curpos); this.delatpos = new Laya.Vector3(); } } /** * 每帧更新时执行，尽量不要在这里写大循环逻辑或者使用getComponent方法 * 此方法为虚方法，使用时重写覆盖即可 */ onUpdate(): void { if (!this.target || !this.camera) return; this.target.transform.position.vsub(this.curpos, this.delatpos); this.camera.transform.position.vadd(this.delatpos, this.delatpos); this.camera.transform.position = this.delatpos; this.target.transform.position.cloneTo(this.curpos); } } 四、 清除标志 接下来，介绍摄像机的清除标志，如图4-1所示。 （图4-1） 每个摄相机在渲染时，都会先将颜色和深度信息存储起来，也就是ColorBuffer与DepthBuffer，然后下一帧直接读取缓冲区中颜色和深度信息，而不是实时计算的。 当使用多个摄像机时，由于每一个摄像机都将自己的颜色和深度信息存储在缓冲区中，那将积累大量的渲染数据。 所以，Clear Flags（清除标记）可以决定是否清除当前渲染之前存储起来的缓冲区信息，该属性功能有四个选项（Sky、Solid Color、Depth only、Nothing），是起到具体清除什么缓冲信息的作用。下面分别介绍。 Skybox 天空盒 天空盒是默认选项， 表示着清除当前渲染之前的全部摄相机缓冲区的颜色与深度信息，使用天空盒代替，如图4-2所示。如果没有指定天空盒，则会显示默认清除色（Clear Color属性的颜色）。 （图4-2） Solid Color 纯色 表示着清除当前渲染之前的全部摄相机缓冲区的颜色与深度信息，使用清除色（Clear Color属性的颜色）代替，屏幕上的任何空的部分都将显示当前摄像机的颜色。如图4-3所示。 （图4-3） Depth only 仅深度 表示着只清除当前渲染之前的全部摄相机缓冲区的深度信息，保留全部摄相机缓冲区的颜色信息。 这个功能非常实用，要想将多个摄像机的画面，渲染到同一个画面，就可以通过Depth only选项来实现，如图4-4所示。 （图4-4） 此时，我们在场景中添加了一个新的摄像机Camera2，Clear Flag使用Depth only，把摄像机Camera2的视野朝向主角，点击运行，我们可以看到，场景的渲染不变还是用的天空盒，但是主摄像机是主角所看到的视野，但是屏幕中还有显示了主角，那就是Camera所看到的，也就是保留了深度信息。如图4-5所示 （图4-5） 注意：当Clear Flags的Depth only开启后，LayaAir引擎会通过摄像机的渲染顺序来控制。默认的渲染顺序就是节点的渲染顺序，开发者也可以通过LayaAir引擎摄像机的renderingOrder来改变渲染顺序。 如果第一摄像机的Clear Flags设置的是Skybox，那第二摄像机的Clear Flags设置Depth only， 这时需要第一摄像机的渲染顺序在第二摄像机的渲染顺序之前，如图4-6所示，Main Camera节点在Camera2节点之上，所以两个摄像机的渲染画面才会合并到一起，出现图4-6的效果。 （图4-6） 如果顺序反了， Camera2先渲染的话，虽然只清理了深度信息保留了颜色信息。但后渲染的Main Camera会把前面所有缓冲区深度和颜色的都清理掉，所以就没办法看到合并到一起的画面了。 在同一个场景中，可以使用多个摄像机，当加载到场景中后，它们会产生各自的游戏视图画面。在我们以前遇到的游戏中，如双人3D游戏就使用了两个3D摄像机，左半屏幕显示一个玩家，右半屏幕显示另一个，极大的丰富了游戏性。不过多摄像机的缺点是非常耗性能，模型三角面数与DrawCall数量会成倍上升，多几个摄像机就会多出几倍性能损耗，因此开发者们需酌情考虑。 另外，再顺便提一下Culling Mask（剔除遮罩）， （图4-7） 在LayaAir中，可以为每个节点设置所属的Layer(层)，不设置就是默认的Default层。图4-7所示，是主角这个节点，默认使用Default层 Culling Mask就是针对层的渲染剔除进行设置，通常会与Depth only搭配使用。例如，将Cube节点设置到一个独立的cube层上，Culling Mask选择cube层，那渲染的时候，将会剔除该摄像机其它的节点物体，像遮罩效果一样，只保留cube层上的节点物体，这样，摄像机合并显示的时候，就只合并保留层上的节点物体。如图4-8所示 （图4-8） 设置cullingMask可以指定单层，也可以多层混合，例如： xx.cullingMask=Math.pow(2,0)|Math.pow(2,1); //该代码表示为第0层和第1层渲染显示。 Nothing 不清除 表示该选项不清除摄相机缓冲区的信息，颜色与深度信息全都保留着。这样做会导致每帧渲染的结果都会叠加在下一帧之上。如动图4-9所示 （动图4-9） 看起来这选项没有存在的必要，事实上的确不常用，但在一些特定场合还是用的上，例如结合自定义shader来使用。 五、 正交投影和透视投影 摄像机成相效果的投影方式有两个选项，分别是默认值透视模式Perspective和正交模式Orthographic。 在LayaAir中，通过是否勾选Orthographic来选择使用哪种方式，如图5-1 （图5-1） Perspective 透视模式 当我们没有勾选Orthographic，就是采用Perspective方式，也是最常用的方式。透视投影的观察体是视锥体，它使用一组由投影中心产生的放射投影线，将三维对象投影到投影平面上去。这种透视模式，是一种模拟了人眼近大远小视觉效果的摄像机成相模式，如动图5-2所示。 （动图5-2） Field of view 视野范围 从动图5-2可以看到，通过修改Field Of View，可以调整透视模式下的视野范围，从4到120度，只有使用透视投影时，Field Of View才有效 Orthographic 正交模式 正交投影模式的观察体是规则的长方体，它使用一组平行投影，将三维对象投影到投影平面上去。如图5-3所示 （图5-3） Orthographic Size 视野大小 正交模式有一个关联属性Size，用于设置正交模式下的视野大小，如动图5-4所示 （动图5-4） 六、 裁剪 剪裁平面是与摄像机视野方向垂直的平面。通过近裁剪面与远裁剪面两个子参数来设置摄像机渲染的范围，超出范围的部分不会被渲染显示，犹如被剪裁掉的效果。如图6-1所示 （图6-1） Near 近裁面 是指离摄像机视野方向最近的剪裁面，小于Near距离值的不渲染。 Far 远裁面 是指离摄像机视野方向最远的剪裁面，大于Far距离值的不渲染。 如动图6-2所示，我们来看看修改这两个参数的效果 （动图6-2） 七、 视图矩形 视图矩形是通过X\\Y\\W\\H四个数值来控制摄像机的视图在屏幕中的位置和大小的功能。这四个数值均使用屏幕坐标系，数值范围是0～1，可以设置小数。 具体的参数说明为： X：水平位置起点 Y：垂直位置起点 W：宽度 H：高度 需要注意的是，在LayaAir中表示屏幕左上角(0,0)位置。如图7-1所示 （图7-1） 假如我们将屏幕水平位置起点X设置为0.25，屏幕垂直位置起点Y设置为0.25，宽度W设为0.5，高度H设为0.5，在LayaAir中效果如图7-2所示。 （图7-2） 八、高动态光照渲染 高动态范围图像（High-Dynamic Range）简称HDR。HDR相比普通的图像，可以提供更多的动态范围和图像细节，它能够更好的反映出真实环境中的视觉效果。 （图8-1） Allow HDR 用于开启摄像机的高动态范围渲染功能，默认是不勾选状态，代表默认不开启HDR。如图8-1所示 由于HDR需要基于webGL 2.0，但是webGL 2.0并没有在各个平台中普及，尤其是一些小游戏的平台。所以，当我们在某些不支持webGL 2.0的平台中发布产品。需要将这里的 Allow HDR选项去掉。或者在引擎里将摄像机的HDR关闭。 开启HDR，还会导致LayaAir引擎抗锯齿功能无效，需要开启抗锯齿功能的，也不能开启HDR 九、 如何从摄像机创建一条射线 在前面的 图形系统基础概念 有讲解过射线这个基础工具。 这里我们从摄像机创建一条射线，使用的是camera的 viewportPointToRay 方法。生成的这条射线是从摄像机的近裁剪面的一点出发，向远裁剪面的一点。这个射线的反向延长线经过摄像机机的原点。 （图9-1） 实战练习 参照3D-RPG项目，我们加上一段代码，当鼠标点击屏幕时，会发射一条射线，这条射线碰到的点，会创建一个立方体。代码和效果如下所示 //在CameraControll.ts类下的onStart()方法中，加入鼠标按下监听 //Laya.stage.on(Laya.Event.MOUSE_DOWN,this, this.onMouseDown); //鼠标点下事件，处理发射射线，检测碰撞物体 onMouseDown(e: Laya.Event) { let point = new Laya.Vector2(); point.x = Laya.stage.mouseX; point.y = Laya.stage.mouseX; //产生射线 let ray = new Laya.Ray(new Laya.Vector3(0, 0, 0), new Laya.Vector3(0, 0, 0)); this.camera.viewportPointToRay(point,ray); //拿到射线碰撞的物体 let outs : any[] = []; this.scene.physicsSimulation.rayCastAll(ray,outs); //如果碰撞到物体 if (outs.length !== 0) { for (let i = 0; i （动图9-1） 十、 可视遮罩层Layer 前面也提到过Culling Mask的用处，在我们制作游戏时，我们也可用通过代码来达到‘ 隐身 ’的效果。 实战练习 还是用3D-RPG项目为例，我们先设置两个Layer （图10-1） 继续，我们把这两个屋子的Layer改为Building1和Building2，如图10-2，10-3所示 （图10-2） （图10-3） 我们在CameraControll.ts类添加如下代码 onMouseDown(e: Laya.Event) { //清除所有图层 this.camera.removeAllLayers(); this.layerIndex++; //设置可视图层 this.camera.addLayer(this.layerIndex%2+ 1); } 这是效果如动图10-4 （动图10-4） 十一、 捕捉目标 在创建摄像机时，我们经常需要调整摄像机的位置，用于对准显示某个三维物体，或显示某个区域。对于初学者来说，空间思维还未形成习惯，调整位置所花的时间会很多。LayaAir 3D引擎3D变换提供了一个lookAt()方法，用于捕捉目标，自动调整3D对象对准目标点。摄像机也可以使用它达到我们的调整视角的目的。 （图11-1） 实战练习 同样，我们在3D-RPG项目中，通过鼠标点击来切换所见区域，代码如下 //CameraControll.ts类脚本中，添加3个节点对象，把3个不同的房子建筑拖入到属性中 @property( { type: Laya.Sprite3D } ) public target1: Laya.Sprite3D; @property({ type: Laya.Sprite3D }) public target2: Laya.Sprite3D; @property({ type: Laya.Sprite3D }) public target3: Laya.Sprite3D; private _up = new Laya.Vector3(0, 1, 0); //同样，添加鼠标事件，来修改摄像机对3个建筑的朝向 onMouseDown(e: Laya.Event) { this.index++; if (this.index % 3 === 1 ){ //摄像机捕捉模型目标 this.camera.transform.lookAt(this.target1.transform.position, this._up); } else if (this.index % 3 === 2){ //摄像机捕捉模型目标 this.camera.transform.lookAt(this.target2.transform.position, this._up); } else{ //摄像机捕捉模型目标 this.camera.transform.lookAt(this.target3.transform.position,this._up); } } 效果如下： （动图11-2） 十二、 横纵比 我们一般不会手动设置屏幕的横纵比，在运行过程中会通过计算自动设置横纵比。但是在一些特殊的情况下需要对横纵比手动设置时，可以自己手动设置。如果需要重置横纵比，变回自动改变横纵比，只需要将这个值设置为0 //手动设置横纵比 camera.aspectRatio = 2; //重置 camera.aspectRatio = 0; 十三、目标纹理 目标纹理就是指摄像机的 RenderTarget 属性。它将摄像机的视图放置在一个纹理上，该纹理可以被应用到另一个对象。这样就可以方便地创建镜子，监控摄像机等效果了。注意的是使用了该属性的摄像机将禁用渲染到屏幕的功能。 实战练习 我们依然用3D-RPG项目为例，Main Camera为场景主渲染摄像机，添加一个新的 renderTargetCamera 为开启 RenderTarget 属性的摄像机。同时在场景中添加一个Plane，面向主摄像机，如图13-1所示 （图13-1） 接下来，我们把Plane和renderTargetCamera添加到CameraControll.ts脚本中，并添加代码： //选择渲染目标为纹理 this.renderTargetCamera.renderTarget = Laya.RenderTexture.createFromPool(512, 512, Laya.RenderTargetFormat.R8G8B8A8, Laya.RenderTargetFormat.DEPTH_16, false, 1); //渲染顺序 this.renderTargetCamera.renderingOrder = -1; //清除标记 this.renderTargetCamera.clearFlag = Laya.CameraClearFlags.Sky; //创建一个UnlitMaterial材质 var mat1: Laya.UnlitMaterial = new Laya.UnlitMaterial(); mat1.albedoColor = new Laya.Color(1.0, 1.0, 1.0, 1.0); mat1.cull = Laya.RenderState.CULL_NONE; //指定plane的材质为创建的材质 this.plane.getComponent(Laya.MeshRenderer).sharedMaterial = mat1; //指定纹理为摄像机的渲染目标 mat1.albedoTexture = this.renderTargetCamera.renderTarget; 在LayaAir引擎中渲染顺序是越小渲染优先度越高 好，我们来运行看下效果，如动图13-2所示，场景中多了一个摄像机的视图放在Plane上作为纹理 （动图13-2） 十四、其它一些参数 （图14-1） 如图14-1所示 Msaa：多重采样抗锯齿。Msaa首先来自于OpenGL。具体是Msaa只对Z缓存( Z-Buffer)和模板缓存（Stencil Buffer）中的数据进行超级采样抗锯齿的处理。可以简单理解为只对多边形的边缘进行抗锯齿处理 Fxaa：快速近似抗锯齿。FXAA的基本原理与MSAA相同，都是通过提取像素界面周围的颜色信息并完成混合来消除高对比度界面所产生的锯齿。但是FXAA将像素的提取和混合过程交由GPU内的ALU来执行，因此其所占用的显存带宽要大大低于传统的MSAA。 Depth Texture Mode：深度贴图模式 ​ None：不生成深度贴图 ​ Depth：生成深度贴图 ​ DepthNormals：生成深度+法线贴图 ​ DepthAndDepthNormals：暂未实现 Opaque Pass：开启opaquePass后，会生成非透明物体贴图。在Shader中可以引入u_cameraOpaqueTexture来得到相机渲染管线的非透明图片。使用非透明物体贴图功能，可以实现玻璃折射，水面折射，热浪等效果 详情见示例 GlassRefractionDemo ，链接: https://layaair2.ldc2.layabox.com/demo2/?language=zh&category=3d&group=Advance&name=GlassRefractionDemo Enable Blit Depth：设置是否使用内置的深度贴图 (如果开启，只可在后期使用深度贴图，不可在渲染流程中使用) Depth Texture Format：摄像机深度格式与深度纹理的默认值是DEPTH_16，随着深度广泛的使用，有的开发者会发现16位的深度已然不够用，现在增加了24位和32位深度模式的值。用于设置depthTextureFormat属性。 （图14-2） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-05-16 15:05:03 "},"3D/Light/readme.html":{"url":"3D/Light/readme.html","title":"3D灯光与阴影","keywords":"","body":"使用3D灯光和阴影一、概述二、PointLight2.1 创建点光源2.2 组件属性2.3 使用代码设置三、DirectionLight3.1 创建平行光3.2 组件属性3.3 使用代码设置四、SpotLight4.1 创建聚光4.2 组件属性4.3 使用代码设置五、AreaLight5.1 创建区域光5.2 组件属性六、如何为灯光添加阴影七、多光源渲染使用3D灯光和阴影 一、概述 光源是每一个场景的重要组成部分。网格和纹理决定了一个物体的形状和外观，但是光源决定了你的环境的颜色和氛围。灯光的种类有多种，不同的光源呈现的效果不同，可以设置不同的参数。 目前光源的种类有： DirectionLight（平行光） PointLight（点光源） SpotLight（聚光灯） AreaLight（区域光） 本篇会一一讲解这四种光源。 二、PointLight PointLight（点光源）是向四面八方发射光线的光源，又称全向光或者球状光，现实中的点光源比如灯泡、蜡烛，可以感觉到点光源是有强度、颜色和衰减半径属性。 如图2-1所示，在一个建筑中，周围都是墙壁，其中创建的点光源，可以通过设置强度，颜色，半径来设置光源效果 （图2-1） 2.1 创建点光源 （动图2-2） 如动图2-2所示，在Scene3D或者任意节点下，鼠标右键选择Light，点击PointLight，即可在场景中创建一个点光源。 2.2 组件属性 2.2.1 基础属性 如图2-3所示，当创建一个PointLight后，在Inspector属性面板中会有如下几个属性 （图2-3） Color：点光源的颜色 （图2-4） Intensity：点光源的强度 （图2-5） Range：设置点光源的范围，相当于点光源的照射范围，数值越大，光照范围越大。 （图2-6） Lightmap Bake Type：光源模式 ​ Mixed：混合光源 ​ 混合光源结合了实时光源和光照烘焙。可以使用混合光源将动态阴影与来自同一光源的烘焙照明相结合，或者在希望灯光提供直接实时照明和烘焙间接照明时使用混合灯光。可在运行时更改混合光源的属性。这样做将更新光源的实时光照，但不会更新烘焙光照。由于混合灯光总是至少结合一些实时和一些烘焙灯光，因此混合灯光总是比完全烘焙灯光涉及更多的运行时计算，并且比完全实时灯光使用更高的内存。 ​ Realtime：实时光源 ​ LayaAir会在运行时为实时光源执行光照计算，每帧进行一次。你可以在运行时更改实时光源的属性，从而创建诸如闪烁的灯泡或穿过暗室的火炬之类的效果。 实时光源可用于在角色或可移动的几何体上提供光照和投射阴影。为实时光源执行运行时计算可能成本很高。 ​ Baked：烘焙光源 ​ LayaAir为烘焙光源执行计算，并将结果作为光照数据保存到磁盘中。这一过程称为烘焙。在运行时，LayaAir将加载烘焙的光照数据，并使用这一数据来照亮场景。由于复杂的计算是预先执行的，因此烘培光源可以减少运行时的着色成本，并减少阴影的渲染成本。烘焙光源可用于照亮在运行时不会发生变化的对象，例如景物。 2.2.2 烘焙属性 如图2-7所示，当选择Lightmap Bake Type为Baked时，下面会出现三个参数。此功能是为了对烘焙效果提前做出设置。 由于只有在烘焙执行后，才能看到烘焙效果，有可能会对如下参数反复进行调整，不断烘焙出最佳效果。 （图2-7） ​ Box：立方体天空盒 ​ Dome：球形天空盒 Material：指定天空盒的材质 Power：烘焙的光照强度 Radius：烘焙的光照半径 Max Bounces：烘焙的光照最大反弹数 （图2-8） 图2-8所示，为对一个建筑场景添加多个点光源，烘焙后的效果 2.3 使用代码设置 //创建点光源 var pointLight: PointLight = (this.scene.addChild(new PointLight())); //点光源的颜色 pointLight.color = new Color(1.0, 0.5, 0.0, 1); pointLight.transform.position = new Vector3(0.4, 0.4, 0.0); //设置点光源的范围 pointLight.range = 3.0; //设置点光源的强度 pointLight.intensity = 2; 三、DirectionLight Direction Light（平行光）与点光区别较大，它有固定的一个方向，可通过弧度值设定，并且也没有衰减和光照范围，会对全场景所有模型进行照亮。3D世界中经常用来模拟固定方向的太阳光。 当新建一个3D场景时，DirectionLight是默认自带的 如图3-1所示，在一个场景中，通过调整平行光的角度，可以调整场景的光照效果 （动图3-1） 3.1 创建平行光 （动图3-2） 如动图3-2所示，在Scene3D或者任意节点下，鼠标右键选择Light，点击DirectionLight，即可在场景中创建一个平行光。 3.2 组件属性 3.2.1 基础属性 如图3-3所示，当创建一个DirectionLight后，在Inspector属性面板中会有如下几个属性 （图3-3） Color：平行光的颜色 （图3-4） Intensity：平行光的强度 （图3-5） Lightmap Bake Type：光源模式，同点光源一样 Shadow Mode：阴影模式 Shadow Cascades Mode：阴影的级联模式 （动图3-6） 如动图3-6所示，可以开启阴影模式的效果，同时调整平行光的角度，可以看到阴影随着改变。我们将会在第六章介绍阴影 3.2.2 烘焙属性 如图3-7所示，当选择Lightmap Bake Type为Baked时，下面会出现三个参数。此功能是为了对烘焙效果提前做出设置。 （图3-7） Power：烘焙的光照强度 Radius：烘焙的光照角度 Max Bounces：烘焙的光照最大反弹数 3.3 使用代码设置 //方向光的颜色 this.directionLight.getComponent(Laya.DirectionLightCom).color.setValue(1, 1, 1, 1); //设置平行光的方向 var mat: Matrix4x4 = this.directionLight.transform.worldMatrix; mat.setForward(new Vector3(-1.0, -1.0, -1.0)); this.directionLight.transform.worldMatrix = mat; setForward 平行光的方向，分别代表x、y、z轴上的方向，负数为负轴，正数为正轴，值的范围为-1—0—1，超过范围后为-1或1，初学者们可以在这个范围内设值观察方向的变化。 （动图3-8） 如动图3-8，设置平行光旋转看到的效果 四、SpotLight SpotLight 聚光指的是从特定光源方向射出的光，比如手电筒，舞台筒灯等。光照区域根据距离因素逐渐放大，同时光照区域边缘也有衰减现象。 如图4-1所示，在一个场景中，通过调整聚光的锥形角度，可以调整场景的光照效果 （动图4-1） 4.1 创建聚光 （动图4-2） 如动图4-2所示，在Scene3D或者任意节点下，鼠标右键选择Light，点击SpotLight，即可在场景中创建一个聚光。 4.2 组件属性 4.2.1 基础属性 如图4-3所示，当创建一个SpotLight后，在Inspector属性面板中会有如下几个属性 （图4-3） Color：聚光的颜色 （图4-4） Range：聚光的照射范围，与点光类似，区别只是聚光有方向，而点光无方向 （图4-5） Spot Angle：聚光灯的锥形角度，设置的值越小，聚光光圈的越小，反之光圈越大。 （图4-6） 4.2.2 烘焙属性 如图4-7所示，当选择Lightmap Bake Type为Baked时，下面会出现五个参数。此功能是为了对烘焙效果提前做出设置。 （图4-7） Power：烘焙的光照强度 Radius：烘焙的光照半径 Max Bounces：烘焙的光照最大反弹数 Spot Size：聚光的尺寸 Blend：混合比例，0-1之间 4.3 使用代码设置 //聚光灯 var spotLight = scene.addChild(new Laya.SpotLight()) as Laya.SpotLight; //设置聚光灯颜色 spotLight.color = new Laya.Vector3(1, 1, 0); //设置聚光灯位置 spotLight.transform.position = new Laya.Vector3(0.0, 1.2, 0.0); //设置聚光灯方向 var mat = spotLight.transform.worldMatrix; mat.setForward(new Laya.Vector3(0.15, -1.0, 0.0)); spotLight.transform.worldMatrix = mat; //设置聚光灯范围 spotLight.range = 6.0; //设置聚光灯锥形角度 spotLight.spotAngle = 32; setForward 平行光的方向，分别代表x、y、z轴上的方向，负数为负轴，正数为正轴，值的范围为-1—0—1，超过范围后为-1或1，初学者们可以在这个范围内设值观察方向的变化。 （动图4-8） 如动图4-8，设置聚光灯旋转看到的效果 五、AreaLight AreaLight（区域光）可以通过空间中的两个形状之一定义区域光：矩形或圆盘。区域光从该形状的一侧发射光。发射的光在该形状的表面区域的所有方向上均匀传播。区域光提供的照明强度以与光源距离的平方反比确定的速率减小（见平方反比定律）。由于此照明计算非常占用处理器，因此区域灯光在运行时不可用，只能烘焙到光照贴图中。 由于区域光同时从几个不同方向照亮对象，因此阴影趋向于比其他光源类型更柔和、细腻。您可以使用这种光源来创建逼真的路灯或靠近玩家的一排灯光。小的区域光可以模拟较小的光源（例如室内光照），但效果比点光源更逼真。 如图5-1所示，在一个场景中，通过调整区域光的尺寸和扩散，可以调整场景的光照效果 （动图5-1） 5.1 创建区域光 （动图5-2） 如动图5-2所示，在Scene3D或者任意节点下，鼠标右键选择Light，点击AreaLight，即可在场景中创建一个区域光。 5.2 组件属性 5.2.1 基础属性 如图5-3所示，当创建一个AreaLight后，在Inspector属性面板中会有如下几个属性 （图5-3） Color：区域光的颜色 Intensity：区域光的强度 Shape：区域光的形状 ​ Rect：矩形 ​ Elliptic：圆形 Spread：扩散度 5.2.2 烘焙属性 Max Bounces：烘焙的最大反弹数 六、如何为灯光添加阴影 投影是灯光照射模型时产生的即时阴影，可随着灯光角度、灯光强度、模型位置等变化而变化。投影是3D世界最重要的因素之一，能产生更加强烈的立体感。 即时阴影非常损耗性能，不能用得太多，特别是游戏场景，模型量较大，一般我们不使用实时投影，而使用静态的光照贴图。 6.1 灯光的阴影属性 要让场景中产生投影，我们需了解灯光的以下属性，每种光源都具备这些属性 6.1.1 阴影模式 （图6-1） ShadowMode：阴影模式，共分为四种模式： ​ None：不产生阴影 ​ Hard：硬阴影，对性能要求较低 （图6-1-1） ​ SoftLow：低强度软阴影，对性能要求一般 （图6-1-2） ​ SoftHigh：高强度软阴影，对性能要求较高 （图6-1-3）效果最好 硬阴影和软阴影的区别：硬阴影（hard shadow）是指由理想电光源（即聚光性能好的单一光源）产生的阴暗均一、边界分明的阴影,它只包含物体的本影（umbra）。软阴影（soft shadow）则是由线、面或体光源等产生的边界柔和、有一定明暗过度的阴影，它包括物体的本影和半影（penumbra）。当物体完全处于阴影中时，即在本影域内，而当物体受到部分光照时则处于半影域内。 6.1.2 阴影属性 当我们选择一种阴影模式后，可以看到设置阴影的属性 （图6-2） shadowStrength：阴影强度，该值越大，阴影越明显。 （动图6-2-1） shadowDistance：灯光产生阴影的范围，范围是指摄像机到模型的距离，超出这个范围的模型将不会产生阴影与接受阴影，开发者可以根据场景大小进行设置。 （图6-2-2） 图6-2-2中，shadowDistance距离为8时的效果 shadowDepthBias：阴影贴图基于深度的偏移，将深度做一个偏移可以有效解决阴影痤疮（”shadow acne”）。但需要提醒的是：在 shadowDepthBias 过大时会导致阴影脱离物体，即”Peter Panning”现象的出现。 shadowNormalBias：阴影贴图基于法线的偏移，将阴影Caster的表面沿着法线方向的反方向偏移，以防止自身阴影（“shadow acne”）伪影的出现。 较大的值可以更好地防止阴影痤疮（”shadow acne”），但要以阴影形状小于实际对象为代价。 shadowNearPlane：阴影视锥的近裁面，可以对阴影视锥的近裁面进行设置。 6.1.3 阴影的级联模式 （图6-3） shadowCascadesMode：阴影的级联模式，数量越大，产生阴影贴图时，将视锥体划分的子视锥体越多，对应的阴影贴图也越多，阴影的质量会越好。 TwoCascades：二级级联阴影分割比例。 （图6-3-1） 图6-3-1中，TwoCascades的效果 FourCascades：四级级联阴影分割比例，X、Y、Z依次为其分割比例，Z必须大于Y，Y必须大于X。 （图6-3-2） 图6-3-2中，FourCascades的效果 6.2 模型的投影属性 除了光源的阴影设置，需要在模型上设置投影属性：如图6-4所示 （图6-4） receiveShadow：是否接受阴影，当模型此属性为true时，计算出的阴影会在此模型上显示出来。在游戏中，我们可以把场景的地面，及场景中可走动区域中的模型 castShadow 属性设置为true。 castShadow：是否产生阴影，当模型此属性为true时，灯光根据产生阴影的模型位置、模型网格形状大小、与灯光的角度等进行阴影计算，然后在接受阴影的模型上产生阴影。比如场景中的角色、NPC等活动游戏元素可以开启此属性。 如动图6-5所示，展现了平行光实时阴影的效果 （动图6-5） 如动图6-6所示，展现了聚光灯实时阴影的效果 （动图6-6） 6.3 使用代码设置 灯光方面的设置: // Use soft shadow. directionLight.shadowMode = ShadowMode.SoftLow; // Set shadow max distance from camera. directionLight.shadowDistance = 3; // Set shadow resolution. directionLight.shadowResolution = 1024; // Set shadow cascade mode. directionLight.shadowCascadesMode = ShadowCascadesMode.NoCascades; // Set shadow normal bias. directionLight.shadowNormalBias = 4; 开启地面接收阴影和模型产生阴影： // A plane receive shadow. var grid: Sprite3D = scene.addChild(Loader.getRes(\"res/threeDimen/staticModel/grid/plane.lh\")); (grid.getChildAt(0)).meshRenderer.receiveShadow = true; // A sphere cast/receive shadow. var sphereSprite: MeshSprite3D = this.addPBRSphere(PrimitiveMesh.createSphere(0.1), new Vector3(0, 0.2, 0.5), scene); sphereSprite.meshRenderer.castShadow = true; 七、多光源渲染 如图7-1所示，在IDE的项目设置中，可以对支持多光源做设置 （图7-1） Enable Multi Light：是否支持多光源 Max Light Count：最大支持的光源数量，目前最大是50 Light Cluster Count： X、Y、Z轴的光照集群数量 X、Y、Z轴的光照集群数量，Z值会影响Cluster接受区域光(点光、聚光)影响的数量，Math.floor(2048 / lightClusterCount.z - 1) * 4 为每个Cluster的最大平均接受区域光数量，如果每个Cluster所接受光源影响的平均数量大于该值，则较远的Cluster会忽略其中多余的光照影响。 （动图7-2） 动图7-2，为多光源的示例，下面为创建多光源的代码 export class MultiLight extends BaseScript { constructor() { super(); } onAwake(): void { var moveScript: LightMoveScript = this.camera.addComponent(LightMoveScript); var moverLights: LightSprite[] = moveScript.lights; var offsets: Vector3[] = moveScript.offsets; var moveRanges: Vector3[] = moveScript.moveRanges; moverLights.length = 15; //添加15个点光源 for (var i: number = 0; i this.scene.addChild(new PointLight())); pointLight.range = 2.0 + Math.random() * 8.0; pointLight.color.setValue(Math.random(), Math.random(), Math.random(), 1); pointLight.intensity = 6.0 + Math.random() * 8; moverLights[i] = pointLight; offsets[i] = new Vector3((Math.random() - 0.5) * 10, pointLight.range * 0.75, (Math.random() - 0.5) * 10); moveRanges[i] = new Vector3((Math.random() - 0.5) * 40, 0, (Math.random() - 0.5) * 40); } //添加一个聚光灯 var spotLight: SpotLight = (this.scene.addChild(new SpotLight())); spotLight.transform.localPosition = new Vector3(0.0, 9.0, -35.0); spotLight.transform.localRotationEuler = new Vector3(-15.0, 180.0, 0.0); spotLight.color.setValue(Math.random(), Math.random(), Math.random(), 1); spotLight.range = 50; spotLight.intensity = 15; spotLight.spotAngle = 60; } } //光源移动脚本 class LightMoveScript extends Laya.Script { forward: Vector3 = new Vector3(); lights: LightSprite[] = []; offsets: Vector3[] = []; moveRanges: Vector3[] = []; onUpdate(): void { var seed: number = Laya.timer.currTimer * 0.002; for (var i: number = 0, n: number = this.lights.length; i Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:44 "},"IDE/sceneEditor/environment/readme.html":{"url":"IDE/sceneEditor/environment/readme.html","title":"3D场景环境设置","keywords":"","body":"3D场景环境设置一、概述二、场景天空2.1 组件属性2.2 使用代码设置场景天空材质2.3 IDE中创建天空盒三、环境光3.1 组件属性3.2 固定颜色3.3 球谐光照四、环境反射4.1 组件属性4.2 天空盒作为反射源4.3 自定义反射源作为反射源4.3 IBL介绍五、场景雾5.1 组件属性5.2 代码使用六、光照贴图6.1 组件属性6.2 创建光照设置文件6.3 属性详解6.4 烘培七、场景管理7.1 创建新场景7.2 场景重命名7.3 设置为启动场景八、场景切换和加载资源8.1 代码切换场景8.2 场景资源加载3D场景环境设置 本篇，我们将全面了解LayaAir3.0 3D场景编辑的强大功能 （图1-1） 一、概述 场景即为LayaAir引擎的3D世界容器，用于呈现游戏的3D画面和加载各种3D元素，游戏中的摄像机，灯光，人物，物品等都需要放到场景中才能展示出画面，相当于一个游戏3D播放器或者3D视图。 在LayaAir3.0引擎中，3D和2D可以混合使用，创建的Scene 3D场景和Scene 2D容器或元素可以同时加载到舞台上。 下面我们先来了解一个3D场景的参数都有哪些，为了让一个3D场景达到一个好的效果，都需要考虑的因素。我们通过创建3D-RPG项目来参考，如图1-2所示 （图1-2） 创建后的3D-RPG项目，如图1-3所示，这个项目本身就是一个场景 从Hierarchy窗口中，可以看到Scene3D和Scene2D根节点，这里我们只讲解Scene3D场景，其中包括了3D场景中重要的组成部分，3D摄像机，3D精灵等等，我们会在其它文档中讲解 （图1-3） 当我们点击Scene3D节点，在Inspector下看看都有什么参数信息，如图1-4所示 （图1-4） 从图1-4看到几个组件，也就是我们需要关心的几个内容，接下来讲解场景涉及到的内容： 环境天空 环境光 环境反射 环境雾 光照贴图（烘培） 二、场景天空 场景天空的实现方式是天空盒，天空盒是一种让场景看上去更广阔无垠的一种视觉技术，用无缝对接的封闭纹理将摄像机的视口360度无死角的包裹起来，天空盒也就是3D世界中的天空。 图2-1中我们可以看到天空盒。天空盒的思想就是绘制一个大的立方体，然后将观察者放在立方体的中心，当相机移动时，这个立方体也跟着相机一起移动，这样相机就永远不会运动到场景的边缘。这与我们真实世界中的情况一样的，我们可以看见远处的天空接触到了地平线，但是不论我们怎么朝着那个方向移动，都不可能到达那个地方。 （图2-1） 天空渲染器组件 Sky Renderer 是Scene3D场景默认的组件，用来指定天空盒的网络形状。 （图2-2） 2.1 组件属性 Mesh Type：网格形状。目前引擎提供常见的两种天空盒网格：立方体 和 球形 。其中立方体网格更为常用。 ​ Box：立方体天空盒 ​ Dome：球形天空盒 Material：指定天空盒的材质 （图2-3） 展开DefaultSkyMaterial，如图2-3，就是正在使用的天空盒材质，目前我们使用LayaAir内置的SkyPanoramic着色器，SkyPanoramic的颜色和纹理是两个最重要的设置，我们会在材质一章中详细介绍LayaAir3.0提供的3种天空盒材质 SkyPanoramic、Skybox、SkyProcedural 注意：如果需要使用SkyProcedural程序化天空，那么只能使用球形天空。因为这种材质使用的顶点着色，需要跟精细的顶点信息。 关于天空盒使用的材质SkyProcedural 程序化天空材质 与SkyBox天空盒材质在后面的 Material材质 篇有讲解 关于 SkyPanoramic 材质，下面看看如何设置 Tint Color：颜色，如图2-4，改变颜色，可以看到改变后的颜色叠加到纹理上了 （图2-4） Rotation：旋转，从0到360度，旋转可以帮助我们调整天空盒的位置 天空盒随着视角的旋转改变，我们可以观察到四面八方都有远景效果。目前提供的这两种网格中，盒型天空的顶点数据要更少，所以这种天空的性能要更好一些。 Panoramic Texture：天空盒的纹理贴图（一张球形模型对应的贴图） 2.1.1 立方体天空 立方体天空盒用到的6张可以无缝相接的贴图参考，图2-5所示 （图2-5） 2.1.2 球形天空 是一个球形模型及一张对应的贴图构成。示例中用到的是一张球形模型对应的贴图，如图2-6 （图2-6） 基本上用到纹理和颜色后，配置好天空盒材质，就可以为我们的场景添加好天空效果 （动图2-7） 运行3D-RPG项目，旋转摄像机，可以看到天空盒的效果，如动图2-7所示 2.2 使用代码设置场景天空材质 当然我们也可以通过代码来加载和指定天空盒 var skyRenderer = this.scene.skyRenderer; //加载相机天空盒材质 Laya.Material.load(\"sky2.lmat\", Laya.Handler.create(null, function(mat: any) { //修改天空盒渲染器的天空盒材质 skyRenderer.material = mat; })); 2.3 IDE中创建天空盒 2.3.1 更改IDE默认的球形天空盒 当我们用IDE场景一个3D场景时，默认是采用SkyPanoramic材质的球形天空盒，如图2-8所示 （图2-8） 由于系统的材质是在IDE内部，无法直接修改，如果需要修改的话，可以通过克隆的方式复制一个同样的天空盒材质到assets目录下，如动图2-9所示 （动图2-9） 然后准备好一张新的球形天空盒贴图，如图2-10所示 （图2-10） 拖入新的贴图到克隆后的材质中，如动图2-11所示 （动图2-11） 此时，不管是在IDE的场景中还是预览的效果，天空盒都换成了新的了 2.3.2 更改立方体天空盒 如果开发者像使用立方体天空盒，首先我们更改上述天空盒材质为Skybox，如动图2-12所示 （动图2-12） Laya.SkyBox材质是支持6张可以无缝相接的贴图，但是需要先创建一个Cube Texture，如动图2-13所示，在assets目录下创建Cube Texture （动图2-13） 在Cube Texture中，添加好预先准备好的6张贴图，并点击应用，如图2-14所示 （图2-14） 最后，拖入配置好贴图的Cube Texture到skyBox材质的天空盒Texture中，立方体天空盒就配置好了，运行场景可以看到效果 （图2-15） 三、环境光 环境光，也称为漫反射环境光，是场景周围存在的光。并且不来自任何特定的光源。它可以对场景的整体外观和亮度做出重要贡献。 环境光在许多情况下都很有用，这取决于您选择的艺术风格。如果需要在不调整单个灯光的情况下增加场景的整体亮度，也可以使用。 图3-1所示，在3D-RPG项目中EnvironmentLight组件来指定环境光 （图3-1） 3.1 组件属性 Ambient Mode：环境光的模式，分为两种 ​ Ambient Color：固定颜色。使用环境光颜色 Ambient Color 作为环境光源 ​ Ambient Intensity：颜色强度。 ​ Spherical Harmonics：球谐光照，通过天空盒生成的球谐数据，直接作用到物体上，后面会介绍当选用球谐光照时，采用IBL来调整效果 3.2 固定颜色 图（3-2） 我们用一个简单的场景来做参考，当我们关掉Direction Light后（图3-2） 动图（3-2） 可以看到使用Ambient Color时，调整颜色对环境光的变化，如动图3-2所示 3.1.1 代码使用 环境光颜色AmbientColor，是对材质进行颜色融合染色，使材质趋于某种颜色色调，同时还能对材质进行提亮，模拟灯箱发光效果。如果设置了天空盒且不设置Scene3D场景的AmbientColor，那么LayaAir3.0会默认使环境光来源于天空盒，也就是球谐光照。 我们也可以通过代码来修改当前场景的环境光 //设置场景环境光 scene.ambientColor = new Laya.Color(0,0,0,0); 3.3 球谐光照 可以看到采用球谐光照的效果，物体的表面受天空盒的影响，如动图3-3所示，下一节我们会介绍采用球谐光照作用到环境反射IBL方式的具体用法 动图（3-3） 四、环境反射 环境反射功能为场景中的每个地方提供了有效的光滑反射效果。 一些重要的材质，比如金属，都依靠各个方向反射效果，这正是环境反射提供的功能。 场景环境反射分两种，天空盒反射与自定义反射。想要有反射效果就必须在物体Shader中有反射材质，如果没有反射材质也是没有效果的，默认的BlinnPhong不支持，PBR材质是支持环境反射的 ReflectionProbe是Scene3D场景的环境反射组件，如图4-1 （图4-1） 4.1 组件属性 Source：反射来源 ​ Skybox：选择此选项可使用天空盒作为反射源 ​ Custom：选择此选项可使用自定义反射源 Resolution：如果选择天空盒反射，可以是设置分辨率 4.2 天空盒作为反射源 上一章的球谐光照的效果，动图（3-3），展示了用场景设置的天空盒作为环境反射 4.3 自定义反射源作为反射源 Cubemap：如果选择自定义反射，会使用cubemap，是一个由六个独立的正方形纹理组成的集合，它将多个纹理组合起来映射到一个单一纹理，如图4-2所示 （图4-2） 注意：纹理贴图要设置成Cube的纹理形状 （图4-3） 把cubemap图拖入到cubemap中，配置Cubemap 如图4-4所示，然后点击 Generate Light 生成反射效果 （图4-4） 如图4-5所示，球体的反射采用指定的天空盒纹理，而不采用场景的天空盒 （图4-5） 不管是哪种天空盒，我们都可以使用IBL来更好的处理反射效果，但是第一步我们先要生成光照 Generate Light 通过点击 Generate Light 按钮，开始生成环境反射，如图4-6所示 （图4-6） 生成过程介绍后，从ReflectionProbe 组件中，可以看到IBL Tex多了天空盒的贴图，如图4-7所示 （图4-7） 4.3 IBL介绍 IBL 是基于物理渲染的真实感的重要来源，是对环境光照的一种处理方案。对于大部分情况来说，环境光来自于天空盒，也就是 cubemap 贴图。因此，IBL 的重点就在于如何从图像中获取光照信息。 iblSamples：基于图像的光照的采用率，采样的越多，就越接近真实 ibl Tex：环境立方体贴图 (Cubemap) ibl Tex RGBD：默认采用RGB深度图 采用IBL时，环境光必须采用 Spherical Harmonics 方式，当点击 Generate Light 后，可以看到IBL Tex纹理会自动生成，并可以在3D物体的材质种调节反射效果。 五、场景雾 雾化效果在项目中起着重要的作用，雾化效果就相当于开启大气的效果，看起来有种朦朦胧胧的感觉，让场景更真实。LayaAir 3.0引擎可以设置场景的雾效可见距离（相当于浓度）及雾效的颜色。雾化使用的恰当不但可以提升游戏性能，还可以增加游戏的体验。 雾化组件 Fog 是Scene3D场景默认的组件，如图5-1所示 （图5-1） 5.1 组件属性 Fog Start：雾化的起始位置 Fog Range：雾化最浓处的距离 Fog Color：雾化的颜色 首先勾选雾化属性，然后调整雾化的范围，雾化的颜色 5.2 代码使用 //雾化代码 this.scene.enableFog = true; //设置雾化的颜色 this.scene.fogColor = new Laya.Color(0,0,0.6); //设置雾化的起始位置，相对于相机的距离 this.scene.fogStart = 10; //设置雾化最浓处的距离。 this.scene.fogRange = 40; 六、光照贴图 在3D游戏场景中，依赖灯光与模型即时渲染产生投影及颜色影响，是非常耗性能。特别是在移动平台上，手机的显卡功能并不强大，如果全部使用即时光影，性能开销是非常大的，游戏也会变得卡顿。 场景光照贴图就是为了解决这个问题，其优点就是可以通过较少的性能消耗使静态场景看上去更加真实，丰富，更具有立体感。缺点就在于不能实时的处理动态光照。 我们来对比下未使用光照贴图和使用光照贴图的效果 （图6-1）未使用光照贴图 （图6-2）使用了光照贴图 我们看到区别是很明显的，现在来讲解怎么生成光照贴图。 6.1 组件属性 当我们创建一个新的场景的时候，默认 Lighting 组件是没有任何设置的，如图6-3 （图6-3） Lightmaps：光照贴图，可以是一组贴图，在没有烘焙的情况下，不需要点击加号+ Lighting Setting：光照贴图设置文件，下面我们将创建这个文件 Bake：Bake按钮用来生成烘焙 6.2 创建光照设置文件 接下来创建一个LightingSetting文件，如果6-4 （图6-4） 将生成的文件，拖入到 Lighting Settings 里 （图6-5） 6.3 属性详解 下面我们可以看到 LightingSettings 的所有属性 （图6-6） Max lightmap size：光照贴图的最大尺寸，尺寸越大越清晰 Mode： ​ Bake：模式将生成烘培图（根据场景分配几张） ​ View：模式将生成渲染图（只有一张） Max sample：采样值，越大效果越好，时间越长 Denoise：消除光照贴图中的噪点，去噪设置 ​ Enable：是否开启 ​ prefillter：去噪方式，可以选择 ​ accurate 精细 ​ fast 快速 ​ none 无 ​ Denoise Type：去噪方法，可以选择 ​ optix 去噪optix方法 ​ openimagedenoise 去噪openimagedenoise方法，业内最好的方法 ​ none 无 AO：控制烘焙环境遮挡中表面的相对亮度。用于烘焙光照的光照贴图计算的间接光照。 ​ Bounces：AO弹射次数，值越大，越慢。默认：8 ​ Factor：AO影响参数。默认：1 ​ Distance：影响AO的最大距离，值越大，效果会好，但是烘培速度越慢。默认：6 Bounce：光线反弹次数 ​ Diffuse bounce：漫反射光线反弹次数。默认：4 ​ Transmission bounce：透射光线反弹次数。默认：12 ​ Glossy bounce：玻璃反弹次数。默认：4 ​ Total bounce：反弹次数。默认：3 Sample_clamp_direct：默认：0，用来减少直接光噪点 Sample_clamp_indirect：默认：10，用来减少间接光噪点，但是灯光会变暗 Margin：渲染扩展边，用来解决边界黑缝的问题，一般选择16 Margin higher filter：边界是否高精度采样 Scene Module Scale：整个场景lightmap大小的缩放 6.4 烘培 设置好参数后，点击Bake，等几分钟之后，会自动生成烘焙后的光照图，并添加到 Lightmaps 中，如图6-7所示 （图6-7） 光照贴图就是在物体本身的贴图基础上生成了一张新的贴图，如图6-8所示 （图6-8） 烘焙后的场景，树上带有光照效果和阴影效果，如图6-9所示 （图6-9） 通过对比，我们能看到光照贴图所带来的效果，并且渲染效率很高，不需要用实时光照。图6-10是没有用光照贴图的对比图 （图6-10） 七、场景管理 3D-RPG项目仅仅是只有一个场景的3D项目，大型的项目是由多个场景组成的，合理的管理3D场景会提高我们开发效率。 7.1 创建新场景 打开3D-RPG项目的Project资源目录，可以看到这里有个scene文件夹，如图7-1所示，这里来存放其它场景文件是比较好的习惯，看起来也比较清晰。 （图7-1） 例如在3D-RPG项目中，有了Game场景，可能还需要有游戏登录场景，那么我们来创建一个 Login 场景，如动图7-2所示 （动图7-2） 也可以从编辑器的File菜单里的New Scene来创建场景，保存到scene目录下，如动图7-3所示 （动图7-3） 7.2 场景重命名 想对场景进行重新命名，可以直接在Project里对场景文件进行改名操作，如动图7-4所示 （动图7-4） 7.3 设置为启动场景 通常 Login 场景是启动场景，因此我们在Project Settings中可以设置启动场景，如动图7-5所示 （动图7-5） 八、场景切换和加载资源 在3D游戏开发过程中，往往我们需要制作多个场景，游戏的主程序需要加载场景做切换，同时释放老的场景资源和内存 8.1 代码切换场景 示例代码如下： //打开指定的场景，同时显示Scene2D和Scene3D Laya.Scene.open(\"scene/Game.ls\",true, null, Laya.Handler.create(this, this.onLoaded), Laya.Handler.create(this, this.onLoading)); //关闭指定的场景 Laya.Scene.close(\"scene/Login.ls\") //销毁指定的场景 Laya.Scene.destroy(\"scene/Login.ls\") 8.2 场景资源加载 示例代码如下： //用Laya.Scene3D的方式加载 Laya.Scene3D.load('scene/Game.ls', Laya.Handler.create(null, function (res:any){ Laya.stage.addChild(res); })); //用Laya.loader的方式加载，加载后根节点是Scene2D Laya.loader.load('scene/Game.ls', Laya.Handler.create(this, this.onLoaded), Laya.Handler.create(this, this.onLoading)).then( (res)=>{ let scene = res.create(); //scene.scene3D 可以获得Scene3D资源 Laya.stage.addChild(scene.scene3D); }); Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-05-11 21:33:09 "},"3D/useModel/readme.html":{"url":"3D/useModel/readme.html","title":"模型与动画的导入使用","keywords":"","body":"3D模型与动画的导入使用一、骨骼蒙皮动画1，模型文件导入2，贴图设置关联3，骨骼蒙皮动画导入及使用4，多个单独骨骼蒙皮动画文件使用5，代码运行示例二、刚体动画1，glTF或fbx文件导入2，动画导入及使用3D模型与动画的导入使用 LayaAir支持的模型后缀为fbx与gltf，支持导入的3D动画为骨骼蒙皮动画与刚体动画 一、骨骼蒙皮动画 在LayaAir中只能制作比较简单的动画，要想要复杂的动画，比如人物跑步的动画，那就要在外部的软件中制作并且导入到LayaAir中使用。通常我们需要使用3dMax软件制作模型和动画，并导出为Fbx格式文件，下面将介绍如何导入3D模型及动画 1，模型文件导入 将Fbx放入Assets目录下 （图1） 打开LayaAir IDE，IDE会识别Fbx文件并可以展开Fbx文件，看到图2中的文件信息，其中Take_001是Fbx自带的骨骼蒙皮动画文件，也是自身待机动画 将Fbx拖入Scene3D场景下，可以看到模型，但是没有贴图和动画，下面先介绍如何为LayaMonkey添加材质和贴图 （图2） 2，贴图设置关联 将贴图文件放入Assets下 （图3） 需要创建一个材质文件，来为模型配置贴图等信息 （图4） 点击新建的Material文件，右面可以看到很多配置信息，这里我们只需要将贴图文件拖入到材质文件中， （图5） 将材质文件拖入LayaMonkey的SkinnedMeshRenderer组件的Materials中 （图6） 可以看到模型已经有贴图效果了 （图7） 3，骨骼蒙皮动画导入及使用 下面介绍如何为LayaMonkey添加动画 当Fbx文件拖入到Scene3D场景中时，会自动添加Animator组件，如果没有可以自行添加Animator组件，并且保证AlwaysAnimate模式 （图8） 此时，我们需要创建一个AnimationController文件，也就是3D动画状态机 （图9） 将新创建的Animation Controller文件，拖入到Animator组件中 （图10） 双击AnimatorController后，将Take_001动画文件拖入Animator窗口中 （图11） 再次点击Scene窗口，点击下面的动画文件预览可以看到动画效果 （图12） 此时运行IDE，可以播放LayaMonkey动画，也可以将LayaMonkey拖入Assets目录下，作为预制体，方便重用或者代码实现 （图13） 4，多个单独骨骼蒙皮动画文件使用 大多数情况下，含动画的模型导出的Fbx文件会同时包含网格信息和动画信息，但是也有一些情况fbx文件只需要导出动画信息。例如同一个模型有很多动画，网格信息只需要一个就够了，其他动画信息可以通过单独的模型文件（不包含网格信息）导出。在制作动画时应该考虑动画的重用，用于场景中同类的模型。例如，不同的人形角色可能都使用相同的走动和跑步动画。只要保持骨骼结构一致，动画就可以重用。 图14中，以girl为例，我们将不带动画信息的Fbx文件和多个只带动画的Fbx文件放入Assets中 （图14） 创建好AnimatorController后，并将待机和跑步动画拖入Animator窗口中，可修改动画名字 （图15） 注意：此时idle待机动画是默认动画 如图16所示，我们可以分别预览待机和跑的动画，并设置是否循环播放 （图16） 多个单独的骨骼蒙皮文件就设置成功了，单独的动画也可以设置到其它的模型去重用 5，代码运行示例 如下代码，我们可以在任何场景下，加载girl预制体，添加到场景中，并用鼠标点击屏幕来切换动画 import { MainBase } from \"./Main.generated\"; import KeyBoardManager = Laya.InputManager; import Keyboard = Laya.Keyboard; const { regClass, property } = Laya; @regClass() export class Main extends MainBase { private _animator: Laya.Animator; private _isRun: boolean; onAwake() { console.log(\"Game start\"); //加载指定的模型预制体，并添加到Scene3D场景内 Laya.loader.load(\"girl/girl.lh\").then(res => { let girl : Laya.Sprite3D = res.create(); this.scene3D.addChild(girl); //获得Animator this._animator = girl.getComponent(Laya.Animator); }); this.on( Laya.Event.MOUSE_DOWN, this, this.switchAni ); } switchAni(): void { if (this._isRun) { //播放对应的动画 this._animator.play(\"idle\"); } else { this._animator.play(\"run\"); } this._isRun = !this._isRun; } } 二、刚体动画 1，glTF或fbx文件导入 将glTF放入Assets目录下，打开LayaAir IDE，IDE会识别glTF文件并可以展开glTF文件，看到图17中的文件信息，其中Animation_0是glTF自带的刚体动画文件 （图17） 将glTF拖入Scene3D场景下，可以看到模型，但是没有动画，下面先介绍如何使用动画 （图18） 2，动画导入及使用 当glTF文件拖入到Scene3D场景中时，会自动添加Animator组件，如果没有可以自行添加Animator组件，并且保证AlwaysAnimate模式 （图19） 此时，我们需要创建一个AnimationController文件，也就是3D动画状态机 （图20） 将新创建的Animation Controller文件，拖入到Animator组件中 （图21） 双击AnimatorController后，将Take_001动画文件拖入Animator窗口中 （图22） 此时运行IDE，可以播放刚体动画，也可以将BoxAnimated拖入Assets目录下，作为预制体，方便重用或者代码实现 （图23） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:44 "},"IDE/animationEditor/readme.html":{"url":"IDE/animationEditor/readme.html","title":"动画编辑模块","keywords":"","body":"动画编辑器动画编辑器 动画编辑器，包括2D时间轴动画编辑、3D时间轴动画编辑、动画控制器（状态机） 时间轴动画编辑详解(2D+3D) 动画状态机详解(2D+3D) Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:47 "},"IDE/animationEditor/timelineGUI/readme.html":{"url":"IDE/animationEditor/timelineGUI/readme.html","title":"时间轴动画编辑详解","keywords":"","body":"时间轴动画编辑详解一、打开时间轴动画编辑器1.1 创建动画1.2 直接启动动画面板1.3 不支持动画组件的节点1.4 添加动画组件二、时间轴动画编辑器的基础概念2.1 关键帧、空帧2.2 当前帧2.3 播放帧率2.4 动画节点属性2.5 曲线、切线、权重2.6 刻度三、时间轴动画编辑面板的基础交互3.1 多选3.2 鼠标左键3.3 鼠标右键3.4 滚轮操作四、属性设置4.1 属性增加4.2 关键帧属性设置五、帧面板通用操作5.1 关键帧管理5.2 关键帧批量管理5.3 空白帧插入5.4 动画事件5.5 关键帧跳转5.6 帧面板缩放六、曲线模式操作6.1 动画曲线调节6.2 曲线定位6.3 曲线显示筛选七、播放动画7.1 动画面板播放7.2 查看运行效果7.3 运行时的循环播放八、其它8.1 保存动画8.2 退出动画编辑器8.3 快捷键总结九、使用动画事件9.1 属性设置9.2 脚本中监听时间轴动画编辑详解 Author：charley LayaAir IDE的时间轴动画编辑器，适用于2D与3D动画的编辑。 本篇中的功能介绍，如果是2D与3D通用的操作，默认以3D为例进行说明，如果存在2D与3D差异的部分，会针对差异进行额外的说明。 隨着版本的升级，文档中截图的部分细节可能会稍有差异，以IDE实际版本为准，如果改动较大的我们会及时调整，未及时调整的欢迎联系官方客服进行反馈。 一、打开时间轴动画编辑器 1.1 创建动画 1.1.1 场景中的节点创建动画 场景中添加的任一节点都可以创建动画，下述介绍以cube（立方体）为例。首先在场景创建一个cube节点，选中cube节点后，就可以在编辑器下方的时间轴动画面板（Timeline） 中看到“创建”按钮。如图1-1所示： （图1-1） 点击图1-1的创建按钮，会弹出如图1-2所示界面，提醒用户设置动画名称（这里重命名为“ani3d.lani”）。 （图1-2） [!Tip] 3D动画文件的后缀是.lani，2D动画文件的后缀是.mc 保存名称后，可以看到时间轴动画编辑面板、动画组件、状态机、动画文件，即代表动画创建成功。如图1-3所示： （图1-3） 1.1.2 预制体中创建动画 我们不仅可以在场景中的节点创建动画，还可以在预制体中创建动画。 不理解预制体的，请先查阅>文档。 从操作看，从场景上创建动画与预制体里创建动画并没有本质上的区别。 主要的区别是： 场景中的节点创建的动画，适用于只用一次动画的情况。 预制体中创建的动画，适用于需要多次复用动画的情况。 1.1.3 动画文件后缀 3D创建的动画文件后缀名称为.lani，3D动画控制器（也叫动画状态机）文件后缀为.controller 2D创建的动画文件后缀为.mc，2D动画状态机文件后缀为.mcc。 在发布微信小游戏等对后缀有限制的平台时，IDE发布功能会自动修改后缀，开发者知道即可，仍按上述标准使用相对路径，引擎会根据不同平台自动适配文件后缀。 1.1.4 动画状态机文件命名规则 首次为节点创建动画的时候，不仅会创建一个由开发者自己命名的动画文件，还会自动创建一个动画状态机文件， 状态机文件命名是由动画节点名_动画名组成。效果如图1-4所示。 （图1-4） 1.2 直接启动动画面板 如果节点上已经绑定了动画组件，那么无需再创建动画，直接点击下方的启动动画面板按钮即可。如图1-5所示： （图1-5） 1.3 不支持动画组件的节点 场景根节点Scene2D、Scene3D不支持创建动画。 1.4 添加动画组件 当已经创建了动画，只是想在某个节点上复用已创建的动画时，可以通过添加动画组件的方式，直接打开已有动画。 以球体（Sphere）节点为例，进行介绍。 首先，选中球体节点，在右侧的属性面板中点击添加组件，选择Animator组件，在3D节点里只能看到Animator，如果是2D节点只能选Animator2D。 [!Tip|label:Tips] Animator2D是2D动画组件，Animator是3D动画组件。 操作顺序如动图1-6所示： （图1-6） 然后，在属性面板中可看到Animator组件。点击Animator组件中的Controller，选择已有的动画状态机。如图1-7所示： （图1-7） 1.4.1 有动画状态机且有动画文件的情况： 以选择“Sphere_ani3d1”动画状态机为例，选择后，即将此动画绑定在Sphere节点上，在有动画状态机且有动画文件的情况下，刷新后点击动画编辑面板中的启动动画即可。如图1-8所示： （图1-8） 1.4.2 有动画状态机但无动画文件的情况： 假如动画状态机中没有动画，添加动画组件并设置状态机后，再点击启动，会提醒没有动画文件，此时会自动弹出创建新动画文件的窗口。 如图1-9所示： （图1-9） 如果想使用已有的动画，直接从资源窗口中拖拽动画文件到状态机视图窗口即可，效果如图1-10所示。 （图1-10） 二、时间轴动画编辑器的基础概念 2.1 关键帧、空帧 2.1.1 关键帧 关键帧指物体运动变化中关键动作所处的那一帧，即存储了属性值的帧。 （图2-1） 2.1.2 空帧 空帧指这个帧里没有设置任何内容，通常指相邻两个关键帧之间的帧。 （图2-2） 2.1.3 关键帧与空帧的区别 关键帧：根据关键帧上存储的属性值决定动画的效果变化。 空帧：引擎会根据插值算法计算出播放时的属性值，用于动画俩个关键帧之间的过渡。 2.2 当前帧 当前帧指针所在的帧，也是当前鼠标点击选择的帧。 并且，编辑器窗口下方也会显示出当前帧指针所在的位置。以图2-3所示为例，当前帧位于第6帧的位置。 （图2-3） 2.3 播放帧率 指每秒播放的动画帧数。如图2-4所示，默认值为60。 （图2-4） 2.4 动画节点属性 动画节点的属性如图2-5左侧所示，当指向某一个关键帧，再通过调节属性值，即可将调整后的属性值存储在该帧中，用于关键帧效果改变的依据。 （图2-5） 2.5 曲线、切线、权重 2.5.1 曲线 定义： 曲线是指两个关键帧之间用于帧过渡的插值算法连线。 作用： 用于两个关键帧之间的属性插值算法，调节动画关键帧之间的过渡效果。 外观： 曲线线条是关键帧之间的属性数值的过渡算法效果，IDE采用三次贝塞尔曲线（也称三阶贝塞尔曲线）算法绘制，绘制原理如动图2-6所示。 (动图2-6) 在动图2-6中，红色的线条就是最终的插值算法曲线效果外观，p0是起始帧，p3是结束帧，纵向红色指针是当前帧基于曲线的运动速度。 曲线的调节，由p1与p2决定，而p1与p2又是由切线与权重决定。 曲线外观的表现有曲线形态，也有直线形态，如图2-7所示，均是采用三次贝塞尔曲线算法绘制。 （图2-7） [!Tip|label:Tips] 以上所指贝塞尔曲线算法绘制的曲线均是可调节的曲线。2D动画内置的缓动曲线模板，并非是贝塞尔曲线算法。 2.5.2 曲线切线 在上文的动图2-6中，p0到p1点的线段是p0点的切线，p2到p3的线段是p3的切线，切线的位置会影响曲线的形态。 对应到动画编辑器的效果如动图2-8所示， （动图2-8） 2.5.3 曲线权重 曲线权重是指曲线切线的长度。最短不能低于0，最长不能超过1。也就是上文动图2-6中，p0到p3这两个关键帧之间的长度。 注意观察动图2-9，当改变权重长度时，tips的第三行也会显示出当前权重的数值。 （动图2-9） 这里仅仅演示权重调节的概念，下文6.1.2小节，会有详细介绍曲线权重如何调节。 2.6 刻度 刻度分为横向刻度和纵向刻度，横向刻度是指动画帧的刻度，纵向刻度是指动画属性值刻度。如图2-10所示。 （图2-10） 三、时间轴动画编辑面板的基础交互 3.1 多选 3.1.1 框选 持续按住鼠标左键进行框选，鼠标选区内全选。 3.1.2 连续区域多选 Shift + 鼠标点击，指定首尾帧与属性区间内全选。 3.1.3 间隔多选 ctrl + 鼠标点击，点中哪个选中哪个。 3.1.4 排除 ctrl + 鼠标点击，在已选中的情况下，按住ctrl + 鼠标点击即可排除该项。 3.1.5 多选松开 通用：所选的首帧与尾帧 曲线：显示所选的最高属性值与最低属性值，以及首帧与尾帧。如图3-1所示： （图3-1） 3.2 鼠标左键 3.2.1 单击 （改变当前帧） 改变当前帧位置，鼠标点击处为当前帧。 3.2.2 双击 添加动画事件： 双击如图3-2所示区域添加动画事件。一帧可派发多个动画事件。 （图3-2） 添加关键帧： 双击如图3-3所示区域添加关键帧。 （图3-3） 3.2.3 拖拽 拖拽单帧： 选中某一关键帧进行拖拽，可改变当前关键帧的位置。 批量拖拽多帧： 也可批量选中多个关键帧进行拖拽，整体进行位置改变。 3.3 鼠标右键 3.3.1 关键帧模式 1、添加关键帧：右键点击关键帧面板区域，可调出关键帧添加菜单。例如，图3-4所示的红1区域，括号内的数字代表是在第几帧上添加。 （图3-4） 2、添加动画事件：右键点击帧刻度与关键帧面板中间的区域，如图3-5所示，可调出添加动画事件菜单，括号内的数字代表是在第几帧上添加。 （图3-5） 3、点击选中某一关键帧，单击右键调出当前关键帧功能菜单。如图3-6所示： （图3-6） 4、右键点击（3）区域，调出属性添加菜单。如图3-7所示： （图3-7） 3.3.2 曲线模式 1、在曲线模式下，右键单击空白区域，调出曲线自动定位菜单。如图3-8所示： （图3-8） 2、在曲线模式下，右键单击关键帧，调出曲线功能菜单。如图3-9所示： （图3-9） 3、在曲线模式下，右键单击曲线，调出曲线定位菜单。如图3-10所示： （图3-10） 3.4 滚轮操作 3.4.1 帧显示缩放 关键帧模式下，直接滚轮，将以鼠标指针为中心，对帧刻度面板进行缩放。如动图3-11所示： （动图3-11） 3.4.2 属性显示缩放 曲线模式下，使用 Ctrl+滚轮 ， 将以鼠标指针为中心，对属性刻度面板进行缩放。如动图3-12所示： （动图3-12） 3.4.3 帧与属性同时缩放 曲线模式下，直接滚轮，将以鼠标指针为中心，对帧与属性刻度面板同时缩放。如动图3-13所示： （动图3-13） 3.4.3 动画属性面板纵向滚动 当有多个属性超出属性面板的显示区域时，为方便操作可直接通过鼠标滚轮对属性面板进行纵向滚动调节。如动图3-14所示： （动图3-14） 3.4.4 动画帧面板纵向滚动 当鼠标在动画帧面板时，直接滚动鼠标滚轮只会对帧面板进行缩放。 那我们也需要纵向滚动时，可以在动画帧面板按住Ctrl+滚动鼠标滚轮进行纵向滚动操作，如动图3-15所示： （动图3-15） 四、属性设置 4.1 属性增加 4.1.1 通过按钮增加 如图4-1所示： （图4-1） 4.1.2 通过右键增加 如图4-2所示： （图4-2） 4.1.3 通过录制增加 首先，点击红色的录制按钮，在刻度条变为红色时，代表此时进入到录制状态，此时通过调节右侧的Transform参数，即可在时间轴动画编辑器中添加对应的属性。操作如图4-3所示： （图4-3） 2D动画属性与3D动画属性的差异： [!Note] 2D动画中的每一个属性值均允许单个设置。3D动画中的Vector属性不可缺少，删除也会自动补上。 2D动画默认是录制模式，3D动画需要点击录制按钮开启录制模式。 4.2 关键帧属性设置 4.2.1 属性输入框直接输入 直接在输入框输入数值。如图4-4所示： （图4-4） 4.2.2 属性输入框划动输入 将鼠标放置输入框上，待光标变为双向箭头时，按住左键后左右拖动鼠标，即可改变数值。 4.2.3 录制模式的同步输入 方式1：在录制模式下，在视图窗口拖拽输入。如图4-5所示： （图4-5） 方式2：在录制模式下，在属性窗口的输入。如图4-6所示： （图4-6） 五、帧面板通用操作 5.1 关键帧管理 5.1.1 添加 在动画帧面板添加： 在动画帧面板中已有属性的情况下，通过双击或鼠标右键单击如图5-1所示的区域来添加关键帧。 （图5-1） 在动画属性面板添加： 在动画属性面板中点击属性右侧的 “+” 号添加，如图5-2所示： （图5-2） 5.1.2 删除 鼠标选中关键帧，通过 “delete” 快捷键或右键菜单中的“删除选中快捷键”按钮进行删除。 5.1.3 复制 鼠标选中关键帧，通过 “ctrl+C” 进行复制。 5.1.4 粘贴 鼠标选中某一空白帧，通过 “ctrl+V” 进行复制。 5.1.5 移动 鼠标选中关键帧，按住左键不放进行拖拽。 5.2 关键帧批量管理 5.2.1 批量平移 批量平移，是指对选中的关键帧整体进行水平位置移动，关键帧之间的间距保持不变。 操作方式是对关键帧进行批量选中，然后桉住鼠标左键不放，即可进行批量平移。如动图5-3所示： （动图5-3） 5.2.2 插入移动 插入移动是指，在选中的全部关键帧之中，每两个关键帧之间插入空白帧。所以首帧位置不变，但其后的所有关键帧间距变大或缩小。 间距增大： 选中多个关键帧，执行插入空白帧操作。如动图5-4所示： （动图5-4） 为方便理解动图5-4，采用了右键操作，但建议用快捷键F5插入空白帧。 间距缩小： 选中多个关键帧，执行删除空白帧操作。当两个关键帧之间的空白帧全部删除后，会停止删除。但不影响其它关键帧的继续删除操作。如动图5-5所示： （动图5-5） 为方便理解动图5-5，采用了右键操作，但建议用快捷键Shift + F5插入空白帧。 5.2.3 批量删除 对关键帧进行批量选中，然后通过快捷键 “delete” 或右键菜单中的删除选中关键帧选项即可进行批量删除。如动图5-6所示： （动图5-6） 5.3 空白帧插入 5.3.1 空白帧单个插入 增加：选中某个关键帧，通过快捷键 “F5” 或右键菜单中的 “插入空白帧” 按钮。 删除：选中某个关键帧，通过快捷键 “shift + F5” 或右键菜单中的 “删除空白帧” 按钮。 5.3.2 空白帧批量插入 增加：选中多个关键帧，通过快捷键 “F5” 或右键菜单中的 “插入空白帧” 按钮。 删除：选中多个关键帧，通过快捷键 “shift + F5” 或右键菜单中的 “删除空白帧” 按钮。 5.4 动画事件 5.4.1 添加 在帧面板中如图5-7所示的区域中，可以通过双击或右键菜单中的 “添加动画事件” 按钮来添加动画事件。 （图5-7） 5.4.2 删除 鼠标选中动画事件，可以通过快捷键 “delete” 或者右键菜单中的 “移除动画事件” 来删除动画事件。 动画事件的具体使用请看第九部分。 5.5 关键帧跳转 （图5-8） 跳转到首帧 点击如图5-8中的（1）所示的按钮，即可快速跳转到首帧。 跳转到上个关键帧 点击如图5-8中的（2）所示的按钮，即可快速跳转到上一帧。 跳转到下个关键帧 点击如图5-8中的（3）所示的按钮，即可快速跳转到下一帧。 跳转到尾帧 点击如图5-8中的（4）所示的按钮，即可快速跳转到尾帧。 5.6 帧面板缩放 5.6.1 滚动条缩放 左缩放：拉动左边滚动条对当前关键帧左边的帧刻度进行缩放。 右缩放：拉动右边滚动条对当前关键帧右边的帧刻度进行缩放。 滚动条如动图5-9所示： （动图5-9） 5.6.2 滚轮缩放 1、鼠标放在帧刻度上滑动滚轮，此时帧刻度以当前鼠标所在刻度处为中心进行缩放。如动图5-10所示： （动图5-10） 2、鼠标放在属性刻度上滑动滚轮，此时属性刻度以当前鼠标所在刻度处为中心进行缩放。如动图5-11所示： （动图5-11） 关于滚轮缩放的锁定某个刻度面板，请上翻查看3.5快捷键小节。 六、曲线模式操作 6.1 动画曲线调节 6.1.1 使用动画曲线模板 动画曲线模板可分为两种，分别是内置的曲线算法与自定义的曲线算法。 使用内置的曲线算法后，曲线不可随意调整。 使用自定义的曲线算法，曲线可以随意调整。 曲线模板打开方法：在曲线模式下右键单击关键帧，在右键菜单中单击 “使用动画曲线模板” 即可打开曲线模板界面。 [!Tip|label:Tips] 内置的曲线算法仅支持2D动画。 内置的曲线算法： Linear：线性动画，也就是匀速。以相同的速度开始以相同的速度结束。动画曲线如图6-1所示： （图6-1） EaseIn：入口缓动曲线，动画以低速开始，进行过程中一直加速。动画曲线如图6-2所示： （图6-2） EaseOut：出口缓动曲线，动画进行过程中一直减速，以低速结束。动画曲线如图6-3所示： （图6-3） EaseInOut：两边缓动曲线，动画以低速开始，加速后再减速，以低速退出。动画曲线如图6-4所示： （图6-4） 自定义的曲线算法： Custom： 如果内置的曲线模板无法满足需求，开发者可以直接在选择Custom曲线模式，然后在面板区域中修改曲线轨迹。如图6-5所示： 修改后可以将其保存下来，以便复用。 （图6-5） 6.1.2 切线调节 （图6-6） 权重： 默认权重：曲线权重默认值是权重总长度的三分之一处，该处为引擎优化位置，采用的是埃尔米特(Hermite)插值算法，性能较好。推荐使用。 （图6-7） 自定义权重：当不勾选锁定权重时，就是自定义权重。自定义权重更加灵活，但是性能不如默认权重的性能好。 （动图6-8） 锁定权重：当使用了自定义权重后，如果想保持这个权重，可以锁定该权重，只调节切线位置。 （动图6-9） 功能： 左切线：调节当前关键帧左侧的切线设置参数。 右切线：调节当前关键帧右侧的切线设置参数。 两条切线：调节当前关键帧俩侧的切线设置参数。 插值过渡： linear：调整曲线角度，让曲线表现为直线形态。 （图6-10） constant：调整曲线角度，让曲线表现为直角折线形态。 （图6-11） 6.1.3 平滑 不勾选状态：关键帧俩侧可分别设置曲线左、右切线来调节，互不影响。但是可能会出现过渡不够平滑，形成尖锐角度情况。如图6-12所示： （图6-12） 勾选状态：关键帧两侧同步设置曲线切线，勾选后会使过渡更平滑。 6.1.4 水平 不勾选状态：自定义曲线切线。 勾选状态：勾选后，使曲线切线快速恢复到水平位置。 （动图6-13） 6.2 曲线定位 6.2.1 在曲线上定位输入 右键单击曲线，在右键菜单中点击 “定位到输入” 选项，即可快速定位到该曲线代表的参数。以绿色曲线为例，点击 “定位到输入” 后，即可发现绿色曲线代表的是X参数的变化。如图6-14所示： （动图6-14） 6.2.2 自动定位 当由于鼠标的一系列操作在曲线面板的显示区域中看不到曲线时，单击右键选择 “自动定位” 就可以使曲线快速显示出来。如动图6-15所示： （动图6-15） 6.3 曲线显示筛选 6.3.1 在动画属性面板筛选指定曲线 在动画属面板中双击参数，可快速找到指定曲线。如动图6-16所示： （动图6-16） 6.3.2 在曲线面板筛选指定曲线 在曲线面板中，选中某一曲线右键单击，在右键菜单中选择 “只显示当前曲线” 即可筛选到指定曲线。如动图6-17所示： （动图6-17） 七、播放动画 7.1 动画面板播放 7.1.1 单次播放 点击播放按钮，会播放动画，默认为单次播放。 单击如图7-1所示按钮，即可播放动画。 （图7-1） 7.1.2 循环播放 动画预览默认是单次播放模式，当我们看到循环图标中间有个数字1的时候，就表示处于单次播放的模式。如图7-2所示。 （图7-2） 点击单次播放状态按钮后，按钮处于循环图标状态，如图7-3所示，此时可无限循环播放动画。 (图7-3) 7.1.3 取消循环播放 点击循环播放状态按钮后，会停止当前循环播放状态，此时循环图标中间又可以看到数字1，说明已取消循环播放，恢复到单次播放模式。 （图7-3） 需要提醒的是，单次播放模式改变为循环播放模式时，由于当前未处于播放状态，所以不会自动转变为循环播放状态。 7.2 查看运行效果 IDE内的播放预览只是动画基础效果，多数情况下，动画还配合了代码交互逻辑，此时还需要在浏览器运行，查看最终运行效果。 点击如图7-4所示按钮，查看在不同平台的预览效果。 （图7-4） 由于动画组件，不能独立播放，必须挂在场景中，所以直接运行动画所在的场景即可播放动画。 如果想独立查看动画效果，则需要建立一个动图效果的测试场景，挂在测试场景中。 7.3 运行时的循环播放 IDE里的循环播放预览，与运行时是否循环播放无关。 如果需要在运行时循环播放，需要勾选图7-5中的loop状态。 （图7-5） 不勾选loop，在运行时会单次播放。 八、其它 8.1 保存动画 如图8-1所示，点击时间轴动画编辑器下方的保存图标即可。这里要注意，如果不保存，那么运行时会按照没有保存的效果播放动画。 （图8-1） 8.2 退出动画编辑器 点击时间轴动画编辑器下方的退出图标即可退出动画编辑器。如图8-2所示： （图8-2） 8.3 快捷键总结 快捷键 作用 F5 插入空白帧 Shift + F5 删除空白帧 Delete 删除关键帧 Ctrl + c 复制关键帧 Ctrl + v 粘贴关键帧 Ctrl+滚轮 关键帧模式下，动画属性面板与动画帧面板，同时纵向滚动曲线模式下，锁定帧刻度面板（不缩放），以鼠标指针为中心，无限制缩放属性刻度面板的精度。 Alt+滚轮 曲线模式下，锁定属性刻度面板（不缩放），以鼠标指针为中心，无限制缩放帧刻度面板的精度。（无限制缩放会导致当缩放拉伸到0帧可见时，不再以缩放前的鼠标指标为中心进行缩放） Alt+Shift+滚轮 曲线模式下，锁定锁定属性刻度面板（不缩放），以鼠标指针为中心，有限制缩放帧刻度面板的精度。（始终保持以鼠标指针为中心进行缩放，当缩放拉伸至0帧可见时，禁止刻度精度缩小，只允许刻度精度放大） Shift 曲线模式下，持续按住Shift键，可以使得移动关键帧，始终保持水平方向位移，单个与批量移动均有效。 Ctrl 曲线模式下，持续按住Ctrl键，可以使得移动关键帧，始终保持垂直方向位移，单个与批量移动均有效。 九、使用动画事件 在5.4小节中介绍了动画事件添加和删除的操作，我们看看如何使用动画事件 9.1 属性设置 当添加动画事件后，点击白色事件图标，可以在IDE后侧属性面板中设置动画事件属性，如图9-1所示 （图9-1） Event Name：在脚本中调用的事件方法名 Params：在脚本中调用事件方式时的传参（字符串），可以设置多个 如图9-2所示，例如对此事件添加一个 “event1” 方法名，添加两个参数，\"a\", \"1\"，点击下面的保存 （图9-2） 9.2 脚本中监听 通过设置动画事件属性后，要想监听到事件和参数，需要在动画节点上添加脚本。 我们通过动图9-3，来看看如何为一个动画节点添加脚本 （动图9-3） 添加脚本后，就可以在脚本中监听到事件和参数了，脚本代码如下： const { regClass, property } = Laya; @regClass() export class Script extends Laya.Script { //declare owner : Laya.Sprite3D; constructor() { super(); } event1(p1:any, p2:any): void { console.log(\"event1\",p1,p2); } } 在脚本中创建event1的方法和接收两个参数，最后我们来运行动画，看看运行结果： （图9-4） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-05-19 17:38:15 "},"IDE/animationEditor/aniController/readme.html":{"url":"IDE/animationEditor/aniController/readme.html","title":"动画状态机详解","keywords":"","body":"动画状态机详解一，概述二、动画状态机组件三、动画状态机文件四、动画状态五、动画切换六、动画播放及脚本七、子状态机动画状态机详解 LayaAir IDE的动画状态机，适用于2D与3D。 本篇中的功能介绍，如果是2D与3D通用的操作，默认以3D为例进行说明，如果存在2D与3D差异的部分，会针对差异进行额外的说明。 隨着版本的升级，文档中截图的部分细节可能会稍有差异，以IDE实际版本为准，如果改动较大的我们会及时调整，未及时调整的欢迎联系官方客服进行反馈。 一，概述 我们先来了解一下什么是动画状态机和它的构成，后面再进一步了解每个部分。 首先，动画状态机 Animator 可以允许我们定义动画状态，以及动画状态之间的切换条件，来驱动3D对象播放不同的动画，表现出不同的行为。那么动画状态机有下面几部分构成： 动画状态机组件 Animator Component ：是Sprite3D上的一个组件，用来控制动画状态机的接口。 动画状态机文件 Animator Controller ：是一个文件，用来执行整个状态机逻辑，驱动动画状态运行，执行状态切换。同时定义了驱动参数，可以由代码逻辑驱动这些参数，再由这些参数驱动动画。 动画状态 Animator State：是状态机的一个动画状态，用来执行动画的逻辑，定义动画播放的属性，可以改变单一动画的播放位置、时间、层级等等。 动画切换 Animator Transition：由参数和比较条件构成，当条件满足时，会切换到相应的动画状态。每个状态，可以创建多个到其它状态的切换。 通过下图，可以清晰了解这四个部分的关系，如图1-1所示： （图1-1） 二、动画状态机组件 我们需要播放动画以及使用动画状态机的对象都需要添加 Animator 组件，该组件是控制动画状态机的接口，下面我们来看看 Animator 组件。 2.1 场景中的节点添加 场景中添加的任一节点都可以添加动画状态机组件，下述介绍以cube为例。首先在场景创建一个cube节点，选中cube节点后，就可以在编辑器的增加组件面板中添加 Animator 组件。如动图2-1所示： （动图2-1） 2.2 预制体中添加 我们不仅可以在场景中的节点添加动画状态机组件，还可以在预制体中创建。 不理解预制体的，请先查阅预制体的文档>。 从操作看，从场景上创建与预制体里创建并没有本质上的区别。 主要的区别是： 场景中的节点创建，适用于只用一次动画的情况。 预制体中创建，适用于需要多次复用动画的情况。 2.3 默认添加 某些情况下，Animator 组件会自动添加到节点下，如图2-2所示，当我们导入一个FBX模型文件到场景中时，已经默认添加好了 Animator 组件。 （图2-2） 2.4 组件属性 Animator 组件有两个属性，Controller 和 Culling Mode，如图2-3所示： （图2-3） Controller ：使用的 Animator Controller文件，当有了 Animator 组件，依然不能打开动画状态机，我们需要创建动画状态机文件，下一章将具体介绍。 Culling Mode：剔除模式，Always Animate表示即使摄像机看不见也要进行动画播放的更新，Cull Completely 表示摄像机看不见时停止动画的所有更新。 三、动画状态机文件 Animator Controller 是一个文件，用来执行整个状态机逻辑，驱动动画状态运行，执行状态切换。 3.1 创建动画状态机文件 Project面板中，任何目录下都可以创建一个动画状态机文件。如动图3-1所示： （动图3-1） 3.2 自动创建动画状态机文件 对于一个带网格和动画信息的Fbx模型文件来说，如图3-2所示，Fbx文件导入过程中，LayaAir 3.0编辑器已经识别出这个Fbx文件具有Animator属性，并可以设置是否可开启压缩。 （图3-2） 当我们拖Fbx模型到场景中时，会自动添加动画状态机组件。打开时间轴动画面板，会自动创建动画状态机文件，如图3-3所示： （图3-3） 这种情况下，LayaAir 3.0已经自动为我们创建好了Animator Controller文件，下一步就可以编辑动画状态机了。 3.3 打开动画状态机 当我们点击动画状态机文件后，可以点击 动画状态机 面板来打开动画状态机，如图3-4所示。 （图3-4） LayaAir 3D引擎的Sprite3D类提供了 getComponent() 方法来获取模型上的组件。带动画的模型在加载创建时引擎默认赋予了Animator（动画状态机）动画组件，因此我们可以这样获取： //获得状态机 this.animator = this.target.getComponent(Laya.Animator); 注：这段代码来自“3D入门示例”的“Animator”场景。 3.4 编辑动画状态机 动画状态机 面板中，可以做一些常规的操作，如动图3-5所示，下面一章，我们将引入动画状态的介绍和操作。 （动图3-5） 3.5 动画状态机分层 默认情况下，一个动画状态机文件只有一个默认的层 BaseLayer，如图3-6所示，比如一个角色模型的常规动作（待机，跑，攻击），我们只需要一个默认层就可以了。 （图3-6） 但是我们也可以创建更多的分层，多个分层可以用来解决什么样的问题呢？试想一下如果你要开发一款第三人称的射击游戏，那么肯定是希望身体的动画分为上下两部分，上方根据瞄准的位置和是否射击进行动画播放，下方根据移动播放动画。所以更多复杂的需求可以用分层来解决，如图3-7所示，我们又添加了一个分层，并命名为Layer1。 （图3-7） 3.5.1 图层的属性 每个图层是有一些参数属性的，如图3-8所示： （图3-8） Name：图层的名字。 Play On Wake：是否默认播放这个层的动画。 Blending Mode：动画混合方式： Override：覆盖，表示当前层的动画会覆盖掉其它层的动画，比如射击播放时右手就不能播放其它的动画了； Additive：添加，表示当前层的动画的量添加到其它层的动画，比如射击播放时，手部奔跑或站立的甩动也会保留。 Default Weight：动画层的权重，默认的Base Layer必须为1。如果设置为0则当前层的动画不会播放，1则会播放，0-1之间会采用类似融合的情况来播放动画，比如之前说的边移动边射击的情况，如果设置为0.5则射击动画播放时手部只会抬到脖子附近。 通过代码，我们可以获得想要的图层，需要使用Animator的 animator.getControllerLayer(layerIndex)方法，该方法的定义如下： /** * 获取控制器层。 */ getControllerLayer(layerInex: number = 0): AnimatorControllerLayer { return this._controllerLayers[layerInex]; } 举一个使用此方法的例子： //获得BaseLayer层AnimatorControllerLayer let animatorControllerLayer : Laya.AnimatorControllerLayer = this.animator.getControllerLayer(0); //获得当前BaseLayer层的默认动画状态 let defaultState = animatorControllerLayer.defaultState; 3.5.2 图层的参数 每个图层是可以添加一些参数的，如图3-9所示，具体这些参数是在动画切换中会用到，我们将在第五章动画切换中介绍。 （动图3-9） 目前LayaAir中，我们可以添加这三种参数： Float：浮点数 Bool：布尔 Trigger：触发器 四、动画状态 动画状态 Animator State，是动画状态机里的一个动画状态，每个状态对应一个动画，所以叫动画状态。用来执行动画的逻辑，定义动画播放的属性，可以改变单一动画的播放位置、时间等等。而我们的游戏逻辑状态，可能由一系列的动画状态构成。 4.1 系统状态 动画状态机创建时，会默认创建2个系统状态，如图4-1所示： （图4-1） 任何状态 AnyState：当我们需要在条件满足时，无论当前是哪个状态，都执行切换时，可以定义切换为从该状态开始。 进入 Entry：进入状态，当进入一个动画状态机时，会首先执行从该状态到默认状态的切换。 当创建子状态机时，会默认多创建一个退出状态，如图4-2所示： （图4-2） 子状态机的内容请参看第七章。 退出 Exit：当需要退出该子状态机时，可以执行一个到该状态的切换。 4.2 创建动画状态 4.2.1 新建动画状态 在动画状态机面板中，鼠标右键点击空白处，点击创建空节点即可。如动图4-3所示： （动图4-3） 4.2.2 拖入一个动画状态 在Project面板中，可以拖动一个Fbx下的动作文件到Animator面板中，如动图4-4所示 ： （动图4-4） 此时，我们已经可以自动播放一个动画了，这是最基本最简单的用法，不需要做额外的工作，可以让LayaMonkey动起来！ （动图4-5） 4.3 动画状态属性 作为动画状态机里的每一个动画状态，我们都可以对此状态做单独的设置，如图4-6： （图4-6） 4.3.1 基础属性 Name：动画状态的名字，可以在代码里用来播放动画。 Is Looping：是否循环播放。 Speed：动画的播放速度。 Cycle Offset：循环偏移，动画文件每次循环播放的起点（0-1之间）。 Clip Start：动画文件的起始播放位置（0-1之间）。 Clip End：动画文件的停止播放位置（0-1之间）。 Clip：动画文件（.lani）。 注意：参数“Cycle Offset”不影响动画播放完整性，例如“Clip Start”设置为0，“Clip End\"设为1，”Cycle Offset“设为0.8，那么动画就是从0.8这个位置开始播放，再播放到0.8这个位置算一次循环。 通常Fbx文件中包含的动画文件，通过拖入Animator中，会自动把动画文件关联进来，如图4-7所示： （图4-7） 4.3.2 切换列表 AnimatorTransition：列出了所有此动画状态连接其它动画状态的动画切换，如图4-8所示： （图4-8） 单机New State -> New State 0可以打开AnimatorTransition详细面板，双击New State -> New State 0，可以改名，如动图4-9所示： （动图4-9） 4.3.3 solo与mute solo与mute：两个选框，Solo表示只生效这一条切换，Mute相当于把这条动画切换禁用掉，如图4-10所示： （图4-10） 注意： solo和mute都可以多选，但是优先级是按照添加顺序的，将会在5.5切换优先级中讲解。 条件满足优先于Solo/Mute，当条件没有满足时依然不会过渡，将会在5.5切换优先级中讲解。 五、动画切换 从一个状态过渡到另一个状态的过程就是动画切换，由参数和比较条件构成，当条件满足时，会切换到相应的动画状态。每个状态，可以创建多个到其它状态的切换。 5.1 创建动画切换 当我们创建好动画状态后，通过在前一个状态上点击鼠标右键，选择连线，此时会创建一点连线，拖动鼠标到后面的动画状态上抬起鼠标，即可创建动画切换，点击此连线时，点击键盘的delete键可以删除此连线。如动图5-1所示： （动图5-1） 当我们从New State连了New State 0，New State 1，New State 2后，在不添加任何条件的情况下，New State会继续切换到New State 0状态，因为New State 0是最先连的。 5.2 设置为默认 当我们创建好多个动画状态时，如果想设置某个动画状态为进入状态，可以鼠标右键点击此动画状态，选择设置为默认即可，如动图5-2所示： （动图5-2） 注意：当我们创建第一个动画状态时，会默认把这个状态设为默认状态，当然我们随时可以改为其它动画状态为默认状态。 5.3 动画切换属性 点击一条连线时，可以看到动画切换的属性，如图5-3所示，用来处理动画切换的动画调整效果。 （图5-3） Exit Time：该时间是一个0-1的归一化时间，用来定义在动画播放的时间百分比。比如0.85，表示动画播放到85%时，开始切换动画。Exit Time的逻辑功能类似于float参数，但是不能进行设置。 Transstarttoffset：该时间是一个0-1的归一化时间，目标状态的时间偏移，即从哪个时间点开始播放目标状态动画。比如0.5，表示目标状态从50%开始播放动画。 Transduration：该时间是一个0-1的归一化时间，用来定义状态切换到目标状态时，持续播放后一个动画状态的时间百分比。比如0.15，表示动画播放到目标动画的15%时，停止切换动画。 注意： 处于过渡时间时，动画1和动画2同时播放。当过渡时间结束，动画1才彻底停止播放，而动画2进入下一段切换的判断。 当过渡时间为0时，动画1会直接切换到动画2。 Exit By Time：是否让Exit Time 生效，如果不勾选，该动画是直接切换到下一个动画。 动图5-3-1和动图5-3-2分别是勾选Exit Time和不勾选的对比效果，明显来看，不勾选会出现动画不衔接的情况。 （动图5-3-1） （动图5-3-2） 5.4 动画切换条件 状态切换可以有一个条件，多个，或者没有条件。如果切换没有条件，那么动画系统也会将Exit Time 作为唯一的条件，当到达时间时触发切换。如果有多个条件，必须所有条件都满足，才触发切换。 目前LayaAir中，我们可以添加这三种参数： 5.4.1 Float：浮点数 如动图5-4所示，我们来看看Float条件怎么设置，首先要定义一个Float的参数，其次在条件中，可以选择这个Float参数，右边会选择 Less 或者 Greater，最后可以填上数值。那么动图5-4的意思是，当Float大于0.5时，切换New State到New State0。 注意：当定义这个Float参数时，可以设置默认值，比如1，那么如果条件是Float参数 Greater 0.5，则条件直接打成，运行时会直接切换状态 （动图5-4） 可以通过代码来满足条件，代码如下： //通过设置“Float”参数的值，来满足切换状态的条件 this.animator.setParamsNumber( \"Float\" , 2 ); 运行效果如动图5-5： （动图5-5） 5.4.2 Bool：布尔 如动图5-6所示，我们来看看Bool条件怎么设置，首先要定义一个Bool的参数（有true或false），其次在条件中，可以选择这个Bool参数，最后可以勾选true或者false。那么动图5-6的意思是，当Bool为true时，切换New State到New State0。 注意：当定义这个Bool参数时，可以设置默认值，比如true，那么如果条件是Bool参数 true，则条件直接打成，运行时会直接切换状态 （动图5-6） 可以通过代码来满足条件，如下： //通过设置“Bool”参数的值，来满足切换状态的条件 this.animator.setParamsBool( \"Bool\" , true ); 运行效果如动图5-7： （动图5-7） 5.4.3 Trigger：触发器 如动图5-8所示，我们来看看Trigger条件怎么设置，首先要定义一个Trigger的参数（有true或false），其次在条件中，可以选择这个Trigger参数。那么后面我们可以通过代码来使用触发器，切换New State到New State0 。 （图5-8） 通过代码来满足条件，如下： //通过触发“Trigger”，来满足切换状态的条件 this.animator.setParamsTrigger( \"Trigger\" ); 运行效果如动图5-9： （动图5-9） 5.4.4 多个参数使用 当然我们可以定义多个参数，但是这种情况下需要对参数进行命名会更有效。如动图5-10所示来修改名字 ： （动图5-10） 修改好名字后，可以比较清晰的来编辑切换条件，如图5-11所示： （图5-11） 注意：这些条件中只要满足一个就可以触发动画切换，而不是并且的关系 5.5 切换优先级 一个动画状态下如果连有多个动画状态时，我们来看看优先级时怎样的。 当没有任何条件时或者条件都满足时，没有选择solo和mute的情况下，如图5-12： （图5-12） 此时，Attack动画播完会播放Stand动画，因为Stand动画是第一个。 当没有任何条件时或者条件都满足时，如果某个选了solo时，如图5-13： （图5-13） 此时，Attack动画播完会播放Run动画，因为Run动画选了solo。 当没有任何条件时或者条件都满足时，如果都选了solo时，如图5-14： （图5-14） 此时，Attack动画播完会播放Stand动画，因为即使都选了solo，但是动画切换只能选一个，按顺序Stand是第一个。 如果Attack-> Stand的条件不满足，Attack-> Run的条件满足，但是依然也如上图5-14一样，都选了solo。 此时，Attack动画播完会播放Run动画，因为Attack-> Stand的条件不满足 当没有任何条件时或者条件都满足时，如果都选了solo时，并Attack-> Stand选了mute，如图5-15： （图5-15） 此时，Attack动画播完会播放Run动画，因为Attack-> Stand选了mute。 当没有任何条件时或者条件都满足时，如果都选了solo和mute时，如图5-16 ： （图5-16） 此时，Attack动画播完不会切换任何状态。 六、动画播放及脚本 上面的章节中，只需要用简单的代码，就可以控制状态机来满足条件，播放指定的动画状态，除此之外，我们也可以通过代码来更多的控制动画播放。 6.1 播放控制 在获得动画状态机组件，添加了多个动画状态的情况下，那怎么播放其中一个动画呢？有几种方法实现对动作的控制与切换： 6.1.1 Play() 查看Animator动画组件中play()方法，具体方法参数如下： /** * 播放动画。 * @param name 如果为null则播放默认动画，否则按名字播放动画片段。 * @param layerIndex 层索引。 * @param normalizedTime 归一化的播放起始时间。 */ play(name: string | null = null, layerIndex: number = 0, normalizedTime: number = Number.NEGATIVE_INFINITY) 这是动画状态机里最基本的播放动画方式，通过下面的代码： //动画状态机，直接播放Run动画状态 this.animator.play(\"Run\"); 看看运行效果，如动图6-1所示： （动图6-1） 通过Play()的参数也可以指定播放动画的起始位置： //动画状态机，直接播放Stand动画状态，从50%的位置开始 this.animator.play(\"Stand\", 0 , 0.5); 看看运行效果，如动图6-2，每次鼠标点击按钮，可以从50%的位置开始播放Stand动画。 （动图6-2） 当然我们也可以通过代码修改动画状态的属性，播放不同的效果： //获得动画状态机的BaseLayer层，也可以获得其它层 let acl: Laya.AnimatorControllerLayer = this.animator.getControllerLayer(0); //获得一个动画状态 let state = acl.getAnimatorState(\"Stand\"); //设置动作状态的名称 state.name = \"Stand_new\"; //设置动作状态播放的起始时间（起始时间与结束时间的设置为0-1的百分比数值） 要截取的时间点 / 动画的总时长 state.clipStart = 10/40; //设置动作状态播放的结束时间 state.clipEnd = 20/40; //动画播放是否循环 state.clip.islooping = true; //动画状态机，直接播放Stand_new动画状态 this.animator.play(\"Stand_new\"); 看看运行效果，如动图6-3所示： （动图6-3） 6.1.2 crossFade() 动画过度融合是用于在给定的时间内从一个动画状态平滑过渡到另一个动画状态。如果一个动画跳转到另一个完全不同的动画耗时很短，那么过渡通常的表现令人满意。 先来看看Animator动画组件中crossFade()方法，具体方法参数如下： /** * 在当前动画状态和目标动画状态之间进行融合过渡播放。 * @param name 目标动画状态。 * @param transitionDuration 过渡时间,该值为当前动画状态的归一化时间，值在0.0~1.0之间。 * @param layerIndex 层索引。 * @param normalizedTime 归一化的播放起始时间。 */ crossFade(name: string, transitionDuration: number, layerIndex: number = 0, normalizedTime: number = Number.NEGATIVE_INFINITY) 通过代码调用如下： //动画状态机，过渡融合到Run动画状态 this.animator.crossFade(\"Run\", 0.3); 看看运行效果，如动图6-4，将待机动画和跑步动画混合起来。 （动图6-4） 6.1.3 暂停动画 播放动画说完了，我们再来说一下暂停动画。可以直接使用动画的播放速度控制动画的暂停与播放，直接设置需要暂停动画的播放速度为0即可，继续播放只需要重新设置速度为1。 //暂停动画 this.animator.speed = 0.0; //播放动画 this.animator.speed = 1.0; //一半速度播放动画 this.animator.speed = 0.5; 看看运行效果，如动图6-5所示： （动图6-5） 6.2 获取播放状态 获取动画播放状态，需要先使用Animator的 animator.getControllerLayer(layerIndex)方法： /** * 获取控制器层。 */ getControllerLayer(layerInex: number = 0): AnimatorControllerLayer { return this._controllerLayers[layerInex]; } 获得 AnimatorControllerLayer 后，再使用 getCurrentPlayState() 方法： /** * 获取当前的播放状态。 * @return 动画播放状态。 */ getCurrentPlayState(): AnimatorPlayState { return this._playStateInfo!; } 获得 AnimatorPlayState 后，有三个常用的方法获取播放状态如下： /** * 播放状态的归一化时间,整数为循环次数，小数为单次播放时间。 */ get normalizedTime(): number { return this._normalizedTime; } /** * 当前动画的持续时间，以秒为单位。 */ get duration(): number { return this._duration; } /** * 动画状态机。 */ get animatorState(): AnimatorState { return this._currentState!; } 通常我们可以利用 normalizedTime 来判断是否某个动画状态是否播完，例如下面的代码： const { regClass, property } = Laya; @regClass() export class Main extends Laya.Script { @property( { type: Laya.Label } ) private label: Laya.Label; @property( { type: Laya.Sprite3D } ) private target: Laya.Sprite3D; private animator : Laya.Animator; onStart() { this.label.on( Laya.Event.CLICK, this, this.test ); //获得状态机 this.animator = this.target.getComponent(Laya.Animator); } //运行状态机的跑动画，可使用动作融合方式 test(e: Laya.Event) { //动画状态机，过渡融合到Run动画状态 this.animator.crossFade(\"Run\", 0.1); //等待动画播放完成 Laya.timer.frameLoop(1,this,()=>{ //如果当前播放state已经播放完了一次 if(this.animator.getControllerLayer(0).getCurrentPlayState().normalizedTime >= 1){ //回到站立状态 this.animator.crossFade(\"Stand\", 0.1); Laya.timer.clearAll(this); } }); } } 看看运行效果，如动图6-6所示： （动图6-6） 6.3 使用状态脚本 对我们的开发需求来说，能够播放和切换动画状态还不够，可能还需要在每一个状态内实现更多的需求，例如当进入或者离开下一个状态时，播放不同的音效，那么通过添加动画状态脚本可以很容易实现，如图6-7所示，每个状态都可以添加一个或者多个状态脚本 。 （图6-7） 6.3.1 创建脚本 我们通过动图6-8，来看看如何为一个站立状态创建一个动画脚本。首先在项目资源->src目录中，创建一个动画脚本，然后选中Stand状态，在Scripts下点击+按钮，即可挂上刚刚创建的动画脚本。 （动图6-8） 6.3.2 脚本使用 我们来看看刚刚创建的动画脚本，初始的代码如下： const { regClass } = Laya; interface AnimatorPlayScriptInfo { animator: Laya.Animator | Laya.Animator2D; layerindex: number; playState: Laya.AnimatorState | Laya.AnimatorState2D; } /** * 继承自AnimatorStateScript(动画状态脚本) * @author ... */ @regClass() export class AnimationScript extends Laya.AnimatorStateScript { /**动画的状态信息 */ playStateInfo: AnimatorPlayScriptInfo = { animator: null, layerindex: -1, playState: null }; /**@internal */ setPlayScriptInfo(animator: Laya.Animator | Laya.Animator2D, layerindex: number, playstate: Laya.AnimatorState | Laya.AnimatorState2D) { this.playStateInfo.animator = animator; this.playStateInfo.layerindex = layerindex; this.playStateInfo.playState = playstate; } constructor() { super(); } /** * 动画状态开始时执行。 */ onStateEnter(): void { console.log(\"动画开始播放了\"); } /** * 动画状态运行中 * @param normalizeTime 0-1动画播放状态 */ onStateUpdate(normalizeTime: number): void { console.log(\"动画状态更新了\"); } /** * 动画状态退出时执行。 */ onStateExit(): void { console.log(\"动画退出了\"); } } AnimationScript脚本继承自Laya.AnimatorStateScript，setPlayScriptInfo是一个生命周期函数，可通过该函数获取当前脚本的动画组件、动画状态机层级、动画状态机。 /**说明 * setPlayScriptInfo为生命周期函数，如果想获得动画状态机的信息，必须要调用。 * @param animator 当前脚本的动画组件 * @param layerindex 当前脚本所处的动画状态机层级 * @param playState 当前脚本的动画状态机 */ setPlayScriptInfo(animator: Laya.Animator | Laya.Animator2D, layerindex: number, playstate: Laya.AnimatorState | Laya.AnimatorState2D) { this.playStateInfo.animator = animator; this.playStateInfo.layerindex = layerindex; this.playStateInfo.playState = playstate; } 此脚本还具备三个方法： onStateEnter：动画状态开始时执行； onStateUpdate：动画状态运行中，方法中可以获得当前状态执行的时间长度 normalizeTime； onStateExit：动画状态退出时执行； 我们可以通过重写这几个方法，来实现动画状态改变时执行自己的逻辑。简单加入一些代码来看效果： const { regClass } = Laya; interface AnimatorPlayScriptInfo { animator: Laya.Animator | Laya.Animator2D; layerindex: number; playState: Laya.AnimatorState | Laya.AnimatorState2D; } /** * 继承自AnimatorStateScript(动画状态脚本) * @author ... */ @regClass() export class AnimationScript extends Laya.AnimatorStateScript { /**动画的状态信息 */ playStateInfo: AnimatorPlayScriptInfo = { animator: null, layerindex: -1, playState: null }; private isShow: boolean = false; private _label: Laya.Label; /**@internal */ setPlayScriptInfo(animator: Laya.Animator | Laya.Animator2D, layerindex: number, playstate: Laya.AnimatorState | Laya.AnimatorState2D) { this.playStateInfo.animator = animator; this.playStateInfo.layerindex = layerindex; this.playStateInfo.playState = playstate; this._label = animator.owner.scene.parent.getChildByName(\"root\").getChildByName(\"Scene2D\").getChildByName(\"Label\"); } constructor() { super(); } /** * 动画状态开始时执行。 */ onStateEnter(): void { console.log(\"动画开始播放了\"); this._label.text = \"开始跑动画\"; } /** * 动画状态运行中 * @param normalizeTime 0-1动画播放状态 */ onStateUpdate(normalizeTime: number): void { console.log(\"动画状态更新了：\" + normalizeTime); if (normalizeTime > 0.5 && !this.isShow) { this.isShow = true; this._label.text = \"跑动画一半\"; } } /** * 动画状态退出时执行。 */ onStateExit(): void { console.log(\"动画退出了\"); this._label.text = \"退出跑动画\"; } } 实际运行效果，如动图6-9所示 （动图6-9） 七、子状态机 子状态机，就是在状态机里面，再创建一个新的状态机，这个新的状态机就叫子状态机。 这个状态机的作用是可以创建另外一套状态，方便来管理复杂的动画状态。举例来说，游戏中角色站着的时候有待机/跑/攻击/防御，下蹲的时候则是另外一套待机/跑/攻击/防御。那么下蹲就是子状态，因为下蹲跑，下蹲攻击这些动作都是基于下蹲这个状态，所以他们可以独立成为一个子状态机。 7.1 创建子状态机 如动图7-1所示，在状态机的空白位置，点击鼠标右键，选择创建节点目录，将会生成一个名为“New StateMachine”的节点，这就是子状态机。双击子状态机可进入子状态机面板，在这个面板中可以看到三个状态， 进入、任何状态和退出 ，这三种状态是属于子状态机的，而非父状态机。父状态机只有进入和任何状态。 （动图7-1） 同样，我们可以对子状态机进行新的命名，如动图7-2所示 ： （动图7-2） 7.2 编辑子状态机 比如我们想把角色的所有攻击和技能动画，都放到子状态机中，归为一类作为角色的攻击状态，而父状态机只用来处理待机，跑，眩晕，死亡，胜利等状态。那么我们进入子状态机中，拖入攻击和技能等动画并连线，同之前的父状态机的操作一样。如动图7-3所示： （动图7-3） 7.3 进入子状态机 拖入一个 Attack（Take 001） 动画进去，此时 进入 状态会连接到此动画，表示该子状态机的默认状态是Attack。如图7-4所示： （图7-4） 接着回到父状态机，将Idle连接子状态机，实际上相当于连接子状态机中的 进入 状态。如动图7-5操作： （动图7-5） 7.4 退出子状态机 如果我们希望Attack动画结束之后，就完成了子状态机的功能，并且退出子状态机，回到父状态机，并回到Idle状态，这个过程属于退出子状态机。 在父状态机里，回到子状态机的状态后，需要继续连线到其它状态，才能让动画连续，如动图7-6所示： （动图7-6） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-06-07 17:46:00 "},"IDE/animationEditor/aniBake/readme.html":{"url":"IDE/animationEditor/aniBake/readme.html","title":"动画烘培详解","keywords":"","body":"动画烘培详解一、IDE中使用动画烘培二、烘培多个动画动画烘培详解 上面两篇文档介绍了在LayaAir3.0中如何使用时间轴动画及动画状态机，本篇将介绍一种特殊的动画优化方案，动画烘培。什么是动画烘培，动画烘培是将所有动画提前计算一次；将所有的骨骼节点预计算，存入内存中；gpu直接通过内存读取对应节点的矩阵值；进行渲染的方式。通过使用动画烘培，可以降低cpu的消耗，因为GPU动画效率高于CPU动画，对于大量使用骨骼动画的场景，可以大大提高性能。 一、IDE中使用动画烘培 由于在LayaAir项目中播放动画的对象都需要添加Animator组件，因此我们先准备好一个带Animator的动画对象，如图1-1所示 （图1-1） 在动画状态机中配置好动画状态和动画片段，如图1-2所示 （图1-2） 此时运行场景，可以看到人物在做待机的动画，如动图1-3所示 （动图1-3） 此时的动画是通过CPU计算骨骼的信息来播放动画的，接下来我们来使用动画烘培，用GPU来计算动画数据 在菜单中，点击“面板”，选择“动画烘培”，如图1-4所示 （图1-4） 可以打开“动画烘培”工具，如图1-5所示 （图1-5） 从工具中可以了解到，要想对上面的带Animator的动画做动画烘培，需要把包含Animator组件的节点，拖入到工具中，如动图1-6所示，我们来拖入节点 （动图1-6） 通过点击烘培后，开始执行动画烘培。在节点名字“DanDing”的目录下会生成动画烘培后的数据文件。 注意：生成数据文件的目录名是节点的名字 我们来看看都生成了什么数据文件，如图1-7所示 （图1-7） 其中，在danding目录下 anim目录：存入动画.lani文件（可以多个动画文件） mesh目录：存入模型文件 DanDing.ktx：烘培后的数据文件，使用ktx纹理图片的格式，用来存放计算好的动画数据 DanDing.controller：重新以节点名字命名的3D动画状态机文件 DanDing.lh：保存烘培后的预制体，可以直接使用。点击预制体，可以从图1-7中后边看到，模型节点上配置了SimpleSkinnedMeshRenderer组件，同时配置好烘培的数据文件 这时我们可以直接使用代码或者直接将预制体拖入场景中，在LayaAir示例中，可以看到加载大量烘培后的动画，效率有大幅提高，如图1-8 预烘培骨骼动画示例：https://layaair.layabox.com/3.x/demo/?category=3D&group=8&name=6 二、烘培多个动画 通常情况下Animator中会配置好多个动画，那么就可以一次性的烘培所有的动画，如图2-1所示 （图2-1） 接下来，重新对DanDing节点，做动画烘培，如动图2-2所示 （动图2-2） 此时，多个动画就烘培好了，如图2-3所示 （图2-3） 在anim目录中生成了多个动画lani文件。 提示：如果开发者有多个FBX文件，每个FBX文件只有一个lani动画文件，在IDE中是不能直接把lani动画文件从FBX文件中导出的，可以通过动画烘培的方式导出lani文件使用，从而保证项目的动画资源比较精简。 打开controller文件后，可以看到所有的动画状态已经创建，后面直接使用预制体就好了。 到此为止，动画烘培已经介绍完了，开发者可以在项目的优化过程中使用LayaAir3.0提供的动画烘培工具，进一步提高性能。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:46 "},"IDE/physicsEditor/readme.html":{"url":"IDE/physicsEditor/readme.html","title":"物理编辑模块","keywords":"","body":"物理编辑模块2D物理编辑3D物理编辑物理编辑模块 LayaAir引擎IDE内集成了2D物理与3D物理的可视化编辑，可直观的实现物理。 2D物理编辑 3D物理编辑 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:48 "},"IDE/physicsEditor/physics2D/readme.html":{"url":"IDE/physicsEditor/physics2D/readme.html","title":"2D物理编辑","keywords":"","body":"LayaAirIDE的可视化2D物理编辑入门一、基础知识1.1 学习本文需要的前置知识1.2 LayaAir内置的物理引擎二、物理引擎基础2.1 刚体 RigidBody2.2 碰撞体 collider2.3 关节 Joint三、物理碰撞的生命周期3.1 onTriggerEnter3.2 onTriggerStay3.3 onTriggerExitLayaAirIDE的可视化2D物理编辑入门 一、基础知识 1.1 学习本文需要的前置知识 物理学基础概念相关 本篇不可避免的会涉及一些物理学相关的基础概念，文中会尽可能简要说明，让大家理解作用与效果。但如果涉及到某块基础概念不理解，或者想进一步深入理解，需根据关键字自行搜索补习相关的基础知识。本篇重点在于介绍引擎中相关属性的作用与如何使用，为了文档的连贯性，对于过于基础的概念，可能不会太详细的进行描述。 1.2 LayaAir内置的物理引擎 LayaAir引擎在1.x的时候内置的是Matter.js物理引擎，核心原因是小巧轻便。但随着微信小游戏产业的兴起，以及物理小游戏的火爆，带动一阵物理小游戏的热潮，因此，对于物理游戏的需求也越来越多。从精度、圆形支持、防穿透等方面，Matter.js已经不能满足。于是在LayaAir 2.0引擎开始，选择了更加成熟和应用最广泛的Box2D作为LayaAir引擎内置的2D物理引擎，并且整合到LayaAirIDE中，可以通过LayaAirIDE可视化编辑物理游戏。让物理游戏开发起来更加轻松。 如果对于物理引擎功能需求较为简单，并且希望能减小引擎体积的情况下，LayaAir引擎仍然可以结合使用Matter物理引擎。 但不在本篇范围内，本篇全面介绍LayaAirIDE中的2D物理引擎组件。 二、物理引擎基础 要了解物理引擎的基础，必须要先充分的理解刚体、碰撞体、关节。 2.1 刚体 RigidBody Box2D可以说是一个用于游戏的2D刚体仿真库。所以，刚体是我们需要首先理解的概念。 2.1.1 什么是刚体 大家都知道，自然界一切有形体的物质，都可以叫物体。刚体是力学中为了体现物体特性的一种科学抽象概念，也是一种理想状态的力学表达模型，是指在运动中和受到力的作用后，形状和大小不变，而且内部各点的相对位置不变的物体。 然而，现实中不可能存在这种理想模型，物体在受力之后，会根据力、材料、弹性、 塑性等综合因素，决定是否改变或改变多少。 如果物体本身的变化不影响整个运动过程，为使被研究的问题简化，仍将该物体当作刚体来处理而忽略物体的体积和形状，这样所得结果仍与实际情况相当符合。 2.1.2 刚体组件属性说明 LayaAir引擎中的2D刚体组件类是 Laya.RigidBody ，继承自创建组件的基类 Component。在LayaAirIDE中，我们可以直接为UI组件添加刚体组件。如下图1所示。 (图1) 刚体类型 type 基于理论力学的理论基础，box2D物理引擎的刚体类型(type)分为：静力学类型static、动力学类型dynamic、运动学类型kinematic，IDE里默认为dynamic。 如图2-1所示。 (图2-1) 静力学类型：static 静力学，它主要研究力系的平衡条件，力系的简化，物体受力分析的基本方法。 静力学static类型的刚体就是始终静止不动，无论施加怎样的力都不会移动， 不受重力影响，速度为零且不可设置 。 在LayaAirIDE中创建的2D示例项目中，永远不会移动的地板，就是使用的static类型刚体。 动力学类型：dynamic 动力学，它主要研究作用于物体的力与物体运动的关系。 动力学dynamic类型的刚体会根据受到的力进行移动， 会受到重力的影响，可设置速度。 在LayaAirIDE中创建的2D示例项目中，受重力影响而不断掉落的方块盒子，使用的就是dynamic类型刚体。 运动学类型：kinematic 运动学，它是运用几何学的方法来研究物体的运动，不考虑力和质量等因素的影响。重点研究物体的轨迹、位移、速度、加速度等运动特性。至于物体的运动和力的关系，则是动力学的研究课题。 运动学kinematic类型的刚体不会根据受到的力进行移动，不受重力影响，可设置速度。与静力学类型的刚体主要区别就是，通常会通过设置速度（线速度和角速度）使其移动。 在LayaAirIDE中创建的2D示例项目中，向上撞击或击碎方块盒子的圆形子弹，使用的就是kinematic类型刚体。 重力缩放系数 gravityScale （图2-2） 设置为0为没有重力 自然界中物体受地心吸引的作用而受到的力叫重力，物理引擎中也同样模拟了重力，并可以设置参数对其改变。 刚体的gravityScale属性是重力缩放系数，通过调整数值可以改变重力大小，数值可以为正数或负数，也包括了正负小数。默认值为1，即正常重力，IDE中如上图2-2所示。如果数值为0则表示没有重力。大于1的数值表示正常重力的倍数，数值越大则重力越大。gravityScale属性数值为负数，则表示反方向重力，数值越小则反方向的重力越大。 角速度 angularVelocity （图2-3） 刚体的angularVelocity属性是角速度， 角速度简单理解就是单位时间的角位移，以弧度每秒进行旋转 。当我们设置angularVelocity属性为正值的时候，则按顺时针旋转位移。angularVelocity属性为负值的时候，则按逆时针旋转位移。属性值的绝对值越大，旋转位移速度越快。angulaVelocity属性的默认值为0，如图2-3所示，此时不会产生旋转位移。 角阻尼 angularDampin （图2-4） 阻尼是外界作用或自身原因引起逐渐下降的衰减特性，刚体的角阻尼则是相对于角速度的旋转阻尼系数，使得旋转速度衰减。默认值为0，表示没有阻尼，如图2-4。通常阻尼的值在0到0.1之间。 线性速度 linearVelocity （图2-5） 刚体的linearVelocity属性称为线速度或者线性速度，是指物体的直线运动速度，如果物体呈曲线运动，就是沿着曲线路径切线方向的单位时间即时速度。 线速度是一个矢量值，它是描述作曲线运动的质点运动快慢和方向的物理量，既有大小也有方向。 在LayaAirIDE里，linearVelocity属性值，为x,y坐标方向的速度值，例如图2-5中示例的10,10，表示x坐标（向右）速度为10，y坐标（向下）速度为10。坐标值可以为负值，坐标值的绝对值越大，速度越快。 在理解角速度与线速度的关系上，假如我们围绕一个原点画一条曲线，那这个曲线从起始到结束的角度除以单位时间就是角速度，这个曲线的长度除以单位时间，就是线速度。 线性阻尼 linearDamping （图2-6） 刚体的linearDamping属性，是指线性速度的阻尼系数，使得线性速度衰减。范围从0到无穷大。默认值为0，表示没有阻尼，如图2-6。通常阻尼的值应该在0到0.1之间。 子弹 bullet （图2-7） 在有些情况下，物理引擎可能会捕捉不到某些已经发生的碰撞，导致互相穿透卡在一起。 刚体的bullet属性，中文是子弹，形容射出的子弹那样高速移动的物体，bullet属性用于防止高速穿透。 bullet默认值为false，如图2-7，此时不对刚体作防穿透处理（连续碰撞检测），会节省性能。当设置为true时，会通过连续碰撞检测防止高速穿透。 允许休眠 allowSleep （图2-8） 物理引擎进行模拟时，是存在性能消耗的。当刚体停止运动时，其实我们可以不去模拟它。刚体设置为休眠状态就会跳过该刚体的模拟，直到被其它刚体解除才会醒来（关节被破坏或者手动唤醒也可以），从而节省性能的消耗。 刚体的allowSleep属性，中文是允许休眠，默认值为ture，如图2-8所示。如果想保持一直醒着的状态，设置为false可以关闭允许休眠。 允许旋转 allowRotation （图2-9） 刚体的allowRotation属性，中文是允许旋转，实际理解还是与字面意思有些差异。这里是可以控制刚体碰撞时角度是否发生旋转改变。默认值为true，如图2-9所示。表示允许刚体发生碰撞时模拟自然撞击的角度改变，看起来更加自然。当设置为false，碰撞后不会产生角度变化。 比如，一把受重力自由下落的尖刀，是希望碰到地板后，最终平躺在地板上。还是始终保持尖刀竖立的状态，可以通过allowRotation属性来控制。 碰撞组 group （图2-10） group属性可以设置当前刚体所属的碰撞组。默认值为0，如图2-10。 碰撞组规则如下： 1、如果两个对象的刚体group相等且group值大于零，它们将始终会发生碰撞。 2、如果两个对象的刚体group相等且group值小于零，它们将永远不会发生碰撞。 3、如果两个对象的刚体group值等于0或者group值不相等，则使用刚体的碰撞类别category和碰撞掩码mask来判断是否碰撞。 碰撞类别 category （图2-11） category属性表示碰撞类别，与碰撞组group关联使用，默认值为1（2的0次方），如图2-11所示。 当两个对象的碰撞组（group）值等于0或者值不相等时，使用2的幂次方值来指定碰撞类别。此属性接收位字段，范围为[1,2^31]内2的幂，共有32种不同的碰撞类别可用。 按2的幂设置值不是强制规定，不按这个规则取值，不会引发报错，但是需要提前用mask值与category以按位与进行检查，否则简单的按category求和法来设置可能会导致结果出错。 碰撞掩码 mask （图2-12） mask属性表示碰撞掩码，默认值为-1，如图2-12所示。 如果说category是用于设置碰撞组的类别ID，那碰撞掩码mask就是用于指定要和哪个category类别ID的对象进行碰撞。用以实现碰撞过滤。 关于如何设置mask的值，需要用到位运算的知识，可以通过按位或运算和异或运算得到指定的值。 通常，我们采用按位或的运算比较多，例如，想与刚体category属性值分别为1、2、8、4的四个物体对象发生碰撞。那我们就要把要碰撞的对象刚体mask属性设置为15（也就是1|2|8|4的位运算结果）。为了简化理解成本，我们也可以把这个二进制的按位或运算，按照表象特点，理解为十进制的求和运算（1+2+8+4），但一定要理解，实质上是按位或的位运算结果。 关于对碰撞分组，类别，掩码，以及位运算，想了解更多的，可以查看官网文档：https://ldc2.layabox.com/doc/?nav=zh-ts-3-5-5 刚体标签 label （图2-13） label属性是刚体的标签名，默认值是RigidBody。如图2-13。 当我们想在项目代码中，通过自定义标签名来识别该刚体，用于判断控制的时候，可以在label属性中进行设置。 2.2 碰撞体 collider LayaAir引擎与IDE基于Box2D物理引擎的形状（shape）封装了更容易理解和使用的碰撞体（collider）。下面针对LayaAir碰撞体进行介绍。 2.2.1 碰撞体与刚体的关系 碰撞体顾名思义，是用来检测碰撞的形状体组件，而刚体是使游戏物体能获得重力和接受力的组件。没有碰撞体的形状区域，只有刚体，则无法产生碰撞效果。 在LayaAirIDE中，使用碰撞体组件，但没有添加刚体时，会强行添加刚体组件。碰撞体是必须依附于刚体的2D碰撞几何结构。具有摩擦(friction)和恢复(restitution)的材料性质。 2.2.2 碰撞体的种类 (图3) LayaAir的碰撞体一共有五种，如图3。我们根据2D几何图形的外观特性，分别命名为：矩形碰撞体BoxCollider，圆形碰撞体CircleCollider，链形碰撞体ChainCollider，多边形碰撞体PolygonCollider，边线碰撞体Edgecollider（Box2D 2.4.1版本新增） BoxCollider也可以称为盒子碰撞体。 2.2.3 碰撞体的基类属性 五种碰撞体都继承于碰撞体基类ColliderBase，有着共有的基类属性。我们先介绍一下通用的属性和基类的属性。稍后再分别介绍各碰撞体的特有属性。 坐标 x、y （图4-1） 碰撞体的坐标与父子节点坐标作用一样。x和y属性是与该碰撞体所属节点偏移的坐标，默认值都为0，如图4-1所示，修改碰撞体x与y的坐标位置就是修改与其节点偏移的位置。 摩擦系数 friction （图4-2） 摩擦系数是指两表面间的摩擦力和作用在其一表面上的垂直力之比值。在现实中，它是和物体表面的粗糙度有关，而和接触面积的大小无关。 物理引擎模拟了摩擦系数，其属性值设置范围是0到1，值越大表示摩擦越大， 0表示没有摩擦，1表示强摩擦， 几乎移不动的摩擦。 默认值为0.2，如图4-2所示。 恢复 restitution （图4-3） 碰撞体的restitution属性直译是恢复，恢复可以使对象弹起，我们可以想象一下打乒乓球、篮球等，以恢复的特性使其弹出或弹起。所以恢复表示一种弹性的碰撞现象。 对于restitution属性值，我们可以理解为弹性系数。值的设置范围是0到1，值越大表示弹性越大。如图4-3的默认值为0，此时不具有弹性，1的时候为完全弹性碰撞，会以同样的速度反弹。 密度 density （图4-4） 密度是单位体积的质量。当一个对象的密度越大，那么它的质量就越大，碰撞时也就相对更难以移动。 密度density值可以为零或者是正数，如果为零， 那将会是一个静止的对象。 IDE里的默认值为10，如图4-4所示。建议使用相似的密度，当产生多物体堆叠在一起时，这样做可以使得堆叠更加稳定。 是否为传感器 isSensor （图4-5） 当游戏逻辑需要判断两个碰撞体是否相交，但不需要有碰撞反应。这时候，可以通过传感器来完成。传感器会侦测碰撞而不产生碰撞反应。 isSensor的默认值为false，如图4-5所示，表示不是传感器。当设置为true时，表示为传感器，此时能够触发碰撞事件，但不会产生碰撞反应。 碰撞体标签 label （图4-6） 碰撞体标签与刚体标签一样，当自定义了标签名后，用于项目代码中识别控制。 label属性的默认值是当前碰撞体的种类名，在LayaAirIDE 创建的2D示例项目中，地板的矩形碰撞体BoxCollider，就使用了自定义的标签ground，如图4-6所示。 2.2.4 矩形碰撞体 BoxCollider （图5-1） 宽高 width、height 矩形碰撞体BoxCollider，也可以直译为盒子碰撞体，是封闭的直角平行四边形碰撞框，为节点添加BoxCollider组件后，默认的BoxCollider宽高会等于该节点的宽高。如果节点的宽高改变后，可以手动更改BoxCollider的width和height改变。或者通过fitsize功能来适配节点的宽高。 适配宽高大小 fitsize （图5-2） 当BoxCollider碰撞体的所属节点宽高改变后，碰撞体大小不会自动跟随改变。快捷的方法是，点击图5-2所示的fitsize按钮，可以自动按节点当前的宽高适配改变碰撞体的大小，让碰撞体的宽高等于所属节点的宽高。 2.2.5 圆形碰撞体 CircleCollider （图6-1） 半径 radius 圆形碰撞体CircleCollider，是一个封闭的圆形框，其大小是通过半径来控制，半径越大，碰撞体的圆形框越大。 当节点添加CircleCollider组件后，半径值默认为该节点的width的一半。如果节点宽高被改变，需要手动修改半径radius值，或者通过fitsize快捷的设置为该节点width的一半。 适配半径大小fitsize （图6-2） CircleCollider的fitsize与BoxCollider的fitsize作用其实一样，都是自动按节点来适配碰撞体大小，只不过规则不同而已。在4种不同的碰撞体种类里，只有BoxCollider与CircleCollider支持fitsize这种自动适配碰撞体大小的功能。 2.2.6 链形碰撞体 ChainCollider 、多边形碰撞体 PolygonCollider ChainCollider与PolygonCollider这两种碰撞体，除了继承的基类属性外，还有一个通用的属性Points。它们都是用x,y坐标点来表示一个线段节点，两个线段节点之间为线段或边，两种碰撞体都可以直接增加点，让ChainCollider成为任意多节的链条状碰撞体，让PolygonCollider成为任意凸多边形框状碰撞体。 点坐标集合 Points （图7-1） Points的属性是一个由x,y坐标组成的点集合，每个x和y坐标为一个点，每一个坐标都是以逗号间隔区分。 除了直接在属性栏里输入坐标数值，在编辑界面中可以更快捷的操作。拖动线段或边上的点可改变位置，点击线段或边可增加新的线段点。双击线上或边上的点可以删除该点。 ChainCollider最少由2个点的线段组成，链接形状不能进行穿插自相交（不同的线形碰撞体可相交）。 PolygonCollider最少由3个点的封闭三角形组成，最多只能是8个点（超出会报错），并且只能是凸多边形。 所以，我们要注意，ChainCollider碰撞体为不自相交的形状或线段，PolygonCollider为一个整体的凸多边形。如下图7-2所示。 （图7-2） 凹多边形是不支持的，如果一定要凹多边形，可以用多个凸多边形组合拼接 链条碰撞体ChainCollider在LayaAir3.0中仅提供单侧碰撞。链条碰撞体的单侧碰撞方向取决于链条碰撞体的缠绕顺序，当链条碰撞体逆时针缠绕时，碰撞发线向外；顺时针缠绕时碰撞发线向内。如图7-3所示： 链形碰撞体ChainCollider只能是单侧碰撞。单侧碰撞的方向取决于链条碰撞体的缠绕顺序，规则如图7-3所示。当最终链的形状是呈逆时针缠绕时，碰撞的法线方向就是向外（从里向外可以发生碰撞，从外向里直接穿透）。当最终链的形状是呈顺时针缠绕时，碰撞的法线方向就是向内（也就是从外向里可以发生碰撞，从里向外直接穿透）。 （图7-3） 我们再放两组效果动图，让大家加深理解： 逆时针缠绕碰撞的动态演示如动图7-4所示： （动图7-4） 顺时针缠绕碰撞的动态演示如动图7-5所示： （动图7-5） 也许还会有开发者提出疑问，如果没有发生缠绕，例如直线，单边碰撞的规则是什么？ 当处于水平直线时， 如果链的初始点在左边，末端点在右边，那么从下向上直接穿透，从上向下发生碰撞。 如果链的初始点在右边，未端点在左边，效果相反，从下向上碰撞，从上向下穿透。 具体效果，就不再放图了，开发者可以在LayaAirIDE里动手尝试体验一下。通常采用链形碰撞体大多会是缠绕的形状，非缠绕形态的直线，除非就是想使用单边碰撞效果，否则建议采用边线碰撞体。 2.2.7 边线碰撞体 Edgecollider 这个碰撞体与链条碰撞体ChainCollider非常相似。属性参数完全一样，外观看上去相似，尤其是同样都处于两点组成的线段时。 但是，区别在于点坐标集合points的值，边线碰撞体EdgeCollider只能是两个端点的直线线段，如图7-6所示。 （图7-6） 链条碰撞体ChainCollider可以是两个端点的线段也可以是多个点的折线，如图7-7所示： （图7-7） 另外，ChainCollider只能是单边产生碰撞，另一边是可以穿透过去的。边线碰撞体 Edgecollider可以两边都发生碰撞。 需要注意的是，边线碰撞体与链条碰撞体都不受重力影响。而以前版本的物理，链条碰撞体ChainCollider是可以受重力影响的。 边线碰撞体可以与矩形碰撞体、圆形碰撞体和多边形碰撞体碰撞，但不能与它们自身碰撞，也不能与未闭合的链条碰撞体碰撞。因为Box2D使用的碰撞算法要求俩个碰撞体形状中至少有一个具有体积。 2.3 关节 Joint 关节用于将刚体约束到物理世界或彼此约束。 譬如游戏中的提线木偶、钟摆等都是关节的应用。 LayaAir引擎封装了10种关节组件，可在IDE中直接添加使用，如图8所示。分别为：距离关节DistanceJoint、齿轮关节 GearJoint、马达关节MotorJoint、鼠标关节MouseJoint、平移关节PrismaticJoint、滑轮关节PulleyJoint、旋转关节RevoluteJoint、绳索关节RopeJoint、焊接关节WeldJoint、车轮关节WheelJoint。 （图8） 2.3.1 距离关节DistanceJoint 距离关节描述了两个刚体锚点之间的距离，并且保持着这个约束的距离。 默认状态下像铁棍一样始终固定连接两点。也可以像弹簧一样连接着两个刚体点。 （图9-1） 另一个刚体 otherBody 距离关节必须由两个刚体组成，otherBody属性用于绑定另一个刚体，此处需要拖拽层级面板中的目标节点或者目标节点刚体到该属性栏目。拖拽后，如图9-1所示。双击已绑定的otherBody属性输入栏，被绑定的目标刚体会在层级面板中被选中，方便我们快速定位被绑定的是哪个刚体。 至于两个刚体之间，谁是绑定或被绑定（otherBody）的关系，要综合实际业务逻辑考虑。仅是为了体现两者的约束关系，那谁是绑定者，并没有什么区别。 另一个锚点 otherbody、自身锚点 selfbody 每一个刚体都有一个刚体锚点，默认是在自身刚体的左上角（自身(0,0)坐标），使用距离关节后，当选中距离关节，场景编辑面板中会出现一红一绿两个圆点，绿色圆点为自身锚点selfbody，红色锚点为otherBody绑定的另一个刚体锚点。如果开发者没有手动进行指定，则是绑定到IDE默认创建的另一个刚体初始坐标(0,0)。效果如下图9-2所示（图中的线是方便开发者观看用脚本挂载到Scene2D上实现的，下面是代码。红点和绿点也是方便开发者观看用截图工具的画笔画出来的引擎中并无红绿点）。 Laya.PhysicsDebugDraw.enable(); （图9-2） 通常我们会指定锚点位置，例如钟摆的示例，如下图9-3所示。 （图9-3） 振动频率 frequency （图10-1） 默认情况下，关节之间的联系是固定的。要想让关节具有弹性，就可以调节frequency（振动频率）。 为了让大家更直观的理解，图10-2是个动图，左侧是frequency默认值，中间是frequency值为0.8，右侧是frequency值为3。 （动图10-2） 阻尼率damping （图11-1） 阻尼率damping会影响弹性的振动，0是无阻尼，也可以无穷大。但是建议取值0到1之间。 相对于动图10-2，我们将damping设置值为1，所以看到效果，如动图11-2所示，影响了振动的幅度和回弹效果。 （动图11-2） 静止长度length （图12-1） length值是当约束的目标静止时，自身锚点到另一个锚点的距离长度（会受振动频率值影响）。默认值0是不设置长度。 上面的振动频率动图效果示例，我们去掉阻尼效果，把长度值都设置为20时，效果如动图12-2所示。 （动图12-2） 连接刚体是否碰撞 collideConnect （图13-1） collideConnect是控制关节连接两端的刚体是否可以发生碰撞，当值为true是允许碰撞，所以连接的刚体就不会形成穿透现象，如动图13-2右侧的效果所示。不过，默认值为false，不发生物理碰撞，所以动图13-2左侧的两个球形刚体就直接穿透了。 （动图13-2） 最小长度minLength （图13-3） 最小长度minLengh属性，最小长度minLength设置的是俩个刚体锚点之间最小的距离长度，-1表示使用默认值。 最大长度maxLengh 最大长度maxLengh属性，最大长度maxLength设置的是俩个刚体锚点之间最大的距离长度，-1表示使用默认值。 注意要点： 距离关节的otherBody、selfAnchor、otherAnchor、collideConnected这几个属性全都是只读属性，只是在首次设置值有效（比如在IDE中设置属性值），不支持动态修改属性值。 2.3.2 绳索关节RopeJoint（LayaAir2.12.1中删除） 绳索关节Rope Joint在LayaAir2.12.1中被删除，如有使用原绳索关节的，可以用此版本中的距离关节DistanceJoint来代替。 绳索关节与距离关节比较类似，稍有区别的是，距离关节有弹性（振动频率），并会受其影响；绳索关节只能通过maxLength设置固定的最大距离长度。 最大长度 maxLength （图14-1） 最大长度maxLength设置的是自己锚点与关节另一端锚点之间最大时的距离长度。无论在IDE如何摆放关节位置，运行时都会强行调整为maxLength属性设置的距离。正如下面动图14-2所示，图左是默认值1，图右是200的固定值。 （动图14-2） 其它说明： 其它属性与距离关节一样去理解，就不再重复介绍了。 2.3.3 鼠标关节 MouseJoint 鼠标关节用于通过鼠标来操控物体。它试图将物体拖向当前鼠标所在的位置。 锚点 anchor （图15-1） 关节的控制点，是相对自身刚体的左上角位置偏移，如果不设置，则根据鼠标点击点作为连接点 由于鼠标关节是刚体与鼠标之间的约束，所以默认情况下，鼠标点中这个刚体的哪里，锚点就在哪里。如动图15-2所示。 （动图15-2） 如果我们设置了锚点anchor的属性值为中心点（例如50,50），无论鼠标点中刚体的什么位置，都会以锚点为约束该关节的控制点。如动图15-3所示。 （动图15-3） anchor是只读属性，只是在首次设置值有效（比如在IDE中设置属性值），不支持动态修改属性值。 最大力 MaxForce （图16-1） 最大力是指鼠标在拖曳鼠标关节的目标刚体时，施加的最大作用力，默认值是10000。假如我们改成100，会发现，只有比较小的牵引力。比如，无法将目标刚体拖起。效果如动图15-2所示。 （动图16-2） 其它说明： 其它属性与距离关节一样去理解，就不再重复介绍了。 2.3.4 焊接关节WeldJoint 焊接关节的特点是约束两端的刚体不能相对运动，如同焊接起来的整体一样。 （动图17-1） 上面的动图17-1是对比距离关节的效果图，我们可以看到，右上摆动的梯形是受静态刚体约束的距离关节，我们用鼠标关节去撞击它，虽然约束的距离始终不变。但是运动方向却发生了改变。而左上的球形同样被静态刚体所约束着。但由于焊接关节的特性，左上的球性怎么去撞击，都不会发生运动，相当于焊接到静态刚体之上。 另外，我们注意到下面的焊接关节刚体，虽然两个刚体没有静态的，但也是如同一个整体一样，始终保持着相对的角度和位置。 那如果我们想让他既保持相对的位置，也可以灵活的动一下，可以通过设置振动频率frequency，让焊接起来的两个刚体保持一些弹性，如动图17-2所示。 （动图17-2） 其它说明： （图17-3） 其它属性可参考距离关节与鼠标关节去理解，就不再重复介绍了。 2.3.5 滑轮关节 PulleyJoint 滑轮关节就是模拟改变施力方向杠杆的物理滑轮，当滑轮关节的其中一个刚体运动，滑轮另一端的刚体就会因约束而跟随运动。例如，当一个物体上升，另一个物体就会下降。效果如动图18-1所示： （动图18-1） 动图18-1，对三角进行拖拽，结合了鼠标关节 另一个范围点otherGroundPoint、自己的范围点selfGroundPoint 由于滑轮运动是基于杠杆原理的，那范围点就是运动的尽头，正如动图18-1所示，到达范围点后，就不会沿着原有运动方向继续运动。下面的图18-2，红圈中的绿色点就是滑轮约束自己的范围点selfGroundPoint，红圈中的红色点是滑轮约束连接的另一个范围点otherGroundPoint。 （图18-2） 初始的范围点与锚点是重合在一起，全都在0,0点的，需要按项目需求进行调整，如动图18-3所示。 （动图18-3） 移动比率ratio ratio属性值可以用来模拟滑轮组，它会使得一方的移动速度与距离是另一方的倍率关系。比如，我们为方块添加了滑轮关节，并设置ratio属性值为2.5。效果如动图18-4所示，很明显，左侧三角下降的速度与移动距离是右侧方块上升的2.5倍。 （动图18-5） 其它说明： 滑轮关节的这些属性，均为只读属性，仅首次设置有效。 其它未介绍的属性可参照距离关节的属性介绍去理解。 2.3.6 马达关节 motorJoint 马达关节是通过设置最大作用力与最大扭力，让A刚体（自己）到达目标位置（B刚体的偏移量）的一种约束。 即便B刚体处于运动中，那A刚体最终也会到达B刚体偏移量的相对目标位置，并且始终保持着相对的位置以及角度。 线性偏移 linearOffset （动图19-1） 线性偏移的值 ，就是基于B刚体（otherBody）的位置偏移量，当施加了力之后，动图19-2的左侧是默认值0,0效果，右侧是设置了50,50偏移值效果。 （动图19-2） 角度偏移 angularOffset （图19-3） 角度偏移的值，就是基于B刚体（otherBody）的旋转角度偏移量，当施加了扭力之后，动图19-4的左侧是没有设置角度偏移的效果（默认值0），右侧是设置旋转180度的角度偏移效果。 （动图19-4） 需要注意的是，angularOffset的属性值是弧度值，不是直接填写角度值。 弧度值计算公式：角度数 ×（π / 180） 最大力 maxForce 与 最大扭力 maxTorque （图19-5） 在物理引擎的计算中，为了满足约束条件，需要计算出一个受力，这个受力可能会很大。通常是为了提高计算的稳定性，需要设定一个最大受力的限制。 在马达关节里， maxForce是用来限制为达到线性偏移linearOffset这个约束条件时受到力的最大值。 maxTorque是用来限制为达到角度偏移 angularOffset这个约束条件时受到扭力的最大值。 最大力与最大扭力的默认值都是1000，开发者可以根据实际需求来调节。如果设置为0，则被限制在0这个最大受力上，会导致无法达成约束条件。例如，无法到线性偏移位置，或者无法到达偏移的角度。 之前的动图19-2与动图19-4，就是分别设置了最大力与最大扭力的效果。 修正系数 correctionFactor （图19-6） 修正系数是修正自己刚体到达目标刚体位置时的位移速度参数。取值范围是0-1，值越大移动的速度越快。 （动图19-7） 动图19-7的左侧是默认值0.3，右侧值是0.05，很明显，0.05慢很多。 2.3.7 旋转关节 RevoluteJiont 旋转关节会迫使两个刚体共享同一个锚点，这个共享的锚点通常被称为铰链点。旋转关节只有一个自由度，两个刚体处于相对旋转。 跳过之前小节介绍过的属性，不理解的可以前翻 启动马达 enableMotor、 马达速度 motorSpeed （图20-1） 想让旋转关节转起来，我们需要启动马达，将enableMotor属性值设置为true。 马达开启后，马达速度与最大马达扭力的值才会有效果。 然后设置马达的最大转动速度motorSpeed，通过动图20-2所示的效果看出，左侧明显转动的更快，这就是左侧设置马达转速值高于右侧的效果。 （动图20-2） 为了仅演示转速对比效果，动图20-2固定了三角刚体。如果三角刚体恢复为默认的动态刚体，当马达转速高的时候，我们就可以看到相对旋转的关节运动效果，如动图20-3所示。 （动图20-3） 最大马达扭力 maxMotorTorque (图20-4) 最大马达扭力是为马达施加的最大扭力。值越大，初始旋转的作用力越高。为0时，无法旋转。 在之前的动图效果中，由于motorSpeed是最大转速值，而最大马达扭力maxMotorTorque的默认值为10000，所以一开始就有一个较高的速度。 当我们把maxMotorTorque值设置为一个较小的值时，则会发现，初始转速会较慢，然后逐渐达到motorSpeed属性值的设置。效果如动图20-5的中间所示。 (动图20-5) 并且我们可以看到，动图20-5的左侧甚至没有转起来，这就是由于maxMotorTorque设置为0导致的。 另外要注意的是，即便是maxMotorTorque值设置的很大，当 motorSpeed值设置比较小，那转速还是会受到最高马达转速的限制，不会越来越快。效果如动图20-5的右侧所示。 启用约束enableLimit 、下限角度lowerAngle、上限角度upperAngle (图20-6) 当启用约束（enableLimit为true）后，下限角度lowerAngle与上限角度upperAngle这两个属性才会生效。 下限角度lowerAngle是弧度值来设置旋转关节的最小旋转角度，当马达的扭力不足时，甚至是不启动马达，这个最小角度的设置依然有效。 上限角度upperAngle是弧度值来设置旋转关节的最大旋转角度。即便马达的扭力再大，仍然会受到这个最大角度设置的限制。 具体效果如动图20-7所示， (动图20-7) 2.3.8 平移关节 PrismaticJoint PrismaticJoint的关节特性是将两个刚体锁定在一个指定的平移轴进行相向或相背移动，平移关节只有一个自由度，无法旋转。所以尽管prismatic直译过来是棱柱的，但我们把PrismaticJoint叫做平移关节或者移动关节更容易理解记忆。 轴向axis、开启马达enableMotor、马达速度motorSpeed、最大马达力maxMotorForce （图21-1) 之前在介绍马达关节的时候，有两种力，作用力与扭力。 上个小节的旋转关节只用到了马达的扭力。这个小节的平移关节只用到了马达的作用力。 所以，与旋转关节类似，在使用平移关节的时候，也是要先开启马达（enableMotor设置为true），才会有移动效果。只是旋转关节的最大马达扭力在这里换成了平移的作用力maxMotorForce。马达的速度motorSpeed也变成了启用马达后的最大移动速度。 而移动的方向，就取决于轴向属性axis了，这个属性值是一个向量值，默认1,0是表示沿X轴向右移动，反之，沿X轴向左移动设置-1,0即可。具体效果可参考动图21-2所示。 (动图21-2) 启用约束enableLimit、平移下限lowerTranslation、平移上限upperTranslation (图21-3) 当启用平移关节的约束（enableLimit设置为true）后，与旋转关节类似，平移的范围也有下限和上限。 平移下限lowerTranslation是指移动的最短距离是离锚点anchor有多远。即便没有启用马达力，也会受这个限制影响。 平移上限upperTranslation是指移动的最长距离可以离锚点anchor有多远，达到限制后，无论设置多大的马达力，也不会再移动。 下限与上限的对比效果如动图21-4所示。 (动图21-4) 2.3.9 齿轮关节 GearJoint (图22-1) 要绑定的第一个关节，类型可以是RevoluteJoint或者PrismaticJoint 绑定关节joint 通过图22-1，我们看到齿轮关节joint1与joint2绑定的不再是刚体，而是两个关节，而且必须是旋转关节或者平移关节。 这是因为，齿轮关节就是通过一个齿轮带动另一个齿轮进行旋转或者平移运动，来模拟现实中的齿轮效果。 （动图22-2） 在动图22-2中，我们就是使用了两个平移关节和两个旋转关节组成了一组复合的齿轮关节。 齿轮的关节，仅从IDE上的属性数量上来看，貌似最简单。其实对新手来说是一个不太容易直观理解的关节，在这个小节中，详细描述一下齿轮关节的制作方式，供开发者作为参考。 首先，我们要了解齿轮关节的本质，就是用一个关节的马达动力来驱动所有的关联关节。 所以，我们先设置一个动力关节，例如动图22-2中，我们用最上面的平移关节，作为齿轮的动力关节。 Tips： 要想不让关节掉下来，要把所有的关节刚体重力值设置为0，否则会直接掉下去。 需要受力而运动的刚体不要设置为静力学或者运动学类型，否则会导致无法通过力来使其运动起来。 第一步： (图22-3) 如图22-3所示，我们为一个叫box的节点添加了刚体和矩形碰撞体。然后添加平移关节，并设置平移的方向（轴axis），开启马达（enableMotor），设置移动速度(motorSpeed)。 注意这里，关节属性上，不需要绑定其它的约束刚体（otherBody）。 在本个齿轮示例的后面，所有的关节属性上都没有绑定其它的约束刚体。 第二步： (图22-4) 如图22-4所示，我们为一个名为laya1的节点添加刚体和圆形碰撞体，然后添加旋转关节，设置锚点为中心点即可。马达等开关都不用管，保持默认的关闭就行。因为我们为laya1添加齿轮关节，并将laya1节点的旋转关节与box节点的平移关节关联起来之后（如图22-4箭头所指），box节点的平移关节马达，就会为laya1的旋转关节提供动力。 其实，到此，齿轮关节的完整制作方式已经完成。运行起来，我们就可以看到沿x轴向左平移运动的box正带动着laya1作逆时针旋转。 第N步： 当需要更多齿轮结构的时候，所有的后续关节，我们衔接的方式，无论是旋转关节，还是平移关节，要想成为齿轮组成员之一，不仅要添加好对应的物理关节，还要同时为其所属的节点也添加上齿轮关节。而绑定关系，就是把自己的旋转关节或者平移关节绑到齿轮关节的joint1或者jonit2上。另一个绑定你打算与其发生齿轮咬合关系的关节。可参考图22-5与图22-4所示。基本上都是在重复第二步的操作流程。 (图22-5) 齿轮系数 ratio 齿轮系数与之前在滑轮关节介绍的移动比率类似，是一个比率值。对于平移是影响移动的速率，对于旋转是影响转动的速率，其值可以为负数。 2.3.10 车轮关节WheelJoint 车轮关节是专为车辆而设计的，它同时提供了平移和旋转，平移的时候有弹簧和阻尼减震来模拟汽车悬架。而旋转马达可以用来模拟汽车的启动与刹车。 前面小节中介绍过的属性在这个小节就不再次说明了，不理解的可以往前翻。 LayaAir2.12.1新增属性： 刚体移动范围约束enableLimit （图23-1） 是否对刚体的移动范围加以约束 当启用约束（enableLimit为true）后，移动范围下限lowerTranslation与移动范围上限upperTranslation才会生效。 移动范围下限lowerTranslation （图23-2） 启用约束后，刚体移动范围的下限，是距离anchor的偏移量 刚体移动范围的下限lowerTranslation是指移动的最短距离距锚点anchor可以多远，即便没有启用马达力，也会受此限制的影响。 移动范围上限upperTranslation （图23-3） 启动约束后，刚体移动范围的上限，是距离anchor的偏移量 刚体移动范围的上限upperTranslation是指移动的最长距离距锚点anchor可以多远，到达限制后，无论设置多大马达力都不会再移动。 车轮关节的注意要点 绑定刚体 在车轮关节里，所有的旋转车轮都可以绑定同一个车身刚体，如图23-1所示。 (图23-4) 锚点 由于车轮是以自己的圆心为轴心进行旋转，一定要把轮子圆心点作为车轮关节的控制锚点anchor，如图23-1右侧的车轮关节anchor属性配置。 震动频率 震动频率其实就是弹簧的弹性系数，引擎中的默认值是5，大家可以根据业务需求来调节，但不要过小，否则可能会导致轮子与车体的组合不稳定。 效果展示 最后我们将调整好属性值的车轮关节运行效果展示出来，如动图23-2所示。 (动图23-5) 三、物理碰撞的生命周期 之前介绍的所有物理属性，开发者都可以在IDE里调节属性值，然后直接运行起来查看效果，不需要写一行代码。 从这个章节里，我们就了解一下脚本中有哪些物理生命周期方法。 如果有对生命周期也不理解的新手，请先去Layabox官网文档的组件化开发相关文档去补一下基础。 3.1 onTriggerEnter onTriggerEnter是在发生物理碰撞时，也就是碰撞生命周期内的第一次进入碰撞，自动执行的生命周期虚方法。 3.2 onTriggerStay onTriggerStay是在发生持续的物理碰撞时，也就是碰撞生命周期内的第二次碰撞到碰撞离开前，每帧都在触发，自动执行的生命周期虚方法。 3.3 onTriggerExit onTriggerExit是在物理碰撞结束时，自动执行的生命周期虚方法。 Tips: 以上的方法是发生在每一次碰撞发生的完整生命周期内，例如，从进入到离开为“Enter,Stay,Stay,……,Exit” 我们在为显示节点设置了碰撞体之后，开发者可以为这些节点挂接Script脚本。在脚本中直接重写以上虚方法的代码逻辑。当运行触发了这些物理碰撞条件，就可以自动执行相应的代码逻辑。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-05-22 20:32:37 "},"IDE/physicsEditor/physics3D/readme.html":{"url":"IDE/physicsEditor/physics3D/readme.html","title":"3D物理编辑","keywords":"","body":"一篇上手LayaAir的3D物理引擎一、刚体二、物理碰撞三、物理约束四、物理射线五、其它物理引擎的使用一篇上手LayaAir的3D物理引擎 LayaAir引擎集成了世界三大物理引擎之一的Bullet引擎，当在Unity中使用了物理组件，用LayaAir的Unity插件导出后，默认就是采用的Bullet引擎。当然，LayaAir引擎也支持使用比较轻量的Cannon物理引擎的基础功能。本篇针对LayaAir引擎的初学者，全面介绍了3D物理引擎使用的基础能力。方便开发者快速上手。 阅读本篇时，除非是Cannon物理引擎的专属章节，或者注明是cannon物理引擎，默认介绍都是基于LayaAir封装的Bullet引擎。 一、刚体 1.1 什么是刚体 无论是2D，还是3D，物理的开篇，都需要先了解刚体（RigidBody），这是物理引擎的基础之一。 大家都知道，自然界一切有形体的物质，都可以叫物体。 刚体是力学中为了体现物体特性的一种科学抽象概念，也是一种理想状态的力学表达模型，是指在运动中和受到力的作用后，形状和大小不变，而且内部各点的相对位置不变的物体。 然而，现实中不可能存在这种理想模型，物体在受力之后，会根据力、材料、弹性、 塑性等综合因素，决定是否改变或改变多少。 如果物体本身的变化不影响整个运动过程，为使被研究的问题简化，仍将该物体当作刚体来处理而忽略物体的体积和形状，这样所得结果仍与实际情况相当符合。 1.2 常用的刚体属性 isKinematic是否为运动刚体 3D的刚体，默认是动力学刚体。受力的影响，可以位移。 一旦我们把刚体设置为运动刚体类型后，即将isKinematic的值设置为true。 那么运动刚体可以触发第三方的物理反馈，自己却不受物理影响。例如，运动刚体与动力学刚体发生撞击，动力学刚体会受力反弹，但运动刚体却不会受力的影响，不会产生受力位移，运动刚体的位移只能通过transform改变节点坐标。 与2D的运动学类型刚体不同，LayaAir 3D的运动刚体脱离了物理引擎运动，即使设置速度也不可以使其位移。这样做的好处是减少了物理运算，节省了性能。 mass质量 质量是物质的量的量度，Bullet引擎中的质量单位为kg。 刚体的质量越大，运动状态改变越难，比如，不同质量的两个物体相撞，质量大的一方改变更小一些，如动图1的左侧所示： （动图1） 静态刚体和运动刚体就相当于无限大质量，不受力的影响。 gravity 重力 自然界中物体受地心吸引的作用而受到的力叫重力，物理引擎中也同样模拟了重力， 动力学刚体在同等的质量下，重力越大，下落的加速度越大。对比效果如动图1-1。 （动图1-1） angularVelocity 角速度 刚体的angularVelocity属性是角速度， 角速度简单理解就是单位时间的角位移，以弧度每秒进行旋转 。当我们设置动力学刚体angularVelocity属性为正值的时候，则按顺时针旋转位移。angularVelocity属性为负值的时候，则按逆时针旋转位移。属性值的绝对值越大，旋转位移速度越快。 （动图1-2） angulaVelocity属性的值是3维向量Vector3类型值，Bullet使用欧拉角来描述物体的旋转，3D向量的每个分量代表绕x、y、z轴旋转的速度，单位是弧度/秒。动图1-2，就是在x轴分别设置了3.14与31.4的对比效果。 angularDamping 角阻尼 刚体的角阻尼相当于是为角速度旋转方向施加了相反的力，使得旋转速度衰减。 动图1-3，是在同样的31.4角速度下，左侧为1的的角阻尼值，右侧为0.9的角阻尼值，对比效果。 （动图1-3） angularFactor 角度因子 刚体的角度因子是在每个轴方向（速度和力）上缩放物理值的角度因子 动图1-4，是在同样的31.4角速度下，左侧为1的的角度因子，右侧为2的角度因子，对比效果。 （动图1-4） linearVelocity 线性速度 刚体的linearVelocity属性称为线速度或者线性速度，是指物体的直线运动速度。 动力学刚体的线速度是3维向量Vector3类型值，向量的方向即速度的方向，向量的长度即速度的大小。 动图1-5，是动力学刚体在同样重力值为0的情况下，没有设置线速度和y轴设置了线速度值的对比效果。 （动图1-5） linearDamping 线性阻尼 刚体的linearDamping属性，是指线性速度的阻尼系数，使得线性速度衰减。 动图1-6，是动力学刚体在重力为0并且y轴设置了同样为-1的线速度值情况下，左侧为0.9线性阻尼值和右侧为1线性阻尼值的对比效果。 （动图1-6） linearFactor 线性因子 刚体的linearFactor属性，是指个轴方向上缩放物理值（速度和力）的线性因子 刚体的linearDamping属性，是指线性速度的阻尼系数，使得线性速度衰减。 动图1-7，是动力学刚体在重力为0并且y轴设置了同样为-1的线速度值情况下，左侧为1线性因子和右侧为2线性因子的对比效果。 （动图1-7） 二、物理碰撞 碰撞是物理引擎中最基础、最常用的功能。在这个小节里，我们对3D物理碰撞进行全面的认知。 2.1 碰撞器与触发器 对于检测3D物理碰撞的方式，有碰撞器与触发器两种。我们先从概念认知开始。 2.1.1 碰撞器 在LayaAir引擎2D物理的时候，通过封装的不同形状的碰撞体，就可以直接实现带范围的物理碰撞。 而LayaAir引擎的3D物理，形状不再是最主要的特征，只是碰撞器用于检测碰撞范围的三维形状区域。 完整的3D碰撞器，由碰撞器和碰撞器形状两部分组成。 3D碰撞器根据特点的不同，分为静态碰撞器、刚体碰撞器、角色碰撞器。 这些碰撞器必须要添加三维碰撞器形状（例如：盒形、球形、圆锥形、圆柱形、胶囊形、平面、混合、模型网格），才可以实现有范围的物理碰撞。 （图2-1） 图2是胶囊形状角色碰撞器的编辑预览效果。 2.1.2 触发器 LayaAir 3D物理的触发器相当于2D物理里的传感器。 触发器是碰撞器的一个属性，任何碰撞器的触发器属性设置生效后，当前的碰撞器即转变为触发器（比如，刚体碰撞器设置触发器后可称为刚体触发器）。即使发生物体接触，也不会产生碰撞的物理反馈。例如，动图3-1右侧所示。下落的盒子无视物理引擎，直接穿透而过。 （动图2-1） 设置触发器后，虽然失去了物理引擎反馈，但是可以激活触发器的碰撞生命周期方法，用于检测物体间碰撞接触的发生。 激活触发器生命周期也有特定的情况除外，具体规则会在下面的物理生命周期章节介绍 当触发器isTrigger设置为true时，如图2-2所示。触发器即可设置生效。 （图2-2） 通过代码设置触发器的方式： /* ……省略若干代码 */ //获取物理刚体组件 this.rigidbody1 = this.cube1.getComponent(Laya.Rigidbody3D) as Laya.Rigidbody3D; this.rigidbody2 = this.cube2.getComponent(Laya.Rigidbody3D) as Laya.Rigidbody3D; //设置rigidbody1为触发器,取消物理反馈 this.rigidbody1.isTrigger = true; this.rigidbody2.isTrigger = false; /* ……省略若干代码 */ 2.2 理解各种碰撞器 2.2.1 静态碰撞器 PhysicsCollider LayaAir的3D物理碰撞器类是PhysicsCollider，为了便于记忆和理解，我们叫他静态碰撞器类。因为它的特性是不受力，不会产生物理移动。 当其与动力学刚体碰撞器或角色碰撞器发生物理碰撞后，可以触发物理碰撞生命周期方法，但不会产生物理的受力位移。 这种碰撞器可以用于不需要物理受力位移的物体，只需要触发碰撞逻辑的应用场景。例如墙体，撞墙后判定游戏结束。 （图2-3） 图2-3是添加LayaAir的3D物理碰撞器组件PhysicsCollider 2.2.2 刚体碰撞器 Rigidbody3D LayaAir的2D物理刚体与碰撞体是分开的，而3D物理的刚体与碰撞器是整合的，Rigidbody3D类即是刚体也是碰撞器，我们可称为刚体碰撞器。 默认情况下，Rigidbody3D是动力学类型的刚体碰撞器，这是可以受力影响的刚体类型碰撞器，所以我们通常用动力学刚体碰撞器进行受力的交互反馈。例如，撞击后的反弹、飞出或者倒下，放在空中会受重力影响而掉落，等等。 当我们将刚体Rigidbody3D的isKinematic设置为true后，那么默认的动力学刚体碰撞器就转变为运动刚体碰撞器。 运动刚体碰撞器从表象上看，与静态碰撞器基本上没有什么区别。都是不受重力、不受速度、不受其它力的影响，在物理世界中永远处于静止，只能通过transform去改变节点坐标来移动。 但实质上，运动刚体有物理特性，它可以是施力物体，可以对非运动刚体产生力，例如通过控制节点去移动运动刚体，会推着挡在前面的动力学刚体移动。而静态碰撞器的应用场景则是要永远不动，也无法施加力。并且，通过节点去移动静态碰撞器，也比较消耗性能。如果有移动的碰撞器需求，例如来回移动的跳板或障碍，使用运动刚体碰撞器就可以了。 通过代码设置运动刚体的方式： /* ……省略若干代码 */ //获得刚体碰撞器 this.rigidbody = this.cube1.getComponent(Laya.Rigidbody3D) as Laya.Rigidbody3D; //开启运动类型刚体 this.rigidbody.isKinematic = true; /* ……省略若干代码 */ 在LayaAir中设置运动类型刚体的方式，如图2-4所示： （图2-4） 由于LayaAir的3D物理中有了静态碰撞器PhysicsCollider，所以并没有在Rigidbody3D中去实现静力学类型的刚体碰撞器。有静止的碰撞反馈需求，直接使用静态碰撞器即可。 2.2.3 角色碰撞器 CharacterController 角色控制器类CharacterController常用于对第一人称和第三人称游戏角色的控制，可以方便的控制角色的跳跃、跳跃速度、降落速度、行走、等。 由于角色控制器继承于PhysicsComponent，也具有碰撞器的特性，可以添加三维碰撞形状，产生碰撞的反馈，因此也称为角色碰撞器，属于碰撞器之一。 与静态碰撞器和刚体碰撞器都继承自物理触发器组件PhysicsTriggerComponent不同，角色控制器直接继承于物理组件的父类PhysicsComponent。所以，角色控制器是无法设置为触发器的。但是，角色碰撞器与触发器进行接触，仍然可以激活触发器的生命周期方法。 （图2-4） 图2-4是添加角色控制器类CharacterController 2.3 碰撞形状 碰撞形状是用于检测碰撞接触的范围，只有添加了形状，碰撞器和触发器才能触发物理反馈和生命周期。 LayaAir引擎支持8种3D碰撞形状，分别为： 盒形BoxColliderShape、球形SphereColliderShape、圆柱形CylinderColliderShape、胶囊形CapsuleColliderShape、圆锥形ConeColliderShape、平面形状StaticPlaneColliderShape、复合形状CompoundColliderShape、网格形状MeshColliderShape。 2.3.1 LayaAir中可创建的碰撞形状 盒形碰撞体Box collider、球形碰撞体Sphere Collider、胶囊形碰撞体Capsule Collider、圆柱形CylinderColliderShape、圆锥形ConeColliderShape、网格碰撞体 Mesh Collider，这6种组件是可以在LayaAir中使用的。 下面我们简单介绍一下这些碰撞体形状的基础属性设置 盒形碰撞形状 盒形碰撞形状是通过设置XYZ调整长宽高的长方体（含立方体）形状。常用于盒子外形的长方体物体，如图2-6所示。 （图2-6） 在LayaAir中，设置盒形碰撞XYZ各轴的大小，如图2-7所示。 （图2-7） 球形碰撞形状 球形碰撞形状是通过设置半径调整球体大小的碰撞形状。常用于球形外观的物体，如图2-8所示。 （图2-8） 在LayaAir中，设置球形碰撞半径，如图2-9所示。 （图2-9） 胶囊形碰撞形状 胶囊形碰撞形状是由两个半球和一个圆柱体组成，需要通过设置球体半径和圆柱体的高来组成胶囊形状。常用于角色碰撞器。如图2-10所示。 （图2-10） 在LayaAir中，设置胶囊形碰撞半径和高，轴方向，如图2-11所示，导出后即可使用。 （图2-11） 圆柱形碰撞形状 圆柱形碰撞形状是通过设置半径和高调整球体大小的碰撞形状。如图2-12所示。 （图2-12） 在LayaAir中，设置圆柱形碰撞半径和高，如图2-13所示。 （图2-13） 圆锥形形碰撞形状 圆锥形形碰撞形状是通过设置半径和高调整球体大小的碰撞形状。如图2-14所示。 （图2-14） 在LayaAir中，设置圆锥形碰撞半径和高，如图2-15所示。 （图2-15） 网格形碰撞形状 网格形碰撞形状是利用模型网格资源构建的形状，如图2-16-1的猴子所示。相对于其它固定规则的碰撞形状（LayaAir内置的3D碰撞基础形状），网格形碰撞形状属于自定义任意外观的碰撞形状，可以适用于任何模型网格。 （图2-16-1） 在LayaAir中，设置模型网格，如图2-16-2所示。 （图2-16-2） 2.3.2 其它LayaAir碰撞形状 除了碰撞体组件支持的一些形状外，LayaAir引擎中还内置了一些基础的3D碰撞形状。这些只能通过代码的方式进行添加。 平面碰撞形状 平面碰撞形状，是一种无限大的2D平面碰撞形状。通常用于整个场景地面的碰撞形状。通过法线来确定在3维世界的平面朝向，可以通过偏移值来调整距离原点的偏移多少。API说明如图2-17所示。 （图2-17） 通过API，我们可以看到normal是一个3维向量值，表示着平面的法线。例如这个值为Vector3(0, 1, 0)，则表示法线位于Y轴正方向，平面碰撞形状就是处于其垂直的X轴无限大水平面。 图2-18和2-19是法线同样位于Y轴正方向，偏移值offset分别为0（左侧）和为1（右侧）的效果对比。 （图2-18） （图2-19） 2.3.3 碰撞器的形状代码添加示例 LayaAir内置的基础碰撞形状使用示例 内置的碰撞器使用思路为，创建节点对象，创建碰撞器，创建碰撞器形状，为碰撞器添加碰撞形状。 我们以创建圆锥形刚体碰撞器为例，编写代码如下所示： /* ……省略若干代码 */ /**增加圆锥形刚体碰撞器 */ private addCone(): void { //生成随机值半径和高 let raidius = Math.random() * 0.2 + 0.2; let height = Math.random() * 0.5 + 0.8; //创建圆锥形3D模型节点对象 let cone = new Laya.MeshSprite3D(Laya.PrimitiveMesh.createCone(raidius, height)); //把圆锥形3D节点对象添加到3D场景节点下 this.newScene.addChild(cone); //设置随机位置 this.tmpVector.setValue(Math.random() * 6 - 2, 6, Math.random() * 6 - 2); cone.transform.position = this.tmpVector; //为圆锥形3D节点对象创建刚体碰撞器 let _rigidBody = (cone.addComponent(Laya.Rigidbody3D)); //创建圆锥形碰撞器形状（使用节点对象的值，保持一致性） let coneShape = new Laya.ConeColliderShape(raidius, height); //为刚体碰撞器添加碰撞器形状 _rigidBody.colliderShape = coneShape; } /* ……省略若干代码 */ 其它基础形状的创建可参考官网的引擎示例 复合碰撞形状的使用示例 复合碰撞形状是由多个基础形状组合而成的碰撞器形状。例如桌子或者凳子等，可以由多个盒形碰撞形状组成，如图2-20所示。 （图2-20） 复合碰撞形状主要就是可以添加多个不同的子形状，理解后其实也是非常简单。 创建复合碰撞形状的方式并不复杂，先实例化复合碰撞形状CompoundColliderShape()，再通过复合碰撞形状对象的addChildShape方法添加基础碰撞形状子对象即可。 我们继续通过代码和注释来理解。编写代码如下所示： /* ……省略若干代码 */ Laya.Mesh.load(\"res/threeDimen/Physics/table.lm\", Laya.Handler.create(this, function(mesh:Laya.Mesh) { //读取Unity导出的桌子模型节点对象，添加到3D场景节点下， var table = scene.addChild(new Laya.MeshSprite3D(mesh)) as Laya.MeshSprite3D; //给桌子节点对象添加刚体碰撞器 var rigidBody = table.addComponent(Laya.Rigidbody3D) as Laya.Rigidbody3D; //实例化一个复合碰撞形状对象 var compoundShape:Laya.CompoundColliderShape = new Laya.CompoundColliderShape(); //创建盒形碰撞形状 var boxShape:Laya.BoxColliderShape = new Laya.BoxColliderShape(0.5, 0.4, 0.045); //获取本地偏移 var localOffset:Laya.Vector3 = boxShape.localOffset; //修改偏移 localOffset.setValue(0, 0, 0.125); boxShape.localOffset = localOffset; //为复合碰撞形状对象添加子形状（刚刚创建的盒形碰撞形状） compoundShape.addChildShape(boxShape); //后面的代码都是类似，把一个个的子形状都添加到复合碰撞形状对象上。子形状也可以是别的形状，例如球形、圆柱形等，根据模型节点的实际情况来。 /* ……省略若干boxShapeXX类似的代码，只保持到boxShape4 */ var boxShape4:Laya.BoxColliderShape = new Laya.BoxColliderShape(0.1, 0.1, 0.3); var localOffset4:Laya.Vector3 = boxShape4.localOffset; localOffset4.setValue(0.2, 0.153, -0.048); boxShape4.localOffset = localOffset3; compoundShape.addChildShape(boxShape4); //把组合好的复合碰撞形状添加给刚体碰撞器的碰撞器形状属性 rigidBody.colliderShape = compoundShape; })); /* ……省略若干代码 */ 2.4 碰撞生命周期方法 生命周期是从开始到结束的完整周期过程，有主动触发的主干生命周期方法，例如onAwake()、onEnable()、等。也有被动触发的事件类生命周期虚方法，这种只有在某个条件达到时才会自动激活，例如，本小节要讲的物理事件相关的方法。 2.4.1 物理事件的生命周期方法说明 前文介绍过，检测物理碰撞的方式有两种，那物理事件的方法，也对应着两种。分别是碰撞事件生命周期方法和触发事件生命周期方法。 碰撞事件生命周期方法说明： 碰撞器之间发生碰撞后，自动激活的事件虚方法。 碰撞事件生命周期方法名称 碰撞事件生命周期方法说明 onCollisionEnter 刚发生物理碰撞时，也就是碰撞事件生命周期内的第一次进入碰撞，自动执行的生命周期虚方法，该方法只会执行一次。 onCollisionStay 持续的物理碰撞时，也就是碰撞事件生命周期内的第二次碰撞到碰撞离开前，自动执行的生命周期虚方法。该方法在持续碰撞期间，每帧都会执行。 onCollisionExit 物理碰撞结束时，自动执行的生命周期虚方法，该方法只会执行一次。 触发事件生命周期方法说明： 设置为触发器之后，因物体接触而自动激活的事件虚方法。 触发事件生命周期方法名称 触发事件生命周期方法说明 onTriggerEnter 刚发生物体接触时，也就是触发事件生命周期内的第一次进行接触，自动执行的生命周期虚方法，该方法只会执行一次。 onTriggerStay 持续的物体接触时，也就是触发事件生命周期内的第二次接触到接触离开前，自动执行的生命周期虚方法。该方法在持续接触期间，每帧都会执行。 onTriggerExit 物体接触结束时，自动执行的生命周期虚方法，该方法只会执行一次。 特别说明： 碰撞事件的生命周期方法永远不会与触发事件的生命周期方法同时激活，只能是碰撞事件或者是触发事件。并且，如果有一方是触发器，那两方一定无法进入碰撞事件，只有进入触发事件的可能。 无论是碰撞事件还是触发事件的生命周期方法，从进入到离开的顺序皆为“Enter,Stay,Stay,……,Exit”。 2.4.2 碰撞事件生命周期方法的触发条件 根据碰撞器的类型不同，并不是所有碰撞器之间，都会触发碰撞的反馈，以及激活相应的生命周期方法。 下面通过表格的方式，对应了各碰撞器之间是否可触发碰撞事件的生命周期虚方法。 静态碰撞器 动力学刚体碰撞器 运动刚体碰撞器 角色碰撞器 静态碰撞器 ✘ ✔ ✘ ✔ 动力学刚体碰撞器 ✔ ✔ ✔ ✔ 运动刚体碰撞器 ✘ ✔ ✘ ✔ 角色碰撞器 ✔ ✔ ✔ ✔ 总结： 通过上面的表格，我们发现，静态碰撞器和运动刚体碰撞器，只能与动力学刚体碰撞器或者是角色碰撞器碰撞才可以触发碰撞器生命周期方法，静态碰撞器和运动刚体碰撞器彼此之间，是无法触发碰撞器生命周期的。 而动力学刚体碰撞器和角色碰撞器，和任意的碰撞器发生碰撞都可以触发碰撞器生命周期方法。 2.4.3 触发事件生命周期方法的触发条件 碰撞器是只能与碰撞器之间碰撞，才有可能进入碰撞器的生命周期， 而触发器则不然，触发器不仅与触发器之间有可能进入触发器的生命周期，当触发器与碰撞器之间接触，也有可能进入触发器的生命周期，所以，我们分成两个表来理解。 触发器与触发器之间： 静态触发器 动力学刚体触发器 运动刚体触发器 静态触发器 ✘ ✔ ✔ 动力学刚体触发器 ✔ ✔ ✔ 运动刚体触发器 ✔ ✔ ✔ 触发器与碰撞器之间： 静态触发器 动力学刚体触发器 运动刚体触发器 静态碰撞器 ✘ ✔ ✔ 动力学刚体碰撞器 ✔ ✔ ✔ 运动刚体碰撞器 ✔ ✔ ✔ 角色碰撞器 ✔ ✔ ✔ 总结： 通过上面的两个表格，我们发现，无论是触发器与触发器之间，还是触发器与碰撞器之间，只有静态碰撞器与静态触发器彼此之间碰撞或者接触，是无法进入物理触发事件的。 而其它类型之间接触，哪怕碰撞器没有开启触发器，甚至没有触发器属性（角色碰撞器），只要有任意一方是触发器，那也会自动进入触发器的生命周期。 2.4.4 使用生命周期方法 创建Script3D脚本 生命周期的方法，只能在脚本类里使用，所以，我们需要创建一个脚本，3D游戏必须要继承3D的脚本Script3D。空脚本的示例代码如下： /** * TypeScript语言的3D脚本示例 */ export default class TSDemo extends Laya.Script3D { constructor() { super(); } } 2D脚本与3D脚本不要混用，如果是用IDE创建的脚本模板，需要将继承的2D脚本类（Laya.Script）改为3D脚本类（Laya.Script3D）， 添加物理脚本 只有为节点添加了我们自定义的脚本，我们才可以让该节点使用生命周期方法。 添加的方式很简单，直接在代码中，用节点的addComponent()方法，就可以轻松的把继承了脚本类的3D脚本添加到节点上。 例如，我们创建一个3D盒子，并为其绑定刚刚创建的TSDemo脚本。示例代码如下： //引入自定义脚本TSDemo import TSDemo from \"./TSDemo\"; /** * TypeScript语言示例 */ export default class GameUI extends GameUIBase { /* ……省略若干代码 */ private addBox(): void { //创建盒型MeshSprite3D let box = this.newScene.addChild(new Laya.MeshSprite3D(Laya.PrimitiveMesh.createBox(0.75, 0.5, 0.5))) as Laya.MeshSprite3D; //设置材质 box.meshRenderer.material = this.mat1; //设置空间位置 let transform = box.transform; let pos = transform.position; pos.setValue(1, 6, 0); transform.position = pos; //创建刚体碰撞器 let _rigidBody = box.addComponent(Laya.Rigidbody3D) as Laya.Rigidbody3D; //创建盒子形状碰撞器 let boxShape = new Laya.BoxColliderShape(0.75, 0.5, 0.5); //设置盒子的碰撞形状 _rigidBody.colliderShape = boxShape; //添加自定义脚本组件TSDemo box.addComponent(TSDemo); } /* ……省略若干代码 */ } 重写物理生命周期方法 之前介绍过，物理事件的生命周期方法分别为三个碰撞事件方法和三个触发事件方法。我们在使用的时候，重写这些虚方法即可，当物理行为触发了对应的物理事件就会自动执行。 重写生命周期方法的示例代码如下： /** * TypeScript语言的3D脚本示例 */ export default class TSDemo extends Laya.Script3D { constructor() { super(); } onTriggerEnter(): void { /* ……省略若干逻辑代码 */ console.log(\"触发器物理事件onTriggerEnter\"); } onTriggerStay(): void { /* ……省略若干逻辑代码 */ console.log(\"触发器物理事件onTriggerStay\"); } onTriggerExit(): void { /* ……省略若干逻辑代码 */ console.log(\"触发器物理事件onTriggerExit\"); } onCollisionEnter(): void { /* ……省略若干逻辑代码 */ console.log(\"碰撞器物理事件onCollisionEnter\"); } onCollisionStay(): void { /* ……省略若干逻辑代码 */ console.log(\"碰撞器物理事件onCollisionStay\"); } onCollisionExit(): void { /* ……省略若干逻辑代码 */ console.log(\"碰撞器物理事件onCollisionExit\"); } } 2.5 碰撞分组与过滤碰撞组 当我们产生复杂的碰撞需求时，例如，想碰哪个，不碰哪个。这时候就需要进行分组，并指定可以与哪个碰撞组进行碰撞。另外，设置碰撞组过滤，还会优化性能。 各种碰撞器从物理组件父类PhysicsComponent那里继承了collisionGroup与canCollideWith属性，用以实现碰撞分组和指定碰撞组。 2.5.1 碰撞组 collisionGroup 碰撞组的值，我们通常设置为2的N次幂值。如果应用场景比较复杂，需要用到的碰撞分组比较多，记不住太多2的N次幂值，也可以直接使用LayaAir引擎内置的碰撞组工具类。 LayaAir引擎内置了17个碰撞组属性值，用于过滤不需要的碰撞。 引擎内置的碰撞组工具类为Laya.Physics3DUtils。 全部可碰撞的组 由于碰撞组之间的碰撞依据是位运算的按位与，按位与的计算结果非0则可以碰撞，为0则不可碰撞。 Physics3DUtils工具类的COLLISIONFILTERGROUP_ALLFILTER属性值为-1，-1与任何2的幂值进行按位与都非0，所以取该属性值为分组时，则所有的碰撞组都可碰撞。 使用示例为： //指定xxx碰撞器所属哪个碰撞组（-1组与LayaAir任何内置组都可碰撞） xxx.collisionGroup = Laya.Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER; 自定义碰撞分组 LayaAir内置的碰撞组，不包括刚刚讲的-1（COLLISIONFILTERGROUP_ALLFILTER），我们可以用的还有10个，分别是COLLISIONFILTERGROUP_CUSTOMFILTER1......10。全都是2的幂，从64到32768。 为了方便记忆，我们可以不记实际值，记住CUSTOMFILTER后1到10的ID号区别即可。 使用示例为： //指定xxx碰撞器所属哪个碰撞组（COLLISIONFILTERGROUP_CUSTOMFILTER2对应的值为128） xxx.collisionGroup = Laya.Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER2; 特定的碰撞分组 除了以上的分组外，LayaAir也对接了一些Bullet物理引擎预留的特定分组，用于比较简单的碰撞过滤需求。 例如，当前场景我们只有动态刚体碰撞器，静态碰撞器，运动学刚体碰撞器，只是对这几种碰撞器之间作碰撞过滤，那么我们就可以分别使用对应的默认碰撞组、静态碰撞组、运动学刚体碰撞组。 具体的预留分组属性说明如下： 碰撞组属性名 属性值 说明 COLLISIONFILTERGROUP_DEFAULTFILTER 1 默认碰撞组 COLLISIONFILTERGROUP_STATICFILTER 2 静态碰撞组 COLLISIONFILTERGROUP_KINEMATICFILTER 4 运动学刚体碰撞组 COLLISIONFILTERGROUP_DEBRISFILTER 8 碎片碰撞组 COLLISIONFILTERGROUP_SENSORTRIGGER 16 传感器触发器 COLLISIONFILTERGROUP_CHARACTERFILTER 32 字符过滤器 以上的属性是原样对接了Bullet物理引擎，例如碎片碰撞组和字符过滤器的概念，当前的引擎版本还没有。开发者想用也可以，但建议不采用，推荐使用自定义碰撞分组，以ID为分组标记更便于记忆。 2.5.2 过滤碰撞组 canCollideWith 指定碰撞单个组 碰撞器的canCollideWith属性可以用于指定与哪个组碰撞，指定哪个，就可以与哪个碰撞。其它的都不可以碰撞，起到了过滤其它碰撞组的效果。 使用示例为： //指定xxx碰撞器可以与其发生碰撞的碰撞组(本例只与自定义组1碰撞) xxx.canCollideWith = Laya.Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER1; 指定碰撞多个组 如果我们想碰撞多个组，可以采用位运算的按位或| ，去指定多个可以与其发生碰撞的碰撞组。 使用示例为： //指定xxx碰撞器可以与其发生碰撞的碰撞组(本例只与自定义组1、2、5进行碰撞) xxx.canCollideWith = Laya.Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER1 | Laya.Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER2 | Laya.Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER5; 关于位运算用于碰撞的基础原理，如果不明白的可以参考2D物理的碰撞分组详解：https://ldc2.layabox.com/doc/?nav=zh-ts-3-5-5 指定不可碰撞的组 在多个碰撞分组的情况下，如果我们只想排除掉某个或者某几个碰撞组不与其发生碰撞，与其它所有的碰撞组发生碰撞如何处理呢？ 这时候可以通过异或运算符^来实现。用 -1去异或^任何2的幂值，那该值的碰撞组就不会被碰撞。 使用示例为： //指定不可以与其发生碰撞的碰撞组(本例将不与自定义组2、5进行碰撞，除自定义2与5组之外，都可以发生碰撞) xxx.canCollideWith = Laya.Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER ^ Laya.Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER2 ^ Laya.Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER5; 三、物理约束 在物理世界中，有些物体的运动会受到其它物体的影响，例如：人体关节、钟摆、链条、滑轮组、等等。 这种限制物体运动，避免其运动超出一定限度的物理方法就是约束。由于其还具有着关节的特性表现，所以有些引擎也称为关节。 3.1 LayaAir支持哪些约束 目前在LayaAir引擎中只支持两种，分别是固定约束Fixed Constraint和可配置约束Configurable Constraint。 固定约束是比较常用的约束，而可配置约束可以模拟任意约束的效果，所以这两种约束可以满足绝大多数的常用需求。 3.2 固定约束Fixed Constraint 固定约束将对象的移动限制为依赖于另一个对象，一个物体产生位移变化 ，另一个与其约束的物体也会随之变化 。有些类似父子节点关系，但它与父子节点不同，位移不是通过transform实现，而是基于物理引擎。 固定关节类似2D物理（Box2D）里的焊接关节，适用于游戏中的物体对象永久或暂时粘在一起的需求，最好是两个没有父子关系的物理一起运动。好处是不必通过脚本更改对象的层级视图来实现所需的效果。代价是所有使用固定关节的对象都必须使用刚体。 3.2.1 设置连接刚体 setConnectRigidBody setConnectRigidBody用于指定固定约束要连接的刚体，若不指定，则该约束连接到世界。 3.2.2 断开力 breakForce breakForce用于设置破坏固定约束需要施加的最大力。 3.2.3 断开力矩 breakTorque breakTorque用于设置破坏固定约束需要施加的最大力矩。 3.3 可配置约束Configurable Constraint 可配置约束可实现各种约束类型的所有功能，比如上文介绍过的固定约束，也可以通过可配置约束来实现，并且提供更强大的角色移动控制。 当开发者想要自定义布娃娃的运动并对角色强制实施某些姿势时，这种约束特别有用。使用可配置约束还可以将约束修改为开发者自行设计的高度专业化约束。 3.3.1 设置连接刚体 setConnectRigidBody setConnectRigidBody用于指定固定约束要连接的刚体，若不指定，则该约束连接到世界。 3.3.2 锚点 anchor 锚点anchor 是用于定义自身刚体约束中心的点。物理模拟会使用此点作为计算的中心点。 3.3.3 主轴 axis 主轴 axis用于基于物理模拟来定义对象自然旋转的局部轴，该轴决定了对象在物理模拟下自然旋转的方向。 3.3.4 连接锚点 connectAnchor 连接锚点connectAnchor 用于设置所连接刚体的约束锚点。 例如自己是车轮，连接的刚体是车身。那锚点就是车轮的约束中心点，连接锚点就是所连接的车身约束中心点。 3.3.5 副轴 secondaryAxis 副轴secondaryAxis的作用是与主轴axis共同定义了约束的局部坐标系。第三个轴会与这两个轴所构成的平面相垂直。 3.3.6 沿XYZ轴平移约束模式 (X\\Y\\Z)Motion (X\\Y\\Z)Motion是表示沿 X、Y 、Z 轴平移约束的模式，根据属性设置的不同，约束的模式也不同。可以设置的值分别是：自由移动Free、锁定移动 Locked、限制性移动 Limited。 自由移动Free就是不作限制的沿某轴移动。 锁定移动 Locked是没有运动，完全固定住。 限制性移动 Limited是平移运动受限于用户定义的约束。 3.3.7 绕XYZ轴旋转的角运动约束模式angular (X\\Y\\Z)Motion angular (X\\Y\\Z)Motion是表示绕X、Y 、Z 轴旋转的角运动约束模式，也是根据自由移动Free、锁定移动 Locked、限制性移动 Limited三种值的设置来区别约束模式，与(X\\Y\\Z)Motion类似，只是运动形式的线性平移和角运动旋转的区别。 3.3.8 弹簧线性限制 （linearLimitSpring、linearDamp） 弹簧力Spring 其中的弹簧力Spring 在LayaAir引擎中对应线性限制的弹簧力linearLimitSpring，如果此处的值设置为零，则无法逾越限制；零以外的值将使限制变得有弹性。 阻尼Damper 其中的阻尼Damper在LayaAir引擎中对应线性阻尼linearDamp，设置为大于零的值可让约束抑制振荡（否则将不断的进行振荡）。 3.3.9 线性移动限制（minLinearLimit、maxLinearLimit、linearBounce） 限制Limit 其中的Limit是从原点到限制位置的距离。在LayaAir引擎中需要分别设置线性移动限制的最小值minLinearLimit和线性移动限制的最大值maxLinearLimit。 反弹力Boundciness 其中的反弹力 Bounciness 是当对象达到限制距离时，要将对象拉回而施加的弹力。在LayaAir引擎中对应线性反弹力linearBounce。 3.3.10 弹簧角运动限制（angularLimitSpring、angularDamp） 弹簧力Spring 其中的弹簧力Spring 在LayaAir引擎中对应角运动旋转限制的弹簧力angularLimitSpring，如果此处的值设置为零，则无法逾越限制；零以外的值将使限制变得有弹性。 阻尼Damper 其中的阻尼Damper在LayaAir引擎中对应角运动旋转阻尼angularDamp，设置为大于零的值可让约束抑制振荡（否则将不断的进行振荡）。 3.3.11 角运动限制（minAngularLimit、maxAngularLimit、angularBounce） 限制Limit 其中的Limit是限制旋转角度，设置对象旋转角度的下限值。在LayaAir引擎中需要分别设置旋转角度限制的最小值minAngularLimit和旋转角度限制的最大值maxAngularLimit。这两个值都是3D向量值。 旋转限制最小值的X对应X轴旋转的下限Low Angular X Limit值，Y对应Y轴旋转的限制Angular Y Limit值取负，Z对应Z轴旋转的限制Angular Z Limit值取负。 旋转限制最大值的X对应X轴旋转的上限Hight Angular X Limit值，Y对应Y轴旋转的限制Angular Y Limit值，Z对应Z轴旋转的限制Angular Z Limit值。 反弹力Boundciness 其中的反弹力 Bounciness 是当对象的旋转达到限制角度时在对象上施加的反弹力矩。在LayaAir引擎中对应角度反弹力矩angularBounce。 四、物理射线 4.1 什么是物理射线 射线的定义是只有一个端点无限延长形成的直的线。LayaAir引擎的数学对象Laya.Ray()就是只有起点和方向的射线。 在LayaAir引擎中，射线常用于基础的碰撞检测，所以具有射线的发射特性，但用于碰撞检测功能的射线称为物理射线。 需要注意的是，射线可以用于物理射线检测，但是物理射线并不等同于射线。 4.2 创建射线 LayaAir引擎提供了创建3D空间射线的类Laya.Ray()，以及通过摄像机从屏幕空间点去生成这个射线的方法viewportPointToRay()。 示例代码如下所示： /* ……省略若干代码 */ //创建一个屏幕点 let point = new Laya.Vector2(); //创建一个射线 Laya.Ray(射线的起点，射线的方向) let ray = new Laya.Ray(new Laya.Vector3(0, 0, 0), new Laya.Vector3(0, 0, 0)); //以鼠标点击的点作为原点 point.x = Laya.stage.mouseX; point.y = Laya.stage.mouseY; //计算一个从屏幕空间生成的射线 _camera.viewportPointToRay(point, ray); /* ……省略若干代码 */ 4.3 使用物理射线 在LayaAir 3D中实现射线检测是使用物理模拟器类PhysicsSimulation。 射线检测的方法有4个，分别为射线检测第一个碰撞物体的方法raycast 和 raycastFromTo以及射线检测所有碰撞物体的方法raycastAll和raycastAllFromTo。 检测一个和所有的区别比较容易理解，就是碰到第一个物体后射线立即结束，和射线可穿透所有碰撞物体一直不结束，这两种区别。如图4-1所示。 （图4-1） 那为什么同样的功能名称还有带FromTo和不带FromTo两种，又有什么区别呢？ 与数学对象的射线所不同的是，用于检测碰撞的物理射线是有长度的，或者是需要设置世界空间的结束位置。 带FromTo的是使用两个点（射线的起始位置点和结束位置点）作为参数。 而不带FromTo的则是直接使用已经创建好的射线，不需要设置射线的结束位置点，但需要设置长度，如果我们不设置长度，则采用默认值长度2147483647。 如果是不带FromTo的射线检测，我们可以沿用上个小节创建射线的示例，稍加补充一下，具体代码如下所示： /* ……省略若干代码 */ //创建一个屏幕点 let point = new Laya.Vector2(); //创建一个射线 Laya.Ray(射线的起点，射线的方向) let ray = new Laya.Ray(new Laya.Vector3(0, 0, 0), new Laya.Vector3(0, 0, 0)); //以鼠标点击的点作为原点 point.x = Laya.stage.mouseX; point.y = Laya.stage.mouseY; //计算一个从屏幕空间生成的射线 _camera.viewportPointToRay(point, ray); //拿到3D场景中射线碰撞的物体 _scene3D.physicsSimulation.rayCastAll(ray,this.outs); //如果射线碰撞到物体 if (this.outs.length !== 0) { for (let i = 0; i 带FromTo的射线检测使用示例，具体代码如下所示： /* ……省略若干代码 */ /*进行射线检测,检测所有碰撞的物体 //_scene3D.physicsSimulation.raycastAllFromTo(this.from, this.to, this.outs); //检测所有物体的射线使用与上个示例类似 */ //进行射线检测,检测第一个碰撞物体 _scene3D.physicsSimulation.raycastFromTo(this.from, this.to, this.out); //将射线碰撞到的物体设置为红色 ((this.out.collider.owner as Laya.MeshSprite3D).meshRenderer.sharedMaterial as Laya.BlinnPhongMaterial).albedoColor = new Laya.Vector4(1.0, 0.0, 0.0, 1.0); /* ……省略若干代码 */ 4.4 使用异形物理射线 常规的物理射线是用一条射线来检测碰撞，LayaAir引擎中也提供了与物理射线检测类似的功能，但采用的是自定义碰撞器形状检测来代替物理射线，相当于异形的射线检测功能。 与普通的射线检测一样，异形射线也是有检测第一个和检测所有两个检测方法，分别是shapeCast和shapeCastAll。 （图4-2） 图4-2的示例，就采用球形射线来实现碰撞检测，具体代码如下所示： //创建球型碰撞器 var sphereCollider:Laya.SphereColliderShape = new Laya.SphereColliderShape(0.5); //通过按钮this.castAll状态切换是采用检测全部还是检测第一个 if (this.castAll) { //采用球形碰撞器进行形状检测,检测所有碰撞的物体 this.scene.physicsSimulation.shapeCastAll(sphereCollider, this.from, this.to, this.outs); for (let i = 0; i 4.5 设置射线碰撞组 无论是普通射线还是异形射线，都可以设置碰撞组，以及指定射线可碰撞的组。 如何设置碰撞组值collisonGroup和如何指定可发生碰撞的组值canCollideWith在前文中已经介绍过， 我们将值带入射线检测对应的方法即可实现射线的选择性碰撞。 射线检测里用于指定检测碰撞组的参数collisionMask对应的是前文介绍的canCollideWith 五、其它物理引擎的使用 之前的章节一直在介绍LayaAir基于Bullet物理引擎封装的物理引擎API。Bullet虽然强大，但是有些开发者对于物理精度要求不高，物理功能的使用也比较基础，只对物理引擎库的体积有要求，比如Cannon物理引擎库，其体积只有不足200k。目前LayaAir3.0的物理引擎接口正在改进中，以支持更多的第三方物理引擎，因此Cannon物理引擎暂时从IDE中删除，等后续改进完将会告知开发者。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:48 "},"IDE/particleEditor/readme.html":{"url":"IDE/particleEditor/readme.html","title":"3D粒子编辑模块","keywords":"","body":"3D粒子编辑器一、3D粒子编辑器基础什么是3D粒子火焰效果展示二、LayaAir引擎中创建3D粒子三、3D粒子的使用3D粒子的使用由三部分构成粒子系统组件粒子渲染模块粒子着色器3.1 粒子系统组件 ParticleSystem3.2 粒子渲染模块 ShurikenParticleRenderer3.3 粒子着色器 PARTICLESHURIKEN四、火焰效果制作示例五、应用场景及代码示例5.1 自定义Particle3D类5.2 自定义对象池类5.3 代码调用3D粒子编辑器 一、3D粒子编辑器基础 什么是3D粒子 在百科中，粒子是指能够以自由状态存在的最小物质组成部分。 在LayaAir引擎中，3D粒子系统中的粒子可用于模拟中烟、雾、水、火、雨、雪、流光等非固定形态的自然现象。而上述这些自然物体的形态由于没有固定的形态，所以不能用固定的模型来模拟实现，需要用多个模型组合成一个完整的视觉效果，而3D粒子正是组合效果的最小单元，但需要注意的是，粒子并非是三维模型，而是面片模型。 火焰效果展示 （动图1） 二、LayaAir引擎中创建3D粒子 2.1 粒子节点 在场景中的Scene3D节点下，可以通过鼠标右键来创建3D粒子 （图2.1.1-1） 默认粒子系统添加完成效果 （动图2） 2.2 预制体 如果考虑到3D粒子是需要复用的，建议使用预制体，在Assets下创建预制体，双击打开预制体后，在Sprite3D节点下通过鼠标右键来创建3D粒子 （图2.1.2） 三、3D粒子的使用 3D粒子的使用由三部分构成 粒子系统组件 粒子渲染模块 粒子着色器 （图3.0）从图3.0中看到，当创建一个3D粒子后，会自动添加这三个组件，下面我们来详细了解各系统的使用 3.1 粒子系统组件 ParticleSystem 粒子系统是LayaAir引擎特效表现的基础，通常粒子系统在三维空间中的位置与运动是由发射器控制的。发射器主要由一组粒子行为参数以及在三维空间中的位置所表示。粒子行为参数可以包括粒子生成速度（即单位时间粒子生成的数目）、粒子初始速度向量（例如什么时候向什么方向运动）、粒子寿命（经过多长时间粒子湮灭）、粒子颜色、在粒子生命周期中的变化以及其它参数等等。 粒子系统组件分类 在LayaAir编辑器中，粒子系统组件由五个部分构成 （图3.1） 3.1.1 基础面板 General 默认的是粒子系统的通用模块，用于设置粒子系统的基础性的设置。此模块为固有模块，不可禁用。该模块定义了粒子初始化时的持续时间、循环方式、发射速度、大小等一些列基本的参数。 （图3.1.1-1） Duration：粒子系统不断发射粒子的持续时间，或者说一个周期时间内可以发射多次粒子，到达设置的时间后，粒子停止发射 ​ 注意：不是一个粒子的生命周期时间，下面会介绍一个粒子的生命周期时间 （动图3）Duration为5的效果，5秒到达时，粒子不在发射，同时Loop要设为不启动 Loop：如果启用，粒子系统在上述持续时间结束时，再次启动并继续重复循环 Play On Awake：如果启用，粒子系统会在创建对象时自动启动 Start Delay：启用后系统开始发射前的延迟时间，可选择两种延迟方式 Constant 固定时间 Random Between Two Constant 从最小到最大两个时间中随机取值 （动图4）展示了使用最小2到最大5秒随机的方式，可以看到当第4秒时，粒子开始发射 Start Lifetime：控制每个粒子的生命周期，也就是粒子发生多长时间后消失，它可以是两个数字之间的随机值 （动图5）展示了使用Start Lifetime为3时的效果，显示每个粒子从发射出生到消失用时3秒 Start Speed：每个粒子在适当方向上的初始速度，可选择两种延迟方式 Constant 固定值 Random Between Two Constant 从最小到最大中随机取值 ​ 动图5中展示了使用Start Speed为5时的速度效果 Start Size：每个粒子的初始大小，如果想分别控制每个轴的大小，请启用3D选项。可选择两种延迟方式 Constant 固定值 Random Between Two Constant 从最小到最大中随机取值 （图3.1.1-2） 展示了Start Size在1和5之间随机，可以看到左边粒子有大有小 ​ 注意：粒子的大小与它所使用的贴图大小是无关的，一个100像素的贴图与一个500像素的贴图绘制出来的同种粒子几乎差不多大，由此可见，StartSize规定了这个粒子的直径，而不是贴图缩放 Start Rotation：每个粒子的初始旋转角度。如果您想分别控制每个轴的旋转，请启用3D选项。可选择两种延迟方式 Constant 固定值 Random Between Two Constant 从最小到最大中随机取值 （图3.1.1-3） 展示了Start Rotation在1和360之间随机，可以看到左边粒子有各个方向的旋转 Start Color：每个粒子的初始颜色 （图3.1.1-4） 展示了Start Color为红色的效果 注意，即便在StartColor中规定了粒子为红色，显示出来的效果也不是纯红色，粒子与粒子，天空，红色方块叠加的地方都变成了不一样的颜色，这是因为画面的最终显示效果是由着色器调控的，我们在设置粒子材质的时候，选择的RenderingMode为Additive(叠加的)，所以最终显示效果会受到粒子背后传来的光的影响从而发生变色。可以尝试选择不同的着色器选项观察变化 （图3.1.1-5） 展示了RenderingMode为Additive的效果 Gravity Modifier：设置物理重力值。零值会关闭重力 （动图6）展示了使用Gravity Modifier为5时的效果 Simulation Space：控制粒子是否跟随粒子发射器移动 ​ Local：粒子生成后跟随粒子发射器坐标的移动而移动，这个模式下，粒子发射器的移动会表现在每个粒子上。 ​ World：粒子生成后不跟随粒子发射器，直接在世界坐标系中移动。 Simulation Speed：调整整个粒子系统更新的速度 Scale Mode：控制粒子的缩放模式 ​ Hierarchy：同时受自己与父节点的缩放影响 ​ Local：只受自己的影响 ​ World：不收影响 Max Particles：一次系统中的最大粒子数。如果达到限制，则会移除一些粒子。如果设置为1，则粒子系统会一个一个发射粒子 Auto Random Seed：自动粒子随机种子，启用后每次播放都会有不同。去掉勾选后，可以填随机种子的数值，不同的数值，发射粒子的表现略有不同 3.1.2 发射模块 Emission 该模块是粒子系统组件的一部分，用来指定发射粒子的属性。当创建新的粒子系统时，Emission 模块会默认启用。 （图3.1.2） Enable：是否启用 Rate over Time：每秒发射的粒子数 Rate over Distance 每个移动距离单位发射的粒子数，此模式对于模拟实际由对象运动产生的粒子非常有用（例如，泥路上车轮留下的尘土） Bursts：爆发是产生粒子的事件。这些设置允许在指定时间发射粒子。可以设置多组爆发点，分别修改时间，最小粒子数，最大粒子数 （动图7）展示了使用Rate Over Time为5，每秒发射5个粒子，同时使用一组Bursts，在第3秒时，突然发射30个粒子 3.1.3 形状模块 Shape 该模块定义了发射粒子的体积或表面，以及起始速度的方向。 （图3.1.3-1） Shape Type：形状的选择会影响可以发射粒子的区域，还会影响粒子的初始方向。例如，一个Sphere向各个方向向外发射粒子，一个Cone发射一个发散的粒子流。 1，Sphere ：球，可以向四面八方发射粒子 Radius：半径 Emit from shell：根据壳发射 Randomize Direction：随机化方向 （动图8）展示了使用球形，半径是3，从球体的边缘发射 2，Hemisphere：半球形状 Radius：半径 Emit from shell：根据壳发射 Randomize Direction：随机化方向 （图3.1.3-2） 3，cone：锥形，让粒子像手电筒的光一样从一点开始向一个圆型扇出 Angle DEG：形状的圆形方面的角度 Radius：半径 Length：长度 Emit from：发射方式 Base：基于锥形底部 Base Shell：基于锥形底部壳 Volume：基于锥形内部 Volume Shell：基于锥形内部壳 Randomize Direction：随机化方向 （动图9）展示了使用锥形，半径是2，锥形长度是6，从锥形内部发射 4，Box：盒子形，可以让所有粒子向单一方向发射，可以很好的模拟雨雪类粒子效果 Length：XYZ各个方向的长度 Randomize Direction：随机化方向 （图3.1.3-3） 5，circle：环形 Radius：半径 Angle DEG：环形的角度 Emit From Edge：基于边缘发射 Randomize Direction：随机化方向 （图3.1.3-4） 3.1.4 生命周期Lifetime 该模块定义了发射出的粒子的生命周期内的属性 （图3.1.4） 1，Velocity over Lifetime：生命周期中的速度 Constant：常数模式，速度是恒定的 Curve：曲线模式 Random from two Constant：随机速度模式 Random between two Curve：在两个曲线中随机取值 Space：空间 Local：模型空间 World：世界空间 2，Color over Lifetime：生命周期中的颜色 Constant：常数模式，颜色是恒定的 Gradient：梯度模式 Random from two Constant：随机两个颜色模式 Random between two Gradient：在两个梯度中随机取值 3，Size over Lifetime：生命周期中的大小 Separate Axes：按轴分离 Curve：曲线模式 Random Between Two Contants：在两个常数中随机取值 Random between two Curve：在两个曲线中随机取值 4，Rotation over Lifetime：生命周期中的旋转 Separate Axes：按轴分离 Constant：常数 Curve：曲线模式 Random Between Two Contants：在两个常数中随机取值 Random between two Curve：在两个曲线中随机取值 3.1.5 纹理动画 Texture Sheet 用来播放粒子动画的模块，粒子动画的原材料是一种纹理，它包含了一组帧动画，能够以动画方式渲染粒子。 帧动画：使用多张图片，每张图片为一帧，构成一个完整的动画叫帧动画。或一张大图片，图片中包含了一个动画的所有帧的图片 （图3.1.5-1） （图3.1.5-2） 目前LayaAir采用网格模式（Grid） Tiles：纹理在 X（水平）和 Y（垂直）方向上划分的图块数量 Animation：动画模式可以设置为整张或单行（即，每行代表一个单独的动画序列） Frame：设置帧 ​ Type：帧类型 ​ Constant：固定帧数 ​ Curve：一条曲线，指定动画帧如何随着时间的推移而增加。 ​ Random Between two constant：两个固定帧数之间随机 ​ Random Between two curve：两个曲线之间随机 Start Frame：起始帧，允许您指定粒子动画应该从哪一帧开始 Cycles：动画序列在粒子生命周期内重复的次数 （图3.1.5-3）第四节火焰示例中会介绍使用过程 3.2 粒子渲染模块 ShurikenParticleRenderer 渲染器模块的设置决定了一个粒子的图像，模型，如何被其它粒子变换、着色和过度绘制。 （图3.2） Receive Shadows：决定此系统中的粒子是否可以接收来自其它来源的阴影。只有不透明的材质才能接收阴影。 Cast Shadows：如果启用此属性，粒子系统会在投射阴影的灯光照射时创建阴影。 Scale In Lightmap：调整特定物体在最终LightMap中的像素密度。 Materials：用来渲染粒子的材质 Render Mode：如何从图形图像（或网格）生成渲染图像。 1，Billboard：将粒子渲染为广告牌，永远面向摄像机 2，Stretched Billboard：粒子面向摄像机的同时，允许使用粒子缩放 Speed Scale： 根据粒子速度设置长度 Length Scale ：通过比较粒子的宽度决定粒子的长度 3，Horizontal Billboard：粒子平面平行于XZ底平面 4，Vertical Billboard：粒子在Y轴上是直立的，但是面向相机 5，Mesh：粒子是从3D网格而不是纹理渲染的 （动图） Sorting Fudge：排序校正，使用这个将影响绘画顺序。粒子系统带有更低Sorting Fudge值，更有可能被最后绘制，从而显示在透明物体和其他粒子系统的前面 3.3 粒子着色器 PARTICLESHURIKEN 在材质中选择Laya的particle，可以添加Laya内置的粒子着色器（PARTICLESHURIKEN），其可渲染各种粒子系统 效果。所有的粒子都是用使用的这个材质。 （图3.3） Color：指定粒子的颜色。 Texture：指定粒子使用的纹理贴图 Alpha Test Value：透明测试开启时，当前像素根据设定条件决定是否输出颜色 Tiling Offset：获取纹理平铺和偏移 Material Render Mode：设置渲染模式 ​ Opaque：默认设置，适用于没有透明区域的普通实体对象。 ​ Cutout：允许创建在不透明和透明区域之间具有硬边的透明效果。在此模式下，没有半透明区域，纹理要么 100% 不透明，要么不可见。这在使用透明度来创建材料的形状（例如树叶或带孔和破烂的布）时很有用。 ​ Transparent： 适用于渲染逼真的透明材质，例如透明塑料或玻璃。在此模式下，材质本身将采用透明度值（基于纹理的 Alpha 通道和色调颜色的 Alpha），但反射和照明高光将在完全清晰的情况下保持可见，就像真正的透明材质一样。 ​ Additive： 叠加方式 ​ AlphaBlended： 透明混合方式 Cull：剔除方式 四、火焰效果制作示例 4.1 创建火焰预制体 （图4.1） 在Scene3D场景下，点击鼠标右键，选择创建Effects->Particle3D 默认创建一个3D粒子系统，命名为FireEffect，拖到Assets->Prefab目录下，创建好预制体 4.2 火焰序列帧动画 （图4.2） 准备好火焰序列帧动画贴图文件，放到Assets目录下，点击贴图，勾选sRGB和Alpha Channel，TextureType依然为Default，点击Apply按钮，确保修改成功 4.3 设置火焰材质 （图4.3） 在Assets下创建一个材质，命名为FlameRoundYellowParticle，Shader使用Laya.Particle，基本上所有的粒子特效都使用此Shader。Color设置为191,191,191,255，texture选择上面添加的贴图，Material Render Mode选择ADDITIVE方式 4.4 设置粒子系统渲染模块 （图4.4-1） 创建粒子系统后，Inspector面板中默认会添加ShurikenParticleRenderer组件，选择FlameRoundYellowParticle材质 （图4.4-2） 在Scene窗口中，可以看到粒子效果已经换成贴图，需要进一步设置贴图动画 4.5 使用贴图动画 （图4.5-1） 在粒子系统的TextureSheet中，创建一个Instance，由于火焰贴图的组成方式为10x5，此时修改Tiles为X：10，Y：5。修改后粒子系统贴图变为火焰效果，但是依然是静态图，下面来修改Frame帧动画，修改Frame->Type为Curve，点击Curve打开面板，横轴为时间线，纵轴为帧动画的帧数，我们希望的效果是1秒中火焰帧动画循环播放一遍，也就是从0到50帧，那么我们修改Curve为下图 （图4.5-2） 完成Curve后，再看火焰效果已经可以播放帧动画 （动图10） 4.6 设置基础属性 （图4.6） Start Speed的Constant为0，火焰发射时的初始速度为0，Start Size的Constant为2，放大2倍火焰的尺寸，Simulation Speed为2，可以加快火焰播放的速度 4.7 设置发射器 （图4.7） 修改每单位时间发射的粒子数为5，相当于每秒中会燃烧5个火焰 4.8 设置形状模块 （图4.8） 我们希望粒子在一个圆形内发射，可以达到火焰聚集燃烧效果 4.9 设置粒子生命周期 （图4.9-1） 最重要一环为设置粒子生命周期，首先设置火焰生命周期内颜色的过程，创建Color Over Lifetime实例，Type设置为Gradient梯度变化曲线，打开Gradient面板，上面3个箭头向下的指示标表明颜色的透明度从 0%的不透明->80%的不透明->100%的全透明，下面的2个箭头向上的指示标表明颜色的区间变化从c99451到ff4500 （图4.9-2） 由于火焰是粒子向上运动到消失，创建Velocity Over Lifetime实例，选择Curve曲线，只需要修改Y轴的位移为1秒钟从0到1，向上移动1个单位 （图4.9-3） 由于火焰是会尺寸上有缩小的过程，创建Size Over Lifetime实例，选择Curve曲线，只需要修改0.5秒时间内，Size从1到0.5，缩小一倍 （动图11） 此时在Scene窗口中看到，火焰效果已制作完成 五、应用场景及代码示例 往往在游戏的战斗过程中，需要大量创建粒子，那么需要用到对象池。对象池优化是游戏开发中非常重要的优化方式，也是影响游戏性能的重要因素之一。在游戏中有许多对象在不停的创建与移除，比如角色攻击子弹、特效的创建与移除，NPC的被消灭与刷新等，在创建过程中非常消耗性能，特别是数量多的情况下。对象池技术能很好解决以上问题，在对象移除消失的时候回收到对象池，需要新对象的时候直接从对象池中取出使用。优点是减少了实例化对象时的开销，且能让对象反复使用，减少了新内存分配与垃圾回收器运行的机会。 注意：对象移除时并不是立即从内存中抹去，只有认为内存不足时，才会使用垃圾回收机制清空，清空时很耗内存，很可能就会造成卡顿现象。用了对象池后将减少程序的垃圾对象，有效的提高程序的运行速度和稳定性。 5.1 自定义Particle3D类 import Node = Laya.Node; import Sprite3D = Laya.Sprite3D; import ShuriKenParticle3D = Laya.ShuriKenParticle3D; import ShurikenParticleSystem = Laya.ShurikenParticleSystem; import { Pool } from \"./Pool\"; //粒子特效的基类，包括创建，播放，暂停，销毁，清理对象池 export class Particle3D extends Sprite3D { private _isInited: boolean = false; private _filePath: string = null; private _particle: Laya.Sprite = null; private _shuriKenParticle3D: Array= []; private _shurikenParticleSystem: Array= []; constructor() { super(); } //通过传入粒子特效的路径，创建一个粒子特效，从对象池里拿一个 static Create(path: string): Particle3D { var ret:Particle3D = Pool.getInstance().getItemByClass(\"Particle3D@\" + path, Particle3D); ret.Init(path); return ret; } //粒子特效初始化 private Init(file_path:string): void { if (this._isInited) { return; } this._filePath = file_path; console.log(\"Particle3D\"); //从拿到的粒子系统克隆一个 var res = Laya.loader.getRes(file_path); var particle = res.clone(); this._particle = particle; //获取这个粒子特效的所有粒子系统，用于后面整体播放 for (var i = 0, len = this._particle.numChildren; i 5.2 自定义对象池类 export class Pool { private _poolDic:{[key: string]: any;} = {}; private InPoolSign: string = \"__InPool\"; constructor() { } private static _instance: Pool = new Pool(); public static getInstance() { return this._instance; } //通过名字找到对应的对象池 getPoolBySign(sign:string): any { return this._poolDic[sign] || (this._poolDic[sign] = []); }; //回收 recover(sign:string, item:any): void { item[\"__InPool\"] = true; }; //通过名字获得一个对象，如果对象池内没有对象，则创建一个 getItemByClass(sign:string, cls:any): any { var ret = null; var pool = this.getPoolBySign(sign); for (var i = 0, len = pool.length; i 5.3 代码调用 const { regClass, property } = Laya; import { Particle3D } from \"./Particle3D\"; @regClass() export class Main extends Laya.Script { //粒子特效的路径 private filePath = \"FireEffect\"; onStart() { console.log(\"Game start\"); //加载粒子特效资源 Laya.loader.load(this.filePath, Handler.create(this, () => { })); } //每次鼠标点下屏幕后，会创建一个特效 mouseDown(e: Event): void { var particle = Particle3D.Create(this.filePath); this.owner.addChild(particle); } //鼠标抬起后，会释放对象池 mouseUp(e: Event): void { Particle3D.ClearPool(this.filePath); } } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:48 "},"IDE/materialEditor/readme.html":{"url":"IDE/materialEditor/readme.html","title":"材质编辑模块","keywords":"","body":"IDE的材质属性1、材质的创建2、材质面板2.1 材质基础属性2.1.1 BlinnPhong 着色器2.1.2 Unlit 着色器2.1.3 PBR 着色器2.1.4 Particle 着色器2.1.5 Trail着色器2.1.6 SkyBox着色器2.1.7 SkyPanoamic 着色器2.1.8 SkyProcedural 着色器2.2 材质效果展示2.2.1 切换不同mesh的材质2.2.2 关闭灯光效果3、材质的使用IDE的材质属性 为了将场景中的物体绘制出来，我们需要描述物体的形状与外表，我们使用mesh来表示物体的形状，使用材质来表示物体的外表。材质与着色器是紧密相连的，我们使用的材质必须设置对应的着色器形式。 1、材质的创建 我们可以在IDE的项目面板内创建材质，创建材质操作如动图1-1所示： 动图1-1 我们创建一个材质，并将其命名为\"myMaterial\"。 2、材质面板 创建完材质之后我们看到右侧的Inspector面板上会出现新的属性说明，当我们选中创建的材质后，属性面板便会显示当前材质的属性内容，属性面板主要由材质基础属性与材质效果展示两部分组成，如图2-1所示，我们详细说明下材质属性面板的组成。 图2-1 2.1 材质基础属性 材质是根据不同的着色器模型来描述不同表面的，IDE内置了八种着色器类型，我们根据着色器类型来说明每种着色器对应材质的基础属性，切换材质的着色器是通过选择材质的Shader来实现的，具体操作图动图2-1-1所示，来切换到其他类型的着色器。 动图2-1-1 2.1.1 BlinnPhong 着色器 Blinn-Phong光照模型能够简单描述物体表面对光的吸收与反射，使物体表面呈现不同的明暗程度，主要描述物体表面的高光、漫反射光与环境光部分。 （1） VertexColor顶点颜色 是否支持顶点颜色的宏定义开关，开启后可以叠加mesh的顶点颜色内容。 （2） AlbedoTexture漫反射贴图 可以设置材质的漫反射贴图的内容，示例使用一个砖块的贴图，效果如动图2-1-1-2-1所示： 动图2-1-1-2-1 （3） AlbedoColor漫反射颜色 可以设置材质的整体漫反射颜色，如动图2-1-1-3所示： 动图2-1-1-3 （4） AlbedoIntensity 设置漫反射颜色的强度。 （5） SpecularTexture高光贴图 用来设置物体表面的高光镜面反射，根据物体当前顶点的uv在高光贴图上的rgb数值来反映物体当前顶点的光滑反射程度，如图2-1-1-5-1与图2-1-1-5-2所示： 图2-1-1-5-1 图2-1-1-5-2 在设置高光贴图前后，可以明显看到由于高光贴图的影响，只对墙壁的部分内容产生了高光效果，这样可以用来模拟不同的材质不同位置的高光现象。 （6） SpecularColor高光颜色 可以设置高光部分的颜色，如图2-1-1-6所示，将高光颜色设置为了绿色： 图2-1-1-6 （7） Shininess光泽度 用来设置高光的范围，效果如图2-1-1-7-1与2-1-1-7-2在不同的光泽度下的对比： 图2-1-1-7-1 图2-1-1-7-2 在shininess值较小的时候，整体的高光范围较大；当shininess值较大的时候，整体的高光范围较小。 （8）NormalTexture法线贴图 用来设置物体模型在切线空间下的法线，用于光照的计算，需要模型带有切线数据。 如图2-1-1-8-1与图2-1-1-8-2所示，在法线贴图参与下的光照与着色更为真实。 图2-1-1-8-1 图2-1-1-8-2 可见在添加了法线贴图之后，光照重新进行了计算，物体的表面也有了凹凸感更为真实。 （9）AlphaTestValue alpha测试值 这个需要配合材质的渲染模式为CUTOUT来使用，在CUTOUT模式下，当前顶点的片元颜色值的alpha小于AlphaTestValue时，这个片元的值会被直接丢弃，不进行渲染，我们使用一张蛛网的图作为漫反射贴图，通过调整AlphaTestValue的值来查看这个值的效果。蛛网图如2-1-1-9-1所示，AlphaTestValue的值如动图2-1-1-9-2所示： 图2-1-1-9-1 镂空部分的alpha通道值为0 动图2-1-1-9-2 可以看到随着值的变大，舍弃的片元原来越多，直到所有的片元都被丢弃不渲染。 （10）TilingOffset缩放偏移 可以设置物体模型uv的缩放与偏移，来实现采样AlbedoTexture的不同效果，如动图2-1-1-10所示： 动图2-1-1-10 （11）MaterialRenderMode材质渲染模式 OPAQUE：不透明模式，遮挡在物体后面的模型不会渲染出来。 CUTOUT：剔除模式，会根据albedo贴图的alpha值与AlphaTestValue的值来舍弃部分片元。 TRANSPARENT：透明模式，会与后面的物体混合来透明效果。 ADDITIVE：叠加模式，会叠加物体后面的像素 ALPHABLENDED：与透明模式相同的混合方式，与透明模式的区别是不会混合场景中的雾。 （12）RenderQueue渲染队列 可以用来设置材质着色器的渲染队列，RenderQuere越大的话，其渲染越靠后。一般设置材质的渲染模式之后会根据渲染模式来设置渲染队列。 OPAQUE模式对应的队列为2000； CUTOUT模式对应的队列为2450； TRANSPARENT模式对应的队列为3000； ADDITIVE模式对应的队列为3000； ALPHABLENDED模式对应的队列为3000； （13）Cull剔除模式 根据面顶点的不同连接顺序（顺时针或是逆时针）来进行剔除。 Off：关闭剔除 Back：剔除背面 Front：剔除前面 2.1.2 Unlit 着色器 Unlit着色器是不受光的材质，不会受到光照的影响，只靠材质的贴图与颜色来表现物体的表面效果。 （1）VertexColor顶点颜色 是否应用顶点颜色，开启此宏定义后会叠加模型顶点颜色。 （2）Texture贴图 设置用来描述物体描边颜色的贴图，如图2-1-2-2-1与图2-1-2-2-2所示，在设置贴图之后，物体表面根据uv来显示对应贴图部位的颜色，且能看到在场景中存在光的情况下，不会收到光照的影响。 图2-1-2-2-1 图2-1-2-2-2 （3）AlbedoColor漫反射颜色 同样AlbedoColor能够叠加颜色到物体表面，如图2-1-2-3-1所示，我们叠加一个红色到物体表面： 图2-1-2-3-1 （4）AlphaTestValue alpha测试值 这个同样也是需要在渲染模式为CUTOUT的模式下才生效，并配合使用，与Blinn-Phong着色器相同，也是通过判断当前顶点片元的alpha值与设置的AlphaTestValue的值大小，小于AlphaTestValue的值的都会被丢弃不进行渲染，我们还是使用上面Blinn-Phong着色器使用的蛛网贴图，来看下不同alphaTestValue的值的处理，如动图2-1-2-4-1所示： 动图2-1-2-4-1 可以看到与Blinn-Phong不同的是Unlit的alpha值会叠加AlbedoColor.a的值，我们的AlbedoColor的alpha为1.0，此时不会出现全部的片段都被丢弃的情况。 （5）TilingOffset缩放偏移 用来设置物体模型UV的缩放与偏移，与Blinn-Phong着色器的效果相同，如动图2-1-2-5-1所示： 动图2-1-2-5-1 （6）MaterialRenderMode 材质渲染模式 OPAQUE：不透明模式，遮挡在物体后面的模型不会渲染出来。 CUTOUT：剔除模式，会根据albedo贴图的alpha值与AlphaTestValue的值来舍弃部分片元。 TRANSPARENT：透明模式，会与后面的物体混合来透明效果。 ADDITIVE：叠加模式，会叠加物体后面的像素。 ALPHABLENDED：与透明模式相同的混合方式，与透明模式的区别是不会混合场景中的雾。 （7）RenderQueue 渲染队列 可以用来设置材质着色器的渲染队列，RenderQuere越大的话，其渲染越靠后。一般设置材质的渲染模式之后会根据渲染模式来设置渲染队列。 OPAQUE模式对应的队列为2000； CUTOUT模式对应的队列为2450； TRANSPARENT模式对应的队列为3000； ADDITIVE模式对应的队列为3000； ALPHABLENDED模式对应的队列为3000； （8）Cull 剔除模式 根据面顶点的不同连接顺序（顺时针或是逆时针）来进行剔除。 Off：关闭剔除 Back：剔除背面 Front：剔除前面 如何用unlit通过改设置，达到原来2.0引擎的effect材质效果 将MaterialRenderMode 材质渲染模式改成 addtive 或者 blend 模式，不排除颜色空间的话效果是一样的，3.0的颜色空间已经变成linear了 2.1.3 PBR 着色器 PBR材质是一种基于物理的渲染材质，可以提供灯光与曲面交互方式的精确表示，可以更为真实的描述物体表面性质。我们使用基于图像照明(IBL)的光照模式来更好的展示PBR的属性，我们需要将场景的环境光来源从SolidColor转化成球谐，并点击下面的GenerateLighing生成一个IBL的立方体贴图CubeMap，如图2-1-3-1所示： 图2-1-3-1 （1）AlbedoTexture漫反射贴图 为了设置物体表面材质的整体纹理，同样使用上面的墙体作为贴图，如图2-1-3-1-1与图2-1-3-1-2所示，设置AlbedoTexture的效果： 图2-1-3-1-1 图2-1-3-1-2 （2）AlbedoColor漫反射颜色 可以叠加一个整体的颜色到物体的表面上，如图2-1-3-2-1所示我们叠加一个黄色到材质上： 图2-1-3-2-1 （3）Metallic金属度 用来设置物体的表面金属光泽度的效果，一般我们使用使用0与1来设置物体的金属度，完全没有或者完全存在，当金属度为1时，能够反射出周围环境的内容。想象下当我们看向一个表面光滑的金属球时，它会反射出我们的脸。这样在IDE内我们已经设置了基于IBL的球谐立方体贴图作为环境光，当我们将材质的金属度越来越接近1时，物体表面会反射出周围环境的内容，同时我们将光滑度设置为1，这样能够更清楚的看到效果，如动图2-1-3-3-1所示： 动图2-1-3-3-1 当我们调节材质的金属度向1滑动时，能够看到物体表面渐渐反射了周围环境的内容，当金属度为1时，能够完全反射周围的环境。 （4）Smoothness光滑度 用来设置物体表面的光滑度，光滑度为0时，物体表面的漫反射明显，高光不足，光滑度为1时，高光部分更为明显。如动图2-1-3-4-1所示： 动图2-1-3-4-1 （5）SmoothnessSource光滑度来源 可以设置两个光滑度来源，分别从AlbedoTexture的alpha通道去获取、从MetallicGloassTexture的alpha通道去获取。实际上是将物体表面材质的光滑度映射到AlbedoTexture贴图的alpha通道、或者映射到MetallicGloass贴图的alpha通道上，这样可以根据物体每个顶点的光滑度来进行光照计算。 AlbedoTextureAlpha：从Albedo贴图的alpha通道来获取物体的表面光滑度。 MetallicGloassTextureAlpha：从MetallicGloass贴图的alpha通道来获取物体的表面光滑度。 （6）SmoothnessTextureScale光滑度贴图缩放值 当设置了从贴图的alpha通道来获取光滑度值时，可以通过设置这个缩放值来控制贴图alpha通道下的整体光滑值。我们设置光滑度来源为albedoTexture的alpha值，并使用上面的蛛网贴图作为albedo贴图，如动图2-1-3-6-1所示： 动图2-1-3-6-1 （7）NormalTexture法线贴图 设置物体的法线贴图，会根据物体法线贴图来计算光照，如图2-1-3-7-1与图2-1-3-7-2所示，设置法线贴图后，光照的高光部分与漫反射部分重新计算了： 图2-1-3-7-1 图2-1-3-7-2 （8）OcclusionTexture遮蔽贴图 通过采样Occlusion贴图的g通道，可以设置模型顶点的AO环境光遮蔽的值，这样在进行PBR的光照计算时，能够更为真实的模拟在细小接缝等位置的光照数值。 （9）OcclusionTextureStrength遮蔽贴图强度 用来调整遮蔽贴图的强度。强度为0时，整体的遮蔽值为1；强度为1时，采用遮蔽贴图的遮蔽值。 （10）Emission自发光 用来设置模型的自发光是否开启，再开启后会新增两个自发光的参数，分别是EmissionColor与EmissionTexture； EmissionColor自发光颜色 叠加的整体的自发光颜色，在漫反射部分会更为明显，如图2-1-3-10-1所示，叠加一个红色的自发光颜色： 图2-1-3-10-1 EmissionTexture自发光贴图 设置自发光贴图可以根据模型来对不同的顶点位置叠加上面设置的自发光颜色，如图2-1-3-10-2所示： 图2-1-3-10-2 （11）EmissionIntensity自发光强度 设置自发光颜色的强度，强度为0没有自发光效果；强度为1时叠加设置的自发光颜色。 （12）MetallicGlossTexture金属光滑贴图 可以设置存放物体表面材质金属度与光滑度的贴图，贴图的r通道存放模型材质的金属度信息，贴图的a通道存放模型材质的光滑度信息，下面我们使用一张纯黑与纯白的贴图来展示金属光滑度贴图对PBR材质的影响，如图2-1-3-12-1与图2-1-3-12-2所示： 图2-1-3-12-1 图2-1-3-12-2 图2-1-3-12-1中纯黑图的金属度与光滑度为0，基本只有立方体贴图的漫反射效果，图2-1-3-12-2中纯白图的金属度与光滑度为1，能够很好的反射周围的立体环境光内容。 （13）AlphaTestValue alpha测试值 同样是需要配合渲染模式为CUTOUT模式来使用，会根据AlbedoTexture与AlbedoColor的alpha叠加值来进行测试，小于AlphaTestValue值得片元会丢弃不进行渲染。 （14）TilingOffset 与Blinn-Phong和Unlit的效果相同，可以用来设置模型uv缩放与偏移值，实现对Albedo贴图不同位置的采样。 （15）MaterialRenderMode材质渲染模式 OPAQUE：不透明模式，遮挡在物体后面的模型不会渲染出来。 CUTOUT：剔除模式，会根据albedo贴图的alpha值与AlphaTestValue的值来舍弃部分片元。 TRANSPARENT：透明模式，会与后面的物体混合来透明效果。 ADDITIVE：叠加模式，会叠加物体后面的像素 ALPHABLENDED：与透明模式相同的混合方式，与透明模式的区别是不会混合场景中的雾。 （16）RenderQueue渲染队列 可以用来设置材质着色器的渲染队列，RenderQuere越大的话，其渲染越靠后。一般设置材质的渲染模式之后会根据渲染模式来设置渲染队列。 OPAQUE模式对应的队列为2000； CUTOUT模式对应的队列为2450； TRANSPARENT模式对应的队列为3000； ADDITIVE模式对应的队列为3000； ALPHABLENDED模式对应的队列为3000； （17）Cull剔除模式 根据面顶点的不同连接顺序（顺时针或是逆时针）来进行剔除。 Off：关闭剔除 Back：剔除背面 Front：剔除前面 2.1.4 Particle 着色器 粒子着色器用来设置粒子的表面显示，主要用于粒子特效中。我们需要在场景中创建一个粒子系统，如动图2-1-4-1所示： 动图2-1-4-1 同时需要将材质赋值给粒子系统，如动图2-1-4-2所示： 动图2-1-4-2 这样就将材质赋值给粒子系统来使用了，下面简单说下各个参数的作用。 （1）Color粒子颜色 用来设置粒子材质的颜色，如图2-1-4-1-1所示，我们设置为红色的粒子颜色，粒子系统此时发出的粒子变为红色： 图2-1-4-1-1 （2）Texture贴图 用来设置粒子的纹理样式，如图2-1-4-2-1所示： 图2-1-4-2-1 （3）AlphaTestValue alpha测试值 粒子着色器上的CUTOUT模式无效，alpha测试值不用设置。 （4）TilingOffset 与Blinn-Phong和Unlit得效果相同，可以用来设置模型得uv缩放与偏移值，实现对Albedo贴图不同效果的采样。 （5）MaterialRenderMode材质渲染模式 OPAQUE：不透明模式，遮挡在物体后面的模型不会渲染出来。 CUTOUT：粒子着色器下无效。 TRANSPARENT：透明模式，会与后面的物体混合来透明效果。 ADDITIVE：叠加模式，会叠加物体后面的像素 ALPHABLENDED：与透明模式相同的混合方式，与透明模式的区别是不会混合场景中的雾。 （6）RenderQueue渲染队列 可以用来设置材质着色器的渲染队列，RenderQuere越大的话，其渲染越靠后。一般设置材质的渲染模式之后会根据渲染模式来设置渲染队列。 OPAQUE模式对应的队列为2000； CUTOUT模式对应的队列为2450； TRANSPARENT模式对应的队列为3000； ADDITIVE模式对应的队列为3000； ALPHABLENDED模式对应的队列为3000； （7）Cull剔除模式 根据面顶点的不同连接顺序（顺时针或是逆时针）来进行剔除。 Off：关闭剔除 Back：剔除背面 Front：剔除前面 2.1.5 Trail着色器 Trail着色器用来实现拖尾的效果，我们需要拖尾特效对象来对应实现，在场景中创建一个拖尾特效对象入动图2-1-5-1所示： 动图2-1-5-1 我们给拖尾特效对象添加对应的材质如动图2-1-5-2所示，将myMaterial材质添加到拖尾特效对象上： 动图2-1-5-2 为了查看拖尾的效果，我们需要移动拖尾特效对象，为此我们添加一个Move脚本，使得特效对象能够沿着x轴进行移动。 （1）Color颜色 用来设置拖尾的颜色，如动图2-1-5-1-1所示，我们设置一个红色作为拖尾颜色： 动图2-1-5-1-1 （2）Texture贴图 用来设置拖尾的形状，如动图2-1-5-2-2中，我们添加一个图2-1-5-2-1作为贴图使用，拖尾着色器使用ADDITIVE模式实现透明叠加的效果： 图2-1-5-2-1 动图2-1-5-2-2 （3）AlphaTestValue alphaTest值 拖尾着色器只使用ADDITIVE与ALPHABLENDED模式，这个值在这里无效。 （4）TilingOffset缩放偏移 可以用来设置贴图采样时UV的缩放与偏移，实现贴图缩放与偏移的效果。 （5）MaterialRenderMode材质渲染模式 拖尾着色器只使用ADDITIVE与ALPHABLENDED模式： ADDITIVE：透明叠加模式，叠加后面像素的全部alpha值，实现透明效果。 ALPHABLENDED：与透明模式相同的混合方式，与透明模式的区别是不会混合场景中的雾，这个模式不会产生ADDITIVE的透明效果。 （6）RenderQueue渲染队列 可以用来设置材质着色器的渲染队列，RenderQuere越大的话，其渲染越靠后。一般设置材质的渲染模式之后会根据渲染模式来设置渲染队列。 OPAQUE模式对应的队列为2000； CUTOUT模式对应的队列为2450； TRANSPARENT模式对应的队列为3000； ADDITIVE模式对应的队列为3000； ALPHABLENDED模式对应的队列为3000； 拖尾着色器只使用ADDITIVE与ALPHABLENDED模式，这里设置为3000。 （7）Cull剔除模式 根据面顶点的不同连接顺序（顺时针或是逆时针）来进行剔除。 Off：关闭剔除 Back：剔除背面 Front：剔除前面 2.1.6 SkyBox着色器 天空盒着色器用来设置场景的天空盒样式，天空盒需要一个立方体贴图来进行采样，我们首先需要新建一个立方体贴图，并根据天空盒的上下左右前后面来设置贴图，如动图2-1-6-1所示： 动图2-1-6-1 设置天空盒需要修改Scene3D的天空盒材质，如动图2-1-6-2所示： 动图2-1-6-2 （1）TintColor颜色 叠加颜色到天空盒上，如图2-1-6-1-1所示，设置一个淡红色，使整个天空发红： 图2-1-6-1-1 （2）Exposure曝光度 用来设置天空盒的曝光度，当曝光为0时，天空盒为黑色；随着曝光值的增大，逐渐显示正常的立方体贴图颜色，随后会由于过曝导致天空盒全变为白色。如动图2-1-6-2-1所示： 动图2-1-6-2-1 （3）Rotation旋转 可以将立方体贴图绕着y轴旋转0~360度。 （4）CubeTexture球状贴图 用来设置天空盒的采样贴图，需要使用CubeMap类型的立方体贴图。 （5）AlphaTestValue alpha测试值 这个值在天空盒着色器上，切换到CUTOUT模式下不生效。 （6）TilingOffset 由于使用的是立方体贴图，这个值在天空盒着色器上不生效。 （7）MaterialRenderMode材质渲染模式 在天空盒着色器上，设置为CUTOUT、TRANSPARENT、ADDITIVE、ALPHABLENED模式均不生效。 （8）RenderQueue渲染队列 可以用来设置材质着色器的渲染队列，RenderQuere越大的话，其渲染越靠后。一般设置材质的渲染模式之后会根据渲染模式来设置渲染队列。 OPAQUE模式对应的队列为2000； CUTOUT模式对应的队列为2450； TRANSPARENT模式对应的队列为3000； ADDITIVE模式对应的队列为3000； ALPHABLENDED模式对应的队列为3000； 这里由于天空盒材质的渲染模式只在OPAQUE模式下生效，设置2000即可。 （9）Cull剔除模式 根据面顶点的不同连接顺序（顺时针或是逆时针）来进行剔除。 Off：关闭剔除 Back：剔除背面 Front：剔除前面 2.1.7 SkyPanoamic 着色器 天空盒全景贴图着色器，这里使用的是一张2D的全景贴图来以立方体贴图的方式包裹场景实现环境光效果，这个材质的使用与天空盒相同，直接赋值给3D场景的天空盒渲染器即可。 （1）TintColor颜色 与天空盒着色器功能相同，都是叠加一个颜色到全景图天空盒上。 （2）Rotation旋转 可以设置天空盒绕Y轴旋转的角度，在0~360之间。 （3）PanoramicTexture全景贴图 全景贴图需要一个使用经纬度的、圆柱形样式的2D贴图。 （4）AlphaTestValue alpha测试值 在全景天空盒着色器上由于只有OPAQUE模式生效，所以这个值在CUTOUT模式下无效。 （5）TilingOffset 由于使用的是2D贴图来实现立方体贴图的方式，这个值无效。 （6）MaterialRenderMode材质渲染模式 在全景图天空盒模式下只有OPAQUE模式生效。 （7）RenderQueue渲染队列 可以用来设置材质着色器的渲染队列，RenderQuere越大的话，其渲染越靠后。一般设置材质的渲染模式之后会根据渲染模式来设置渲染队列。 OPAQUE模式对应的队列为2000； CUTOUT模式对应的队列为2450； TRANSPARENT模式对应的队列为3000； ADDITIVE模式对应的队列为3000； ALPHABLENDED模式对应的队列为3000； 由于只有OPAQUE模式生效，这里设置为2000； （8）Cull剔除模式 根据面顶点的不同连接顺序（顺时针或是逆时针）来进行剔除。 Off：关闭剔除 Back：剔除背面 Front：剔除前面 2.1.8 SkyProcedural 着色器 程序化天空盒，通过设置太阳的参数来模拟天空。 （1）U_SunSize 太阳大小 太阳的圆盘大小设置，如图2-1-8-1-1所示，设置太阳大小为0.1： 图2-1-8-1-1 （2）Sun太阳类型 用来设置程序化天空盒的太阳类型，有如下三种类型： SUN_NONE 没有太阳，选择此模式后，天空盒上没有太阳显示。 SUN_HIGH_QUALITY 高品质太阳模拟，这个模式下，太阳光的发散与收敛可以进行调节。 SUN_SIMPLE 简单的太阳模拟，只能调整太阳的整体大小。 （3）U_SunSizeConvergence太阳大小收敛 太阳的大小收敛，值越小，整体的太阳圆盘越大，只在SUN_HIGH_QUALITY的模式下生效。如动图2-1-8-3-1所示： 动图2-1-8-3-1 （4）U_AtmosphereThickness大气层厚度 大气层的密度，更高密度的大气会吸收更多的颜色，如图2-1-8-4-1在密度为1时，与图2-1-8-4-2在密度为2时所示： 图2-1-8-4-1 图2-1-8-4-2 （5）U_SkyTint天空颜色 设置地平线以上天空的颜色。 （6）U_GroundTint地面颜色 设置地平线以下地面的颜色。 （7）U_Exposure曝光 通过曝光值来设置天空盒的明暗，如动图2-1-8-7-1所示： 动图2-1-8-7-1 （8）AlphaTestValue alpha测试值 由于程序化天空盒只使用OPAQUE，所以此值无效。 （9）TilingOffset 由于程序化天空并没有贴图，所以此值也无效。 （10）MaterialRenderMode材质渲染模式 只在OPAQUE模式下生效。 （11）RenderQueue渲染队列 可以用来设置材质着色器的渲染队列，RenderQuere越大的话，其渲染越靠后。一般设置材质的渲染模式之后会根据渲染模式来设置渲染队列。 OPAQUE模式对应的队列为2000； CUTOUT模式对应的队列为2450； TRANSPARENT模式对应的队列为3000； ADDITIVE模式对应的队列为3000； ALPHABLENDED模式对应的队列为3000； 由于程序化天空盒只在OPAQUE模式下生效，设置为2000. （12）Cull剔除模式 根据面顶点的不同连接顺序（顺时针或是逆时针）来进行剔除。 Off：关闭剔除 Back：剔除背面 Front：剔除前面 2.2 材质效果展示 材质效果展示主要用来显示设置属性后的材质效果，可以使用鼠标在此处进行交互来操作材质球不同方向上的效果。 2.2.1 切换不同mesh的材质 可以通过点击右侧的方块键来切换不同mesh下材质的效果，如动图2-2-1所示： 动图2-2-1 2.2.2 关闭灯光效果 可以通过点击右侧的灯泡按键来切换材质在受光与不受光的效果，如动图2-2-2所示： 动图2-2-2 3、材质的使用 当我们调整材质的属性为我们想要的效果之后，就可以将材质赋值给场景中的物体，设置物体的材质有两种方法可以使用，分别是下列动图3-1与动图3-2所示： 动图3-1 上面动图3-1可以直接将材质拖拽到Scene窗口内的物体上，或者也可以按照动图3-2所示，在对应物体的渲染器上选择相应的材质。 动图3-2 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:48 "},"IDE/ShaderBlueprint/readme.html":{"url":"IDE/ShaderBlueprint/readme.html","title":"蓝图编辑模块","keywords":"","body":"Shader蓝图1.蓝图概述1.1 创建蓝图1.2 蓝图界面预览2.与Shader的异同2.1 固定的三种基础材质类型2.2 材质混合方式2.3 ShaderName //待定项2.4 ShadowCaster2.5 DepthNormal2.6 AlphaTest2.7 SceneFog3.简单示例3.1 显示一个简单的模型3.2 显示一个简单的Blinnphong材质球4.节点数据的传输方式5.常见的节点类型5.1 坐标类5.2 相机类5.3 数学类5.4 纹理类5.5 颜色类6.常见的Params类型6.1 Float6.2 Texture2D6.3 Vector2/3/46.4 Color6.5 Define7.自定义函数8.进阶示例8.1 顶点着色器片段8.2 片段着色器片段拓展：快捷操作Shader蓝图 1.蓝图概述 1.1 创建蓝图 在Assert窗口右键Create菜单选择Shader BluePrint创建一个蓝图文件 在蓝图文件未打开时，蓝图文件对应的Shader文件并未创建；打开蓝图文件时才会创建Shader文件，完成蓝图与Shader的映射对应 图1-1 1.2 蓝图界面预览 图1-2 蓝图文件Inspector窗口 蓝图Params窗口 蓝图文件Pass窗口 蓝图预览窗口 2.与Shader的异同 2.1 固定的三种基础材质类型 2.1.1 PBR 常见的Shader属性： NormalWS 世界法线计算世界坐标中各顶点的光照结果 alphaTest 启用AlphaTest开关后，Shader通过alophatest的值来判断是否丢弃该像素 AlbedoColor 表面颜色（不包含光照） Metallica 金属度，描述物体的金属属性的值，实际上是在控制表面在多大程度上像“金属”，对于纯表面金属度的值可能是0或1，现实中的大多数物体其实是介于这个区间之间的 Smoothness 光滑度，描述物体的光滑程度，通常情况可以根据反射的模糊或者清晰度或者镜面反射高光的广度或者密集度加以确定 Occlusion 环境光遮蔽参数，环境光遮蔽是一种近似于光线因遮挡而衰减的效果，这是一种细微的表现，使角落，裂缝变得更暗，以创建一个更自然，现实的外观 Emission 自发光颜色 Anisotropy 各向异性参数，增加采样次数来补充贴图展示在模型上的细节 Alpha 透明度，选择了TRANSPARENT渲染模式，会根据Alpha值选择不同的透明度 图2-1展示了PBR材质类型是Shader蓝图的片段着色器内容 图2-1 2.1.2 UnLit NormalWS 世界法线计算世界坐标中各顶点的光照结果 AlphaTest 启用AlphaTest开关后，Shader通过alophatest的值来判断是否丢弃该像素 Color 基础颜色 Alpha 透明度，选择了TRANSPARENT渲染模式，会根据Alpha值选择不同的透明度 图2-2展示了UnLit材质类型是Shader蓝图的片段着色器内容 图2-2 2.1.3 Blinnphong NormalWS 世界法线计算世界坐标中各顶点的光照结果 AlphaTest 启用AlphaTest开关后，Shader通过alophatest的值来判断是否丢弃该像素 DiffuseColor 漫反射颜色（不产生光照的地方的颜色） SpecularColor 高光颜色（产生光照的地方的颜色） Shininess 表面光滑度 Gloss 表面粗糙度 Aplha 透明度，选择了TRANSPARENT渲染模式，会根据Alpha值选择不同的透明度 图2-3展示了Blinnphong材质类型是Shader蓝图的片段着色器内容 图2-3 2.2 材质混合方式 OPAQUE（不透明） 最终颜色 = 来源颜色。这意味着材质将绘制在背景前面。 CUTOUT（镂空） ​ 如果贴图中采样到的Aplha值 > AlphaTestValue，则最终颜色为来源颜色，否则废弃像素。 TRANSPARENT（半透明） 最终颜色 = 来源颜色不透明度 + 目标颜色（1 - 不透明度）。 ADDTIVE（加色混合） 最终颜色 = 来源颜色 + 目标颜色 ALPHABLENDED（透明混合） 这意味着对象为半透明的模式，但是最终像素的着色的混合模式不同，AlphaBlended混合方式为SrcAlpha SrcColor + （1 - SRCAlpha） DstColor，通常来说SrcAlpha来自纹理的Alpha值 2.3 ShaderName //待定项 ShaderName文本框中输入的是ShaderName 2.4 ShadowCaster 阴影计算开关，开启此开关时， 2.5 DepthNormal DepthNormal开关，开启此开关时，会加入DepthNormal Pass以计算场景的法线信息（部分后期处理可能会用到该功能） 2.6 AlphaTest Alpha测试开关，开启此开关的时，启用片段着色器的AlphaTest变量的Value值功能，启用透明裁剪，触发alphatest Value条件的像素直接丢弃，不填充颜色 2.7 SceneFog 场景雾效开关，开启此开关时，启用sceneFog通过屏幕空间的w值来计算雾效的范围 3.简单示例 3.1 显示一个简单的模型 图3-1 通过Params传入一张纹理 通过UV采样传入的纹理 将从纹理中采样到的颜色作为传入Unlit的Color 将世界法线传入Unlit的世界法线输入中 蓝图的结果展示如下 图3-2 3.2 显示一个简单的Blinnphong材质球 图3-3 传入世界法线 通过Params传入表面颜色 蓝图的结果展示如图 图3-4 4.节点数据的传输方式 在蓝图中一个节点中左侧为输入数据，右侧为输出数据 输入数据可以来自一个源数据、Params变量或者其他节点的输出 图4-1 5.常见的节点类型 5.1 坐标类 坐标类型 坐标释义 PositionWS 世界空间下的顶点世界坐标 normalWS 世界空间下的顶点法线世界坐标 tangentWS 世界空间下的顶点切线世界标 biNormalWS 世界空间下的顶点副切线世界坐标 worldMat 世界空间矩阵 5.2 相机类 属性类型 属性释义 viewDirection 视线向量（3D世界空间下的视线数学化表达) cameraPosition 相机位置世界空间坐标 cameraDirection 相机forward方向 cameraUp 相机Up方向 cameraNear 相机近平面大小 cameraFar 相机远平面大小 5.3 数学类 属性类型 属性释义 add / minus / multiply / divide 四则运算 sin / cos / tan 三角函数 clamp 钳取值在min和max范围内 mix / max 最小值，最大值 step / smoothstep x > value : 0.0 : 1.0 pow 幂次方 dot / cross 点乘向量，叉乘向量 5.4 纹理类 属性类型 属性释义 sampler2D 普通采样2D纹理贴图 samplerCube 采样3D CubeMap sampler2DNormal（OpenGL） 采样法线贴图（GL在左下角) sampler2DNormal(Directx) 采样法线贴图（DX在左上角) 5.5 颜色类 属性释义 属性类型 GammaToLinear 伽马空间转换到线性空间 LinearToGamma 线性空间转换到伽马空间 6.常见的Params类型 添加一个Params变量。在Params窗口下选中\"＋\"，选择相应的Parmas变量类型 图6-1 6.1 Float 定义一个float值，在检视面板中先试用一个float类型的对象 图6-2 6.2 Texture2D 定义一个2D纹理的值，在检视面板中显示一个2D纹理类型的对象 图6-3 6.3 Vector2/3/4 定义一个向量类型，根据不同的分量数量分为Vector2、Vector3、Vector4 图6-4 6.4 Color 定义一个颜色值，通常存在RGBA四种分量的数据 图6-5 6.5 Define 宏定义，用于对宏条件的不同触发结果来执行不同的结果内容，效率高于if-else 图6-6 7.自定义函数 7.1创建蓝图函数 在Project窗口右键Create菜单，选择Shader BluePrint Function创建一个蓝图函数 图7-1 7.2 添加参数 在蓝图编辑窗口下，右键空白处，选择ShaderFunction选项，选择Input In选项卡 图7-2 7.3 自动返回值 在最后的Default Output Result节点，输入的数据类型决定了该Shader函数的输出类型，函数蓝图会自动判断输出类型，如下图所示 图7-3 7.4 函数中调用函数 在蓝图函数界面，在需要放置蓝图函数节点的位置右键，在CustomFun-BlueMap项选择创建蓝图函数时定义的函数（蓝图函数文件名） 图7-4 8.进阶示例 简单的草 图8-1 8.1 顶点着色器片段 使用柏林噪声模拟出一个Vec4的向量 图8-2 对噪声值进行一些特殊的变换 把生成的噪声值缩小0.016，分别与外部传入的Color的g通道和a通道相乘，将分别乘完的结果求和，将得到的和与一个干扰值相加，最后与世界矩阵相乘 图8-3 3.将于世界矩阵相乘完的结果取出xz分量与positionOS的xz分量相加为新的positionOS的xz分量 图8-4 8.2 片段着色器片段 判断是否启用了SNOW宏，宏启用的时候计算 1- 顶点颜色g值的2次方在（0,1）的结果，宏关闭是值为0 图8-5 将UV坐标偏移与一个三角函数组成的2x2矩阵相乘再偏移回原来的位置 图8-6 采样草体纹理贴图，提取其中A通道转换为伽马值作为草体的Alpha值传入PBR函数，Albedo值为传入颜色值 * 纹理采样值 + 宏判断的值 图8-7 蓝图的结果展示如下 图8-7 拓展：快捷操作 节点类型 生成方式 快速生成float节点 长按数字键1，左键点击需要放置的位置 快速生成Vector2节点 长按数字键2，左键点击需要放置的位置 快速生成Vector3节点 长按数字键3，左键点击需要放置的位置 快速生成Vector4节点 长按数字键4，左键点击需要放置的位置 快速生成int节点 长按字母键i，左键点击需要放置的位置 快速生成bool节点 长按字母键b，左键点击需要放置的位置 快速生成time节点 长按子母键t，左键点击需要放置的位置 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:45 "},"IDE/Component/readme.html":{"url":"IDE/Component/readme.html","title":"内置组件","keywords":"","body":"内置组件网格拖尾像素线反射探针静态合批LOD组内置组件 引擎内置了大量的常用组件，方便开发者使用。 由于有一些组件与其它的功能联系紧密，就在其它的章节里进行体现，例如物理组件、动画组件等 本章节的组件包括： 网格 拖尾 像素线 反射探针 静态合批 LOD组 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:45 "},"IDE/Component/Mesh/readme.html":{"url":"IDE/Component/Mesh/readme.html","title":"网格","keywords":"","body":"组件系统之Mesh1.Mesh1.1 Mesh 概述2.Mesh组件--MeshRenderer2.1 Mesh Renderer Inspector2.2 MeshRenderer的Material3.Mesh组件--MeshFilter3.1 MeshFilter Inspector 引用4.通过PrimitiveMesh创建简单Mesh组件系统之Mesh 1.Mesh 1.1 Mesh 概述 Mesh是指模型的网格数据，3D模型是由多边形拼接而成，而一个复杂的多边形，实际上是由多个三角形拼接而成。所以一个3D模型的表面是由多个彼此相连的三角面构成。三维空间中，构成这些三角形的顶点的数据以及三角形的索引数据的集合就是Mesh。 图1.1 1.2 Mesh数据 一个网格数据中包含了很多的数据信息，Shader中常见的顶点，法线等数据都是从Mesh数据中获取而来 一个标准的网格数据由以下的几部分属性组成 Vertex：三维空间中位置的集合 Topology：Mesh的基本片元类型 Index：索引数据，描述顶点组合片元的整数集合 Vertex：顶点数据 每个顶点可以具有以下的属性内容： position顶点 顶点位置标示顶点在模型空间的具体位置，在引擎中使用这个值来确定Mesh的表面，所有的网格都需要这个顶点属性，为必须项 normal法线 顶点法线表示从顶点位置的表面直接 “向外” 指出的方向。 tangent切线 顶点切线表示沿着顶点位置表面的“ u”(水平纹理)轴指向的方向 color颜色 顶点颜色表示顶点的基本颜色(如果有的话)。 uv坐标 一个网格最多可以包含八组纹理坐标。纹理坐标通常称为 UV，这些集合称为通道。 骨骼（可选） 在蒙皮网格中，混合指数表示哪些骨骼影响顶点，骨骼重量描述这些骨骼对顶点的影响程度 Topology：片元拓扑 网格的拓扑结构定义了索引缓冲区的结构，而索引缓冲区又描述了顶点位置如何组合成面。每种拓扑类型在索引数组中使用不同数量的元素来定义单个面 LayaAir支持以下网格拓扑: Triangle Quad Lines Points Index Data : 索引数据 索引数组包含引用顶点位置数组中元素的整数。这些整数称为索引 例如，对于包含下列值的索引数组的网格: 0,1,2,3,4,5 如果网格具有三角形拓扑，那么前三个元素(0,1,2)识别一个三角形，而后三个元素(3,4,5)识别另一个三角形。顶点可以贡献的面的数量没有限制。这意味着同一个顶点可以多次出现在索引数组中。 2.Mesh组件--MeshRenderer Mesh Renderer 组件用于渲染网格。该组件与同一个游戏对象上的 Mesh Filter组件配合使用；Mesh Renderer 组件渲染 Mesh Filter 组件引用的网格 在引擎代码中MeshRenderer类继承自BaseRender组件类 2.1 Mesh Renderer Inspector 图2-1 A：指定该Render是否显示投射阴影 B：指定当一个合适的光照射到Render上时，该渲染器是否投射阴影以及如何投射阴影 C：LightMap缩放大小 D：LightMap索引号 E：Render材质列表 2.2 MeshRenderer的Material Material与Share Material的区别‘ Material 当我们引用修改这个属性的时候，LayaAir会返回该Render下第一个实例化后的material赋予当前的MeshRederer组件。 那么，什么是第一个实例化后的material呢？ Unity中每个MeshRenderer组件里有个Materals属性，这个数组决定了该物体下可以放几个material组件，默认是1。 当同一个物体上有很多个material的时候，我们可以手动更改material组件的上下位置关系。这里的第一个实例化后的material指的就是该物体上从上往下的第一个material组件，而不是MeshRenderer.materials[0]，也就是说我们每一次引用就会生成一个新的material到内存中。但是在引用后并不会改变我们项目工程中材质球的原始属性设置 Share Material 当我们改变Renderer.sharedMaterial的时候，所有使用这个材质球物体都会被改变，并且改变后的设置将会被保存在项目工程中 假设cube01和cube02共用一个材质redMat,当我们想通过sharedMaterial修改cube01上material的属性的时候，cube02上对应的属性也会被修改 总结 当使用MeshRenderer.material的时候，每次调用都会生成一个新的material到内存中。 当使用Renderer.sharedMaterial的时候并不会生成新的material，而是直接在原material上修改，并且修改后的设置就会被保存到项目工程中。一般不推荐使用这个去修改，当某个材质球只被一个gameobject使用的时候可以使用这个去修改，并且最好在修改之前把原属性设置保存，当使用完毕后立即恢复原设置，防止下次加载后的gameobject上还会残留之前的设置信息。 如果是主角这一类gameobject身上需要修改材质的属性或者shader属性比较多的时候，可以第一次使用material，这样可以动态的生成一个material实例，然后再使用sharedmaterial，动态的修改这个新生成的material，而且不会创建新的material 3.Mesh组件--MeshFilter Mesh Filter 组件包含对网格的引用。该组件与同一个游戏对象上的 Mesh Renderer组件配合使用；Mesh Renderer 组件渲染 Mesh Filter 组件引用的网格。 3.1 MeshFilter Inspector 引用 图3-1 Mesh属性 对网格资源的引用要更改MeshFilter组件引用的网格资源，请选择网格名称旁的箭头标识符来调用选取列表选择想要的Mesh网格 注意：当更改 Mesh Filter 组件引用的网格时，此游戏对象上其他组件的设置不会改变。例如，MeshRenderer 组件不会更新其设置，这可能会导致引擎使用非预期的属性渲染网格。如果发生这种情况，请根据需要调整其他组件的设置 4.通过PrimitiveMesh创建简单Mesh 在快速开启3D之旅的课程中，我们已用到了PrimitiveMesh的createBox方法创建一个盒子模型，本节课中介绍该类来创建其他的基础模型，并且使用transform来调整位置。更详细的使用情况可以查看API。 创建时需注意的是，加载到场景中的引擎自带模型，轴心点在模型正中心，因此我们是以模型中心点为参考进行移动、旋转、缩放。加载到场景中时，模型默认会放置到场景的世界座标原点上。 //创建一个空节点用来放置各模型 sprite3D = scene.addChild(new Laya.Sprite3D()); //正方体 var box = sprite3D.addChild(new Laya.MeshSprite3D(Laya.PrimitiveMesh.createBox(0.5, 0.5, 0.5))); box.transform.position = new Laya.Vector3(2.0, 0.25, 0.6); box.transform.rotate(new Laya.Vector3(0, 45, 0), false, false); //球体 var sphere = sprite3D.addChild(new Laya.MeshSprite3D(Laya.PrimitiveMesh.createSphere(0.25, 20, 20))); sphere.transform.position = new Laya.Vector3(1.0, 0.25, 0.6); //圆柱体 var cylinder = sprite3D.addChild(new Laya.MeshSprite3D(Laya.PrimitiveMesh.createCylinder(0.25, 1, 20))); cylinder.transform.position = new Laya.Vector3(0, 0.5, 0.6); //胶囊体 var capsule = sprite3D.addChild(new Laya.MeshSprite3D(Laya.PrimitiveMesh.createCapsule(0.25, 1, 10, 20))); capsule.transform.position = new Laya.Vector3(-1.0, 0.5, 0.6); //圆锥体 var cone = sprite3D.addChild(new Laya.MeshSprite3D(Laya.PrimitiveMesh.createCone(0.25, 0.75))); cone.transform.position = new Laya.Vector3(-2.0, 0.375, 0.6); //平面 var plane = sprite3D.addChild(new Laya.MeshSprite3D(Laya.PrimitiveMesh.createPlane(6, 6, 10, 10))); 效果如图2-2: 图2-2 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:44 "},"IDE/Component/Trail/readme.html":{"url":"IDE/Component/Trail/readme.html","title":"拖尾","keywords":"","body":"拖尾一、概述二、IDE中创建与使用2.1 创建拖尾对象2.2 属性设置2.3 拖尾材质2.4 拖尾过滤器拖尾 一、概述 拖尾渲染器（Trail Renderer）用于制作跟在场景中的物体后面的拖尾效果来代表它们在到处移动。像在物体移动路径的位置上出现的残影，就是一种拖尾效果。 （动图1-1） 如动图1-1所示，这是一个自身旋转的立方体，周围有拖尾效果。下面我们来看看在IDE中是如何创建和使用拖尾的 二、IDE中创建与使用 2.1 创建拖尾对象 在一个3D场景的Hierarchy窗口中，任何节点下，或者是空白位置，都可以通过鼠标右键来创建拖尾对象，如动图2-1所示 （动图2-1） 此时创建的拖尾对象，是看不到任何效果的，实际上就是创建了一个空节点，并添加了拖尾渲染器（Trail Renderer）组件，我们来了解一下组件的信息 2.2 属性设置 如图2-2所示，拖尾渲染器有如下的属性 （图2-2） 由于 Trail Renderer 组件是继承自 Base Renderer 组件，因此拖尾渲染器本身具备一些基础属性，如图2-3所示 （图2-3） 接收阴影 Receive Shadow ，产生阴影的设置 Case Shadow 和光照贴图的缩放和偏移等基础属性，在这里就不介绍了 2.3 拖尾材质 拖尾所使用的的材质，也就是需要使用 Laya.Trail 这个Shader 2.3.1 创建材质 首先我们在Asset下新建一个Material，默认情况下Material的Shader是BlinnPhone，接下来我们修改下Shader，如动图2-4所示 （动图2-4） 2.3.2 材质贴图 如图2-5所示，带 Laya.Trail Shader的材质有如下几个属性 （图2-5） 这里我们主要关注拖尾效果的贴图，如动图1-1示例中的效果，需要做出拖尾效果的话，需要一张拖尾效果的纹理贴图，如图2-6所示 （图2-6） 我们接下来将纹理贴图拖入材质中，如图2-7所示，这样拖尾的贴图就配置好了 （动图2-7） 2.3.3 纹理颜色 我们想让拖尾的效果是一种灰色的类似烟雾的效果，那么我们需要对材质的颜色做设置，如图2-8所示，选取灰色的颜色，并改透明图为55 （图2-8） 这样颜色就配置好了，同时我们需要改下 Material Render Mode为 Additive 模式，才能让贴图中黑色的颜色变为纯透明，并改变 Cull 为 Off，如图2-9所示 （图2-9） 这样修改后，效果才能如动图2-10所示 （动图2-10） 2.4 拖尾过滤器 拖尾材质可以指定拖尾的纹理效果，透明方式等等，但拖尾过滤器才可以设置拖尾的时间，轨迹，长度等等，就像3D粒子系统一样，如图2-11所示 （图2-11） 2.4.1 淡出时间 Time ：淡出时间，时间越长，拖尾淡出时间越长 默认是5秒，5秒之后才会消失，如动图2-12所示 （动图2-12） 但是我们可以调整时间为1秒，如动图2-13所示 （动图2-13） 2.4.2 轨迹准线 Alignment ：设置轨迹面向的方向 ​ VIEW： 轨迹面向摄像机 ​ TransformZ： 轨迹朝向其变换组件的 Z 轴 2.4.3 最小距离 Min Vertex Distance：获取新旧顶点之间最小距离，实际上是最小拖尾片段距离，相当于拖尾的长度 可以确定在将新段添加到该路径之前，应用轨迹的游戏对象必须行进的距离（采用世界单位）。像 0.1 这样较小的值会更频繁地创建轨迹段，从而形成更平滑的轨迹。像 1.5 这样较大的值会创建在外观上更有锯齿状的轨迹段。另外，当顶点非常靠近并且轨迹会在短距离内显著改变方向时，较宽的轨迹可能出现视觉瑕疵。 注意：出于性能原因，最好使用尽可能最大的值来实现要创建的效果 2.4.4 宽度设置 Width ：宽度值和曲线值以控制轨迹沿其长度的宽度。 曲线是在每个顶点处采样的，因此其精度受制于轨迹中的顶点数量。轨迹的总宽度由宽度值控制。 如动图2-9所示，我们可以通过鼠标双击红线上来添加曲线节点，并通过白色旋转轴来调整曲线角度，通过鼠标双击红色节点来删除 （动图2-14） 2.4.5 颜色设置 Color ：采用 colorGradient 方式设置，有两个可选模式 ​ Fixed 固定模式 ​ Blend 混合模式 如图2-15所示，为设置从半透明到白色，最后变为半透明的颜色设置 （图2-15） 2.4.6 纹理模式 texture Mode ：纹理模式，与普通纹理模式相同 ​ Stretch ：可沿着轨迹的整个长度应用纹理贴图 ​ Tile ：使纹理沿着轨迹的长度平铺 通常我们使用Stretch为主，主要是应用一张贴图变化的效果 如动图2-16，采用Tile平铺的方式效果 （动图2-16） 最终我们选择Stretch为拖尾效果，如动图2-17所示 （动图2-17） 到此，拖尾渲染器就介绍完了，结合动画编辑器的使用，使物体在场景中运动起来，这样拖尾效果才能看到运行的效果，开发者可以很好的利用拖尾渲染器做出类似烟雾，残影等效果！ Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:45 "},"IDE/Component/PixelLine/readme.html":{"url":"IDE/Component/PixelLine/readme.html","title":"像素线","keywords":"","body":"像素线一、概述二、IDE中创建与使用2.1 创建像素线3D精灵2.2 属性设置2.3 像素线材质2.4 像素线数据三、代码中创建与使用3.1 构造方法3.2 AddLine()3.3 Tool.linearModel()3.4 代码使用像素线 一、概述 像素线（Pixel Line ）也可以称之为像素线3D精灵，是通过渲染一组带有颜色的线，来绘制3D精灵的方式，如图1-1所示 （图1-1） 如图1-1所示，这是六种IDE提供的3D基础显示对象的网格模式，是一种用线条来展现网格的绘制方式 二、IDE中创建与使用 2.1 创建像素线3D精灵 在一个3D场景的Hierarchy窗口中，任何节点下，或者是空白位置，都可以通过鼠标右键来创建像素线3D精灵，如动图2-1所示 （动图2-1） 此时创建的像素线3D精灵，是看不到任何效果的，实际上就是创建了一个空的3D精灵节点，并添加了像素线渲染器（Pixel Line Renderer）组件，我们来了解一下像素线渲染器组件的信息 2.2 属性设置 如图2-2所示，像素线渲染器有如下的属性 （图2-2） 由于 Pixel Line Renderer 组件是继承自 Base Renderer 组件，因此像素线渲染器本身具备一些基础属性，如图2-3所示 （图2-3） 接收阴影 Receive Shadow ，产生阴影的设置 Case Shadow 和光照贴图的缩放和偏移等基础属性，在这里就不介绍了 2.3 像素线材质 首先我们在Asset下新建一个Material，默认情况下 Material 的 Shader 是 BlinnPhone，接下来我们先把这个Material拖入像素线渲染器的材质属性中，如动图2-4所示 （动图2-4） 第二步要修改 BlinnPhone 的 shader 为 Laya.Unlit shader ，并勾选 Vertex Color （动图2-5） 有了材质，剩下就需要添加像素线数据了 2.4 像素线数据 像素线数据就两点，像素线的最大线数量和像素线数据，如图2-6所示 （图2-6） Max Line Count：最大线数量 Pixel Lines Datas：像素线数据 注意：像素线数据的数量是不能超过最大线数量的 默认时，已经添加了一个像素线数据，从（0，0，0）点到（0，0，0）点的白色线，只不过是一个点，我们无法看到效果 我们可以通过修改 End Position 和颜色，如图2-7所示 （图2-7） 修改之后，我们可以看到一条最基本的像素线，如图2-8所示 （图2-8） 到此，像素线渲染器就介绍完了，通常我们通过IDE来添加每一条像素线来描绘一个网格是不可能的，往往我们会通过代码来实现，下面我们介绍代码是如何使用的 三、代码中创建与使用 PixelLineSprite3D 是 LayaAir引擎提供的像素线3D精灵类，我们看看这个类最重要的方法 3.1 构造方法 从下面的代码中可以看到，当初始化一个PixelLineSprite3D 的构造方法时，代码已经帮我们添加了 PixelLineRenderer 组件和 设置了 UnlitMaterial 材质并勾选了使用 VertexColor ，如上面2.3小节中手动添加材质的过程在代码中是自动做好了 /** * 创建一个 PixelLineSprite3D 实例。 * @param maxCount 最大线段数量。 * @param name 名字。 */ constructor(maxCount: number = 2, name: string = null) { super(name); this._render = this.addComponent(PixelLineRenderer); this._geometryFilter = (this._render as PixelLineRenderer)._pixelLineFilter; (this._render as PixelLineRenderer).maxLineCount = maxCount; let material = this._render.material = new UnlitMaterial(); material.enableVertexColor = true; } 3.2 AddLine() PixelLineSprite3D 已经直接调用了 PixelLineRenderer 组件的 addLine() ，看来可以直接设置点位置和颜色即可 /* * 增加一条线。 * @param startPosition 初始点位置 * @param endPosition 结束点位置 * @param startColor 初始点颜色 * @param endColor 结束点颜色 */ addLine(startPosition: Vector3, endPosition: Vector3, startColor: Color, endColor: Color): void { (this._render as PixelLineRenderer).addLine(startPosition, endPosition, startColor, endColor); } 3.3 Tool.linearModel() 通常我们可以利用addLine() 方法来实现把复杂的网格数据转变成像素线数据，我们可以写一个Tool工具类，方便转换使用： //Tool工具类 export class Tool { private static transVertex0: Vector3 = new Vector3(); private static transVertex1: Vector3 = new Vector3(); private static transVertex2: Vector3 = new Vector3(); private static corners: Vector3[] = []; //线性模型转换方法 static linearModel(sprite3D: Sprite3D, lineSprite3D: PixelLineSprite3D, color: Color): void { if (sprite3D instanceof MeshSprite3D) { var meshSprite3D: MeshSprite3D = sprite3D; //获得Sprite3D对象的网格数据 var mesh: Mesh = meshSprite3D.meshFilter.sharedMesh; var positions: Array = []; //拷贝并填充位置数据至数组 mesh.getPositions(positions); //拷贝并获取网格索引的副本 var indices = mesh.getSubMesh(0).getIndices(); for (var i: number = 0; i 3.4 代码使用 通过如下代码对工具类 Tool.linearModel 的使用，可以把一个 PixelLineSprite3D 对象的网格数据设置成像素线数据： //创建一个球体 var sphere: MeshSprite3D = (this.sprite3D.addChild(new MeshSprite3D(PrimitiveMesh.createSphere(0.25, 20, 20)))); sphere.transform.position = new Vector3(0.0, 0.75, 2); //创建一个像素线3D精灵 var sphereLineSprite3D: PixelLineSprite3D = (this.lineSprite3D.addChild(new PixelLineSprite3D(3500))); //转换球体的网格数据为像素线数据 Tool.linearModel(sphere, sphereLineSprite3D, Color.GREEN); 到此，像素线代码部分就介绍完了，往往我们也可以对一个外部模型转换成像素线数据来使用，在实际项目中可以丰富展现效果 如动图3-1所示，展示外部模型的像素线效果 （动图3-1） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:44 "},"IDE/Component/ReflectionProbe/readme.html":{"url":"IDE/Component/ReflectionProbe/readme.html","title":"反射探针","keywords":"","body":"Reflection Probe：反射探针1. 反射探针概述1.1 烘焙探针2.反射探针的属性2.1 Ambient Mode2.2 Importance2.3 Intensity2.4 Box Projection(盒式投影)2.5 Bounds2.6 环境光强度与反射强度2.7 采样大小与采样质量2.8 Clear信息2.9 IBL选项Reflection Probe：反射探针 1. 反射探针概述 传统形式的反射是通过反射贴图的形式来模拟来自对象的反射，对于静态的开放场景来说，传统反射贴图的形式得到的效果是可以接受的，但对象处于复杂环境中，反射贴图的效果就捉襟见肘了，LayaAir通过反射探针的形式，对对象所有场景的周围环境进行采样，利用反射探针可以在复杂的环境中来保证对象的反射效果足够的真实。当存在多个探针的时候，引擎会自动对每个探针采样到的反射结果进行插值以得到平滑的反射过渡效果。 反射探针使用CubeMap的贴图形式来从六个方向来收集并保存在CubeMap中，如下图中所示六个方向的反射结果 图1-1 1.1 烘焙探针 LayaAir引擎中的探针类型为Bake，烘焙探针捕获的反射只能为包含标记为Static的对象，具体的操作为选择需要烘焙反射的对象，选中该对象，在Inspector面板右上角勾选对象Static选项。 图1-2 在将需要烘焙反射信息的对象设置为Static完毕后，在Sprite3D对象添加Reflection Probe组件 图1-3 在Reflection Probe组件选择适合的采样等级采样大小，点击Bake按钮就可以开始反射探针的烘焙 图1-4 2.反射探针的属性 2.1 Ambient Mode 环境光模式有两种，一种是球谐模式一种是纯色模式 图2-1 球谐模式 通过球谐函数计算天空盒提供的环境光信息，反射探针收集到的为球谐函数计算得到的数值 纯色模式 在反射探针收集非指定位置的反射信息由纯色填充 2.2 Importance 重要性判断，当前引擎只支持单探针模式，如果当前新建的探针Important值大于主探针Important值，才用当前探针作为主探针 2.3 Intensity 应用于该反射探针在其着色器中的纹理的强度大小调节 2.4 Box Projection(盒式投影) 通常情况下，假设反射立方体贴图处于与任何给定对象之间无限远的距离。当对象转动时，立方体贴图的不同角度都将变为可见状态，但是对象不能进一步靠近或远离反射环境。这种状态通常对于室外场景表现良好，但其局限性表现在室内场景中；房间的内部墙壁显然不是无限远的距离，物体越靠近墙壁，墙壁的反射应该越大。 图2-2 2.5 Bounds 反射探针作用的范围用一个包围盒的形式来，反射探针只接受位于包围盒内物体的反射信息 Bounds Min：包围盒最小值坐标 Bounds Max：包围盒最大值坐标 包围盒Size = Max — Min 图2-3 2.6 环境光强度与反射强度 环境光强度：属性为接收到的环境光强度，作用到映射反射物体上的效果为反射效果中的环境光更强烈、更亮 反射强度：属性为接收到的反射内容强度，作用到映射反射物体上的效果为反射效果更强烈、更亮 2.7 采样大小与采样质量 烘焙反射探针采样大小：决定了烘焙CubeMap的单张RT的尺寸（分辨率） 烘焙反射探针采样质量：决定了烘焙CubeMap的单张RT的写入质量（高中低三挡） 图2-4 2.8 Clear信息 清除信息：除了反射内容部分，烘焙的探针内容时填充的内容可选项 清除颜色：当填充内容选择为SolidColor时，在ClearColor选项中选择填充的颜色 图2-5 2.9 IBL选项 IBL Tex：烘焙的反射探针IBL Texture IBL Tex RGBD：烘焙的纹理格式（颜色通道+深度通道） 图2-6 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:44 "},"IDE/Component/StaticBatchVolume/readme.html":{"url":"IDE/Component/StaticBatchVolume/readme.html","title":"静态合批","keywords":"","body":"Static Batch Volume组件Static Batch Volume组件 在Object的inspect面板，增加组件，选择Rendering选项，找到Static Batch Volume组件 图1 在Scene视窗中拖动小白点选择合适的Volume大小 图2 Static Batch Volume组件的使用: 在Scene中上面的Volume框选到合适的大小后，在组件的详情面板中，勾选Static Instance Batch，再点击reBatch，Volume中所框选的物件就会执行Batch操作，优化Draw Call，提升运行效率，勾选CheckLOD选项，启用LOD Cull Rate Array接管Volume中的物体LOD组，此时Volume中的所有物体的LOD判断不再是基于单个渲染对象的，而是基于Volume的LOD判断，系统会计算Volume与视野中计算出的Rate来选择不同的LOD层级。 在Game中Rebatch会自动调用, 位于Volume中的所有物体会自动判断并实行Static Batch Instance操作。 图3 图4 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:44 "},"IDE/Component/LOD/readme.html":{"url":"IDE/Component/LOD/readme.html","title":"LOD组","keywords":"","body":"LOD1. LOD概述2.LOD组件2.1 创建LOD组件2.2 LOD 等级滑块2.3 Renders3.导入LOD网格（实验性）4.LOD Cull Rate ArrayLOD 1. LOD概述 细节级别 (LOD) 是一种减少 LayaAir引擎渲染远距离网格所需的 GPU 操作数量的技术。 当场景中的某个游戏对象距离摄像机很远时，与距离摄像机很近的游戏对象相比，可以看到的细节将会减少。但默认情况下，引擎会使用相同数量的三角形来渲染两个远近不同距离的游戏对象。这可能会浪费 GPU 运算资源，从而影响场景中的性能。 LOD 技术允许引擎根据与摄像机的距离来相应减少为游戏对象渲染的三角形数量。要使用此技术，游戏对象必须具有大量网格，这些网格的几何体的细节级别逐渐降低。这些网格称为 LOD 级别。游戏对象离摄像机越远，引擎渲染的 LOD 细节级别越低。此技术减轻了这些远处游戏对象给硬件带来的负担，因此可以提高渲染性能。 2.LOD组件 2.1 创建LOD组件 可以通过创建一个LOD组件向场景中物件添加LOD组，引擎的LOD可以添加多个LOD组来实现不同距离实现不同的渲染结果 创建LODGroup组件的步骤：添加组件 -> 选择Rendering组件类型 -> 选择LOD Group组件 图2-1 图2-2 2.2 LOD 等级滑块 通过调整不同LOD等级在LOD等级滑块上的占比来调整不同LOD的切换范围 图2-3 LOD等级滑块被划分为一个从左到右范围为[100%, 0%]的区间, 每一级的区间显示百分比为当前区块的左区间值 黑线指示了当前相机所处的LOD等级, 黑色指示线是实时刷新的,会随着相机的移动而变换到不同的LOD区间内。 拓展 Mincull Rate 图2-4 每个 LOD 级别层级的Mincull Rate表示激活该级别的阈值。该阈值基于游戏对象的屏幕空间高度与屏幕总高度之比。例如，如果 LOD0的阈值设置为0.4，则当摄像机回拉得足够远，使得游戏对象的高度占视图的40%时，LOD0就会激活。 在上图中Mincull Rate的比值在图像中表现为绿色线的长度与黄色线长度的比值，通常情况为一个0.0到1.0的浮点小数 2.3 Renders 图2-5 Renders渲染器实际上是该LOD层级保存网格的Sprite3D对象。通常情况下这是具有LOD 组件的Sprite3D对象的子对象 Renders渲染器可以添加多个渲染对象在同一个LOD层级可以渲染多个对象 3.导入LOD网格（实验性） 在美术软件创建好一个带有LOD层级网格资源，当导入引擎IDE之后，选择网格模型文件，勾选中导入设置中的Add Lod Group功能 图3-1 4.LOD Cull Rate Array 实际上LOD Cull Rate Array是Static Batch Volume的其中一个功能。 LOD Cull Rate Array实际上是对这个Volume中的物体计算的Rate的N种等级的渲染。 例如当前视野与Volume的实际Rate为0.2， LOD Cull Rate Array中LOD2的等级为0.1， 所以当前视角的物体为渲染的LOD2的物体。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-08 20:46:05 "},"IDE/prefab/readme.html":{"url":"IDE/prefab/readme.html","title":"预制体模块","keywords":"","body":"预制体模块一、概述二、IDE中创建2.1 创建预制体(2D)2.2 创建预制体(3D)2.3 修改预制体编辑场景三、使用预制体3.1 2D预制体3.2 3D预制体四、预加载预制体预制体模块 一、概述 在项目开发中，经常会出现这样的情况： 1，立项的时候，美术定义一系列标准的字体颜色，字号，在各个UI中应用，有一天美术突然说要更改默认的字体颜色，字号，苦逼的UI制作者就需要把所有界面都修改一次，这样会非常麻烦。针对这种情况，使用预制体就能轻松应付，只修改一个地方，就能影响全局。 2，不同的2D界面，局部有相同的布局，希望修改一次，多个界面相同布局跟着一起变化。针对这种情况，使用预制体就能轻松应对。 3，3D项目开发中，重复使用在同一场景中或者不同场景中的某种对象，例如模型，贴图，动画等设置都制作好了，就可以在场景中直接创建英雄，怪物，特效等等。我们希望在使用的时候只需用代码加载即可。针对这种情况，使用预制体才能实现。 针对类似上面需求，LayaAir3.x IDE提供了2D预制体和3D预制体，接下来本文将介绍这两种预设如何使用。 二、IDE中创建 创建预制体的过程只能在IDE中完成，通常预制体创建后都是以“.lh”为后缀的文件。本节介绍在IDE中如何创建预制体(2D)和预制体(3D) 2.1 创建预制体(2D) 预制体(2D)是针对2D界面开发过程中所使用的预制体，通常对于重复会用到的2D组件，局部界面等等。 如动图2-1所示，在IDE中项目资源的assets下，开发者可以选择希望预制体存放的目录，在此目录下，鼠标右键的菜单中创建预制体(2D) （动图2-1） 创建好的预制体，通常开发者是需要重新命名的，这样才能通过名字来识别预制体的功能，如动图2-2所示 （动图2-2） 点击Title预制体，可以看到有一个根节点“Box”，如图2-3所示 （图2-3） 开发者可以在Box下创建2D组件，或者把Box节点转换成其它2D组件来使用，后面我们将详细介绍 2.2 创建预制体(3D) 创建预制体3D的过程同预制体2D一样，如动图2-4所示 （动图2-4） 不同的是，双击打开预制体3D，根节点是“Sprite3D”，也就是我们需要创建的3D精灵对象。同时图2-5右面是默认的IDE场景，用了IDE自带的天空盒 （图2-5） 2.3 修改预制体编辑场景 开发者可以通过如下的方式来更换3D预制体的编辑场景，如动图2-6所示 （动图2-6） 例如我们有一个3D的城市场景，在IDE的项目设置中 ，点击编辑选项，在预制体编辑场景中，拖入3D的城市场景文件，此时再次查看预制体的场景窗口，可以看到场景更换到3D城市了，这种情况下，可以更方便开发者更加灵活的在场景中制作3D预制体 三、使用预制体 3.1 2D预制体 第一小节中提到，由于开发过程中，会有很多界面使用类似于标题这样的字体，开发者最好通过预制体的方式来实现，当有需求改变所有界面标题的字体时，只需要修改一次预制体即可。 3.1.1 转换节点类型 由于创建的预制体默认是Box跟节点，如果在Box下面创建标题的话，那么这个Box节点是多余的，如果界面中创建大量的标题，那么会创建很多的Box，对于性能的考虑来说是强烈不推荐的，因此我们希望使用转换节点来把Box改为Label组件。如动图3-1所示 （动图3-1） 3.1.2 设置字体 接下来，这里就不多介绍标题的制作过程了，如图3-2所示，我们暂时制作一个黄色的30号黑体的字体，作为标题，并改名为Title （图3-2） 3.1.3 IDE中使用预制体 当预制体制作好之后，可以在IDE中拖入到我们希望使用到的界面中，如动图3-3所示 （动图3-3） 场景中有一个List，我们希望item里会有一个标题，我们把Title预制体拖入到List的Box下，作为List的item项的Label标题。可以看到节点中，Label名字颜色是绿色的，代表这个节点是预制体节点，当然这个节点下所有的节点都会是绿色的。 注意：使用预制体的节点中，也就是任何绿色的节点，都是不可以删除的 3.1.4 修改预制体属性 当需求说想把所有的标题都改为红色时，也就是修改一次，多个界面跟着一起变化。那么只需要在Title预制体中修改文字的颜色即可，如动图3-4所示 （动图3-4） 修改预制体后，需要保存预制体文件，同时需要重新打开使用预制体的场景界面，才能在场景编辑器中刷新效果，当然你也可以不用这样操作，直接运行就可以 预制体中也可以继续添加新的UI组件，同理在场景中新加的UI组件同步过来了。这里就不展示了，开发者可以自己尝试。 注意：任何UI组件上添加的脚本，也可以同步到场景中，但是预制体下的runtime类不能同步 3.1.5 覆盖预制体属性 如果我们在场景中操作了预制体节点，比如新增加了UI组件，修改了UI组件的属性，UI组件上挂了脚本，如图3-3所示 （图3-3） 例如场景中List下的有个item节点为预制体，我们在List下做了几个改动，在图3-3中都会有标识 对Label组件增加了LabelScript脚本（有“+”号标识） 对item节点修改了width属性（右边属性面板有黄色线提示） 添加了Button组件（有“+”号标识） 这些修改也可以覆盖到预制体中，我们来看看如何操作。如图3-4所示 （图3-4） 点击item节点，在右边的属性面板中，点击 覆盖属性 按钮，可以打开 覆盖属性到 item 的操作面板 由于之前有三个操作，那么我们点击 item，LabelScript，Button，可以看到，如图3-8所示 （图3-8） IDE记录了这三个修改操作，我们可以分别对每一项进行撤销或者应用，也可以直接进行撤销全部或者应用全部 当每个操作点击应用或者使用应用全部后，回到item预制体窗口后，三个修改都会更新并保存到预制体中，如图3-9所示 （图3-9） 通过上面的操作，使用覆盖预制体属性的方式，也可以达到修改预制体的效果。 3.1.5 代码中使用预制体 通过代码添加预制体的方式，就像使用一个组件一样简单，如图3-5所示，我们希望把Title预制体放到Box下 （动图3-5） 示例代码如下： const { regClass, property } = Laya; @regClass() export class ScriptA extends Laya.Script { //declare owner : Laya.Sprite3D; @property( { type: Laya.Box } ) private box: Laya.Box; constructor() { super(); } onStart(): void { //加载预制体文件 Laya.loader.load(\"resources/Title.lh\").then( (res)=>{ //创建预制体 let label: Laya.Label = res.create(); //添加预制体Label字体到box节点下 this.box.addChild( label ); } ); } } 运行效果如图3-6所示 （图3-6） 3.2 3D预制体 3D预制体的使用过程同2D预制体一样，在这里我们就不介绍如何制作预制体了，通过下面的示例来看看3D预制体的使用效果 3.2.1 IDE中使用 假设我们已经创建了3D预制体，并通过添加模型，材质，动画状态机等组件，制作了LayaMonkey，如图3-7所示 （图3-7） 此时，制作好的LayaMonkey可以拖入任何场景中，如动图3-8所示 （动图3-8） 3.2.2 代码中使用 通过代码使用3D预制体是最常用的方式，往往在游戏战斗中的敌人是通过代码不断创建的，像上述IDE拖入LayaMonkey的情况，我们用代码来实现如下： const { regClass, property } = Laya; @regClass() export class Main extends Laya.Script { @property( { type : Laya.Camera } ) private camera: Laya.Camera; @property( { type : Laya.Scene3D } ) private scene: Laya.Scene3D; onStart() { console.log(\"Game start\"); //加载预制体文件 Laya.loader.load(\"resources/Prefab.lh\").then( (res)=>{ //创建预制体 let monkey: Laya.Sprite3D = res.create(); //添加预制体到场景中 this.scene.addChild( monkey ); monkey.transform.position = new Laya.Vector3(-28.9354,0.3,-63.20264); } ); } } 运行效果如动图3-9 （动图3-9） 四、预加载预制体 在开发过程中，我们会通过大量创建预制体的方式来实现各种功能，因此预制体也可以理解为一组资源的集合体，通过代码加载预制体文件时，可以一同加载所关联资源。因此在项目启动加载过程中，可以直接先加载所有的预制体，就像预加载场景一样，引擎会把关联的资源一起加载。 在LayaAir 2D入门示例代码中，可以看到，通过预加载一组预制体的实现代码： import { LoadingRTBase } from \"./LoadingRT.generated\"; const { regClass, property } = Laya; @regClass() export default class LoadingRT extends LoadingRTBase { onAwake(): void { Laya.loader.load( //先加载本场景要用的 [\"resources/UI/image.png\", \"resources/UI/progress.png\", \"resources/UI/progress$bar.png\"] ).then(() => { let resArr: Array = [ { url: \"resources/prefab/uiDemo/useUI/ChangeTexture.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/useUI/MouseThrough.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/useUI/PhysicalCollision.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/useUI/Progress.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/useUI/TextShow.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/page/IframeElement.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/page/UsePanel.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/list/BagList.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/list/ComboBox.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/list/LoopList.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/list/MailList.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/list/Refresh.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/list/TreeBox.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/list/TreeList.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/animation/AtlasAni.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/animation/FrameAni.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/animation/SkeletonAni.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/animation/TimelineAni.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/animation/TweenAni.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/interactive/Astar.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/interactive/Joystick.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/interactive/ShapeDetection.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/interactive/tiledMap.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/Bullet.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/closeBtn.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/ComboList.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/defaultButton.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/defaultLabel.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/DropBox.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/LoopImg.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/role.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/ani/cd.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/ani/refresh.lh\", type: Laya.Loader.HIERARCHY }, ]; //3.0的load，同时可以加载2D,3D资源 Laya.loader.load(resArr, null, Laya.Handler.create(this, this.onLoading, null, false)).then(() => { // 加载完成后，处理逻辑 this.progress.value = 0.98; console.log(\"加载结束\", this.progress.value); //预加载的东西太少，为了本地看效果延迟一秒，真实项目不需要延迟 Laya.timer.once(1000, this, () => { //跳转到入口场景 Laya.Scene.open(\"Scenes/Index.ls\"); //不要使用Laya.Scene.open(\"./Scenes/Index.ls\"); }); }); // 侦听加载失败 Laya.loader.on(Laya.Event.ERROR, this, this.onError); }); } /** * 当报错时打印错误 * @param err 报错信息 */ onError(err: string): void { console.log(\"加载失败: \" + err); } /** * 加载时侦听 */ onLoading(progress: number): void { //接近完成加载时，让显示进度比实际进度慢一点，这是为打开场景时的自动加载预留，尤其是要打开的场景资源多，并没有完全放到预加载中，还需要再自动加载一部分时。 if (progress > 0.92) this.progress.value = 0.95; else this.progress.value = progress; console.log(\"加载进度: \" + progress, this.progress.value); } } 通过上述代码，可以在浏览器中的调试工具中看到引擎会加载全部预制体的资源。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-04-06 14:36:19 "},"basics/2.x-Upgrade/readme.html":{"url":"basics/2.x-Upgrade/readme.html","title":"2.x引擎项目升级指南","keywords":"","body":"2.0引擎开发者使用3.0的差异汇总1、LayaAir3.0 Loader修改1.1加载一个资源1.2 加载多个资源（用数组）1.3 加载多个文件（组合）1.5 加载HTMLImage1.6 使用Options。1.7 预制体/场景的问题1.8 旧版本引擎load和create的兼容性问题1.9扩展Loader能力2、关于动态加载IDE里的资源说明3、LayaAir3.0 输入处理模块修改3.1 2D和3D统一接口，3.2 2D能对3D正确遮挡。3.3 新增 MOUSE_DRAG和MOUSE_DRAG_END3.4 删除了RIGHT_MOUSE_DOWN和RIGHT_MOUSE_UP3.5 事件汇总4、LayaAir3.0 组件系统修改5、Runtime的使用差异6、2D动画2.0引擎开发者使用3.0的差异汇总 Author：谷主 && Charley [!Note] 本篇文档仅适用3.0以前的旧版引擎开发者，熟悉一些项目差异，后续还会进一步进行总结。 1、LayaAir3.0 Loader修改 1.1加载一个资源 示例： var url = \"xxx.png\"; var type = Laya.Loader.IMAGE; Laya.loader.load(url).then((res)=> { //不带类型，用于常规的资源 }); Laya.loader.load(url, type).then((res)=> { //带类型，用于区别同一后缀不同作用的资源。 //例如，图片xxx.png被定义为TextureCube，使用load(\"xxx.png\", Laya.Loader.TEXTURECUBE)。得到的是TextureCube。 }); 1.2 加载多个资源（用数组） var url1 = \"xxx.png\"; var url2 = \"xxxxx.png\"; var type1 = Laya.Loader.IMAGE; var type2 = Laya.Loader.TEXTURE2D; Laya.loader.load([url1, url2]).then((res:Array)=> { //加载多个，不带类型 }); Laya.loader.load([url1, url2], type).then((res:Array)=> { //加载多个，统一设置类型 }); Laya.loader.load([{ url:url1, type: type1 }, { url:url2, type: type2 }]).then((res:Array)=> { //加载多个，分别设置类型 }); 1.3 加载多个文件（组合） let tasks:Array> = []; tasks.push(Laya.loader.load(url)); tasks.push(Laya.loader.load(url2)); Promise.all(tasks).then((res:Array)=> { //用于异步加载 }); 1.4 Texture和Texture2D的问题 同一个资源地址，无论是加载Texture还是Texture2D，他们在内存中都只有一份，但可以获取不同类型。 Laya.loader.load(\"1.png\").then((res)=> { /* res是Texture */ }); Laya.loader.load(\"1.png\", Loader.Texture2D).then((res)=> { /* res是Texture2D */ }); Laya.loader.getRes(\"1.png\"); //res是Texture Laya.loader.getRes(\"1.png\", Loader.Texture2D); //res是Texture2D Laya.Loader.getTexture2D(\"1.png\"); //res是Texture2D 1.5 加载HTMLImage Laya.loader.fetch(\"1.png\", Laya.Loader.IMAGE).then((res)=> { /* res是HTMLImage */ }); [!Type|label:Tips] 不能使用Loader.getRes获得fetch结果，因为fetch方法不缓存 1.6 使用Options。 Laya.loader.load(url, { group:xx, piority:1 }); //priority不限制0-5。为任意整数，数字越大优先级越高。 1.7 预制体/场景的问题 加载lh/ls/gltf这三种文件，会下载和加载所有依赖的资源。 但不会自动创建节点。缓存的也不是节点。 Laya.loader.load(\"1.lh\").then(res=> { /* 注意res不是节点类型！ 类型也不必关心，只需要知道它有一个create方法实例化节点树。*/ let node = res.create(); }); 1.8 旧版本引擎load和create的兼容性问题 3.0以前的引擎，有Laya.loader.load()和Laya.loader.create()方法两个方法，分别用于加载2D和3D资源。 3.0引擎版本统一使用load()方法即可， 对于lh/ls/gltf这类资源，旧版本的create方法相当于3.0引擎的load+createNodes， 对于其他资源，create方法和load方法没有区别。旧引擎的create方法在3.0引擎中已取消，因为这个方法的不当使用会造成内存泄露，所以需要报编译错误强制开发者修改。 1.9扩展Loader能力 原来的parseMap，createMap都已经取消。 编写一个类实现IResourceLoader接口，例如一个最简单的实现： class MyLoader { load(task:ILoadTask) { return task.loader.fetch(task.url, \"json\", task.createCallback()).then(data=> { let obj = /*解析data*/; return obj; }); } } 加载类里不需要考虑是单独加载，还是是批量加载其中一个环节，因为task.createCallback可以很好的将总体进度归一化为0~1。 复杂的例子可以参考引擎里的TextureLoader/MaterialLoader/MeshLoader之类。 然后使用Loader.registerLoader注册这个类。例如 Loader.registerLoader([\"xyz\"], YourLoader); 2、关于动态加载IDE里的资源说明 无论加载什么资源，编辑器内文件名是什么，路径就填什么。不用放到bin目录，直接放到assets目录，以assets为根路径。 例如： 1、拖入了FBX或者GLTF后，使用load(\"xxx.FBX\", Laya.Loader.HIERARCHY) 加载编辑器里的fbx或者gltf。不需要自己手动搞成lh。编辑器会自动使用转换后的结果。 2、加载蓝图shader用load(\"xxxx.lbp\")，而不是\"xxx.shader\"。 3、LayaAir3.0 输入处理模块修改 原有的MouseManager和KeyboardManager合并为InputManager。MouseManager以前在游戏中应该很少直接用到，所以影响不大。KeyboardManager原来只有一个接口hasKeyDown，现在改为调用InputManager.hasKeyDown即可。 新的输入处理系统的特性有： 3.1 2D和3D统一接口， 都可以通过事件监听方式和Laya.Script命名函数方式处理输入。例如： this.aNode.on(Laya.Event.CLICK, ()=> { console.log(\"clicked\"); }); class MyScript extends Laya.Script { //脚本事件 onMouseClick(e:Event) { console.log(\"clicked\"); } } aNode.addComponent(MyScript); 以上两种方式是等价的，且在纯2D，或2D/3D混合这两种情况中均可正常使用。 3.2 2D能对3D正确遮挡。 输入处理时，2D能对3D正确遮挡。 3.3 新增 MOUSE_DRAG和MOUSE_DRAG_END 新增了两个事件：MOUSE_DRAG和MOUSE_DRAG_END。 在对一个物体按下鼠标并移动（无论是否在此物体上方），将持续对此物体派发MOUSE_DRAG， 松开鼠标后（无论是否在此物体上方）对此物体派发MOUSE_DRAG_END。 3.4 删除了RIGHT_MOUSE_DOWN和RIGHT_MOUSE_UP 删除了RIGHT_MOUSE_DOWN和RIGHT_MOUSE_UP，改为派发MOUSE_DOWN和MOUSE_UP，可以通过Event.button区分鼠标左中右键。 3.5 事件汇总 Laya.Script 里相关的输入处理函数有： /** * 鼠标按下时执行 */ onMouseDown?(evt: Event): void; /** * 鼠标抬起时执行 */ onMouseUp?(evt: Event): void; /** * 鼠标在节点上移动时执行 */ onMouseMove?(evt: Event): void; /** * 鼠标进入节点时执行 */ onMouseOver?(evt: Event): void; /** * 鼠标离开节点时执行 */ onMouseOut?(evt: Event): void; /** * 鼠标按住一个物体后，拖拽时执行 */ onMouseDrag?(evt: Event): void; /** * 鼠标按住一个物体，拖拽一定距离，释放鼠标按键后执行 */ onMouseDragEnd?(evt: Event): void; /** * 鼠标点击时执行 */ onMouseClick?(evt: Event): void; /** * 鼠标双击时执行 */ onMouseDoubleClick?(evt: Event): void; /** * 鼠标右键点击时执行 */ onMouseRightClick?(evt: Event): void; /** * 键盘按下时执行 */ onKeyDown?(evt: Event): void; /** * 键盘产生一个字符时执行 */ onKeyPress?(evt: Event): void; /** * 键盘抬起时执行 */ onKeyUp?(evt: Event): void; 和老版本比较，有如下改变 1) onClick 名字变更为 onMouseClick 2) onDoubleClick 名字变更为 onMouseDoubleClick 3) 删除了onStageMouseDown，onStageMouseUp，onStageClick，onStageMouseMove 4) 删除了onMouseEnter，它与onMouseOver重复。 4、LayaAir3.0 组件系统修改 4.1 LayaAir2的组件系统中有3种组件的基类，Component、Script和Script3D。 LayaAir3.0合并了Scirpt和Script3D，也就是只使用Script即可。Script3D仍然可以使用，但它只是Script的别名。Script可以挂载到2D对象，也可以挂载到3D对象。 4.2 LayaAir2中，Component与Script的区别，是Component主要通过继承方式写逻辑，Script则是比较纯正的组件机制。 在LayaAir3.0中，Component具有完整的生命周期，即onAwake,onStart,onEnable,onUpdate,onLateUpdate,onDisable,onDestroy，不再使用_onEnable,_onDisable等下划线函数。 _onEnable,_onDisable等下换线函数仍然给内部使用 对比Component, Script增加了交互行为，即onTriggerEnter, onCollisionEnter, onMouseClick, onKeyDown等与输入输出相关的回调。除此之外，Script与Component无本质区别。开发者一般使用Script。 4.3 Component或Script的Update/LateUpdate方法是否在IDE编辑模式下运行，由他们的runInEditor属性决定。开发者则一般通过给Script附加装饰@runInEditor实现。默认不运行。 关于修饰符的使用，参照下面的示例： const { regClass, property } = Laya; //有了@regClass()，才会被识别为script脚本类 @regClass() export class Script extends Laya.Script { //属性上面有了@property()，才会被识别为IDE里可暴露的属性，每一个属性只要需要暴露，上面就都需要加上@property()。 @property( { type : String } ) public text: string = \"\"; constructor() { super(); } } 5、Runtime的使用差异 3.0的场景与2.0完全不是一个概念， 3.0的runtime只能在场景上的2D根节点Scene2D或预制体的根节点上设置，其它的子级节点，不再支持runtime，如果有代码的需求，要使用脚本script来实现。 3.0的UI没有var属性，name与var合并了，默认只需要name，如果需要在场景继承类上runtime通过this.xxx访问，那把name后面的 Declare Var给勾选上即可导出该属性到场景的基类里。 3.0不再把场景类统一生成到一个文件里，而是生成到Runtime类的同级目录，当为runtime指定一个场景类后，该场景类的同级目录会自动生成一个文件名相同，但后缀不同的基类。场景类基类的后缀名字为xxx.generated.ts 如果开发者不想看到.generated.ts的文件，可以在vscode的配置文件里，加上.generated.ts后缀名屏蔽生成的基类。 6、2D动画 2D动画不再支持ani格式，采用状态机与动画文件结合来使用 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-04-06 14:38:57 "},"2D/advanced/readme.html":{"url":"2D/advanced/readme.html","title":"2D进阶","keywords":"","body":"2D进阶文本进阶使用TiledMap地图2D性能优化2D进阶 2D进阶部分包括一些引擎扩展功能、引擎功能的综合性使用，进阶性使用等相关的文档。 文本进阶使用 TiledMap地图 2D性能优化 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:43 "},"2D/advanced/useText/readme.html":{"url":"2D/advanced/useText/readme.html","title":"文本进阶使用","keywords":"","body":"文本进阶使用一、显示文本组件二、位图显示文本组件三、HTML文本组件四、可输入文本组件五、关于文本的性能优化5.1 尽可能使用对应的文本组件5.2 尽可能避免使用文本描边5.3 被文本打断的DrawCall优化文本进阶使用 LayaAir引擎与IDE提供了丰富的文本组件，适用于各种文本应用场景。本篇分别就IDE中的显示文本组件、位图文本组件、可输入文本组件，这几个类型的组件进行介绍，让大家全面了解一下LayaAir引擎的各个文本组件。 一、显示文本组件 显示文本就是只能看，不能编辑修改的基础文本。LayaAirIDE中提供了Text和Label这两种基础的显示文本组件。 1.1、文本的底层渲染机制 LayaAir引擎在文本的底层渲染上，有两种方式。 分别是Text文本类的文本统一提交方式，和Graphics类的fillText文本单字符绘制提交方式。 如果采用了Text文本，那每一个Text文本对象中的文本字符会一起形成小图集提交到大图合集中，比如游戏中某个文本对象有300字，其中一个字符发生改变，也会对该文本对象的300字整段文本图集重新提到大图合集中。 又假如，在一个剧情游戏中，两人在对话。那其中一个文本对象，要不断的重新取值和赋值操作，使得该文本对象的显示内容频繁发生改变。此时，Text文本对象，就会不断的向大图合集进行文本图集的提交，占满大图集后，又需要创建一个新的图集继续提交，而不用的旧图集，如果没达到GC条件，也会一直存在，所以如果此次查看内存占用统计信息，就可以看到会一直在涨内存，直到GC条件达到之后，才会被销毁。并且GC在清空垃圾内存的时候，还有可能会导致瞬间的卡顿。 而采用Graphics类的fillText文本绘制，则是按单个字符向大图合集中进行提交，并且大图合集中已经存在的字符不会重复提交。所以对于图集的利用率比较好，即便是发生文本改变的时候，也不会向Text文本那样，创建很多垃圾图集。 这样看来，是不是fillText就是最好用的呢？ 如果文本不需要改变，那按单字提交图集的效率是不如一次性直接提交的。 所以，我们还是要看文本的类型，对应文本使用时的类型，选用相应的引擎API，才会更好。 1.2、静态文本与动态文本 基于上一小节的文本渲染提交的机制，以及文本仅用于展示或用于交互的区别，我们分成两种概念，就是把仅用于显示，文本内容无需改变的文本叫静态文本。对于文本内容需要改变的文本叫动态文本。 Text和Label都属于处理静态文本的类，它们都是把文本的每次改动都统一提交大图集的渲染机制。 fillText、fillBorderText、strokeText等，都是Graphics类中用于单字符提交的文本绘制方法。 在LayaAirIDE中，Text和Label属于静态文本组件，而LayaAir引擎中Graphics类的fillText、fillBorderText、strokeText等文本绘制方法，在IDE中是没有封装为组件的，需要在项目代码中直接使用引擎的API。 1.3、不同的文本API的使用区别与选择 如果我们已经理解了什么是静态文本和动态文本，那使用起来的选择就比较简单了，例如，一些导航和标签按钮等，他在UI上完全没有必要进行改变，完全可以使用静态文本。文字剧情和任务等，就需要动态文本了。 那静态文本组件有Text和Label两种，那是怎么选择呢。 其中Text是最基础的文本组件，他直接继承于Sprite，而Label继承于UIComponent再往上才是Sprite，从原理上，路径越短，性能自然越好。所以，比较简单的文本，当Text可以满足时，原则上优先使用Text，而Label由于属性非常丰富，适用于相对布局等等Text无法满足的应用场景。 对于fillText而言，我们不仅要了解它的优势，也要了解他的不足。fillText文本由于是引擎自己绘制的，目前只适用于中英文等主流国家语言，对于泰国语、阿拉伯语等复杂的语言，显示可能会有异常。所以对于这些排版复杂的国际语言游戏，那只能是采用静态文本组件的系统字或者是位图字，尽可能减少文本动态修改的产品需求。 1.4、使用时要注意的 静态的文本优先使用Text组件，因为只显示静态文本的时候性能最好。动态文本优先使用fillText，除非是国际化等需求不能满足的时候。 静态文本，对于有相对布局等复杂需求时，Label组件的功能比较强大。 fillText的代码使用方法说明如下： /** * 在画布上绘制文本。 * @param text 在画布上输出的文本。 * @param x 开始绘制文本的 x 坐标位置（相对于画布）。 * @param y 开始绘制文本的 y 坐标位置（相对于画布）。 * @param font 定义字号和字体，比如\"20px Arial\"。 * @param color 定义文本颜色，比如\"#ff0000\"。 * @param textAlign 文本对齐方式，可选值：\"left\"，\"center\"，\"right\"。 */ fillText(text: string | WordText, x: number, y: number, font: string, color: string, textAlign: string): FillTextCmd { return this.addCmd(FillTextCmd.create(text, x, y, font, color, textAlign, 0, \"\")); } 这里重点介绍一下fillText中font属性与其它几个文本font属性区别，fillText示例代码如下： /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { let sprite = new Laya.Sprite(); Laya.stage.addChild(sprite); sprite.graphics.fillText(\"fillText:引擎绘制的文本，适合简单的单行文本\", 100, 300, \" 60px simHei \", \"#ff0000\", \"left\"); } 在Text与Label中，font仅仅是指系统字体，例如该文本是Microsoft YaHei还是Arial，选择或者输入对应的字体就可以。而fillText中，font是字体与字体大小的设置值，也可以把所有相关的文本样式（大小、字体、斜体、加粗）也在这里指定。 例如，当值为 60px simHei ，是将文本大小设置为60像素大小，采用simHei字体。如下图1-1所示： （图1-1） 值为60px simHei italic 增加了斜体效果。如下图1-2所示： （图1-2） 值为bold 60px simHei italic 增加了文本加粗效果。如下图1-3所示： （图1-3） Tips: 大小与字体是必须设置的，并且在字体必需要放到文本px大小的后面。 bold需要放到文本px大小的前面。 二、位图显示文本组件 位图显示文本，是一种基于位图的文本，虽然显示的是文本的内容，其本质还是位图。通常用于系统上不通用的字体或者美术设计的个性字体，通过位图的方式可以保障字体的兼容性与美观。对于文本效果与位置要求比较严格的游戏，建议采用位图文本。 普通的文本，在不同运行环境下，可能会存在像素级的位置偏移。比如Chrome低版本和高版本也存在位置偏移。所以要求高的静态UI文本，可以采用位图显示文本。 位图文本适用于文本单字总量不大需求，常用于第X关，X连击等标题性文本。对于文字剧情这种游戏，就不太适合。 1、FontClip字体剪辑组件 FontClip组件是LayaAir基于等份切割原理将完整的位图切分成一个个独立的文本单元，然后任意剪辑拼接起来。效果如图2-1所示， （图2-1） 图2-1的数字0-9是美术原图效果的展示，数字999是FontClip组件效果。 在图2-1右侧的属性面板上，sheet值对应位图的9个数字，此时数字要完全对应起来，因为这个值不仅是引擎切割份数的参考依据，更是文本映射关系。只有对应起来，属性value中输入什么值就会显示什么值，例如图2-1的999。并且FontClip组件还可以控制切割后的位图文本间距等效果。 如果位图文本不是数字，是字母或者中文等，内容比较多，美术出图时也可以将文本多行排行，但是每个文本之间必须要等高等宽等距进行排列。此时用于映射的sheet值，要在每行结束位置加一个空格，让引擎知道这个位图文本是多行排行的。效果如下图所示： （图2-2） 通过图2-2，我们可以看出sheet属性值鼠牛虎兔龙蛇马羊 猴鸡狗猪年快乐对应了位图上的文本，并且在羊后加了一个空格，此时就可以在value输入位图上的文本字符了，而且我们还展示了竖向排版的效果，说明切割后的文本还可以排版控制的。 如果细心的开发者会发现，位图字是繁体的，sheet的值是简体的，但展示的效果并没有受到影响。这是因为sheet值只是起到映射关系的作用，哪怕这十二生肖的文本对应的就是生肖图片，那也会显示对应的生肖图。但是映射的文本与位图上的数量一定要是完整的，否则切片的份数不对，就会导致位图剪辑后的显示错误。 最后再说一下空格，如果当前的FontClip组件是图2-1那样面向单行的整句文本，此时sheet值是不支持空格的。而对于图2-2的多行文本，sheet值里的空格表示换行，并不是空一格。如果在Value值里加一个空格，可以从图2-2中看出，会空出一个完整的文本位置。其实不止是空格，所有sheet值中不存在的文本，输入在value中都会以空的完整字符占位。 2、BitmapFont位图字体 通常FontClip已经可以满足关卡、特效等单行位图文本的需求。如果有特殊情况，就是想要空格或者某些系统里没有的艺术字体，那也可以通过BitmapFont位图字体来实现。在LayaAir IDE里，可以直接创建制作位图字体，下面就来介绍这一功能。 如图2-3所示，在项目资源面板中，右键创建位图字体。 （图2-3） 创建后，如图2-4所示，会生成一个BitmapFont.fnt字体文件， （图2-4） 点击选中后，在如图2-5所示的属性设置面板中，就可以创建位图字体了。 （图2-5） 点击“编辑字符集”的+创建一个字符，如图2-6所示： （图2-6） 参数 意义 允许缩放 勾选后，可以按文本中的字体大小设置进行缩放显示。如果这里不勾选，则会无视字体大小设置，仅按位图文本的实际大小显示 字号 勾选允许缩放后，此处的字体大小用于实际文本字体大小的缩放调节。例如，实际文本的字体大小设置为24，位图字体的字体大小设置为12，那么位图字体最终将放大1倍显示，此处建议与文本组件的”font size“属性保持一致，这样获得的缩放效果最准确。如果不允许缩放，那此处与实际文本的字体大小设置均无效，会始终保持位图字体的源图大小 自定义行高 勾选后，可以设置行高。如果不勾选，则使用默认行高。行高决定了文本多行显示时每行所占高度，主要用于文本垂直方向的排版。如果为0，就是采用字号大小作为行高。如果大于0，就是实际文本的行间距（两个位图字体上边界之间的距离）。创建后可以在文本组件的”leading“属性中设置行高 字符 图片对应的字符，只支持单字符，可以是数字或者字符串 图片 资源库里的一张图片 占位 如果值为0，创建后表示一个字符的水平占位宽度，它由字符图片的宽度决定。如果值大于0，则使用该值作为字符之间的字间距（两个位图字体左边界之间的距离） 如图2-7所示，在resources文件夹下有十二张图片，分别是”鼠牛虎兔龙蛇马羊猴鸡狗猪“十二个字的位图，将这十二张图作为位图字体。图片的高度为151 px，所以行高设置为151。占位默认为0，创建后会变为144，即图片的宽度。编辑好之后点击”应用“，点击后还会再创建一张BitmapFont.png图片用于预览位图字体。 （图2-7） 位图字体可以在Text、Label、TextInput、TextArea等文本组件的Font属性中被选择，并且能够调整字体大小与行间距等。下面以Text为例，演示位图字体的使用。如动图2-8所示，在Text中选择好刚刚创建的位图字体，然后在文本中输入位图字体对应的”字符“即可使用位图字体了。 （动图2-8） Tips： 开发者也可以通过外部工具制作完成后，再导入使用。这里推荐一个开源工具：https://snowb.org/，在线即可制作。 三、HTML文本组件 HTML文本是用于图文混排的文本组件，组件名为HTMLDivElement。该组件通常用于聊天室等动态文本场景需求，所以引擎也是采单字符提交图集的模式，与Graphics的文本绘制有些类似，但又不太一样，因为绘制采用的是系统字，并支持常见的HTML标签。 目前引擎支持的常见HTML标签如下： 标签名 标签说明 div div容器标签，例如： 文本的最外层，可以通过style设置HTML文本的宽高 span 行内元素标签，例如： 多个span之间不会自动换行，除非是达到了宽度限制 h h1 到 h6是标题标签，例如：h1最大 …… h6最小 p 段落标签，例如：多个p标签之间会自动换行，每个完整的p标签是一个单独的段落 br 换行标签，例如：要换行 &nbsp; 空格标签，例如： &nbsp;&nbsp; style 样式标签，例如：HTML文本 img 图片标签，例如： color 文本颜色标签，例如：颜色 具体到style标签的属性支持如下： style标签属性示例 属性说明 italic:true｜false; 是否是斜体 bold:true｜false; 是否是粗体 letter-spacing:10px; 字间距 font-family:宋体; 字体 font-size:20px; 字体大小 font-weight:bold; 字体是否是粗体，功能同bold color:#ff0000; 字体颜色 stroke:2px; 字体描边宽度 strokeColor:#ff0000; 字体描边颜色 padding:10px 10px 20px 20px; 边缘的距离(上右下左) line-height:100px; 行高（仅div中使用） align:left｜right｜center 水平对齐方式（仅div中使用） background-color:#ff0000; 背景颜色（仅div中使用） border-color:#ff0000; 边框颜色（仅div中使用） width:100px; 宽度（仅div中使用） height:100px; 高度（仅div中使用） 下面的代码是运用的示例代码， 使用 HTMLDivElement&nbsp;&nbsp;组件 创建的 HTML文本 P标签，不需要br也会自动换新一行 当我们将以上代码复制到HTMLDivElement组件的innerHTML属性里，运行效果如下图所示。 四、可输入文本组件 可输入文本组件为单行输入组件TextInput和多行文本域组件TextArea。 从组件名字其实上就可以看出区别， 一个是不能换行，用于单行输入。比如注册信息上的那些单行输入框用TextInput。 另一个是能换行的多行文本组件TextArea，比如个人简介，备注说明等等。而且TextArea文本组件支持右侧的垂直滚动条，和底部的水平滚动条。 由于可输入文本组件的用法比较简单，组件也比较容易理解。这里就不详细介绍了，具体在使用过程中，可以看提示进行尝试或者直接看对应的组件属性说明文档。 五、关于文本的性能优化 5.1 尽可能使用对应的文本组件 每个不同的组件都是有自己独特的作用，所以一定要充分了解组件的作用，对应特点来使用。 上文中也讲到过，静态显示文本Text组件的性能是最好的，所以，在项目开发时，能用Text尽可能要用Text组件。当Text组件不满足的时候再用Label。 对于无需改变内容的静态文本，当文本组件节点较多时，我们可以开启cacheAs，设置normal可以优化节点数，设置bitmap可以优化DrawCall数。 而当文本内容需要改变时，哪怕只改变一个字符，如果FillText可以满足需求的话，那尽可能优先使用FillText文本组件。FillText不能满足时，其次考虑位图文本组件是否可以满足，最后再考虑静态文本组件。 5.2 尽可能避免使用文本描边 在运行时，设置了描边的文本比没有描边的文本多调用一次绘图指令。此时，文本对CPU的使用量和文本的数量成正比。因此，尽量使用替代方案来完成同样的需求。例如，字符量较少的时候，可以使用位图文本。 5.3 被文本打断的DrawCall优化 在2D的UI布局时，如果开发者将文本与其它UI节点混合排列，那么必然会打断图集的合并渲染，增加DrawCall数量，产生不必要的性能开销。所以，有两个方案来优化。 一是，LayaAir IDE编辑布局时，将所有文本组件在节点中顺序排列，不要与其它UI组件穿插。 二是，LayaAir IDE中的组件中有一个drawCallOptimize属性，我们为所有文本的父级节点drawCallOptimize属性设置true值。当这样设置之后，引擎会自动启用文本合并优化，将所有的文本提取到最上层，而开发者无需再刻意调整图集资源和文本的排序，即可实现drawCall自动优化的目标，而且优化的更加干脆彻底。 需要提醒的是，drawCallOptimize优化方案由于会自动将文本提升显示层级，不适用于必须要将文本半遮挡的特殊需求。当然，绝大多数情况下文本是要处于全文显示的，如果有全隐藏的情况，可以直接设置隐藏属性。所以，建议开发者开启该优化方案。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-06-05 21:06:57 "},"2D/useBinaryImage/readme.html":{"url":"2D/useBinaryImage/readme.html","title":"使用二进制图片","keywords":"","body":"使用二进制图片一、图片与二进制二、如何加载三、Laya中如何使用使用二进制图片 一、图片与二进制 在页游时代，为了防止资源被盗取，通常的做法就是把图片等资源进行加密。所谓的加密就是打乱资源本来的存储字节，或者穿插一些东西。但是到了html5时代，发现基本都是直接加载的图片，为什么和页游时代做法不一样了呢？是不是html5不能加载解码二进制图片？当然不是。之所以不进行加密这层操作，主要是我们项目的源码完全暴露在浏览器端，根本没有什么秘密可言，即便加密了，写个脚本执行下就能拿到你的源码。但是为了满足开发者这方面的需求，我们来讲解下LayaAir3.0是如何进行二进制图片操作的。 二、如何加载 关于如何加载，这里我们先从原生开始，然后在过渡到LayaAir引擎，这样开发者可以理解其中的含义。以二进制流的方式加载，这里我们采用XMLHttpRequest二进制流的方式来加载。关于XMLHttpRequest的操作我们这里不在陈述，我们先按照二进制的方式来加载试试。这里我们先用js脚本进行操作。代码如下： var xhr = new XMLHttpRequest(); xhr.open(\"get\", \"res/atlas/comp.png\", true); xhr.responseType = \"arraybuffer\"; xhr.onload = function () { if (this.status == 200) { var blob = new Blob([this.response], { type: \"image/png\" }); var img = document.createElement(\"img\"); img.onload = function (e) { window.URL.revokeObjectURL(img.src); // 清除释放; }; img.src = window.URL.createObjectURL(blob); document.body.appendChild(img); } } xhr.send(); 上面这个方法是用了浏览器自身提供的方法来把二进制转换成图片，二进制转换成图片其实还有很多种方法，比如加载进来二进制，解码成base64，然后在赋值给你img，或者把二进制数据用canvas绘制出图片，然后toDataURL赋值给你img的src等等，方法很多，我们这里就用最简单有效的办法转换图片。 图片加载完成之后，实例化一个XMLHttpRequest对象xhr ，responseType属性设置成 arraybuffer，实例化一个Blob对象blob，用来创建一个img标签，window.URL.createObjectURL(blob)创建一个指向该参数对象的URL，把创建的img对象我们添加到网页的body上进行显示。把这段代码嵌入到index.html文件中，运行可以看到网页已经正常的显示我们的图片。 三、Laya中如何使用 上面的简单例子我们是用的js脚本书写，那么在LayaAir3.0项目中是怎么使用的呢 在项目中的脚本中添加如下代码： //test.bin为二进制图片，图片加密数据是在图片的前面写入了四个字节的数据 Laya.loader.fetch(\"resources/res/test.bin\",\"arraybuffer\").then((res)=>{ //获得res的ArrayBuffer数据 let arraybuffer: ArrayBuffer = res; //Byte数组接收arraybuffer let byte:Byte = new Byte(arraybuffer); //从第四个字节开始读取数据 byte.writeArrayBuffer(arraybuffer,4); //获得最终的ArrayBuffer let imageArrayBuffer = byte.buffer; //实例化一个Blob对象blob，用来创建一个img标签 let imgBlob = new Blob([imageArrayBuffer], { type: \"image/png\" }); //转换为Base64图片格式 let reader = new FileReader(); reader.readAsDataURL(imgBlob); reader.onload = (e)=> { let sp1:Sprite = new Sprite(); //加载Base64图片数据 sp1.loadImage(e.target.result as string); this.owner.addChild(sp1); } }); 上述代码中，用 Laya.loader.fetch 加载图片二进制数据，根据自定义的规则，可以解析数据加密方式，并获得完整图片数据。在这里我们更多的介绍一下 LayaAir3.0引擎的 Laya.loader.fetch 方法。使用 Laya.loader.fetch 的好处是它是较为底层的下载资源的方法，它和load方法不同，不对返回的数据进行解析，也不会缓存下载的内容。 当选取图片数据的ArrayBuffer后，可以创建Image的Blob对象，通过FileReader类可以转换为Base64图片数据显示图片。这里不是用DOM来显示图片的，而是通过Laya.Sprite绘制。 开发者也可以使用Laya.Texture的方式，通过Laya.Sprite的drawTexture方式渲染，代码如下： //创建一个url对象； var url:string = Laya.Browser.window.URL.createObjectURL(imgBlob); //加载URL获得HTMLImageElement Laya.loader.fetch( url,\"image\" ).then((res)=>{ //创建Texture2D var t2d: Texture2D = new Texture2D(res.width, res.height, TextureFormat.R8G8B8A8, false, false, true); t2d.setImageData(res, true, false); //创建Texture var texture: Texture = new Texture(t2d); let sp2:Sprite = new Sprite(); //使用Sprite对象的绘制纹理方式 sp2.graphics.drawTexture(texture, 150, 0); this.owner.addChild(sp2); }); 当创建好Blob对象后，通过window.URL.createObjectURL(blob)创建一个指向该参数对象的URL，再通过Laya.loader.fetch 加载URL获得HTMLImageElement 对象，通过Laya.Texture2D 的setImageData 可以把HTMLImageElement 对象数据转换为 Laya.Texture2D，最后创建Laya.Texture来绘制 在上述代码中，也可以通过传递 Option 参数来使用Laya.loader.fetch，可以把 blob对象作为参数直接传递，代码如下： //创建Option let option:any = {}; option.blob = imgBlob; //通过传递Option参数，其中包含blob对象，来获得HTMLImageElement对象 Laya.loader.fetch( \"\" ,\"image\", null, option).then((res)=>{ //创建Texture2D var t2d: Texture2D = new Texture2D(res.width, res.height, TextureFormat.R8G8B8A8, false, false, true); t2d.setImageData(res, true, false); //创建Texture var texture: Texture = new Texture(t2d); let sp2:Sprite = new Sprite(); //使用Sprite对象的绘制纹理方式 sp2.graphics.drawTexture(texture, 150, 0); this.owner.addChild(sp2); }); 以上方法就是二进制图片的处理方法，开发者可以根据需求制定更多的二进制数据规则，可以把很多图片打包成一个图片集合文件，一次性解析并加载等待。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:43 "},"2D/TiledMap/readme.html":{"url":"2D/TiledMap/readme.html","title":"TiledMap地图","keywords":"","body":"使用TiledMap地图一、概述二、导出引擎支持的Tiled Map地图2.1 Tiled Map Editor下载安装2.2 导出引擎支持的Tiled Map地图格式三、LayaAir引擎使用Tiled Map 地图3.1 IDE勾选laya.tiledmap组件3.2 创建TiledMap地图3.3 控制地图3.4 拖动地图四、Tiled Map 使用优化4.1 销毁地图4.2 缓存相关4.3 合并图层4.4 移除被覆盖的格子使用TiledMap地图 一、概述 Tiled Map Editor是一个免费的地图编辑器，可以用来编辑2D游戏地图，LayaAir引擎支持解析Tiled Map导出的地图。本文将介绍如何在LayaAir引擎开发中使用Tiled Map Editor导出的地图。 注意：本文仅面向熟悉和使用Tiled Map地图工具的开发者。在文中介绍Tiled Map Editor导出的地图在LayaAir引擎的项目中如何使用，关于Tiled Map Editor工具的自身内容请自行查找第三方教程文档。 二、导出引擎支持的Tiled Map地图 2.1 Tiled Map Editor下载安装 打开官方首页（http://www.mapeditor.org/）后，直接点击`DownLoad at itch.io`按钮进入下载链接（https://thorbjorn.itch.io/tiled）。 （图2-1） 如果官网改版，也可以直接从下载页 http://www.mapeditor.org/download.html 找到下载链接。 找到对应的系统版本链接，下载安装即可，(本篇文档采用的版本为Tiled 1.9.2 )。 Tips： 打开下载会弹出赞助该软件的付费页面，如果不想付费，可以直接点击 No thanks, just take me to the downloads，会带你进入一个免费下载的链接。 2.2 导出引擎支持的Tiled Map地图格式 Tiled Map工具的具体使用方式，本文不多讲，可以自行在百度或谷歌中搜索相关教程文档。和引擎有莫大关系的是格式。需要开发者特别注意，一般出问题都是在这里没有注意。 2.2.1 创建地图时，对图块层格式的要求 点击新建地图，设置好地图大小和块大小等初始参数后，点击另存为，存在你指定的位置即完成了创建。 然而，图块层格式需要特别注意，由于LayaAir引擎不支持Tiled Map地图为Base64的图块层格式。所以在创建新地图时必须为CSV格式，如图2-2所示。 （图2-2） 如果创建的时候选错了，也可以在属性面板里，将图块层格式改为CSV或者是XML，如图2-3所示，Base64相关的格式都不支持。 （图2-3） 2.2.2 导出为json格式 本例中，我们直接打开Tiled Map的示例地图 orthogonal-outside.tmx（位于Tiled Map地图安装目录的 examples目录下），如图2-4所示 （图2-4） 在导出的时候，我们要选择json的格式。 在Tiled工具的文件菜单里，点击另存为，将已完成的Tiled地图，另存为json文件类型，本例命名为 orthogonal.json（文件名开发者随意，后面保持一致即可），点击保存，存到项目目录内（本例为项目根目录\\assets\\resources\\TiledMap\\），如图2-5所示。 （图2-5） 2.2.3 修改图集路径和复制Tiled资源 只是存为json文件还不够，我们还要更改image绝对路径为相对路径。 我们通过IDE，打开刚刚保存的 orthogonal.json，搜索关键字 image 我们会发现默认的图集路径位于Tiled安装目录中。如图2-6所示。 （图2-6） 路径在Tiled安装目录中肯定是不行的， 所以，我们需要先将这个图片复制到项目目录，与之前保存的orthogonal.json同级， 如图2-7所示。 （图2-7） 同时，我们要把图片文件在IDE里的格式做修改，支持透明通道 （图2-8） 然后将 orthogonal.json 中的图集路径修改为相对路径，如图2-9所示 （图2-9） 准备阶段结束，下面开始步入编码阶段…… 三、LayaAir引擎使用Tiled Map 地图 3.1 IDE勾选laya.tiledmap组件 （图3-1） 如图3-1，勾选laya.tiledmap组件后，引擎类库中才支持 tiledmap 3.2 创建TiledMap地图 3.2.1 createMap API 说明 laya.TiledMap类中的createMap方法可以创建一个 TiledMap 地图。基础的参数说明如图3-2所示。 （图3-2） 3.2.2 创建地图示例 const { regClass, property } = Laya; @regClass() export class Main extends Laya.Script { private tMap:Laya.TiledMap; onEnable() { //创建地图对象 this.tMap = new Laya.TiledMap(); //创建Rectangle实例，视口区域 var viewRect:Laya.Rectangle = new Laya.Rectangle(0, 0, Laya.stage.designWidth, Laya.stage.designHeight); //创建TiledMap地图 this.tMap.createMap(\"resources/TiledMap/orthogonal.json\", viewRect, new Laya.Handler(this, this.completeHandler)); } //添加地图到Scene2D下 private onLoaded(): void { this.tMap.mapSprite().removeSelf(); this.owner.addChild(this.tMap.mapSprite()); } //地图加载完成的回调 private completeHandler(e: any = null): void { this.onLoaded(); } } 编译运行代码，效果如图3-3所示，说明地图已创建成功。 （图3-3） 3.3 控制地图 控制地图必须要先加载地图的json，然后在回调方法里控制。下面将结合实例了解相关的用法。 3.3.1 地图的缩放 laya.map.TiledMap类中的scale属性可以控制地图的缩放比例。我们沿用之前的示例，在createMap方法内，增加回调，然后使用scale属性对地图进行缩放。 示例代码如下： private onLoaded():void { this.tMap.mapSprite().removeSelf(); this.owner.addChild(this.tMap.mapSprite()); //将原地图放大2倍 this.tMap.scale = 2; } 运行效果如图3-4所示。 （图3-4） 3.3.2 设置地图缩放的中心点 很明显，图3-4中的效果并不是我们想要的。放大后。有一部分并没有显示出来。这是默认的缩放的中心点是在视口的中心区域造成的。 视口区域与默认的缩放中心点位置 视口区域在创建地图方法 （createMap）的第二个参数中所设置， //创建地图对象 this.tMap = new Laya.TiledMap(); //创建Rectangle实例，视口区域 var viewRect:Laya.Rectangle = new Laya.Rectangle(0, 0, Laya.stage.designWidth, Laya.stage.designHeight); //创建TiledMap地图 this.tMap.createMap(\"resources/TiledMap/orthogonal.json\", viewRect, new Laya.Handler(this, this.completeHandler)); 通过查看代码，我们发现视口被设置为（ Laya.stage.designWidth, Laya.stage.designHeight）。而控制缩放的方法 setViewPortPivotByScale 默认值为0.5。那么中心点位置如图3-5所图。 （图3-5） 当地图放大两倍时（this.tMap.scale = 2;）由于是以视口区域的x与y轴的中心点进行的缩放，所以放大后，会产生图3-6的效果。 （图3-6） 下面我们通过动图3-7，从原图比例的0.1到2倍的缩放变化效果，来进一步理解scale属性的中心点。 （动图3-7） 用setViewPortPivotByScale方法设置缩放中心点 前文中介绍的是默认的缩放中心点效果。那如何设置和改变缩放中心点呢。在laya.map.TiledMap类中的setViewPortPivotByScale()方法可以设置视口的中心点。API基础说明如图3-8所示。 （图3-8） setViewPortPivotByScale() 方法的第一个参数 scaleX 是X轴方向的缩放坐标比例，scaleY 是Y轴方向的缩放坐标比例。 例如： this.tMap.setViewPortPivotByScale(0.1,0.5); 代码说明： 假设视口大小为1136*640 scaleX 值 0.1 表示x轴缩放中心点的坐标为113.6（1136*0.1） scaleY 值 0.5 表示y轴缩放中心点的坐标为320（640*0.5） 代码运行时以x轴113.6，y轴320为视口的中心点坐标进行缩放。 将缩放中心点设置为视口的左上角 当 setViewPortPivotByScale 的缩放中心点设置为0,0时，为视口的左上角。继续沿用前面的示例，编码如下： //添加地图到Scene2D下 private onLoaded(): void { this.tMap.mapSprite().removeSelf(); this.owner.addChild(this.tMap.mapSprite()); //设置缩放中心点为视口的左上角 this.tMap.setViewPortPivotByScale(0,0); //将原地图放大2倍 this.tMap.scale = 2; } 将缩放中心点设置在视口的左上角，再放大2倍时，效果如图3-9所示。 （图3-9） 3.4 拖动地图 当地图被放大后，无法全部显示。这时就需要拖动地图查看全部。 拖动地图除了前文中介绍的方法外，还需要用到moveViewPort()（移动视口）方法和changeViewPort()（改变视口大小）方法。 这两个API的基础说明如图3-10与3-11所示。 （图3-10） （图3-11） 下面直接查看代码，了解这两个方法的使用。 const { regClass, property } = Laya; @regClass() export class Main extends Laya.Script { private tMap:Laya.TiledMap; private MapX:number = 0; private MapY:number = 0; private mLastMouseX:number; private mLastMouseY:number; onEnable() { //创建地图对象 this.tMap = new Laya.TiledMap(); //创建Rectangle实例，视口区域 var viewRect:Laya.Rectangle = new Laya.Rectangle(0, 0, Laya.stage.designWidth, Laya.stage.designHeight); //创建TiledMap地图 this.tMap.createMap(\"resources/TiledMap/orthogonal.json\", viewRect, new Laya.Handler(this, this.completeHandler)); } //添加地图到Scene2D下 private onLoaded(): void { this.tMap.mapSprite().removeSelf(); this.owner.addChild(this.tMap.mapSprite()); //设置缩放中心点为视口的左上角 this.tMap.setViewPortPivotByScale(0,0); //将原地图放大3倍 this.tMap.scale = 3; Laya.stage.on(Laya.Event.RESIZE,this,this.resize); Laya.stage.on(Laya.Event.MOUSE_DOWN, this, this.mouseDown); Laya.stage.on(Laya.Event.MOUSE_UP, this, this.mouseUp); this.resize(); } //地图加载完成的回调 private completeHandler(e: any = null): void { this.onLoaded(); } /** * 移动地图视口 */ private mouseMove():void{ var moveX:number = this.MapX - (Laya.stage.mouseX - this.mLastMouseX); var moveY:number = this.MapY - (Laya.stage.mouseY - this.mLastMouseY) //移动地图视口 this.tMap.moveViewPort(moveX, moveY); } private mouseUp():void { this.MapX = this.MapX - (Laya.stage.mouseX - this.mLastMouseX); this.MapY = this.MapY - (Laya.stage.mouseY - this.mLastMouseY); Laya.stage.off(Laya.Event.MOUSE_MOVE, this, this.mouseMove); } private mouseDown():void { this.mLastMouseX = Laya.stage.mouseX; this.mLastMouseY = Laya.stage.mouseY; Laya.stage.on(Laya.Event.MOUSE_MOVE, this, this.mouseMove); } /** * 改变视口大小 * 重设地图视口区域 */ private resize():void { //改变视口大小 this.tMap.changeViewPort(this.MapX, this.MapY, Laya.stage.designWidth, Laya.stage.designHeight); } } 代码运行效果如动图3-12所示。 （动图3-12） 四、Tiled Map 使用优化 4.1 销毁地图 当Tiled Map不再使用的时候，需要使用destroy()方法进行销毁，回收被占用的内存。 例如： this.tMap.destroy(); 4.2 缓存相关 4.2.1 开启和关闭自动缓存 LayaAir引擎使用TiledMap时，默认会将没有动画的地块自动缓存起来，并且缓存类型默认为normal。 //自动缓存没有动画的地块 this.tMap.autoCache = true; //自动缓存的类型，地图较大时建议使用normal this.tMap.autoCacheType = \"normal\"; //消除缩放导致的缝隙，也就是去黑边 this.tMap.antiCrack = true; 以上的代码属性是引擎的默认值，在多数情况下，保持默认值即可，无需额外设置。 那么为什么要再介绍一遍呢？ 因为有的时候，缓存后的Tiled地图会出现黑边（缝隙）。尽管有 antiCrack 属性，可以消除绝大多数因 normal 缓存导致的黑边。但如果偶现的黑边问题仍未得到解决时。可以通过关闭自动缓存来解决黑边（缝隙）问题。 4.2.2 设置缓存区块大小 缓存区块的设置推荐 TiledMap 地图都是由一个个单元区块拼接组成。如果缓存时保持原大小，当小图区块很多时会对性能产生影响。因此建议开启缓存区块设置，并将缓存区块的大小设置为512像素左右，必须保持原小图区块的整数倍。 例如，本文示例中的单图区块大小为16*16，那么缓存区块可以设置 16的32倍，即为 512*512。 如果单图是15*15，缓存可区块可以设置为510*510（34倍），以此类推，尽量在原区块整数倍的前提下，设置在512左右。推荐为 512*512。 缓存区块的具体设置方法 缓存区块的设置需要在 createMap（创建地图）的时候设置。设置第四个参数 gridSize，示例如下： //为第二个参数创建Rectangle实例，视口区域 var viewRect:Laya.Rectangle = new Laya.Rectangle(0, 0, Laya.Browser.width, Laya.Browser.height); //为第四个参数gridSize创建一个512*512大小的Point对象实例 var gridSize:Laya.Point = new Laya.Point(512, 512); //创建TiledMap地图 this.tMap.createMap(\"res/TiledMap/orthogonal.json\",viewRect, Laya.Handler.create(this,this.onMapLoaded), null, gridSize); 4.3 合并图层 4.3.1 开启合并图层 当 TiledMap 里有多个图层时，开启合并图层的属性 enableMergeLayer，可以将图层合并，会对性能有所提高。 开启的方式为： //开启图层合并 this.tMap.enableMergeLayer = true; Tips: 需要注意的是，如果需要对合并前的图层进行操作，那就不能直接合并。因为合并后会导致无法对合并前的图层进行操作。 4.3.2 图层合并分组 如果没有在 TiledMap 里将图层分组，那么图层合并时，会将所有图层合并到一起。因此，需要分为多个图层并分别操作时。可以在 TiledMap 里将图层分组。 TiledMap图层分组方式 打开 TiledMap 地图编辑器，选中要分组的图层，在图层的自定义属性栏，添加一个名为layer的string类型属性。操作如图4-1所示。 （图4-1） 点击OK，添加完成后，将所有添加了自定义属性layer的图层。设置分组名称。 例如，我们将块层2与块层3的分组名称设置为 layaAir，那么名为 layaAir 的图层，开启 enableMergeLayer 后，会合并到同一个图层。操作如图4-2所示。 (图4-2) 开启合并图层时，图层属性内可添加layer属性，运行时将会将相邻的layer属性相同的图层进行合并以提高性能 4.4 移除被覆盖的格子 如果下层的格子被遮挡，并且遮挡地块并不是透明的，那么被遮挡的部分直接移除而不被渲染，可以提高性能。 移除被覆盖的开启方式为： //移除被非透明地块覆盖的部分 this.tMap.removeCoveredTile = true; Tips： 如果开启后，需要对移除的部分进行操作，是不可能的。所以开启该功能前要确认，不再对移除部分进行操作。 removeCoveredTile 开启的前提 如果在Tiled Map中没有对图块设置 type 属性，那么即便开启了 removeCoveredTile ，也是无效的。所以，开启之前，需要先在 TiledMap 编辑器中，为图块新增自定义属性type，并将设置为1。 Tiled Map中设置图块type的操作方式 在图块面板中，点击图块编辑，打开图块地形编辑面板。操作如图4-3所示。 (图4-3) 在图块地形编辑面板内，选中地形，在自定义属性栏，点击+号图标，添加int类型的type属性。然后点击OK，完成添加。操作如图4-4所示。 (图4-4) 完成添加后，设置type属性值为1。操作如图4-5所示。 (图4-5) 只要是自定义属性type设置为1的地形，当 removeCoveredTile 开启后。被遮挡不可见时都可以被移除，以提高性能。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:43 "},"2D/performanceOptimization/readme.html":{"url":"2D/performanceOptimization/readme.html","title":"2D性能优化","keywords":"","body":"性能优化一、 内存优化方式1.1 通过对象池优化内存1.2 释放内存1.3 资源卸载1.4 关于滤镜、遮罩二、渲染优化方式2.1 优化Sprite2.2 优化DrawCall2.3 优化Canvas2.4 CacheAs2.5 文字描边2.6 跳过文本排版，直接渲染三、减少CPU使用量3.1 减少动态属性查找3.2 性能消耗的回收3.3 获取显示对象边界的做法3.4 根据活动状态改变帧频3.5 使用callLater3.6 图片/图集加载四、其它优化策略4.1 减少粒子的使用数量4.2 Canvas模式尽量减少旋转，缩放，alpha等属性的使用4.3 不要在Timer的循环里创建对象及复杂计算4.4 尽量少用autoSize与getBounds4.5 被try catch的函数执行会变得非常慢五、使用chrome的性能分析器5.1 CPU占用分析5.2 内存占用分析六、纹理压缩的使用性能优化 一、 内存优化方式 1.1 通过对象池优化内存 对象池优化是游戏开发中非常重要的优化方式，也是影响游戏性能的重要因素之一。 在游戏中有许多对象在不停的创建与移除，比如角色攻击子弹、特效的创建与移除，NPC的被消灭与刷新等，在创建过程中非常消耗性能，特别是数量多的情况下。 对象池技术能很好解决以上问题，在对象移除消失的时候回收到对象池，需要新对象的时候直接从对象池中取出使用。 优点是减少了实例化对象时的开销，且能让对象反复使用，减少了新内存分配与垃圾回收器运行的机会。 注意：对象移除时并不是立即从内存中抹去，只有认为内存不足时，才会使用垃圾回收机制清空，清空时很耗内存，很可能就会造成卡顿现象。用了对象池后将减少程序的垃圾对象，有效的提高程序的运行速度和稳定性。 具体使用方式请参考《对象池》文档 1.2 释放内存 JavaScript运行时无法启动垃圾回收器。要确保一个对象能够被回收，需要删除对该对象的所有引用。Sprite提供的destory()方法会帮助设置内部引用为null。 例如，以下代码确保对象能够被作为垃圾回收： //创建一个Sprite实例 var sp:Laya.Sprite = new Laya.Sprite(); //将sp内部引用设置为null sp.destroy(); 当对象设置为null，不会立即将其从内存中删除。只有系统认为内存足够低时，垃圾回收器才会运行。内存分配（而不是对象删除）会触发垃圾回收。 垃圾回收期间可能占用大量CPU并影响性能。通过重用对象，尝试限制使用垃圾回收。此外，尽可能将引用设置为null，以便垃圾回收器用较少时间来查找对象。有时（比如两个对象相互引用），无法同时设置两个引用为null，垃圾回收器将扫描无法被访问到的对象，并将其清除，这会比引用计数更消耗性能。 1.3 资源卸载 游戏运行时总会加载许多资源，这些资源在使用完成后应及时卸载，否则一直残留在内存中。 下例演示加载资源后对比资源卸载前和卸载后的资源状态： var assets: Array = [] assets.push(\"resources/apes/monkey0.png\"); assets.push(\"resources/apes/monkey1.png\"); assets.push(\"resources/apes/monkey2.png\"); assets.push(\"resources/apes/monkey3.png\"); Laya.loader.load(assets).then(()=>{ for(var i:number = 0, len: number = assets.length; i 1.4 关于滤镜、遮罩 尝试尽量减少使用滤镜效果。将滤镜（BlurFilter和GlowFilter）应用于显示对象时，运行时将在内存中创建两张位图。其中每个位图的大小与显示对象相同。将第一个位图创建为显示对象的栅格化版本，然后用于生成应用滤镜的另一个位图： （图1-1） 应用滤镜时内存中的两个位图 当修改滤镜的某个属性或者显示对象时，内存中的两个位图都将更新以创建生成的位图，这两个位图可能会占用大量内存。此外，此过程涉及CPU计算，动态更新时将会降低性能。 ColorFiter在Canvas渲染下需要计算每个像素点，而在WebGL下的GPU消耗可以忽略不计。 最佳的做法是，尽可能使用图像创作工具创建的位图来模拟滤镜。避免在运行时中创建动态位图，可以帮助减少CPU或GPU负载。特别是一张应用了滤镜并且不会在修改的图像。 二、渲染优化方式 2.1 优化Sprite 尽量减少不必要的层次嵌套，减少Sprite数量。 非可见区域的对象尽量从显示列表移除或者设置visible=false。 对于容器内有大量静态内容或者不经常变化的内容（比如按钮），可以对整个容器设置cacheAs属性，能大量减少Sprite的数量，显著提高性能。如果有动态内容，最好和静态内容分开，以便只缓存静态内容。 Panel内，会针对panel区域外的直接子对象（子对象的子对象判断不了）进行不渲染处理，超出panel区域的子对象是不产生消耗的。 2.2 优化DrawCall 对复杂静态内容设置cacheAs，能大量减少DrawCall，使用好cacheAs是游戏优化的关键。 尽量保证同图集的图片渲染顺序是挨着的，如果不同图集交叉渲染，会增加DrawCall数量。 尽量保证同一个面板中的所有资源用一个图集，这样能减少提交批次。 2.3 优化Canvas 在对Canvas优化时，我们需要注意，在以下场合不要使用cacheAs： 对象非常简单，比如一个字或者一个图片，设置cacheAs=”bitmap”不但不提高性能，反而会损失性能。 容器内有经常变化的内容，比如容器内有一个动画或者倒计时，如果再对这个容器设置cacheAs=”bitmap”，会损失性能。 可以通过查看Canvas统计信息的第一个值，判断是否一直在刷新Canvas缓存。 2.4 CacheAs 设置cacheAs可将显示对象缓存为静态图像，当cacheAs时，子对象发生变化，会自动重新缓存，同时也可以手动调用reCache方法更新缓存。 建议把不经常变化的复杂内容，缓存为静态图像，能极大提高渲染性能，cacheAs有”none”，”normal”和”bitmap”三个值可选。 默认为”none”，不做任何缓存。 当值为”normal”时，Canvas下进行画布缓存，webgl模式下进行命令缓存。 当值为”bitmap”时，Canvas下进行依然是画布缓存，webGL模式下使用renderTarget缓存。这里需要注意的是，webGL下renderTarget缓存模式有2048大小限制，超出2048会额外增加内存开销。另外，不断重绘时开销也比较大，但是会减少drawcall，渲染性能最高。 webGL下命令缓存模式只会减少节点遍历及命令组织，不会减少drawcall，性能中等。 设置cacheAs后，还可以设置staticCache=true以阻止自动更新缓存，同时可以手动调用reCache方法更新缓存。 cacheAs主要通过两方面提升性能。一是减少节点遍历和顶点计算；二是减少drawCall。善用cacheAs将是引擎优化性能的利器。 下例绘制10000个文本(根据电脑性能而定，本例为10000)： class Test { private text:Laya.Text; constructor() { Laya.init(550,400,Laya.WebGL); Laya.Stat.show(); var textBox=new Laya.Sprite(); for(var i=0;i 下面是笔者电脑上的运行时截图，FPS稳定于52上下。 （图2-1） 当我们对文字所在的容器设置为cacheAs之后，如下面的例子所示，性能获得较大的提升，FPS达到到了60帧。 //...省略其他代码 var textBox=new Laya.Sprite(); textBox.cacheAs=\"bitmap\"; //...省略其他代码 （图2-2） 2.5 文字描边 在运行时，设置了描边的文本比没有描边的文本多调用一次绘图指令。此时，文本对CPU的使用量和文本的数量成正比。因此，尽量使用替代方案来完成同样的需求。 · 对于几乎不变动的文本内容，可以使用cacheAs降低性能消耗 · 对于内容经常变动，但是使用的字符数量较少的文本域，可以选择使用位图字体。 2.6 跳过文本排版，直接渲染 大多数情况下，很多文本都不需要复杂的排版，仅仅简单地显示一行字。为了迎合这一需求，Text提供的名为changeText的方法可以直接跳过排版。 this.text.text=\"text\"; Laya.stage.addChild(this.text); //后面只是更新文字内容，使用changeText能提高性能 this.text.changeText(\"text changed.\"); Text.changeText会直接修改绘图指令中该文本绘制的最后一条指令，这种前面的绘图指令依旧存在的行为会导致changeText只使用于以下情况： · 文本始终只有一行。 · 文本的样式始终不变（颜色、粗细、斜体、对齐等等）。 即使如此，实际编程中依旧会经常使用到这样的需要。 三、减少CPU使用量 3.1 减少动态属性查找 JavaScript中任何对象都是动态的，你可以任意地添加属性。然而，在大量的属性里查找某属性可能很耗时。如果需要频繁使用某个属性值，可以使用局部变量来保存它： foo() { var prop=this.target.prop; //使用prop this.process1(prop); this.process2(prop); this.process3(prop); } 3.2 性能消耗的回收 日常在使用消耗性能的功能时，尤其是循环处理，当无需使用时，一定要及时回收，或停止循环。 LayaAir提供两种计时器循环来执行代码块。 Laya.timer.frameLoop执行频率依赖于帧频率，可通过Stat.FPS查看当前帧频。 Laya.timer.loop执行频率依赖于参数指定时间。 Laya.timer.frameLoop(1, this, this.animateFrameRateBased); Laya.stage.on(\"click\", this, this.dispose); dispose() { Laya.timer.clear(this, this.animateFrameRateBased); } 当一个对象的生命周期结束时，记得清除其内部的Timer 3.3 获取显示对象边界的做法 在相对布局中，很经常需要正确地获取显示对象的边界。获取显示对象的边界也有多种做法，而其间差异很有必要知道。 使用getBounds/ getGraphicBounds。 var sp=new Laya.Sprite(); sp.graphics.drawRect(0,0,100,100,\"#FF0000\"); var bounds:Laya.Rectangle=sp.getGraphicBounds(); Laya.stage.addChild(sp); getBounds可以满足多数多数需求，但由于其需要计算边界，不适合频繁调用。 设置容器的autoSize为true。 var sp=new Laya.Sprite(); sp.autoSize=true; sp.graphics.drawRect(0,0,100,100,\"#FF0000\"); Laya.stage.addChild(sp); 上述代码可以在运行时正确获取宽高。autoSize在获取宽高并且显示列表的状态发生改变时会重新计算（autoSize通过getBoudns计算宽高）。所以对拥有大量子对象的容器应用autoSize是不可取的。如果设置了size，autoSize将不起效。 使用loadImage后获取宽高： var sp=new Laya.Sprite(); sp.loadImage(\"res/apes/monkey2.png\",0,0,0,0,Laya.Handler.create(this,function() { console.log(sp.width,sp.height); })); Laya.stage.addChild(sp); loadImage在加载完成的回调函数触发之后才可以正确获取宽高。 直接调用size设置： Laya.loader.load(\"res/apes/monkey2.png\",Laya.Handler.create(this,function() { var texture=Laya.loader.getRes(\"res/apes/monkey2.png\"); var sp=new Laya.Sprite(); sp.graphics.drawTexture(texture,0,0); sp.size(texture.width,texture.height); Laya.stage.addChild(sp); })); 使用Graphics.drawTexture并不会自动设置容器的宽高，但是可以使用Texture的宽高赋予容器。毋庸置疑，这是最高效的方式。 注：getGraphicsBounds用于获取矢量绘图宽高。 3.4 根据活动状态改变帧频 帧频有三种模式， Stage.FRAME_FAST fast模式，最高FPS为显示器的最大帧率，如果显示器最大帧率是60，则最大FPS为60，显示器最大帧率是120，则最大FPS为120。 Stage.FRAME_SLOW slow模式，最高FPS为显示器最大帧率的一半，在游戏运行的过程中，引擎会隔帧丢弃。如果实际可以达到40帧，那游戏最终帧率只是20，如果帧率能达到100，那最终帧只能是50。 Stage.FRAME_MOUSE mouse模式则选择性在fast模式与slow模式之间切换，有时并不需要让游戏以满帧速率执行，比如60帧满帧的时候，30FPS已经能够满足多数情况下人类视觉的响应，但是鼠标交互时，30FPS可能会造成画面的不连贯，于是Stage.FRAME_MOUSE应运而生。 下例展示以Stage.FRAME_SLOW的帧率，在画布上移动鼠标，使圆球跟随鼠标移动： Laya.init(this.Browser.width,this.Browser.height); Laya.Stat.show(); Laya.stage.frameRate=Laya.Stage.FRAME_SLOW; var sp=new Laya.Sprite(); sp.graphics.drawCircle(0,0,20,\"#990000\"); Laya.stage.addChild(sp); Laya.stage.on(Laya.Event.MOUSE_MOVE,this,function() { sp.pos(Laya.stage.mouseX,Laya.stage.mouseY); }); （图3-1） 此时FPS显示30，并且在鼠标移动时，可以感觉到圆球位置的更新不连贯。设置Stage.frameRate为Stage.FRAME_MOUSE： Laya.stage.frameRate = Laya.Stage.FRAME_MOUSE; （图3-2） 此时在鼠标移动后FPS会显示60，并且画面流畅度提升。在鼠标静止2秒不动后，FPS又会恢复到30帧。 3.5 使用callLater callLater使代码块延迟至本帧渲染前执行。如果当前的操作频繁改变某对象的状态，此时可以考虑使用callLater，以减少重复计算。 考虑一个图形，对它设置任何改变外观的属性都将导致图形重绘： var rotation=0, scale=1, position=0; private function setRotation(value):void { this.rotation=value; update(); } private function setScale(value):void { this.scale = value; update(); } private function setPosition(value):void { this.position = value; update(); } public function update() { console.log('rotation: ' + this.rotation + '\\tscale: ' + this.scale + '\\tposition: ' + this.position); } 调用以下代码更改状态： setRotation(90); setScale(2); setPosition(30); 控制台的打印结果是: rotation: 90scale: 1position: 0 rotation: 90scale: 2position: 0 rotation: 90scale: 2position: 30 update被调用了三次，并且最后的结果是正确的，但是前面两次调用都是不需要的。 尝试将三处update改为： Laya.timer.callLater(this, update); 此时，update只会调用一次，并且是我们想要的结果。 3.6 图片/图集加载 在完成图片/图集的加载之后，引擎就会开始处理图片资源。如果加载的是一张图集，会处理每张子图片。如果一次性处理大量的图片，这个过程可能会造成长时间的卡顿。 在游戏的资源加载中，可以将资源按照关卡、场景等分类加载。在同一时间处理的图片越少，当时的游戏响应速度也会更快。在资源使用完成后，也可以予以卸载，释放内存。 四、其它优化策略 4.1 减少粒子的使用数量 由于粒子属于矢量绘制，大量使用粒子对CPU压力大，在移动平台Canvas模式下，尽量不用粒子； WebGL模式下可以采用GPU运算，能减轻CPU压力，但也要尽量控制，减少使用量。 4.2 Canvas模式尽量减少旋转，缩放，alpha等属性的使用 在Canvas模式下，尽量减少旋转，缩放，alpha等属性的使用，这些属性会对性能产生消耗。 如要使用，建议在WebGL模式下使用； 4.3 不要在Timer的循环里创建对象及复杂计算 由于Timer的loop()与frameLoop()方法里会不断的循环执行，当创建对象及复杂计算时，会导致大量的性能消耗出现在循环里，因此，尽可能不要在循环里创建对象及复杂计算。 4.4 尽量少用autoSize与getBounds autoSize()与getBounds()需要大量计算，对性能的影响较大，尽量少用。 4.5 被try catch的函数执行会变得非常慢 项目中尽量减少try catch的使用，被try catch的函数执行会变得非常慢。 五、使用chrome的性能分析器 性能分析器（Profiles）是 chrome 开发者工具的一部分，可以通过在页面右键选择审查元素或在谷歌浏览器页面按F12 打开 chrome 开发者工具。然后点击 Profiles 切换至性能分析器（Profiles）面板。 5.1 CPU占用分析 启动CPU性能分析器 选中 Record JavaScript CPU Profile，点击 Start 按钮或左上角的实心圆点，这个时候Chrome 就会开始记录当前网页的方法的执行。如图5-1所示。 （图5-1） 结束CPU性能分析器的监控 结束这个性能分析器的监控记录需要点击Stop按钮（或左侧的红色实心圆圈）。如图5-2所示。 （图5-2） 查看CPU性能分析器的记录 结束监控后，在左侧 Profiles 下会列出一个监控结果文件，单击可以打开此监控结果文件。如图5-3所示 （图5-3） 监控结果是以数据表格形式展现的。我们可以根据消耗排行，找到Function中提供的函数名，针对性能消耗较大的地方进行优化。 5.2 内存占用分析 启动内存分析 选中 Take Heap Snapshot，点击 Take Snapshot 按钮（也可以点击左边黑色实心圆圈），如图5-4所示， （图5-4） 生成的内存快照文件是以数据表格的形式记录了，当前网页对象的个数、所占的内存大小等。 内存快照记录 在启动内存分析后，很快就会在左侧的 Profiles 栏目下生成一个当前网页的内存快照记录文件。单击可以查看相关数据，如图5-5所示。 （图5-5） 内存快照分析 在拍完第一个内存快照后，点击左上角的圆点，可以记录一个新的内存快照。单击选择第二个内存快照，可以选择 Comparison 模式对此第二个快照与第一个快照之间的变化。通过分析，对网页进行优化。 （图5-6） （图5-7） 六、纹理压缩的使用 使用纹理压缩的好处： 1，降低内存，特别是移动端应用，内存占用不应过大，否则低端机很容易崩溃 2，降低带宽，手游类应用，在渲染时会有大量贴图传输到GPU，不限制的话不仅会严重影响渲染性能，同时会带来很严重的发热 具体使用方式请参考《纹理压缩》文档 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:43 "},"2D/useWorker/readme.html":{"url":"2D/useWorker/readme.html","title":"多线程Worker","keywords":"","body":"多线程worker原生worker属性Laya中应用多线程worker 本文档中的worker仅限于浏览器模式中的HTML5模式运行支持，LayaNative打包APP方案中暂不支持worker 从传统意义上来说，浏览器是单线程的，它们会强制应用程序中的所有脚本一起在单个 UI 线程中运行。虽然你可以通过使用文档对象模型 (DOM) 事件和 setTimeout等API 造成一种多个任务同时在运行的假象，但只需一个计算密集型任务就会使用户体验急转直下。在html5引入了worker的功能，通过使用Web Worker， 我们可以在浏览器后台运行JavaScript， 而不占用浏览器自身线程。Web Worker可以提高应用的总体性能，并且提升用户体验。线程可以执行任务而不干扰用户界面。 原生worker web worker分为两种，专用线程dedicated web worker，以及共享线程shared web worker。 Dedicated web worker随当前页面的关闭而结束；这意味着Dedicated web worker只能被创建它的页面访问。与之相对应的Shared web worker可以被多个页面访问。但是web worker有些限制，并非所有的接口和方法都能使用。 Web Worker无法访问DOM节点； Web Worker无法访问全局变量或是全局函数； Web Worker无法调用alert()或者confirm之类的函数； Web Worker无法访问window、document之类的浏览器全局变量； workder 支持的函数 页面提供了一个 worker 支持的全局函数列表。开发者可以自己看下相应的方法。 方法概述 构造函数Worker() 该构造函数创建一个 web worker，它能执行位于指定 URL 上的脚本。脚本必须遵循 同源策略。 postMessage()： 向 worker 的内部作用域内传递消息。该方法接收一个单独的参数，即要传递给 worker 的数据。数据可以是任何值或者是经过结构化拷贝算法处理过的 JavaScript 对象，换句话说，可以包含循环引用。 #参数 aMessage 传输给 worker 的对象；它将包含于传递给 onmessage 处理函数的事件对象中的 data 字段内。你可以传递任意值或是经过结构化拷贝算法处理过的 JavaScript 对象，即可以包含循环引用。 transferList 一个可选的对象数组，用于转让它们的所有权。如果一个对象的所有权被转让，那么它在原来的上下文内将不可使用，而只能在转让到的 worker 内可用。 terminate() 立即终止 worker。该方法不会给 worker 留下任何完成操作的机会；就是简单的立即停止 属性 Property Type Description onmessage EventListener 一个事件监听函数，每当拥有message属性的MessageEvent从worker中冒泡出来时就会执行该函数。事件的data属性存有消息内容。 onerror EventListener 一个事件监听函数，每当类型为error的ErrorEvent 从 worker 中冒泡出来时就会执行该函数。 下面我们用原生js看下如何使用。 新建一个js文件，放到index.html中。代码如下： var myWorker = new Worker(\"js/my_task.js\"); myWorker.onmessage = function (oEvent) { console.log(\"Called back by the worker!\\n\"); }; myWorker.postMessage(\"start\"); // start the worker. 新建一个my_task.js文件，放到js文件夹下，代码如下： self.addEventListener('message', function (e) { var xmlreq = new XMLHttpRequest(); xmlreq.responseType = \"text\"; xmlreq.onload = function (e) { var data = e.currentTarget.response; self.postMessage(data); } xmlreq.open(\"get\",\"../atlas/comp.json\"); xmlreq.send() }, false); 这个例子是在worker中进行加载文件，加载完毕传给主进程，运行这个例子可以在浏览器控制台看到数据输出来。 var myWorker = new Worker(\"my_task.js\")实例化一个worker，传进去一个js文件，通过myWorker.postMessage(\"start\")通知worker线程启动。 self.addEventListener('message',xxx)监听主线程通知的消息。 self.postMessage(data);发送数据给主线程。 注意：web worker不支持文件协议，所以直接打开是不能运行的，开发者可以配合IDE内置的服务器，通过网址来运行就可以看到效果。打开控制台可以看到数据已经打印出来了。 Laya中应用 在LayaAir3.0中内部封装了worker，解决加载解码图片卡顿现象，开发者可以打开开关，也可以自定义worker，解决项目中耗费cpu的地方，下面我们分别来介绍下。 新建一个项目，为了方便显示，我们新建一个ui项目。简单的调用接口如下： class LayaUISample { constructor() { //初始化引擎 Laya.init(600,400,Laya.WebGL); //设置Laya提供的worker.js路径 Laya.WorkerLoader.workerPath = \"libs/worker.js\"; //开启worker线程 Laya.WorkerLoader.enable = true; //加载引擎需要的资源 Laya.loader.load(\"../atlas/comp.atlas\",Laya.Handler.create(this,this.onLoaded)); } private onLoaded():void{ //实例UI界面 var testView:ui.test.TestPageUI = new ui.test.TestPageUI(); Laya.stage.addChild(testView); } } new LayaUISample; WorkerLoader.workerPath = \"libs/worker.js\"; 设置worker.js的路径，这个worker.js是Laya官方提供的，我们把他拷贝复制到我们自己设置的路径，这个js在Laya的引擎库当中。我这里设置的是libs下。 WorkerLoader.enable = true; 开启worker模式加载解码图片，大大解放了主线程解码的压力。 上面的方法是2.0官方的解码的做法，在LayaAir3.0中我们也可以自定义worker来优化项目当中的耗费cpu的地方。 下面通过简单的例子来演示下用法。我们可以把教程开头的js脚本移植过来。 var worker:any = Laya.Browser.window.Worker(\"js/my_task.js\"); worker.onmessage = function(oEvent):void{ console.log(\"Called back by the worker!\\n\"); }; worker.postMessage(\"start\"); // start the worker. my_task.js中的代码还是加载一个文件。代码如下： self.addEventListener('message', function (e) { var xmlreq = new XMLHttpRequest(); xmlreq.responseType = \"text\"; xmlreq.onload = function (e) { var data = e.currentTarget.response; self.postMessage(data); } xmlreq.open(\"get\",\"../atlas/comp.atlas\"); xmlreq.send() }, false); 编译运行代码，可以看到控制台输出了我们加载comp.atlas的数据。 总结：web worker我们一般应用到解析加载大的文件，比如大的json文件，比较费时的计算，或者不需要即时加载的一些资源都可以放到后台线程来完成，这样用户基本感受不到主线程的卡顿。增强项目的流畅性。提高用户体验。 详细的Web Workers，请看 W3C的xhr 标准; 详细的api和介绍参考这里 workder 支持的函数 页面提供了一个 worker 支持的全局函数列表。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-05-11 21:27:15 "},"2D/dom/readme.html":{"url":"2D/dom/readme.html","title":"和原生Dom交互","keywords":"","body":"LayaAir和原生DomLayaAir之SVGLayaAir之Dom元素ImageLayaAir之Dom元素videoLayaAir之dom元素FileLayaAir之dom元素script标签LayaAir之dom元素iframeLayaAir和原生Dom 在开发项目中，开发者难免遇到dom元素支持，但是LayaAir中不支持或者支持的不完善。那么本节我们就来看下在开发中遇到的一些技巧。 LayaAir之SVG 什么是svg？可能大部分开发者听说过这个名词，或者也知道它是w3c规定的矢量图像描述格式。关于svg的一些定义和历史这里我们不再陈述，感兴趣的开发者可以参考这里。但是在项目中真正用到它的地方很少。但是svg的强大是不容忽视的，有些简单的图形，几行文本就可以描述出来，不必进行网络的加载。比如丰富的艺术字，比如奇形怪状的图形，比如文字的透视效果等等假如用程序实现，可能会困难重重，比如下面这个： 假如你的项目中有这种文字如何处理呢？可能我们想到的是美术出图片。那有没有更简单的方法呢？这里我们选择用svg来进行处理。我们知道在dom元素中用div+css样式来显示这种效果是最简单快捷的方法。那么我们来借助css样式来展示这种效果。下面我们看下简单的脚本怎么实现这种效果。 var data = '' + '' + '' + 'I like ' + '' + 'cheese' + '' + '' + ''; var DOMURL = window.URL || window.webkitURL || window; var img = new Image(); var svg = new Blob([data], {type: 'image/svg+xml'}); var url = DOMURL.createObjectURL(svg); img.src = url; img.style.position =\"absolute\"; img.style.zIndex = 99999 document.body.appendChild(img); 怎么运行上边这段代码呢？打开谷歌浏览器，随便打开一个空白网页，F12，把上面的代码粘贴到控制台，然后回车，就能看到上面截图的效果。或者新建个html把代码粘贴进去，用浏览器打开。是不是很简单呢？然后我们可以任意修改显示的文字。开发者可以修改试试看效果。我们简单的介绍下这段代码。其中data是svg的数据格式，这个可以参考svg的定义和描述。 //这里是重点，文字的效果我们是通过svg支持的css样式来设置 text-shadow设置的是文字的css样式效果，假如开发者想改变文字的样式，可以修改style即可。 上面是在JavaScript中，用原生的dom元素img来进行显示，那么在游戏中我们想用的话该怎么办呢？这个其实很简单，现在我们已经用img显示到页面上了，那么接下来我们要做的是如何在项目中应用和显示这个img。我们新建个项目。代码如下所示： var data: string = \"data:image/svg+xml,\" + '' + '' + '' + 'I like ' + '' + 'cheese' + '' + '' + ''; var sp: Laya.Sprite = new Laya.Sprite(); sp.loadImage(data, 0, 0, 200, 200); Laya.stage.addChild(sp); 通过data来当做url传递给loadImage这个方法引擎就会帮我们加载并解码显示出来。loadImage这个方法中的参数不仅仅有接收地址的url还接收base64和svg的格式。编译运行上面的代码我们看到下图中的效果。 总结：上面的代码给我们很好的启示，在项目中我们的特殊艺术字可以用这种方法更加简单方便。开发者可以自行找一些更加绚丽的效果，比如3D的透视效果，图文混排，阴影，倒影等等。这种方法不仅仅减少了网络的宽带，更重要的是方便我们时时修改。设置好一种样式，项目中导出都可以应用。假如用上面的方法代替位图字体的做法是不是更加高效快捷呢。 LayaAir之Dom元素Image 在html5中，image标签功能强大，这里我们不想过多的介绍其特性，这里我们介绍简单的击中常用形式。 二维码 比较常见的一种功能是在项目中显示当前的二维码地址。用户长按可以识别。这里生成二维码，我们借助第三方的js类库来生成二维码。类库代码可以再GitHub上下载，这里用的是这个地址。 新建个项目，把下载的qrcode.js添加到index.html中。qrcode的api请参考地址。具体的逻辑代码如下： var div:any = Laya.Browser.document.createElement(\"div\"); this.qrcode = new Laya.Browser.window.QRCode(div,{ width:100, height:100 }); var url:string = \"http://layabox.com/\"; this.qrcode.makeCode(url); Laya.stage.once(\"click\",this,this.clickHandler); this.qrcodeSp = new Laya.Sprite(); Laya.stage.addChild(this.qrcodeSp); 编译运行上面的代码，然后点击舞台可以看到，二维码已经显示到了舞台上，可以用手机扫下，发现手机已经跳转到了官网。注意：这个时候生成的二维码在微信或者浏览器中长按没有任何反应，因为qrcode生成的是canvas标签而不是image标签。所以要想长按弹出识别的选项，只有用image标签才可以。这个开发者可以自行扩展。 LayaAir之Dom元素video 视频直播 在html5时代，视频播放基本用的是video标签来播放，视频播放假如没有丰富的经验，最好的选择是用成熟的播放插件来实现。目前流行的是video.js, hls.js, plyr.js。无论在兼容性，体验和性能方面都是非常优秀的。这些插件的官方都给出了的demo。比如https://plyr.io/，http://video-dev.github.io/hls.js/demo/，http://codepen.io/sampotts/pen/JKEMqB。 下面我们就以Plyr + hls.js来为例子，看看在LayaAir中我们应该怎么写。 在index.html文件中加入如下代码： 播放器的样式文件， 添加video标签。命名id为“player”，这个一会我们在程序中会用到。 这是播放器用到的类库。开发者在生产环境中记得下载到自己的项目中或者服务器中。 下面是主类的逻辑： class LayaUISample { constructor() { //初始化引擎 Laya.init(0,0); var Hls:any = Laya.Browser.window.Hls;//获取对Hls的引用。 var plyr:any = Laya.Browser.window.plyr;//获取对plyr的引用 //获取video对象，就是页面上命名为“player”的标签 var video:any = Laya.Browser.document.querySelector('#player'); if(Hls.isSupported()){ var hls:any = new Hls(); //加载m3u8源 hls.loadSource('http://content.jwplatform.com/manifests/vM7nH0Kl.m3u8'); hls.attachMedia(video); hls.on(Hls.Events.MANIFEST_PARSED,function():void{ video.play(); }); } plyr.setup(video); } } new LayaUISample; 编译运行代码，发现网页已经可以播放视频了。开发者可能注意到这里我们初始化引擎的时候是这样的： Laya.init(0,0);//初始化引擎;设置尺寸为0，因为这里我们没有和舞台的交互。所以我们这里设置为0，我们甚至可以不初始化。假如开发者项目中含有和舞台交互的逻辑，可以设置适合自己的尺寸。 在播放的过程中开发者可以F12 打开谷歌的控制台，切换到Network标签看下我们的视频是一段段的ts文件。 随着播放的进行，发现文件的个数越来越多。其实这就是基于hls协议的播放。该技术基本原理是将视频文件或视频流切分成小片(ts)并建立索引文件(m3u8)。更深层次的原理，比如视频解码，视频帧数据，开发者可以参考如下： https://developer.apple.com/streaming/。 https://developer.mozilla.org/zh_CN/docs/Web/API/MediaSource。 https://github.com/nickdesaulniers/netfix https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement 上面的例子我们使用hls+plyr来进行播放。其他的方法请开发者参考本教程进行扩展。 摄像头 html5的video做摄像头浏览器的支持度是有限的，而且需要https的协议谷歌和新版的微信支持度还是不错的。假如你的兼容性不要求那么高，可以尝试下添加摄像头的功能。 下面我们先来看下mdn上给的例子。 https://mdn.github.io/webaudio-examples/stream-source-buffer/ 开发者用手机或者微信打开这个地址测试下你手机的支持度。 这个是个测试的连接，协议也是https的，开发者在调用摄像头的时候要注意这一点。自己的远端地址一定要https。 更多的资料可以参考这里:https://github.com/mdn/webaudio-examples 这里的链接是mdn给出的声音和视频的例子。 LayaAir关于摄像头也有相应的封装，下面我们来看下用法。 class Main { private video:Laya.Video; constructor() { //初始化引擎 Laya.init(Laya.Browser.width,Laya.Browser.height); if(Laya.Media.supported() === false){ alert(\"当前浏览器不支持\"); } else{ this.showMessage(); var options:any = { audio:true, video:{ facingMode: { exact: \"environment\" }, // 后置摄像头，默认值就是，不设至也可以。 width: Laya.stage.width, height:Laya.stage.height } }; Laya.Media.getMedia(options,Laya.Handler.create(this,this.onSuccess),Laya.Handler.create(this,this.onError)); } } private showMessage():void{ var tex:Laya.Text = new Laya.Text(); Laya.stage.addChild(tex); tex.text = \"单击舞台播放和暂停\"; tex.color = \"#ffffff\"; tex.fontSize = 100; tex.valign = \"middle\"; tex.align = \"center\"; tex.size(Laya.stage.width,Laya.stage.height); } private onSuccess(url:string):void{ this.video = new Laya.Video(Laya.stage.width,Laya.stage.height); this.video.load(url); Laya.stage.addChild(this.video); Laya.stage.on(\"click\",this,this.onStageClick); } private onerror(error:Error):void{ alert(error.message); } private onStageClick():void{ //切换播放和暂停 if(!this.video.paused){ this.video.pause(); } else{ this.video.play(); } } } new Main; 编译运行上面的例子，发现打不开。这很正常，运行这个例子要自己搭建一个https的服务器。然后用手机打开这个地址对应的index.html。搭建一个简单的htpps服务器也很简单。这里我们借助Laya的命令行工具就可以。 下载地址https://nodejs.org/en/进行安装。 安装完成之后 打开cmd 命令行，输入 npm install -g layacmd 等待安装完成。 找到我们刚才编译的那个index.html。按住shift+右键 在此处打开cmd窗口 输入layacmd open ，然后就会启动一个http和htpps的静态服务器，根据命令行输出的地址，然后我们用手机谷歌浏览器或者微信访问这个地址 比如我们这里是https://10.10.20.34:8001/index.html。 LayaAir之dom元素File 在项目开发中我们可能会用到让用户上传图片的需求。这个我们需要借助html5的file标签（微信的要用微信提供的接口，后面的教程我们专门在微信教程中讲。其他浏览器也可能存在兼容性问题）。下面我们写的简单的例子。 class Main { private video:Laya.Video; constructor() { //初始化引擎 Laya.init(100,100); var file:any = Laya.Browser.document.createElement(\"input\"); file.type = \"file\"; file.style.position = \"absolute\"; file.style.zIndex = 999; Laya.Browser.document.body.appendChild(file);//添加到舞台 var fileReader:any = new Laya.Browser.window.FileReader(); file.onchange = function(e:any):void { if(file.files.length){ fileReader.readAsDataURL(file.files[0]); } }; fileReader.onload = function(evt):void { if(Laya.Browser.window.FileReader.DONE == fileReader.readyState) { var sp:Laya.Sprite = new Laya.Sprite(); sp.loadImage(fileReader.result,0,0,300,300); Laya.stage.addChild(sp); } } } } new Main; 编译上面的代码，点击按钮。选择一个图片文件或者相机进行拍照，发现图片已经显示到舞台上了。那么一个简单的调用相册或者相机的程序就这样完成了。但是我们发现这个“按钮”非常丑陋。那么怎么改变这个按钮样式呢?这个就需要借助css样式来处理下。传统的做法就是把这个按钮的透明值设置为0，然后在放一个和他重合的按钮来代替。通过这样的假象来改变他的样式，其实实际点击的还是他。只不过用户感觉不到。那么我们就来修改下，看看怎么改变样式。 //创建隐藏的file并且把它和按钮对齐。达到位置一致，这里我们默认在0点位置 var file:any = Laya.Browser.document.createElement(\"input\"); //设置file样式 file.style=\"filter:alpha(opacity=0);opacity:0;width: 150px;height:60px;\"; file.type =\"file\";//设置类型是file类型。 file.accept=\"image/png\";//设置文件的格式为png； file.style.position =\"absolute\"; file.style.zIndex = 999; 下面看下完整的代码： class Main { private video:Laya.Video; constructor() { //初始化引擎 Laya.init(100,100); var skins:any = [\"res/a.png\"]; Laya.loader.load(skins,Laya.Handler.create(this,this.onUIAssetsLoaded)); } private onUIAssetsLoaded():void{ var btn:Laya.Button = new Laya.Button(\"res/a.png\"); Laya.stage.addChild(btn); //创建隐藏的file并且把它和按钮对齐。达到位置一致，这里我们默认在0点位置 var file:any = Laya.Browser.document.createElement(\"input\"); //设置file样式 file.style=\"filter:alpha(opacity=0);opacity:0;width: 150px;height:60px;\"; file.type =\"file\";//设置类型是file类型。 file.accept=\"image/png\";//设置文件的格式为png； file.style.position =\"absolute\"; file.style.zIndex = 999; Laya.Browser.document.body.appendChild(file);//添加到页面； var fileReader:any = new Laya.Browser.window.FileReader(); file.onchange = function(e:any):void { if(file.files.length>0) { fileReader.readAsDataURL(file.files[0]); } }; fileReader.onload = function(evt):void { if(Laya.Browser.window.FileReader.DONE == fileReader.readyState) { var sp:Laya.Sprite = new Laya.Sprite(); sp.loadImage(fileReader.result,0,0,100,100); Laya.stage.addChild(sp); } }; } } new Main; 编译运行代码，可以看到，那个丑陋的dom按钮不见了。我们点击我们自定义的按钮，一样可以选择图片，显示到舞台上。 上面的例子我们是把它在原点重合，设置透明度为0,伪装成了不可见。开发者可以试着放到其他的位置来测试下，本节教程不在具体实现。关于file的其他api请参考mdn和w3c相关说明。除了显示到舞台上，可能还有上传服务器的操作，这时候可以用FormData。这个开发者可以尝试下。 LayaAir之dom元素script标签 有时候我们项目的js文件很多，很大，一次性的全部加载进来不仅仅是流量的浪费，还会造成页面的卡顿，导致极差的用户体验。用压缩混淆的方式虽然能减小些，但是稍微大一点的项目，代码量就会很大。或者地方的js文件，首屏加载时不必要的，这时候我们就需要自适当的时候在加载，因此拆分文件和模块非常必要。拆分文件，就会涉及到即用即加载。那么这时候script标签就会派上用场。 通过script的src来加载远端脚本，可以实现这种功能。也可以通过设置script的innerHTML来实现，当然还有第三种eval。下面我们就这几种情况分别说明下用法。 通过设置src来实现 script的创建可以手动添加到页面，也可以代码动态的创建。这里我们以代码创建为例子进行说明。我们先上代码. 代码逻辑如下： class Main { private video:Laya.Video; constructor() { //初始化引擎 Laya.init(500,500); var script:any = Laya.Browser.document.createElement(\"script\"); script.src = \"demo1.js\"; script.onload = function():void{ //加载完成函数，开始调用模块的功能。 //new一个js中的对象 var client:any = new Laya.Browser.window.Demo1(); client.start(); } script.onerror = function():void{ //加载错误函数 } Laya.Browser.document.body.appendChild(script); } } new Main; 然后再新建一个js文件，简单代码如下： var Demo1 = (function () { function Client() { } Client.prototype.start = function () { // body... console.log(\"调用方法\"); }; return Client; })(); console.log(\"我被加载进来了\"); 下面我们简单的讲解下这两段代码。 var script:any = Laya.Browser.document.createElement(\"script\");创建一个script标签。 script.src = \"demo1.js\";设置要加载的js的路径。 script.onload = ......和script.onerror =....分别是加载完成和加载失败的回调函数。 Laya.Browser.document.body.appendChild(script);把创建的script标签添加到页面。 var client:any = new Laya.Browser.window.Demo1();实例化js声明的那个类。 client.start();调用实例的函数。 编译运行上面的代码。打开谷歌的控制台，可以看到输出： “我被加载进来了” “调用方法” 通过script的innerHTML设置 设置innerHTML其实就是把js的文本格式赋值给innerHTML。这个我们可以通过加载文件的格式把远端加载的文件转换成文本内容赋值给标签。下面看下例子。 class Main { private video:Laya.Video; constructor() { //初始化引擎 Laya.init(500,500); var httpreq:Laya.HttpRequest = new Laya.HttpRequest(); httpreq.on(Laya.Event.COMPLETE,this,this.completeHandler); httpreq.on(Laya.Event.ERROR,this,this.errorHandler); httpreq.send(\"demo1.js\"); } private completeHandler(e:any):void{ var script:any = Laya.Browser.document.createElement(\"script\"); Laya.Browser.document.body.appendChild(script); script.innerHTML = e; var client:any = new Laya.Browser.window.Demo1(); client.start(); } private errorHandler(e:any):void{ } } new Main; 编译运行上面的代码，可以看到效果和用src加载的效果是一样的。这个例子是用HttpRequest来加载文件然后把加载的内容赋值给script.innerHTML。标签自行解析执行js。当然本例子是用的HttpRequest来加载，开发者也可以用Laya.loader.load的方法来进行加载。 eval方法进行加载 private completeHandler(e:any):void { Laya.Browser.window.eval(e); var client:any = new Laya.Browser.window.Demo1(); client.start(); } 我们把前面的加载完成函数改上面的 `Laya.Browser.window.eval(e);` 然后编译，打开控制台，发现效果是一样的。这个和script标签已经没有什么关系了。 总结:上面的三种常用的方法都可以实现动态加载js文件。三种方法有什么不同呢？ - script标签src的方式加载的是js文件，这个js文件可以和当前页面不同源，也就是说可以跨域加载。 - script.innerHTML的方法接收的是一段js文件的文本格式，用的是XMLHttpRequest方式进行加载，所以文件不能跨域，或者说允许加载才可以，优点就是这个js文件可以自定义格式，比如进行加密，穿插别的格式，然后用二进制的格式进行加载，在程序中在解码成真正的js。 - eval的方法和script.innerHTML的方式基本差不多。加载的内容也是很随意。不过不推荐eval这种方式，eval是快被废弃的方法，无论在性能还是安全性方面都是不推荐使用的。具体的原因请看mdn的解释 [https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval。](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval) **其实加载的方式我们还可以放到worker中去，这样更加的减少了页面的渲染压力和卡顿现象。开发者可以阅读worker的教程进行发散。** ### LayaAir之dom元素声音 说起html5的声音，开发者可能第一个想到的是audio标签，但是audio标签对于开发项目极其鸡肋，今天我们讲到的是另一个接口，HTML5提供给JavaScript编程用的Audio API则让我们有能力在代码中直接操作原始的音频流数据，对其进行任意加工再造。音频的api，w3c给我提供了足够的[接口](https://www.w3.org/TR/webaudio/)，在[mdn](https://developer.mozilla.org/zh-CN/docs/Web/API/AudioContext)上面介绍的也比较详细。在支持比较完善的浏览器上，声音的api能做出的视觉效果极其丰富。由于声音的api极其丰富，我们这里就抛砖引玉，简单介绍下用法，至于音频的合成，混音，音效，音频数据进行频谱分析，音频加上滤镜比如提高音色等开发者可以查阅mdn或者相关资料。 我们先看下mdn上的一个例子。在这个例子中, 创建一个2秒的缓冲器,并用白噪音填充它, 然后通过[`AudioBufferSourceNode`](https://developer.mozilla.org/zh-CN/docs/Web/API/AudioBufferSourceNode)来播放它. 注释里说明了它的功能。 ```javascript var audioCtx = new (window.AudioContext || window.webkitAudioContext)(); // Stereo var channels = 2; // Create an empty two-second stereo buffer at the // sample rate of the AudioContext var frameCount = audioCtx.sampleRate * 2.0; var myArrayBuffer = audioCtx.createBuffer(2, frameCount, audioCtx.sampleRate); window.onclick = function() { // Fill the buffer with white noise; //just random values between -1.0 and 1.0 for (var channel = 0; channel 运行上面的js代码，单击页面就会听到声音播放出来了。那么用LayaAir怎么写呢？ var audioCtx: any = new (Laya.Browser.window.AudioContext || Laya.Browser.window.webkitAudioContext)(); //Stereo var channels: number = 2; // Create an empty two-second stereo buffer at the // sample rate of the AudioContext var frameCount: number = audioCtx.sampleRate * 2.0; var myArrayBuffer: any = audioCtx.createBuffer(2, frameCount, audioCtx.sampleRate); Laya.stage.on(Laya.Event.CLICK, this, function (): void { // Fill the buffer with white noise; //just random values between -1.0 and 1.0 for (var channel: number = 0; channel 编译运行上面的例子，单击舞台，就会听到声音播放出来。这个例子很简单，就是在内存中构建出一个声音。那么外部加载的怎么办呢？ 下面这个例子我们就外部加载一个声音文件。顺便把声音的频谱我们画出来。 class Main { private AudioContext:any; private audioContext:any; private analyser:any; private audioBufferSourceNode:any; constructor() { //初始化引擎 Laya.init(500, 500); AudioContext = Laya.Browser.window.AudioContext || Laya.Browser.window.webkitAudioContext; this.audioContext = new AudioContext(); this.analyser = this.audioContext.createAnalyser(); this.analyser.fftSize = 256; Laya.stage.once(Laya.Event.CLICK,this,this.clickHandler); } private clickHandler(e:any):void { var http:Laya.HttpRequest = new Laya.HttpRequest(); http.on(Laya.Event.COMPLETE,this,this.completeHandler); http.send(\"res/3.mp3\",\"\",\"get\",Laya.Loader.BUFFER); } private completeHandler(e:any):void { this.audioContext.decodeAudioData(e,this.decodeAudioData.bind(this)); } private decodeAudioData(buffer:any):void { this.audioBufferSourceNode = this.audioContext.createBufferSource(); this.audioBufferSourceNode.connect(this.analyser); this.analyser.connect(this.audioContext.destination); this.audioBufferSourceNode.buffer = buffer; this.audioBufferSourceNode.start(0); Laya.timer.loop(1,this,this.drawHandler); } private drawHandler():void { Laya.stage.graphics.clear(); var dataArray:Uint8Array = new Uint8Array(this.analyser.frequencyBinCount); this.analyser.getByteFrequencyData(dataArray); var step:number = Math.round(dataArray.length / 60); for (var i:number = 0; i 编译运行上面的项目，点击舞台可以看到，声音的频谱就显示出来了。如下图所示： 总结:可以看到 web的声音功能越来越强大，假如不考虑某些低端机的兼容性，完全可以做一个web的播放器。这里只是做出了一个频谱的效果，开发者可以试试混音，给声音加滤镜等等功能。相关的api可以查阅下mdn。 LayaAir之dom元素iframe 在插入三方的一些网站的时候我们一般会用到iframe，甚至三方的渠道基本都是用iframe嵌入一个应用。我们项目中也会遇到用iframe的情况。下面的例子就是演示在项目中应用iframe。 代码如下所示： var iframe:any = Laya.Browser.document.createElement(\"iframe\"); iframe.style.position =\"absolute\";//设置布局定位。这个不能少。 iframe.style.zIndex = 100;//设置层级 iframe.style.left =\"100px\"; iframe.style.top =\"100px\"; iframe.src = \"http://ask.layabox.com/\"; Laya.Browser.document.body.appendChild(iframe); 这里面需要提醒开发者的就是定位和层级要记得设置。很多开发者不注意导致iframe跑到游戏层的下面而看不见。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:43 "},"3D/advanced/readme.html":{"url":"3D/advanced/readme.html","title":"3D进阶","keywords":"","body":"3D进阶自定义Shader后处理CommandBuffer3D性能优化WebXR3D寻路Unity资源导出插件3D进阶 3D进阶部分包括引擎功能的综合性使用，进阶性使用等相关的文档。 自定义Shader 后处理 CommandBuffer 3D性能优化 WebXR 3D寻路 Unity资源导出插件 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-04-01 12:07:34 "},"3D/advanced/customShader/readme.html":{"url":"3D/advanced/customShader/readme.html","title":"自定义Shader","keywords":"","body":"一篇学会自定义Shader一、Shader基础知识1.1 shader是什么？1.2 LayaAir引擎的shader2.如何自定义Shader2.1 Mesh中常见的属性2.2 规则说明3.UniformMap4.子着色器SubShader4.1 什么是subShader4.2 什么是Pass5.Shader文件结构详述5.1 Instancing5.2 ReflectionProbe5.3 attributeMap5.4 Defines6.GLSL语法简述6.1 常见的变量类型6.2 常见的向量类型6.3 常见的矩阵类型6.4 varying7.ShaderPass8.GLSL BlockdefineGLSL 和#endGLSL 中包含的内容为与之着色器功能相对于的glsl的语句9.开始编写一个LayaAir Shader9.1 创建一个Shader9.2 编写一个ShaderdefineGLSL 定义 VS或FS的glsl语句片段10.顶点着色器片段11.片段着色器片段12.GLSL数据传递12.1 应用处理阶段12.2 顶点着色器阶段12.3 片段着色器片段拓展1 材质的渲染模式与Shader的渲染模式一篇学会自定义Shader Date: 2022-11-09 本篇文档属于LayaAir引擎3D使用的进阶性文档，在阅读前需要具备3D顶点、法线、UV等通用的3D基础知识，如果涉及到不理解的名词，请先阅读相关的基础概念文档。 一、Shader基础知识 1.1 shader是什么？ Shader 中文名为着色器， Shader本质上是一段采用GLSL着色语言编写在GPU上运行的程序 ， 用于告诉图形软件如何计算和输出图像。小到每一个像素，大到整个屏幕。 着色语言好几种，LayaAir引擎基于webGL，只能用GLSL语言。 Shader主要分两类：顶点着色器Vertex Shader和片段着色器Fragment Shader（也叫片元着色器） 。 1.1.1 顶点着色器Vertex Shader 顶点着色器是用来处理顶点数据的程序，如顶点坐标、法线、颜色和纹理坐标。 它在每个顶点上调用，可将几何图形（例如：三角形）从一个位置转换为另一个位置， 例如，用于顶点变换、纹理坐标生成、 纹理坐标变换等等。 由于3D图形是一个个三角面片组成的，所以，顶点Shader要计算每个三角面片上的顶点，并为最终的像素渲染做准备。 1.1.2 片段着色器Fragment Shader 片段着色器用来计算和填充每个像素的颜色，所以也称为像素着色器。可用于插值的运算、 纹理存取、纹理应用 、 雾 、 色彩计算等。 对于由图元覆盖的像素的每个样本，都会生成“片段”。每个片段都有一个“窗口空间”位置以及其他一些值，并且它包含来自上一个“顶点处理”阶段的所有内插的每个顶点输出值。片段着色器的输出是深度值，可能的模板值（片段着色器未修改）以及可能会写入当前帧缓冲区中的缓冲区的零个或多个颜色值。片段着色器将单个片段作为输入，并生成单个片段作为输出。 1.2 LayaAir引擎的shader 1.2.1 结构与组成 LayaAir引擎中的shader主要是围绕着.shader文件为核心，在引擎核心中.shader文件是Shader3D类对象抽象为文本化表示的结果，在选择不同的shader效果会生成不同的.shader文件，这些shader文件成为模型材质各不相同的核心因素。 如何创建.shader文件？ 在Project窗口右键菜单栏 -> 选择Create -> 选择Shader（如图1-1所示） 图1-1 1.2.2 应用范围 LayaAir引擎中的Shader的应用主要体现在对不同物体的材质效果表达，通过对不同shader的选择，物体的材质随之改变形成了各不相同的效果 LayaAir引擎内置的默认Shader有：BlinnPhong，Unlit，PBR，Particle，Trail，SkyBox，SkyPanoramic，SkyProcedural。 2.如何自定义Shader 2.1 Mesh中常见的属性 polygon这个词来自希腊语，由poly(很多)和gnow(角)组成，根据定义，多边形是指以线段为界的封闭平面图形 在不同的3D软件或游戏引擎中我们可以找到最基本的常见3D物体：球体，圆柱体，胶囊体，方块，这些基本的3D物体由若干的多边形组合而成，这些3D物体的形状不相同，但性质相似，它们都存在顶点、法线、UV坐标、顶点颜色等属性，这些都存储在定义为Mesh的数据结构中。我们可以在一个shader中独立访问所有的这些属性，并将它们保存在一些常见的数据结构中，例如Vector，这样是很好的，因为我们可以修改他们的数值，从而产生令人兴奋的效果。 下图1-2展示的是顶点、多边形、边缘的可视化三种形态 ​ 图1-2 3D物体的顶点、多边形、边缘三种形态 接下来单独介绍Mesh数据结构中常见的属性 顶点 顶点是什么？顶点是三角形中两条边相交的点，因此每个三角形都由三个顶点组成，所以一个最基本的三角形片元拥有三个顶点 下图1-3展示的是物体对象的transform和物体顶点坐标的可视化形态 ​ 图1-3 变换对象与顶点坐标 法线 假设我们有一张空白的纸，我们让一个朋友在纸的正面画画。如果两侧相等，我们如何确定哪一个是空白页的正面？这就是法线存在的原因。法线对应于多边形曲面上的垂直向量，用于确定面或顶点的方向或方向 在3D软件中我们可以选择可视化顶点的法线，它可以让我们看到顶点在空间中的位置 下图1-4展示的是物体对象的法线可视化的结果 ​ 图1-4 顶点与顶点法线的可视化表达 UV坐标 纹理坐标，也称UV坐标，映射了纹理的宽度和高度；在UV坐标上定位顶点的过程称为“UV映射”。这是一个创建、编辑和组织显示为对象网格的平面二维表示的UV的过程。在我们的着色器中，我们可以访问此属性，以在三维模型上定位纹理或在其中保存信息，图1-5展示了Mesh和UV坐标的形态关系。 ​ 图1-5 Mesh数据和UV坐标 UV坐标的面积等于0.0f到1.0f的范围，其中0.0f表示起点，1.0表示终点，下图1-6展示了UV坐标的可视化表达 ​ 图1-6 UV坐标的可视化表达 VertexColor 当我们从 3D 软件中导出对象时，软件会为要受影响的对象分配颜色，通过照明或复制另一种颜色。 这种颜色称为顶点颜色，默认情况下对应于白色，在 RGBA 通道中具有值“1.0”。 2.2 规则说明 Shader3D Start/End Shader文件头/尾 用于声明渲染pass，渲染状态、材质参数等参数 Shader3D Start { //此处填写Shader渲染pass、渲染状态、材质参数等属性 } Start3D End name Shader名称 用于解释该Shader的名称，区别不同的Shader的功能与效果 Shader3D Start { //此处ShaderName为Shader的名字，非.shader文件名字，实际为Shader3D对象的名称 name: ShaderName } Shader3D End type Shader类型 目前LayaAir仅支持Shader3D类型，考虑后续支持Compute Shader等高级Shader类型 Shader3D Start { type:Shader3D } Shader3D End 3.UniformMap Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，但uniform和顶点属性有些不同。首先，uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。 UniformMap则是存储这样一堆Uniform变量的数据结构，通过组合的形式更直观的让开发者了解到在Shader中所使用到的Uniform变量。 3.1 Uniform常见变量类型 Uniform变量的常见类型：Texture2D，Color，Vector2，Vector3，Vector4，Bool，Float，Matrix4x4，TextureCube Texture2D用于2D纹理采样的图片类型，图片本地支持格式：JPG，PNG Color 颜色类型，为四个Float类型组成的向量值，单位为0-1范围的RGB值变量 Vector2 向量2类型，多用于2D的坐标位置表示，常用于UV坐标和屏幕坐标 Vector3向量3类型，最常用的3D坐标位置表示，三个分量xyz表达3D空间中的具体位置 Vector4 向量4类型，多用于齐次化3D空间的坐标位置表示 Bool 布尔类型 Float浮点类型 Matrix4X4 4X4齐次矩阵 TextureCube 用于3D纹理采样的图片类型，图片本地支持格式：PNG，JPG，HDR Shader3D Start { //联动上面提到的属性(name, type) type: Shader3D name: ExampleShader uniformMap : { u_Color : {type: Color, default:[1,1,1,1]}, u_MainTex : {type: Texture, default: \"white\"}, u_SampleTexcoord : {type: Vector2, default:[1,1]}, u_LightDir : {type: Vector3, default:[1,1,1]}, u_vecPos : {type:Vector4, default:[1,1,1,1]}, u_isWebGL2 : {type: bool, default: true}, u_spend : {type:float, default:1.0}, u_SkyMap : {type:TextureCube, defalue: \"black\"} u_defaultMat : {type:Matrix4x4, default:[ 1,0,0,0 0,1,0,0, 0,0,1,0, 0.0,0, ]} } } shader3D End 3.2 引擎常见内置Uniform 注意：以下列举的Uniform变量仅为引擎常用的Uniform变量，其余引擎涉及到的Uniform变量为高阶的使用方法在本文中不会做详细的介绍，感兴趣的开发者可以在引擎中的xx.glsl文件中可以找到相对应的Uniform变量，在此篇幅仅介绍在常用的Shader编写中所使用的到的一些高频的Uniform变量。 变量名 描述 所属GLSL文件(高阶操作不推荐直接使用) u_WorldMat 世界矩阵 Sprite3D.glsl u_ProjectionParams(near, far, invert, 1 / far) 投影参数 Camera.glsl u_Viewport(x, y, width, height) 视口 Camera.glsl u_CameraDirection 相机方向 Camera.glsl u_CameraUp 相机上朝向 Camera.glsl u_CameraPos 相机位置 Camera.glsl u_ZBufferParams：1.0 - far / near, far / near, (near - far) / (near * far), 1 / near Zbuffer参数 Camera.glsl u_CameraDepthTexture 深度纹理 Camera.glsl u_Time 时间 Scene.glsl u_FogParams(Start, range, Density, 缺省) 雾效参数 Scene.glsl u_FogColor 雾效颜色 Scene.glsl 4.子着色器SubShader 4.1 什么是subShader SubShader子着色器可以理解为shader的渲染方案。每个Shader至少一个subShader，可以有多个subShader，子着色器用将Shader对象分为多个部分，分别兼容不同的硬件、渲染管线和运行设置信息。 在一个subShader中包含有： 有关此子着色器的硬件、管线和运行时设置等信息 一个或者多个pass 4.2 什么是Pass Pass是Shader对象的基本元素，SubShader中定义了一系列的Pass，它包含设置GPU状态的质量和在GPU上运行的shader程序。 但是过多的Pass存在一个SubShader中会造成渲染效率的下降，产生性能瓶颈。 Shader3D Start { ..... shaderPass:[ { //Shader VS/FS Info here } ] } Shader3D End 5.Shader文件结构详述 5.1 Instancing 什么是Instancing 当渲染的时候如果存在一类相同顶点数据的物体，只不过是世界空间位置不同，这样的物体就是适合Instancing渲染。想象一个充满草的场景：每根草都是一个包含几个三角形的小模型。你可能会需要绘制很多根草，最终在每帧中你可能会需要渲染上千或者上万根草。因为每一根草仅仅是由几个三角形构成，渲染几乎是瞬间完成的，但上千个渲染函数调用却会极大地影响性能。 如果启动Instancing，将这类数据一次性发送给GPU，然后调用一次绘制函数让OpenGL利用这些数据绘制多个物体，这样就十分的方便，这就是Instancing。Instancing可以让我们使用一个DrawCall来绘制多个物体，节省每次绘制时CPU->GPU的通信。 EnableInstancing开关 EnableInstancing是否启用Instancing 当启用EnableInstancing为true时，Shader启用Instancing功能，当启用EnableInstancing为false是，Shader不开启Instancing功能 Shader3D Start { .... enableInstancing:true, .... .... } Shader3D End 5.2 ReflectionProbe 什么是ReflectionProbe 反射探针可以从各个方向捕获周围的环境，然后将捕获到的内容存储为CubeMap（立方体贴图），可供给具有反射材料的对象使用。在一个场景中可以使用多个反射探针，探针可在场景中的关键点对视觉环境进行采样。当反射对象靠近探针时，探针采样的反射可用于对象的反射贴图。此外，当几个探针位于彼此附近时，引擎可在它们之间进行插值，从而实现反射的逐渐变化。因此，使用反射探针可以产生非常逼真的反射，同时将处理开销控制在可接受的水平。 反射探针的工作原理 探针的捕获环境可由CubeMap表示，CubeMap在概念上很像一个在内部表面绘制有立方体六个面图像的盒子，需要Shader必须能够采样CubeMap的图像。对象表面的每个点都可在表面朝向的方向（即表面法向矢量的方向）上“看到”立方体贴图的一小块区域。着色器在此处使用立方体贴图的颜色来计算对象表面应该是什么颜色，下图5-1展示了CubeMap和天空盒的对比结果。 图5-1 SupportReflectionProbe开关 SupportReflectionProbe ReflectionProbe开关 当场景中存在探针时，将开关启用为True，当场景中不存在探针时，将开关启用为False Shader3D Start { .... .... supportReflectionProbe:false, .... .... } Shader3D End 5.3 attributeMap attribute通常是来自Mesh顶点中的数据，该属性的变量值是只读的，通常情况下是不需要设置的，引擎中默认有一套attributeMap，满足常见的mesh顶点类型，只有需要特殊mesh数据的时候才需要对attributeMap中设置特殊的变量 在LayaAir3D中的顶点数据是逐精灵的，在这里只介绍常用的模型精灵相关的顶点数据。（即不包含拖尾精灵与粒子精灵） 该表格会列出目前所有会有引擎传入的顶点数据的变量名与对应的顶点通道。 描述 通道 顶点在模型空间下的位置 VertexMesh.MESH_POSITION0 顶点在模型空间下的法向量 VertexMesh.MESH_NORMAL0 模型空间的切向量 VertexMesh.MESH_TANGENT0 第一个uv坐标 VertexMesh.MESH_TEXTURECOORDINATE0 第二个uv坐标 VertexMesh.MESH_TEXTURECOORDINATE1 骨骼权重 VertexMesh.MESH_BLENDWEIGHT0 骨骼索引 VertexMesh.MESH_BLENDINDICES0 MVP矩阵 VertexMesh.MESH_MVPMATRIX_ROW0 世界矩阵 VertexMesh.MESH_WORLDMATRIX_ROW0 顶点色 VertexMesh.MESH_COLOR0 用户自定义预留位 VertexMesh.MESH_CUSTOME0 5.4 Defines 使用宏开关来控制顶点着色器和片段着色器产生不同分支条件的Shader指令，在defines中宏开关的基本构成为 defineName ：宏开关的名称 type：一般为bool，true或false触发两个不同的分支 private：当private值为false时，在Inspector面板shader窗口中宏开关会显示为勾选开关的形式，供开发者按需在面板控制宏的开启与关闭；当private值为true,不显示勾选开关（下图5-2展示了勾选开关在Shader窗口的展示,图5-3展示了define在Shader文件中的具体使用方法） (图5-2) (图5-3) 6.GLSL语法简述 GLSL的变量类型跟uniformMap存在部分重合的内容，LayaAir引擎的Shader文件是基于GLSL语言的封装的，目的是为了提升开发者编写着色器的易用性。GLSL是基于GL系的图形API而推出的着色器语言，包含了一些常见的变量类型和针对向量和矩阵的操作，使得渲染管线具有可编程的特性。 6.1 常见的变量类型 变量类型 说明 LayaAir 中的默认值 bool 布尔型标量数据类型 false float/vec2/vec3/vec4 包含 1，2，3，4 个浮点型向量 0/[0, 0]/[0, 0, 0]/[0, 0, 0, 0] sampler2D 表示 2D 纹理 “white” samplerCube 表示立方体纹理 mat4 表示 4x4 的矩阵 6.2 常见的向量类型 向量的构造方式可以通过下面的三种形式构造 vec2 v1 = vec2(1.0, 0.0); vec3 v2 = vec3(1.0); // v2 = [1.0, 1.0, 1.0] vec4 v3 = vec4(1.0, 0.0, vec2Value); //v3 = [1.0, 1.0, vec2Value.x, vec2Value.y] 向量可以通过x，y，z，w和r，g，b，a进行访问操作，glsl支持同时访问多个下标 eg: vec.xyz 6.3 常见的矩阵类型 mat4 marixt4x4 = mat4(1.0); // marixt4x4 = { 1.0, 0.0, 0.0, 0.0, // 0.0, 1.0, 0.0, 0.0 // 0.0, 0.0, 1.0, 0.0 // 0.0, 0.0, 0.0, 1.0 } mat2 matrix2x2 = mat2(coll1, col2); mat3 matrix3x3 = mat3(0.0, 0.0, 0.0, // 第一列 0.0, 0.0, 0.0, // 第二列 0.0, 0.0, 0.0); // 第三列 6.4 varying varying 是由顶点着色器输出并传输给片元着色器的变量。在管线的作用下，变量值并不会和顶点着色器输出的保持一致，而是由管线进行插值，这就可能会出现顶点输出的法线没有归一化的情况。此时需要手动归一化，代码示例如下： // 归一化法线 vec3 normal = normalize(v_normal); 7.ShaderPass 前面我们在SubShader中简要的介绍了Pass的作用，在本节中我们会结合详细的Shader内容来展示ShaderPass的具体功能 Shader3D Start { type:Shader3D name:exmpleShader enableInstancing:true, supportReflectionProbe:false, uniformMap: { u_MVPMatrix : {type: Matrix4x4}, u_OutLineWidth : {type: float, default:0.0} } shaderPass:[ { pipeline:Forward, VS:OutLineVS, FS:OutLineFS } { pipeline:Forward, VS:OutLine1VS, FS:OutLine1FS } ] } Shader3D End Shader3D Block设置了Shader的type和name以及对instancing、探针的支持情况，对shader中需要的uniform变量做了声明，shaderpass定义了渲染的方式为前向渲染和相对于的glsl的vs和fs的GLSL Block内容。 8.GLSL Block 8.1 GLSL Block的概述 该部分的内容主要是定义上述ShaderPass中不同渲染片段中的vs和fs中的glsl语句内容 开始和结束标志：GLSL Start / GLSL End Pass 对应的VS和FS片段标记：#defineGLSL “name” / #endGLSL defineGLSL 和#endGLSL 中包含的内容为与之着色器功能相对于的glsl的语句 GLSL Start #defineGLSL OutlineVS void main() { vec4 position = vec4(a_Position.xyz + a_Normal * u_OutlineWidth, 1.0); gl_Position = u_MvpMatrix * position; } #endGLSL #defineGLSL OutlineFS varying vec3 v_Normal; varying vec2 v_Texcoord0; void main() { gl_Position = u_MvpMatrix * a_Position; mat3 worldMat=mat3(u_WorldMat); v_Normal=worldMat*a_Normal; v_Texcoord0 = a_Texcoord0; gl_Position=remapGLPositionZ(gl_Position); } #endGLSL GLSL End 9.开始编写一个LayaAir Shader 9.1 创建一个Shader 在LayaAir引擎界面，找到Project窗口 -> 右键打开菜单界面 -> 选择Create选项 -> 选择Shader选项（如下图9-1所示） 图 9-1 9.2 编写一个Shader 打开刚才创建的Shader文件，此时打开的Shader为默认创建的Shader里面包含一些实际开发中可能遇到的常见功能 Shader3D Start Shader文件开始头 Shader3D End Shader文件结束头 Shader3D Start/End 中的内容为Shader的一些属性信息，不涉及glsl语句 下图9-2展示了一个基本Shader3D Start/Shader3D End 结构中包含的基本信息 图9-2 type: 设置type为Shader3D name: 设置Shader名称为NewShader enableInstancing: 启用Instancing supportReflectionProbe： 不启用光照探针支持 UniformMap： 创建了四个Uniform变量，下图9-3显示了材质与Shader绑定后在IDE面板上显示的结果 图9-3 当材质与Shader绑定之后，UniformMap中的变量就会成为IDE材质编辑器上的一个面板接口，可以在面板接口上对uniform值进行修改 shaderPass当前Shader只有一个pass，vs内容为unlitVS，fs内容为unlitFS，渲染模式为前向渲染 GLSL Start / GLSL End 每个Pass的VS与FS对的开始与结束 defineGLSL 定义 VS或FS的glsl语句片段 FS片段 给物体填一个纯色，将gl_FragColor设置为一个带有透明通道的vec4变量，实际的结果如下图9-4所示 图9-4 给物体填上纹理的颜色，将gl_FragColor设置为采样纹理的颜色值（左上角为原始纹理示意图，具体效果如下图9-5所示 图9-5 给物体颜色填充为uniform变量的颜色，具体效果如下图9-6所示 图9-6 使用tilingoffset对UV纹理的采样进行偏移，具体效果如下图9-6所示 图9-6 注意：此时的v_Texcoord0是在VS中进行放缩偏移变换的，并非在FS中变换的，此处先按下不表，在VS部分会详细讲解 VS片段 图9-8 LayaAir Shader中的#include类似于C语言的include，xxx.glsl中内置了一些引擎已经打包好的shader算法，上图展示了一部分这些算法的用法，具体的用法如下 在图形学中常常有围绕着变换进行的一些用法：例如世界矩阵、投影矩阵、裁剪空间，UV变换等等，在LayaAir的glsl头文件中存在了这样一些用法如下： getWorldMatrix() 返回一个mat4类型的世界矩阵( ) ，模型空间坐标 世界矩阵 = 世界空间坐标 [ Sprite3DVertex.glsl *] getVertexParams() 返回一个Vertex结构体，结构体中包含Mesh的原始数据：顶点坐标、法线、UV（UV宏）、切线（NEEDTBN宏）、副切线（NEEDTBN宏）、顶点颜色（COLOR宏）[Vertex.glsl] transfromUV（）返回一个vec2的新UV坐标，按照函数第二参数进行放缩和偏移的操作，实际的算法为：newUV = (oldUV.x x + tilloffset.z, oldUV.y y + tilloffset.w) tilloffset的xy对应xy的放缩值，zw对应xy的偏移值 [Vertex.glsl] 结构体PixelParams定义了一些世界空间下的顶点属性：顶点坐标、法线、UV（UV宏）、切线（NEEDTBN宏）、副切线（NEEDTBN宏）[BlinnPhongCommon.glsl] 结构体PixelParams只是定义了这些世界的顶点属性，并没有初始化，InitPixelParams() 返回初始化后的PixelPaams变量 getPositionCS() 传入世界坐标返回的是裁剪空间的坐标 [Camera.glsl] remapPositionZ() 对裁剪空间的坐标Z进行重映射 [Camera.glsl] 10.顶点着色器片段 顶点着色器的主要功能是对输入的顶点进行变换，从模型空间变换到裁剪空间下输出到片段着色器，图10-1展示了一个顶点着色器简单的输入与输出 图10-1 读者不必深入了解WebGL的运行细节，只需要专注于GLSL的语句的内容，就可以轻松的完成Shader内容的创作，前面章节简述了GLSL的一些内容，下图10-2展示了顶点着色器在图形渲染管线中的运行阶段图示。 图10-2 在上图所示的阶段，从模型中的顶点经过了图10-3的一系列变换内容 Local Space 局部坐标，也可以称之为模型坐标。可以理解为就是相对于父节点的坐标。 World Space 世界坐标。世界坐标是一个很大的空间范围，相对于世界原点。通过模型坐标与世界矩阵相乘之后得出。 View Space 观察坐标。可以理解为将世界坐标转换到相机空间的坐标，转换后的值是相对于相机原点。通过世界坐标与观察矩阵相乘之后得出。 Clip Space 裁剪坐标。也就是将观察坐标处理到 -1.0 ～ 1.0 的范围，也就是我们在 WebGL 里提供的标准设备化坐标，最终剔除超出 -1 ～ 1 的坐标。通过观察坐标结合投影矩阵得出。 Screen Space 屏幕坐标。这个过程其实就是将 -1.0 ～ 1.0 范围的坐标转换到 gl.viewport 所定义的坐标范围内。最后变换出来的坐标会送到光栅器，转换成片段。 11.片段着色器片段 片段着色器的主要功能主要是计算每个像素片段的颜色，从顶点着色器获得颜色的差值，从纹理中采样出颜色数据。图11-1展示了模型采样纹理的着色结果 图11-1 12.GLSL数据传递 12.1 应用处理阶段 模型在应用处理阶段被整合为基本片元（三角形），从模型中获取到不同的属性坐标信息，图12-1展示了应用处理阶段的功能图示 图12-1 12.2 顶点着色器阶段 应用阶段完成计算后的一些值作为uniform传入顶点着色器参与计算，然后再通过varing类型的形式传入到光栅化以及后面的片段着色器部分，图12-2展示了这一阶段的具体步骤。 图12-2 12.3 片段着色器片段 在光栅化阶段完成颜色插值之后的varing类型结果，传入到片段着色器中，片段着色器对颜色值进行处理，将结果输出到对应的缓冲区（分为颜色缓冲区和深度缓冲区），这个步骤在图12-3中进行了展示。 图12-3 拓展1 材质的渲染模式与Shader的渲染模式 在LayaAir中不同的材质有着不同的渲染模式，不同的模式下的渲染结果是不相同的，常见的渲染模式如下图a-1红色框选内容所示 图a-1 OPAQUE（不透明） 无任何透明效果，即使贴图中有半透明，模型也不会发生半透明效果，Alpha值不影响最终渲染效果，始终为1。 CUTOUT（镂空） 图a-2 ​ 根据包含Alpha信息的贴图中采样出来的Alpha值进行透明裁剪，也可以根据图a-2中的AlphaTest的值与贴图中采样的Alpha值进行对比来进行裁切，这样裁剪出来的结果造成的空洞部分与正常部分会产生严重的锯齿，但效率高，如果锯齿效果印象严重，建议是采样TRANSPARENT模式，透明的结果就会比较线性 TRANSPARENT（半透明） 根据贴图中Alpha值来进行半透明的渲染或者给定固定的Alpha值来进行渲染。 ADDTIVE（加色混合） 主要用于一些透明并颜色亮度较高的材质，它会根据贴图像素的亮度进行加色混合，模型正面与背面贴图颜色、相重叠的模型的贴图颜色会相互叠加，形成高亮半透明效果 图a-3 ALPHABLENDED（透明混合） 这意味着对象为半透明的模式，但是最终像素的着色的混合模式不同，AlphaBlended混合方式为SrcAlpha SrcColor + （1 - SRCAlpha） DstColor，通常来说SrcAlpha来自纹理的Alpha值 图a-4 在引擎内部Shader的RenderMode会和材质上的RenderMode做一个比较，一般是以材质上的RenderMode为主。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-06-08 14:46:45 "},"3D/advanced/PostProcessing/readme.html":{"url":"3D/advanced/PostProcessing/readme.html","title":"后处理","keywords":"","body":"后处理1.后处理概述2.添加一个内置后处理效果3.引擎内置后处理类型：ScalableAO4.引擎内置后处理类型：Bloom5.引擎内置后处理类型：GaussianDoF6.引擎自定义后处理类型后处理 1.后处理概述 后处理是现代游戏中必不可少的技术之一，PostProcessing，通常在普通的场景渲染结束后对结果进行处理，将一张或数张Texture处理得到一张新的Texture。 PostProcessing的渲染Pipeline普通的模型渲染一样，不同之处在于在顶点着色器中通常只是简单的拷贝，主要的逻辑写在片段着色器中 下面的图像展示了应用和未应用后期处理的场景。 未应用后期处理的场景 应用后期处理后的场景 2.添加一个内置后处理效果 在Scene中选择需要添加后处理效果的相机对象 图2-1 在相机对象的组件面板中PostProcess组件 图2-2 选择实例化PostProcess组件 图2-3 在Effects中添加合适的后处理效果 图2-4 3.引擎内置后处理类型：ScalableAO 环境光遮蔽效果用于计算场景中暴露在环境照明下的点。然后，它会使隐藏在环境光之外的区域变暗，例如折痕、孔洞和靠近的物体之间的空间。 您可以通过两种方式实现环境光遮蔽效果：作为全屏后期处理效果实时实现。实时环境光遮蔽效果可能会占用大量资源。它对处理时间的影响取决于屏幕分辨率和效果属性。 图3-1 可拓展环境光遮蔽参数类型： 参数类型 参数解释 AO Color 设置环境光遮挡的颜色 Intensity 环境光遮挡产生强度 Radius 设置采样点的半径，以控制环境光遮蔽区域的范围 AO Quality 环境光遮蔽效果质量（高-中-低三档） 4.引擎内置后处理类型：Bloom Bloom效应使图像中的明亮区域发光。为了做到这一点，它创建的边缘光从明亮的领域扩展到你的形象。这模拟了真实世界中的照相机在光线淹没镜头时所产生的效果。布鲁姆效果也有一个肮脏的功能，你可以用它来应用一个全屏幕层的污迹或灰尘来衍射Bloom效果。 图4-1 Bloom参数类型： 参数类型 参数解释 Clamp 设置钳制像素的值以控制 Bloom 数量 Color 选择 Bloom 的颜色 Fast Mode 快速模式 Dirt Texture 选择一个肮脏的纹理添加污迹或灰尘的镜头 Intensity 设置镜头肮脏的强度 Threshold 设置亮度级别以过滤掉此级别下的像素 Soft Knee 为低于/超过阈值(0 = 硬阈值，1 = 软阈值)之间的转换设置渐进阈值。 Diffusion 与屏幕分辨率无关的方式设置面纱效果的范围。 Anamorphic Ratio 设置比例以垂直(范围[ -1,0])或水平(范围[0,1])缩放 Bloom。这模拟了变形透镜的效果。 5.引擎内置后处理类型：GaussianDoF 景深是一种常见的模拟相机镜头焦距特性的后处理效果。在现实生活中，相机只能在一定距离内对物体进行锐利的聚焦; 离相机较近或较远的物体会有点失焦。这种模糊不仅提供了一个关于物体距离的视觉线索，而且还引入了 Bokeh，这是一个术语，用来描述当图像的明亮区域失焦时出现的令人愉快的视觉伪影。 图5-1 GaussianDoF参数类型： 参数类型 参数解释 Far Start 景深开始值 Far End 景深结束值 Max Radius 最大模糊景深半径 6.引擎自定义后处理类型 在3.0引擎中编写好自己的后处理效果后，在类定义前加上关键字@regClass()就可以将自定义好的后处理效果显式的展现在Camera的后处理组件的效果列表中 图6-1 图6-2 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:44 "},"3D/advanced/CommandBuffer/readme.html":{"url":"3D/advanced/CommandBuffer/readme.html","title":"CommandBuffer","keywords":"","body":"CommandBuffer文档1.简介2.使用步骤3.使用示例CommandBuffer文档 1.简介 CommandBuffer为渲染命令缓冲区，保存了渲染命令列表。当我们将一些渲染指令添加到CommandBuffer后，可以实现对渲染流程的控制，将这些指令在我们想要的时机进行执行。command buffer设置渲染目标或绘制给定网格，可以设置在摄像机渲染期间的不同点执行 CommandBuffer是一个高阶的3D渲染功能，用来拓展LayaAir引擎渲染管线的渲染效果。在实现毛玻璃（玻璃透明模糊感）、轮廓透视描边或者边缘光效、沙滩脚印、景深等等效果时非常好用，懂的人都明白，CommandBuffer非常强大，也是3A级大作经常用到的渲染功能，并且不会有额外的功能损耗，甚至某些效果比其它方案更省性能，是一种小游戏平台中也可以用来加强3D渲染效果的渲染扩展功能 2.使用步骤 1.创建好CommandBuffer后，添加渲染指令给CommandBuffer 添加代码接口如下： var buf:CommandBuffer = new CommandBuffer();buf.setRenderTarget(renderTexture);buf.drawRender(renders[i],materials[i],0); 2.需要将CBuffer绑定到Camera的渲染事件中，目前laya支持的Camera事件如下： BeforeForwardOpaque = 0,//在渲染非透明物体之前BeforeSkyBox = 2,//在渲染天空盒之前BeforeTransparent = 4,//在渲染透明物体之BeforeImageEffect = 6,//在后期处理之前AfterEveryThing = 8,//所有渲染之后 添加CommandBuffer到相机事件的接口如下： this.camera.addCommandBuffer(this.cameraEventFlag,this.commandBuffer); 删除CommandBuffer的接口如下： this.camera.removeCommandBuffer(this.cameraEventFlag,this.commandBuffer); CommandBuffer是一个渲染指令集，组成这个渲染指令集的是一个一个的独立的渲染指令 setShaderData//设置shader数据，可以设置shader中的texture vector number等 setGlobalShaderData//设置全局数据，可以用于所有的shaderblitScreenQuad//通过全屏四边形将源纹理渲染到目标渲染纹理指令。blitScreenQuadByMaterial//通过全屏四边形将源纹理渲染到目标渲染纹理指令setRenderTarget//设置指令渲染目标，调用后，所有的渲染都会渲染到方法绑定的图片上clearRenderTarget//清理绑定的渲染纹理drawMesh//渲染一个MeshdrawRender//渲染一个Render 可以组合不同的渲染指令然后放入不同的渲染流程，下面具体分析官方示例来更好的理解一下CommandBuffer的用法。 3.使用示例 3.1.BlurryGlass示例（毛玻璃示例） 效果图 示例原理 毛玻璃属于透明材质，后面的三个胶囊体都是非透明材质，所以我们需要每帧将毛玻璃模型后面的所有渲染物体全部拿出，进行模糊，再将图片按屏幕uv采样到毛玻璃上面，便可以实现这样的效果 示例代码 createCommandBuffer(camera:Camera){ //当需要在渲染透明物体之前拿到摄像机渲染结果，所以调用下面的属性true camera.enableBuiltInRenderTexture = true; //创建CommandBuffer var buf:CommandBuffer = new CommandBuffer(); //创建需要模糊使用的屏幕RenderTexture var viewPort:Viewport = camera.viewport; //创建新的RenderTexture var renderTexture = RenderTexture.createFromPool(viewPort.width,viewPort.height,RenderTextureFormat.R8G8B8,RenderTextureDepthFormat.DEPTHSTENCIL_NONE); this.texture = renderTexture; //将当前渲染的结果拷贝到创建好的RenderTexture buf.blitScreenTriangle(null,renderTexture); //获得模糊shader var shader:Shader3D = Shader3D.find(\"blurEffect\"); //设置模糊参数 var shaderValue:ShaderData = new ShaderData(); //down Sample level设置降采样等级 var downSampleFactor:number = 4; var downSampleWidth:number = viewPort.width/downSampleFactor; var downSampleheigh:number = viewPort.height/downSampleFactor; //设置模糊材质参数 var texSize:Vector4 = new Vector4(1.0/viewPort.width,1.0/viewPort.height,viewPort.width,downSampleheigh); shaderValue.setNumber(BlurEffect.SHADERVALUE_DOWNSAMPLEVALUE,1); shaderValue.setVector(BlurEffect.SHADERVALUE_TEXELSIZE,texSize); //创建降采样RenderTexture1 var downRenderTexture = RenderTexture.createFromPool(downSampleWidth,downSampleheigh,RenderTextureFormat.R8G8B8,RenderTextureDepthFormat.DEPTHSTENCIL_NONE); //降采样命令流 buf.blitScreenTriangle(renderTexture,downRenderTexture,null,shader,shaderValue,0); //创建降采样RenderTexture2 var blurTexture:RenderTexture = RenderTexture.createFromPool(downSampleWidth,downSampleheigh,RenderTextureFormat.R8G8B8,RenderTextureDepthFormat.DEPTHSTENCIL_NONE); blurTexture.filterMode = FilterMode.Bilinear; //Horizontal blur buf.blitScreenTriangle(downRenderTexture,blurTexture,null,shader,shaderValue,1); //vertical blur buf.blitScreenTriangle(blurTexture,downRenderTexture,null,shader,shaderValue,2); //Horizontal blur buf.blitScreenTriangle(downRenderTexture,blurTexture,null,shader,shaderValue,1); //vertical blur buf.blitScreenTriangle(blurTexture,downRenderTexture,null,shader,shaderValue,2); //至此 模糊图片已经生成在downRenderTexture中 //设置全局uniform变量 var globalUniformNameID:number = Shader3D.propertyNameToID(\"u_screenTexture\"); //将全局变量u_screenTexture赋值为模糊图片 buf.setGlobalTexture(globalUniformNameID,downRenderTexture); //将commandBuffer加入渲染流程 camera.addCommandBuffer(CameraEventFlags.BeforeTransparent,buf); //回收用过的RenderTexture RenderTexture.recoverToPool(downRenderTexture); RenderTexture.recoverToPool(blurTexture); return; } 3.2.OutLine示例（轮廓线描边） 效果图： 示例原理： 在渲染完成之后，绑定另外一个黑色的Rendertexture，重新画好粒子，Box，猴子为纯红色，再将图片模糊，模糊图片颜色减去没模糊的图片，就能得到渲染边框，最后将渲染边框重新加到渲染好的画布上面，便可实现轮廓效果 代码如下 createDrawMeshCommandBuffer(camera:Camera,renders:BaseRender[],materials:Material[]):CommandBuffer{ var buf:CommandBuffer = new CommandBuffer(); //当需要在流程中拿摄像机渲染效果的时候 设置true camera.enableBuiltInRenderTexture = true; //创建和屏幕一样大的Rendertexture var viewPort:Viewport = camera.viewport; var renderTexture = RenderTexture.createFromPool(viewPort.width,viewPort.height,RenderTextureFormat.R8G8B8A8,RenderTextureDepthFormat.DEPTHSTENCIL_NONE); //将RenderTexture设置为渲染目标 buf.setRenderTarget(renderTexture); //清楚渲染目标的颜色为黑色，不清理深度 buf.clearRenderTarget(true,false,new Vector4(0,0,0,0)); //将传入的Render渲染到纹理上 for(var i = 0,n = renders.length;i Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:44 "},"3D/advanced/performanceOptimization/readme.html":{"url":"3D/advanced/performanceOptimization/readme.html","title":"3D性能优化","keywords":"","body":"3D性能优化1.图形性能的基本认知1.1 降低渲染的CPU成本1.2 降低渲染的GPU成本2.优化Draw Call3.GPU instance4.Dynamic Batch5.Static Batch6.Custom Static Batch(Static Batch Volume组件)3D性能优化 1.图形性能的基本认知 1.1 降低渲染的CPU成本 在渲染过程中，对CPU渲染时间影响时间最大的因素是将渲染指令发送到GPU的成本，渲染指令包括Draw Call以及在绘制3D物体之前更改GPU上设置的命令。 以下的几种手段都可以降低渲染的CPU成本： 减少场景中渲染物体的数量 考虑减少场景中对象的总数，例如：使用天空盒来代替远距离3D物体的渲染 对场景中的物体执行更高效的剔除手段，以便减少引擎中渲染的压力。 减少渲染对象的次数 在适当情况下，使用LightMap烘焙光照和阴影，该操作会增加显存使用量和构建时间，但可以提到运行效率 减少光源的数量 慎用实时阴影 慎用反射探针 1.2 降低渲染的GPU成本 受内存带宽限制，纹理尺寸太高，纹理数量过多，会引发GPU渲染瓶颈 为与相机的距离在运行时变化的纹理启用 mipmap。（例如，3D 场景中使用的大多数纹理）。这会增加这些纹理的内存使用量和存储空间，但可以提高运行时 GPU 性能。 使用合适的压缩格式来减小内存中纹理的大小。这可以缩短加载时间、减少内存占用并改善 GPU 渲染性能。压缩纹理仅使用未压缩纹理所需内存带宽的一小部分。 如果应用受到顶点处理的限制，意味着GPU在顶点处理阶段可以处理更多的顶点 降低顶点着色器的执行成本。 优化几何图形：不要使用不必要的三角形，并尽量保持 UV 映射接缝和硬边（双倍顶点）的数量尽可能少。 使用LOD优化不同的Mesh类型，优化顶点数量。 2.优化Draw Call 由于呈现状态更改会占用大量资源，因此对其进行优化非常重要。优化渲染状态更改的主要方法是减少它们的数量。有两种方法可以执行此操作： 减少绘制调用的总数。减少绘制调用的数量时，也会减少它们之间的渲染状态更改的数量。 以减少对呈现状态的更改次数的方式组织绘制调用。如果图形 API 可以使用相同的呈现状态来执行多个绘制调用，则可以将绘制调用组合在一起，而无需执行尽可能多的渲染状态更改。 LayaAir中提供了以下几种方法: GPU instance Dynamic Batch Static Batch Custom Static Batch 3.GPU instance GPU 实例化是一个绘制调用优化方法，它在一个绘制调用中呈现具有相同材质的多个网格副本。网格的每个副本称为一个实例。这对于绘制场景中出现多次的事物很有用，例如，树木或草体。 GPU 实例在相同的绘制调用中呈现相同的网格。要添加变化并减少重复的外观，每个实例可以具有不同的属性，如 Color 或 Scale。绘制调用，呈现多个实例出现在框架调试器绘制网格(实例)。 GPU Instance需要硬件的支持，确保你当前所使用的硬件可以支持GPU Instance渲染 上图展示了一个GPU Instance测试场景和测试场景相对应的详细绘制信息，图中红-绿-蓝-黄为四种不同的材质 当前Instance DrawCall仅为三个，引擎自动为符合Instance条件的物体执行了Instance渲染流程 引擎Instance渲染条件： 相同的Mesh 相同的材质 enableInstance（自定义Shader上的开关，引擎默认shader开启了Instance） 阴影状态是否相同（是否接收阴影） 反射探针状态是否相同 红-绿-蓝三类物体，具有不同的Mesh、不同的材质，但每一个红色、绿色或者蓝色的物体都是具有相同的材质、相同的Mesh、相同的Instance状态、相同的阴影状态、相同的反射探针状态。所以这三类物体符合引擎Instance渲染判断流程。引擎自动为这三类物体进行了实例化渲染，将红-绿-蓝三种物体将每种颜色的所有物体实例化以一个InstanceDraw Call的形式完成了渲染流程。黄色物体满足了Instance渲染判断的几乎所有内容，但是因为Mesh网格数据不同、引擎不会对所有的黄色物体进行Instance实例化渲染。 综上，一个基本的Instance渲染条件基本可以归纳为三个点：开启了enableInstance，相同Mesh，相同材质。 如果需要自己定制具有个性化的Instance渲染判断，开发者需要通过CommandBuffer的形式自己组织渲染的数据 4.Dynamic Batch 动态合并分为 实例合并 与 顶点合并 两种。这两种优化都无需开发者进行任何设置，而且物体可动态移动，不受限制。但是合并原则相对严格。以下是两种合并最基本条件。 实例合并: 需要同Mesh和同材质双条件满足。在三维场景中同Mesh同材质的模型还是可能大量存在的，在这时实例合并有不小的发挥空间。 顶点合并: 需要同材质且模型顶点小于10个。顶点合并目前在一些假阴影和特效模型上有发挥空间。 注意：半透明的物体需要连续渲染才能动态合并，所以半透明物体的动态合并几率低。 关闭动态合批选项 在引擎的Config3D.ts文件中enableDynamicBatch值选项，true为开启动态合批，false为关闭动态合批 图4-1 5.Static Batch 静态批处理是一种绘制调用批处理方法，它组合不移动的网格以减少绘制调用。 它将组合的网格转换为世界空间，并为它们构建一个共享的顶点和索引缓冲区。 然后，对于可见网格，引擎执行一系列简单的绘制调用，每个调用之间几乎没有状态变化。 静态批处理不会减少绘制调用的次数，而是减少它们之间渲染状态更改的次数。 静态批处理比动态批处理更有效，因为静态批处理不会在 CPU 上转换顶点。 关闭静态合批选项 在引擎的Config3D.ts文件中enableStaticBatch值选项，true为开启动态合批，false为关闭动态合批 图5-1 静态合批的条件： 物体为Static（包括子物体） 使用同种材质的统一模型 图5-2 6.Custom Static Batch(Static Batch Volume组件) 在Object的inspect面板，增加组件，选择Rendering选项，找到Static Batch Volume组件 图6-1 在Scene视窗中拖动小白点选择合适的Volume大小 图6-2 Static Batch Volume组件的使用: 上面的Volume框选到合适的大小后，在组件的详情面板中，勾选Static Instance Batch，再点击reBatch，Volume中所框选的物件就会执行Batch操作，优化Draw Call，提升运行效率。勾选了CheckLOD选项的Batch组件, 会自动检查Volume中的物体LOD属性信息, 然后将Volume中的所有物体按照LOD Cull Rate Array的物体LOD等级划分为不同的LOD渲染对象 图6-3 图6-4 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-05-10 20:43:05 "},"3D/WebXR/readme.html":{"url":"3D/WebXR/readme.html","title":"WebXR","keywords":"","body":"WebXR使用说明一、WebXR简介二、WebXR的现状与前景三、LayaAir引擎WebXR应用WebXR使用说明 一、WebXR简介 WebXR 是一组支持将渲染3D场景用来呈现虚拟世界（虚拟现实，也称作VR）或将图形图像添加到现实世界（增强现实，也称作AR）的标准。 WebXR 设备 API 实现了 WebXR 功能集的核心，管理输出设备的选择，以适当的帧速率将3D场景呈现给所选设备，并管理使用输入控制器创建的运动矢量。 从引擎层面上，通过计算应用于场景的透视图，以从每个用户的视角呈现场景，从而在3D中呈现场景，考虑到眼睛之间的常规距离，然后渲染场景两次，每只眼睛一次。然后将生成的图像(场景在一个帧上呈现两次，每只眼睛一半)显示给用户。如图1所示。 （图1） 二、WebXR的现状与前景 XR我们可以理解为VR与AR的统称。无论是纯虚拟世界沉浸式体验的VR设备，还是现实世界增强显示体验的AR设备，均已开始走入到人们的生活，设备购买的人数不断在增加。这正如同智能手机早期的状态，随着设备越来越轻，佩戴体验越来越友好，相信普及度也会越来越广。 当然，我们也要认清当下的XR设备，如果普及度要达到智能手机的规模，那还是有不少硬指标要实现的。例如，要达到还原现实世界的视觉体验，必须要考虑VR设备的视场角（简称FOV）。人的单眼在没有遮挡的情况下所能看到的水平角度大概是150°左右，垂直角度大概在120°左右。如果我们要想在接近这个的FOV体验下达到视网膜级别的高清显示，那单眼就需要8K，双眼达到16K的视觉显示大小。这对web端的传输带宽和硬件性能的压力，绝对不是短期之内可以解决的。即便是采用毫秒级的眼球追踪技术，也需要达到单眼4K，双眼8K的物理分辨率。考虑到5G的普及速度与硬件性能的提升速度，产品的携带与佩戴体验等。至少也要几年后才勉强可以进入了全民级的基础门槛。 尽管当下和近期无法达到全民应用的级别，但VR的硬件配置、佩戴体验，平台内容质量等等生态都在明显的变好，所以用户量也是不断的增长。再加上2021年元宇宙的概念一波又一波的热度，使得资本市场对这种沉浸式体验的未来前景更加看好。所以2维显示的时代（没有真实空间感），早晚会过渡到沉浸式的3维显示时代。 提前了解与布局XR，率先进入蓝海领域，是不可错过的时代机遇。 LayaAir引擎于2.13版本开始支持WebXR标准，可以在主流VR设备的浏览器中直接运行，也可以在支持WebXR标准的手机端Chrome浏览器中运行。 三、LayaAir引擎WebXR应用 3.1 在手机里显示 3.1.1 支持webXR的手机浏览器 在手机里运行的时候，那种能夹住手机的VR盒子就可以满足VR的显示。如动图2所示。 （动图2） 由于现在手机里的浏览器对webXR支持的并不友好，目前已知的WebXR浏览器环境，只有Chrome 安卓79以上的版本和Samsung Internet 11.2以上的版本才可以。并且还需要翻墙去下webXR运行所必须的服务。交互操作方面，当前也没有非常成熟的配套设备。所以，手机上的VR，除了看片之外，对于互动体验的游戏来说，VR完全不适合我们当前的普通手机这种应用场景，除非是没有交互的3D展馆等演示性需求，我们并不推荐基于手机进行VR的开发。 3.1.2 准备好webXR运行环境 本篇文档编写时的硬件设备是OPPO iQOO机型，浏览器环境采用的是Chrome 96。 还需要通过翻墙（中国香港的VPN）去下载安装Google Play应用商店。然后在应用商店里搜索安装Google Play Services For AR与Google VR服务。 运行环境不必和本篇完全一样，能安装好Google Play应用商店，和最新版的Chrome浏览器（安卓）即可。 完成以上准备后，才可以正常显示基于webXR标准的链接。 3.1.3 如何用LayaAir开发webXR标准的产品 关于webXR的显示，官网的webXR已经有全部的示例代码，这里对主要的流程进行描述介绍，大家也可以前往官网示例查看完整的示例源码。 首先，场景的加载，摄像机的控制，脚本的添加，UI等，这与普通的3D游戏的编写没有什么区别（所以就不介绍这部分了）。 在启动VR模式之前， 通常开发者需要判断一下当前的环境是否支持webXR的VR模式，再决定是否启动VR模式，或者激活启动VR模式的UI按钮。 是否支持VR的API为：WebXRExperienceHelper.supportXR(\"immersive-vr\") //判断浏览器是否支持VR模式,有三种模式immersive-vr\\immersive-ar\\inline this.changeActionButton.visible = await WebXRExperienceHelper.supportXR(\"immersive-vr\"); immersive-vr就是VR模式的参数，如果是AR模式，参数换成immersive-ar即可。本篇文档只介绍VR模式。 如果检测到支持VR环境，那就可以直接进入VR模式，或者激活进入VR模式的UI按钮，通过侦听按钮的点击来进入VR模式。 /** 初始化XR */ async initXR(){ //创建一个webXR的摄像机 let caInfo : WebXRCameraInfo = new WebXRCameraInfo(); //设置远裁面 caInfo.depthFar = this.camera.farPlane; //设置近裁面 caInfo.depthNear = this.camera.nearPlane; //申请XR的交互，传入VR需要的信息 let webXRSessionManager = await WebXRExperienceHelper.enterXRAsync(\"imersive-vr\",\"local\",caInfo); //设置WebXR摄像机 WebXRExperienceHelper.setWebXRCamera(this.camera, webXRSessionManager); } 通过以上的代码，就可以完成VR的显示了。 3.2 在Oculus里显示与交互 3.2.1 代码部分 无论是手机浏览器还是Oculus VR设备，由于都是基于WebXR标准的，不管是在哪里显示，开发者的代码流程上都是一样的。 只是，相对于手机浏览器，Oculus等专用的VR头显设备，不仅仅是天然的webXR环境（不需要额外安装XR服务），在交互操作方面也非常友好，这也是我们推荐的VR开发与体验环境。 所以，在这个小节里，我们不再介绍VR显示的部分，直接介绍交互部分即可。 /** 初始化XR */ async initXR(){ //创建一个webXR的摄像机 let caInfo : WebXRCameraInfo = new WebXRCameraInfo(); //设置远裁面 caInfo.depthFar = this.camera.farPlane; //设置近裁面 caInfo.depthNear = this.camera.nearPlane; //申请XR的交互，传入VR需要的信息 let webXRSessionManager = await WebXRExperienceHelper.enterXRAsync(\"imersive-vr\",\"local\",caInfo); //设置WebXR摄像机 let webXRCameraManager = WebXRExperienceHelper.setWebXRCamera(this.camera, webXRSessionManager); //注意，这里开始对VR进入手柄输入的控制交互 let webXRInput = WebXEExperienceHelper.setWebXRInput(webXRSessionManager, webXRCameraManager); this.bindMeshRender(webXRInput); } bindMeshRender(webXRInput:WebXRInputManager){ let rightControl = Laya.loader.getRes(\"res/OculusController/controller.gltf\") as Sprite3D; let leftControl = Laya.loader.getRes(\"res/OculusController/controller-left.gltf\") as Sprite3D; let pixelright = new PixelLineSprite3D(20,\"right\"); let pixelleft = new PixelLineSprite3D(20,\"left\"); this.scene.addChild(rightControl); this.scene.addChild(leftControl); this.scene.addChild(pixelright); this.scene.addChild(pixelleft); webXRInput.bindMeshNode(leftControl,WebXRInput.HANDNESS_LEFT); webXRInput.bindMeshNode(rightControl,WebXRInput.HANDNESS_RIGHT); webXRInput.bindRayNode(pixelleft,WebXRInput.HANDNESS_LEFT); webXRInput.bindRayNode(pixelright,WebXRInput.HANDNESS_RIGHT); //获得xrInput的帧循环方案 webXRInput.getController(WebXRInput.HANDNESS_RIGHT).on(WebXRInput.EVENT_FRAMEUPDATA_WEBXRINPUT,this,this.getRightInput); webXRInput.getController(WebXRInput.HANDNESS_LEFT).on(WebXRInput.EVENT_FRAMEUPDATA_WEBXRINPUT,this,this.getLeftInput); /** * 0 扳机 * 1 侧扳机 * 3 摇杆按下 * 4 X、A键 * 5 Y、B键 */ // 左控制器监听 let leftXRInput = webXRInput.getController(WebXRInput.HANDNESS_LEFT); // 左控制器的按钮事件监听 leftXRInput.addButtonEvent(0,ButtonGamepad.EVENT_TOUCH_OUT,this,this.LeftbuttonEvent0); // 注意同一按钮的不同触发 leftXRInput.addButtonEvent(1,ButtonGamepad.EVENT_TOUCH_STAY,this,this.LeftbuttonEvent1); leftXRInput.addButtonEvent(1,ButtonGamepad.EVENT_TOUCH_OUT,this,this.LeftbuttonEvent1_1); leftXRInput.addButtonEvent(3,ButtonGamepad.EVENT_TOUCH_OUT,this,this.LeftbuttonEvent3); leftXRInput.addButtonEvent(4,ButtonGamepad.EVENT_TOUCH_ENTER,this,this.LeftbuttonEvent4); leftXRInput.addButtonEvent(5,ButtonGamepad.EVENT_TOUCH_OUT,this,this.LeftbuttonEvent5); // 左控制器的摇杆事件监听 leftXRInput.addAxisEvent(1,AxiGamepad.EVENT_OUTPUT,this,this.LeftAxisEvent); // 右控制器监听 let rightXRInput = webXRInput.getController(WebXRInput.HANDNESS_RIGHT); // 右控制器的按钮事件监听 rightXRInput.addButtonEvent(0,ButtonGamepad.EVENT_PRESS_ENTER,this,this.RightbuttonEvent0); rightXRInput.addButtonEvent(0,ButtonGamepad.EVENT_PRESS_VALUE, this, this.rightTriggerOn); // 注意同一按钮的不同触发 rightXRInput.addButtonEvent(1,ButtonGamepad.EVENT_PRESS_STAY,this,this.RightbuttonEvent1); rightXRInput.addButtonEvent(1,ButtonGamepad.EVENT_PRESS_OUT,this,this.RightbuttonEvent1_1); rightXRInput.addButtonEvent(3,ButtonGamepad.EVENT_PRESS_OUT,this,this.RightbuttonEvent3); rightXRInput.addButtonEvent(4,ButtonGamepad.EVENT_PRESS_ENTER,this,this.RightbuttonEvent4); rightXRInput.addButtonEvent(5,ButtonGamepad.EVENT_PRESS_OUT,this,this.RightbuttonEvent5); // 右控制器的摇杆事件监听 rightXRInput.addAxisEvent(1,AxiGamepad.EVENT_OUTPUT,this,this.RightAxisEvent); } /** 省略的代码请前往官网示例查看 **/ 以上的代码，并不是全部代码，关于oculus显示与交互的全部代码请前往官网示例中查看。 3.2.2 demo测试提示 代码编译好之后，直接前往Oculus Quest自带的浏览器中输入测试地址，即可运行测试效果。 提醒：Oculus Quest 设备的帐号激活也需要VPN翻墙 示例中默认状态为正常模式，需要点击按钮切换到WebXR模式，此时可查看VR示例并通过控制器进行交互。 在设定好VR设备的游戏区域后，打开VR设备的浏览器并跳转到WebXRController示例的地址，等待示例加载运行后，示例中默认状态为正常模式，同样需要点击按钮切换到WebXR模式，此时可查看VR示例并通过控制器进行交互。 示例的控制器交互说明： 射线检测并拾取物体 在VR场景内可见左右控制器及射线，可以通过射线来检测并拾取物体，具体操作为将射线末端或射线方向指向要拾取的物体，并持续按下左右控制器的侧扳机来锁定物体。 调节与拾取物体的距离 拾取到物体后，可以通过控制器上的按键来调节与物体的距离；右控制器上，”B“键为增加与物体的距离、”A“键为减小与物体的距离；左控制器上，”Y“键为增加与物体的距离、”X“键为减小与物体的距离。需要注意左控制器的X、Y按键为TOUCH类型的事件，触发灵敏，触摸按键即可触发。 调整拾取物体的旋转速度 拾取到物体后，可以通过控制器上的扳机键来控制物体的旋转速度；右控制器的扳机范围为线性范围，可在0~1的范围内通过对扳机施加的力度来控制旋转速度；左控制器的扳机事件也可以为线性范围，为了区别事件触发，左控制器扳机设置为固定值，无法通过左扳机进行调节。 调整拾取物体在x、y轴上的旋转角度 拾取到物体后，可以通过控制器上的摇杆来调整物体在x、y轴上的旋转角度，两个控制器摇杆逻辑一致，摇杆的前后移动调整物体在x轴上的角度；摇杆的左右移动调整物体在y轴上的角度。 控制器事件监听 控制器事件监听主要分为TOUCH与PRESS两大类，事件监听与实现逻辑如下： EVENT_TOUCH_ENTER与EVENT_PRESS_ENTER: 对应监听为左右控制器的X、A键，逻辑区别为X键轻触即可触发，A键需要按下才能触发。 EVENT_TOUCH_STAY与EVENT_PRESS_STAY: 对应监听为左右控制器的侧扳机按键，需要持续轻触或持续按下。 EVENT_TOUCH_OUT与EVENT_PRESS_OUT: 对应监听为左右控制器的Y、B键，逻辑区别为Y键轻触离开与B键按下离开。 EVENT_PRESS_VALUE: 对应监听是右扳机这类输出类型存在一个范围的事件。逻辑实现为根据扳机的按压力度来返回浮动的value值。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:44 "},"3D/advanced/Unity/readme.html":{"url":"3D/advanced/Unity/readme.html","title":"Unity资源导出插件","keywords":"","body":"Unity资源导出插件一、关于插件二、导入LayaAir的Unity插件2.1 创建一个空项目2.2 两种插件导入方式（项目中首次安装）三、资源导出插件的功能3.1 场景导出3.2 预设导出3.3 帮助 help四、场景对象导出支持列表4.1 Inspector面板的基础属性4.2 相机的属性4.3 光照相关的属性4.4 模型相关的属性4.5 纹理的属性4.6 动画的属性五、模型的导出文件与加载显示5.1 导出文件类型的说明5.2 加载显示Unity资源导出插件 一、关于插件 采用Unity插件方案的主要原因，主要是为了支持开发者在Unity资源商城中购买的资源可以无感的迁移到LayaAir IDE中进行相关的开发工作，Unity资源商城拥有一定数量的精美且高质量的美术资源，采用Untiy资源导出插件能将这些精美的美术资源迁移到LayaAir引擎的IDE中进行开发，对一些小而美的团队来说无疑是一种无形的帮助，更可以让有Unity经验的优质开发者可以更低学习成本进入HTML5和小游戏产业中来。 插件的下载地址：https://github.com/layabox/LayaAir3.0UnityPlugin/releases （图1-1） 直接下载Unity的资源包即可。 二、导入LayaAir的Unity插件 Unity里有一个导入自定义包的功能，通过这个功能，可以在Unity里导入LayaAir引擎提供的专属功能包，用来导出Unity里编辑好的场景和资源，然后再用以LayaAir引擎3D的开发。在Unity里导入这个自定义的LayaAir功能包的过程，我们可以视为安装了一个LayaAir引擎资源导出的Unity插件。本小节会针对这个过程进行详细介绍。 2.1 创建一个空项目 除非是在已经安装过LayaAir3D插件的Unity项目上进行升级安装，否则，我们建议去创建一个新的空项目。 因为直接打开一个Unity已有项目进行插件的安装，可能会有冲突，会导致插件安装不成功。 如果想使用已有Unity项目的场景资源和编辑好的场景，建议先在一个Unity空项目里安装好LayaAir引擎的插件后，再把旧项目的资源目录（也就是Unity项目中的Assets目录）复制到新建的项目里。 Tips: 旧项目中的其他文件对于导出插件而言都用不上，只复制Assets目录即可 2.2 两种插件导入方式（项目中首次安装） 2.2.1 菜单式导入 在Unity的资源菜单Assets（如图2-1）或者资源面板的Assets（如图2-2），右键import Package-> custom Package。 （图2-1）从菜单导入 （图2-2）从资源面板导入 以上的两种导入方式，任选一种点开后，选择之前下载好的LayaAir引擎unity插件（xx.unitypackage）打开，如图2-3所示。 （图2-3） 点击打开后，如图2-4所示，会有插件包含的内容列表展示，如果有我们不想要的功能，比如在Unity里直接预览这个功能不想要，也可以把相关默认的勾选去掉，但是我们建议全部导入（默认是全选）。 所以，我们直接点击Import按钮，开始全部导入，即可。 （图2-4） 导入完成后，我们可以看到菜单栏多出一个LayaAir3D，如图2-5所示。此时说明，已经导入成功。 （图2-5） 2.2.2 拖拽式导入 拖拽式安装的操作方式是把下载好的插件（xx.unitypackage）直接拖拽到Assets面板下，如图2-6所示。其他后续操作与菜单式安装一样。就不重复介绍了。 （图2-6） 2.2.3 插件导入安装的提醒 对于Unity还不太熟悉的开发者，需要提醒的是，LayaAir引擎Unity资源导出插件，不是一次导入所有项目通用，本质上这并不是真的为Unity安装工具插件，而是为项目导入自定义的功能包，虽然我们可以理解为工具插件，但要明白这个插件的本质。所以，在每次创建新的项目工程后，都要重复上面导入LayaAir插件包的过程。 三、资源导出插件的功能 3.1 场景导出 （图3-1）场景导出面板 3.1.1 节点设置 忽略未激活节点：如果勾选此选项，类似图3-2中Camera这类未激活的节点将不会被导出。 （图3-2） 3.1.2 模型设置 忽略顶点UV：如果勾选此选项，导出的Mesh数据不存在UV信息。 忽略顶点颜色：如果勾选此选项，导出的Mesh数据不存在顶点颜色信息。 忽略顶点法线：如果勾选此选项，导出的Mesh数据不存在顶点法线信息。 忽略顶点切线：如果勾选此选项，导出的Mesh数据不存在顶点切线信息。 自动生成UV1：如果勾选此选项，导出的Mesh数据UV Set设置为UV1。 3.1.3 其他设置 自定义导出根目录：如果勾选此选项，如图3-3所示，可以设置插件导出的资源路径(文本框填取绝对路径)。 （图3-3） 3.2 预设导出 （图3-4）预设导出面板 3.2.1 节点设置 忽略未激活节点：如果勾选此选项，类似图3-5中Camera这类未激活的节点将不会被导出。 （图3-5） 批量导出一级节点：如果勾选此选项，类似图3-6中这类节点最终导出的为LayaMonkey根节点。 （图3-6） 3.2.2 模型设置 忽略顶点UV：如果勾选此选项，导出的Mesh数据不存在UV信息。 忽略顶点颜色：如果勾选此选项，导出的Mesh数据不存在顶点颜色信息。 忽略顶点法线：如果勾选此选项，导出的Mesh数据不存在顶点法线信息。 忽略顶点切线：如果勾选此选项，导出的Mesh数据不存在顶点切线信息。 自动生成UV1：如果勾选此选项，导出的Mesh数据UV Set设置为UV1。 3.2.3 其他设置 自定义导出根目录：如果勾选此选项，如图3-7所示，可以设置插件导出的资源路径(文本框填取绝对路径)。 （图3-7） 3.3 帮助 help 帮助菜单项里，下级菜单有学习文档Study、问答社区Answsers这些外链菜单项，方便开发者快速进入对应的官网页面中。还有插件版本About LayaAir，如图3-8所示。 （图3-8） 四、场景对象导出支持列表 除了LayaAir引擎插件自身面板上的导出设置项，我们还要注意并且必须要了解Unity的功能面板有哪些是可以导出使用，哪些是不支持的。 因为LayaAir引擎的Unity插件并非是将Unity所有的功能全都支持导出。毕竟我们的LayaAir引擎设计与结构与Unity的引擎并不相同，虽然3D场景基于Unity编辑器进行编辑和导出，但我们需要按LayaAir引擎插件的支持规则来使用。 在本小节，我们就全面介绍LayaAir引擎与插件支持哪些Unity中的功能。如果在本小节支持清单中未提及的，都是当前不支持的。所以，如果是刚接触Unity的开发者，在学习Unity工具使用的时候，也不必要全部学习，可以把本小节中所涉及的支持内容，作为关键字搜索学习即可。 LayaAir引擎插件也会不断在更新，当升级新的引擎版本后，可以关注版本更新日志以及该文档的变化。 4.1 Inspector面板的基础属性 在Unity的Inspector面板中，可以查看和编辑Unity编辑器中几乎所有内容，下面，我们先了解一下Inspector面板的基础通用属性。 （图4-1） 在图4-1的基础属性里，LayaAir导出支持情况如下： Unity的Inspector基础属性 LayaAir是否支持导出的说明 GameObject Name（节点名称） 支持 Static（静态） 只支持勾选 或 不勾选 Layer（层） 只支持层的序号导出，开发者也可以在LayaAir引擎中设置Layer Position（位置） 支持（包括：X、Y、Z） Rotation（旋转） 支持（包括：X、Y、Z） Scale（缩放） 支持（包括：X、Y、Z） 对比上面的图和表格，我们看到Tag是不支持的。Static与Layer是部分支持。后续将不再提醒，关注表格中的支持状态即可。 这里特别说一下，静态Static勾选后是全选，也就是Everything，如图4-2所示。但实际上LayaAir引擎只支持了Lightmap Static和Batching Static，那开发者不选Everything，只勾选这两个行不行。当然是不行的，我们其实只认Static勾选或不勾选这个状态，如果此处单独选择，导出并没有效果。 （图4-2） 4.2 相机的属性 （图4-3） 在图4-3中的Unity相机属性里，LayaAir导出支持情况如下： Unity的相机属性 LayaAir是否支持导出的说明 Clear Flags（清除标志） 支持 （包括：Skybox天空盒（Background背景色）、Solid Color纯色（Background背景色）、Depth only仅深度、Don’t Clear不清除） Projection（投射方式） 支持（包括：Perspective透视（Field of View视野范围），Orthographic正交（size视野大小）） Clipping Planes（剪裁平面） 支持（包括：Near近点、Far远点） Viewport Rect（标准视图矩形） 支持（包括：X、Y、W、H） Allow HDR（允许渲染高动态色彩画面） 支持 Culling Mask在Unity中设置无效，但是layaAir引擎中是支持的，默认值相当于Unity中的Everything，也可以通过引擎的cullingMask进行设置层ID。 4.3 光照相关的属性 4.3.1 灯光的属性Light （图4-4） 在图4-4中的Unity灯光属性里，LayaAir导出支持情况如下： Unity的灯光属性 LayaAir是否支持导出的说明 Type（灯光类型） 部分支持（包括：Spot聚光（Range照射范围、Spot Angle聚光灯锥形角度）、Directional平行光、Point点光（Range照射范围）） Color（灯光颜色） 支持 Mode（灯光模式） 部分支持（包括：Realtime实时灯光、Baked烘焙光照贴图） Intensity（灯光强度） 支持 Tips：灯光的阴影不支持从Unity中导出使用，但是LayaAir引擎中有灯光阴影的API，具体阴影的使用，可以查阅LayaAir引擎相应的官方文档与API。 4.3.2 反射探针的属性 Reflection Probe （图4-5） 当Unity中添加Reflection Probe（反射探针）组件后，在图4-5中的属性里，LayaAir导出支持情况如下： Unity的反射探针相关配置属性 LayaAir是否支持导出的说明 Type（类型） 部分支持（包括：Baked烘焙模式、Custom自定义模式） Runtime settings （运行时设置） 部分支持（包括：Importance权重参数、Intensity亮度、Box projection盒式偏移反射、Box Size反射探针大小、Box Offset反射探针偏移） Cubemap capture settings（立方体贴图捕捉设置） 支持 4.4 模型相关的属性 关于模型的属性，分别支持普通模型和骨骼模型。 4.4.1 普通模型 普通模型需要Mesh Filter组件Mesh Render组件，下面分别进行介绍。 网格过滤器Mesh Filter （图4-6） 在图4-6中的Unity网格过滤器属性里，LayaAir导出支持情况如下： Unity的蒙皮网格渲染属性 LayaAir是否支持导出的说明 Mesh（网格） 支持 网格渲染器Mesh Renderer （图4-7） （图4-8） 在图4-7中Unity的Mesh Render组件属性里，LayaAir导出支持情况如下： Unity的网格渲染属性 LayaAir是否支持导出的说明 Materials（材质） 支持（包括：Size大小、Element材质球元素） Lightmap Static（ 静态光照贴图） 部分支持（包括：Lightmaps贴图（Baked Lightmap烘焙光照贴图（Lightmap Index、Tiling X、Tiling Y、Offset X、Offset Y））） 4.4.2 骨骼模型 骨骼模型的Mesh与Mesh Renderer不再分开，合并在组件Skinned Mesh Renderer里，如下图所示： （图4-9） 在图4-9中Unity的Skinned Mesh Renderer组件属性里，LayaAir导出支持情况如下： Unity的蒙皮网格渲染属性 LayaAir是否支持导出的说明 Mesh（网格） 支持 Root Bone（骨骼根节点） 支持 Bounds（包围盒） 支持（包括：Center中心（X、Y、Z）、Extent范围（X、Y、Z）） Materials（材质） 支持（包括：Size大小、Element材质球元素） 4.4.3 材质 对于模型的材质，这里我们介绍一下常见支持的材质类型。 分类 材质 Build in 管线 Standard 材质 Ulit Color/Texture/Cut Out/ Transparent 材质 URP 管线 URP Lit材质 URP Ulit材质 天空盒 Procedural 程序化天空盒 6 Sideed Panoramic 全景图 旧版着色器（只做兼容考虑, 不建议） Diffuse Fast Diffuse Diffuse Detail Bumped Diffuse Bumped Specular 除了上述提供的材质Shader外，Unity里的其他材质，都不能在LayaAir引擎中使用。 4.5 纹理的属性 在Assets（资源）面板里，找到2D图片资源，可以为其设置纹理的属性。 （图4-10） 在图4-10中的Unity纹理属性里，LayaAir导出支持情况如下： Unity的纹理属性 LayaAir是否支持导出的说明 Generate Mip Maps（生成Mipmap） 部分支持（仅支持是否勾选的状态） Wrap Mode（循环模式） 部分支持（包括：Repeat重复、Clamp强制拉伸） Filter Mode（过滤模式） 支持（包括：Point点过滤、Bilinear双线性过滤、Trilinear三线性过滤） Aniso Level（各向异性等级） 支持 4.6 动画的属性 在动画方面，LayaAir支持Animator组件和关联的Animator Controller面板的部分属性导出和使用。 4.6.1 Aniamtor组件 （图4-11） 在图4-11中的Unity动画属性里，LayaAir导出支持情况如下： Unity的动画属性 LayaAir是否支持导出的说明 Controller（动画控制器） 支持 Culling Mode（ 剔除模式） 部分支持（包括：Always Animate 总是播放、Cull Completely完全剔除） 4.6.2 Animator Controller State 在Aniamtor组件属性中双击Controller打开动画控制器的面板，选中State(状态)，可以看到图4-12所示的面板。 （图4-12） 在图4-12中的Unity动画控制器State属性里，LayaAir导出支持情况如下： Unity的动画控制器State属性 LayaAir是否支持导出的说明 Motion（选定动画） 支持 Speed（动画播放速度） 支持 五、模型的导出文件与加载显示 当了解完插件的功能和使用规则后，我们就可以在Unity中进行编辑并导出了，但是导出后的文件名分别代表着什么，又是怎么进行加载使用的。本小节开始为大家介绍。 5.1 导出文件类型的说明 文件的后缀 导出文件类型的说明 .ls 场景文件，选择导出场景Scene3D类别时生成的文件类型。会导出完整的场景信息，其中包含了场景需要的各种数据、光照贴图、模型、位置等。所以，需要导出场景相关的设置时，必须要使用Scene3D类别导出，就可以看到.ls后缀的文件。 .lh 预设文件，选择导出预设Sprite3D类别时生成的文件类型。相对于.ls后缀的场景文件，会缺少环境光、环境反射、场景雾效等等与场景渲染相关的信息。 .lm 模型数据文件，通常是FBX格式的转换而成。 .lmat 材质数据文件，是在unity中为模型设置的材质信息。加载.ls或.lh文件时会自动加载.lmat文件来产生材质。可以使用 BaseMaterial 类来加载。 .lani 动画数据文件，如果模型上有动画，导出后将生成的动画配置文件，其中包含了动画帧数据。加载可以使用 AnimationClip 类来加载。 .jpg JPEG格式的纹理图片文件。 .png PNG格式的纹理图片文件。 .hdr 全景天空盒需要的HDR格式图片文件 5.2 加载显示 导出的Unity资源，在不考虑其它逻辑的情况下，要通过LayaAir引擎显示出来，就需要先加载资源。 5.2.1 场景的加载显示 当我们想导出整个场景时，可以选择场景，设置导出路径。如图5-1所示，导出路径建议设置为在LayaAir IDE项目工程目录下的assets文件夹，至于是assets目录下的什么目录，由开发者自行决定。 （图5-1） 导出之后只需在IDE中打开其中的.ls文件，即可加载场景。 打开场景后，导出的场景并不具有环境光sh信息，需要找到在Scene3D层级下的烘焙开关。如图5-2所示，点击烘培，对当前场景的环境光sh数据进行预计算， 这样烘焙完成后的效果就是我们想要的效果了。 （图5-2） 5.2.2 预设的加载显示 如图5-3所示，预设的导出，主要是用于当不需要完整导出使用整个场景，只需要某些节点资源。又或者某些节点资源需要独立导出复用或代码动态使用等需求。 （图5-3） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-05-17 10:49:09 "},"released/web/readme.html":{"url":"released/web/readme.html","title":"Web发布","keywords":"","body":"Web发布一、概述二、IDE中发布2.1 构建发布2.2 发布选项2.3 目标平台2.4 发布代码使用的资源（resources）2.5 IDE中使用的资源2.6 分包三、打包图集3.1 为什么要使用图集资源3.2 支持图集打包的格式3.3 用LayaAir IDE制作图集的方式3.4 打包生成的图集文件介绍3.5 如何在项目中使用图集中的小图四、发布原生资源Web发布 一、概述 Web发布功能是非常核心的功能，通常是指发布为HTML5版本，运行于浏览器环境、webView、LayaNative的APP环境中。在项目完成开发，或阶段性完成开发，准备提交到生产环境中进行测试时，通常会用到项目发布的功能。由于LayaAir 3.0 IDE在功能和结构上与2.0相比有很大的变化，在IDE Web发布上面来说，开发者需要更多的注意资源目录的问题，本篇将具体讲解一下。 二、IDE中发布 2.1 构建发布 使用IDE 发布项目，开发者首先在文件菜单中，打开“构建发布”选项，如图2-1所示： （图2-1） 2.2 发布选项 构建发布选项打开后，我们来看看都有哪些选项： 名称：项目的名称，对于Web发布来说，就是html中的title名称。 目标平台：选择不同的平台类型，会在发布的时候适配不同的平台（详细参考2.3）。 输出目录：输出目录是指要发布到的目标目录，默认在项目的release目录下，这里不建议更改。当然，开发者如果有需求自定义输出目录，可以在项目所在的目录，也可以是与项目无关的目录。 压缩引擎库：勾选后，将使用压缩后的引擎类库。 压缩JS文件：勾选后，将使用压缩后的JS文件。 Sourcemap：勾选后，输出目录会打包”.js.map“文件，用于源代码映射。 启动场景：启动项目运行时的第一个场景。 包含场景：所包含的场景所引用的资源会拷贝到输出目录中（详细参考2.5.1）。 始终包含的资源目录：所选资源目录下的资源始终拷贝到输出目录中（详细参考2.5.2）。 拷贝BIN目录下文件：勾选后，发布的输出目录会包含工程目录中bin文件夹中的文件（详细参考第四节）。 开启版本管理：勾选后，将会对发布的文件名添加key值用于版本管理映射，可以有效避免缓存或CDN带来的错误加载影响。 开启分包：勾选后，开启分包功能（详细参考2.6）。 2.3 目标平台 发布平台中有目前有八种选择选项，分别为：Web、Android、iOS、字节跳动小游戏、OPPO小游戏、VIVO小游戏、微信小游戏、小米快游戏。如图2-2所示。 （图2-2） Web 是指发布为HTML5版本，运行于浏览器环境、webView、LayaNative的APP环境中。 Android 是指发布为安卓平台，运行于安卓的APP环境中。 iOS 是指发布为iOS平台，运行于iOS的APP环境中。 字节跳动小游戏 是指发布为已适配字节小游戏的项目，发布后的项目可以运行于抖音开发者工具内（关于字节跳动小游戏可阅读相关的文档）。 OPPO小游戏是指发布为已适配OPPO小游戏的项目，发布后的项目可以运行OPPO开发者工具内（关于OPPO小游戏可阅读相关的文档）。 VIVO小游戏是指发布为已适配VIVO小游戏的项目，发布后的项目可以运行VIVO开发者工具内（关于VIVO小游戏可阅读相关的文档）。 微信小游戏 是指发布为已适配微信小游戏的项目，发布后的项目可以运行于微信开发者工具内（关于微信小游戏可阅读相关的文档）。 小米快游戏是指发布为已适配小米快游戏的项目，发布后的项目可以运行小米开发者工具内（关于小米快游戏可阅读相关的文档）。 本篇主要介绍Web发布目录，除此之外的发布平台可以参考其它文档。 2.4 发布代码使用的资源（resources） 开发者的项目中往往会使用代码引用的方式来使用资源，那么对于IDE来说就无法识别这些资源，因此IDE指定了 Resources 目录为开发者满足此需求，如图2-3所示： （图2-3） 这是一个示例项目，只通过代码来实现资源的使用，注意resources 目录下有两个图片 image 和 c1，来看下发布后的目录。点击“版本发布”按钮，等待发布成功后，如图2-4所示。 （图2-4） 我们看到web目录下会有一个 resources 目录，里面包括了 image 和 c1，同时我们发现还有两个json文件，实际上json文件中是资源属性信息，文件内容如下： { \"sRGB\": true, \"wrapMode\": 0, \"filterMode\": 1, \"anisoLevel\": 0, \"readWrite\": false, \"mipmap\": false, \"pma\": true, \"hdrEncodeFormat\": 0, \"files\": [ { \"file\": \"\", \"ext\": \"png\", \"format\": 1 } ], \"platforms\": { \"0\": 0, \"1\": 0, \"2\": 0 } } 在不需要额外操作的情况下，resources 目录中的任何资源都会发布到输出目录中，因此开发者可以利用 resources 目录作为代码使用资源的目录。 2.5 IDE中使用的资源 上述 resources 目录主要是针对用代码使用资源的方式，资源需要存放到 resources 目录。但是在我们实际开发过程中，资源通常会放到assets目录下，包括场景和预制体文件等等，如图2-5所示，这是IDE中自带的“3D-RPG示例”项目。 （图2-5） 这么多的资源目录，如果都改到 resources 目录是一件非常庞大的修改工作。因此IDE为开发者提供了两种更便捷的方式： 2.5.1 包含场景：场景中引用的资源 如图2-6所示，可以把Game等场景添加到包含场景中，这些场景所引用的资源都会发布到输出目录中，发布后打开发布后的目录。 （图2-6） 如图2-7所示，这些目录已经成功发布到输出目录中。 （图2-7） 接下来运行看看效果，如动图2-8所示： （动图2-8） 可以看到场景正常运行，但是没有发现敌人，并且没有音乐。打开调试信息，如图2-9所示，可以看到 enemy.lh 和 bgm.mp3 并没有在输出目录中，这是由于 enemy.lh 和 bgm.mp3 是通过代码执行的。代码里引用的资源，必须放到resources目录里，才会被复制到发布目录里，如果代码引用的资源不在resources目录下，也没有在场景中进行引用，则需要将该资源所在目录设置为始终包含的资源目录。 （图2-9） 这时，我们可以使用第二种方式 2.5.2 始终包含的资源目录：代码中引用的资源 在”始终包含的资源目录“选项中，点击+选择 enemy.lh 和 bgm.mp3 资源所在的文件夹，如图2-10所示 ： （图2-10） 此时，再次点击“版本发布”，等待发布成功后，查看输出目录，如图2-11所示，发现 enemy.lh 和 bgm.mp3 文件已经分别发布到 prefab 和 music 目录中。 （图2-11） 此时运行再看看效果，如图2-12所示，敌人已经正常运行，说明资源的发布都已经包含了。 （图2-12） 最后来总结一下，如图2-13所示，通过 resources目录、包含场景、始终包含的资源目录三种方式，可以让项目运行过程中所使用的资源都成功打包到输出目录中。 当项目需要的资源较少时，可以统一放在图中标号1的resources目录下，这样不论是场景中引用或者是代码中引用的资源，都可以发布到输出目录下；当项目的资源较多时，放在resources目录下不方便管理，那么发布时就需要对resources目录外的资源目录进行设置，场景要添加在标号2的”包含场景“中，代码中引用的资源要添加在标号为3的”始终包含的资源目录“中。 （图2-13） 开发者在项目开发的初始阶段，尽量提前规划好项目资源的目录结构，避免造成资源的重复使用，或者是项目后期不断修改资源目录，造成场景中资源引用错误的情况发生。 2.6 分包 在构建发布时，可以进行分包，分包就是将选定的资源分成多个小包，以便于用户进行资源加载，还可以避免网络不稳定出现中断等问题。对于Web目标平台下，一般使用的是远程包，后面2.6.1节会详细介绍原因。 下面先以一个具体的例子，来演示如何开启分包。如动图2-14所示，点击开启分包后，可以在下面增加一个或多个分包，动图中添加了两个分包（资源文件夹），选择路径\"sub1\"和\"sub2\"后，则这两个路径下所有资源，在发布后各成为一个分包。 ”sub1“中有预制体（Cube.lh）、材质（CubeMaterial.lmat）、纹理图（layaAir.png）；\"sub2\"中只有一个预制体（Sphere.lh）。 （动图2-14） 在配置分包时，需要设置如下参数： 参数 说明 资源文件夹 资源文件夹中的内容，就是要进行分包的资源 是否远程包 勾选后，该资源文件夹（分包）在版本发布后会转移到remote目录下 启动时自动加载 勾选后，运行启动发布的项目时，该资源文件夹（分包）会自动加载 远程包地址 如果同时勾选“是否远程包”和“启动时自动加载”，会显示此参数，要求填写远程包的地址 2.6.1 Web远程包 Web平台可以使用远程包。远程包是指可以将这部分资源放置到CDN（内容分发网络，不理解的读者可以先将它理解为一种服务器），来提供高性能、可扩展性及低成本的网络内容传递给用户。如果Web平台不使用远程包，则对其分包的意义不大。 例如动图2-15所示，如果设置\"sub1\"和\"sub2\"目录为远程包，则在发布后，这两个目录会转移到“remote”目录下。 （动图2-15） 开发者需要自行将“remote”下所有的子目录传到CDN（不是传“remote”目录本身，要传该目录下的\"sub1\"和\"sub2\"），上传完成后将“remote”目录删除即可。这里为了方便演示，使用本地服务器来模拟代替CDN。 在桌面新建一个文件夹命名为“serve”，它表示本地服务器中的文件夹，里面新建了一个文本文件“这是一个本地服务器.txt”用来测试本地服务器启动成功。可以使用Node.js的anywhere启动一个本地服务器。如动图2-16所示，在“serve”文件夹中打开命令行cmd，输入anywhere 2840，然后点击键盘回车键就可以启动一个本地服务器了，其中2840是指定的端口号。 （动图2-16） 通过动图可以看到，本地服务器的地址为http://192.168.56.1:2840/，这个地址在后面的演示会用到。这里要注意，在运行发布的项目时，需要本地服务器为开启状态。 下一步就是将资源导入到本地服务器，在实际上传到CDN时，可以使用工具进行上传，但对于本地服务器来说，直接将远程包（\"sub1\"和\"sub2\"）从“remote”文件夹剪切到“serve”文件夹即可，然后删除“remote”目录。 [!Tip] 小游戏平台不可以用远程包，具体小游戏的分包请参考对应小游戏发布的文档。 将远程包导入本地服务器后，加载远程包有两种情况，在IDE中自动加载，和用代码进行加载。 2.6.2 IDE中自动加载 如图2-17所示，在IDE中引用了资源（添加资源在场景中）后， （图2-17） 在构建发布时，勾选启动时自动加载，然后填写远程包地址，就是本地服务器的地址http://192.168.56.1:2840/，如下动图所示： （动图2-18） 点击版本发布后，需要再次将\"sub1\"和\"sub2\"上传到本地服务器“serve”文件夹，然后删除“remote”目录，如动图2-19所示： （动图2-19） 现在就可以运行发布的Web项目了，如动图2-20所示，同样也是使用本地调试的方法，在发布的文件夹中打开命令窗口，输入anywhere回车启动，运行Web项目时是默认端口号8000，注意要保持远程包地址http://192.168.56.1:2840/的本地服务器为开启状态。 （动图2-20） 可以看到资源都加载出来了，打开开发者工具，如图2-21所示，可以看到资源是从远程包http://192.168.56.1:2840/加载的。 （图2-21） 2.6.3 代码引用的资源 有时，我们不想让游戏一开始就加载过多的资源，这样负荷太大，这时就需要手动代码加载了。 如图2-22所示，场景中没有引用要分包的资源，在Scene2D节点的属性设置中添加一个自定义组件脚本， （图2-22） 然后在脚本中添加如下代码： const { regClass, property } = Laya; @regClass() export class Script extends Laya.Script { //declare owner : Laya.Sprite3D; @property({ type: Laya.Scene3D }) scene3d: Laya.Scene3D; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { //Web平台使用远程包 Laya.loader.loadPackage(\"sub1\",\"http://192.168.56.1:2840/\",this.printProgress).then(()=>{ Laya.loader.load(\"sub1/cube.lh\").then((res:Laya.PrefabImpl) =>{ let sp3:Laya.Sprite3D =res.create() as Laya.Sprite3D; this.scene3d.addChild(sp3); }); }) Laya.loader.loadPackage(\"sub2\",\"http://192.168.56.1:2840/\",this.printProgress).then(()=>{ Laya.loader.load(\"sub2/sphere.lh\").then((res:Laya.PrefabImpl) =>{ let sp3:Laya.Sprite3D =res.create() as Laya.Sprite3D; sp3.transform.localPositionX += 1.0; //防止球体和立方体都在初始位置发生重叠 this.scene3d.addChild(sp3); }); }) } printProgress(res: any) { console.log(\"加载进度\" + JSON.stringify(res)); //将res对象转换成JSON格式的字符串，此处打印的值为1。本句代码主要应用于小游戏发布后打印loadTask反应下载进度 } } 注：资源加载请参考《资源加载》。 利用代码加载时，不勾选启动时自动加载，但如果分包的资源不在resources目录下（本例中的\"sub1\"和\"sub2\"就不在），就要将包添加到始终包含的资源目录中，配置如下图所示： （图2-23） 点击版本发布后，与之前的操作一样，需要将\"sub1\"和\"sub2\"上传到本地服务器“serve”文件夹，然后删除“remote”目录。 接下来就可以运行这个Web项目了，与之前的操作相同，使用anywhere启动，效果如图2-24所示： （图2-24） 可以看到资源加载出来了，打开开发者工具，如图2-25所示，可以看到资源是从远程包http://192.168.56.1:2840/加载的。 （图2-25） 三、打包图集 图集(Atlas)是游戏开发中常见的一种美术资源，通过IDE发布流程将多张图片合并成一张大图，并通过atlas格式的文件存放原始图片资源信息。 图3-1就是采用LayaAirIDE打包好的一张png图集资源。 (图3-1) 3.1 为什么要使用图集资源 在游戏中使用多张图片合成的图集资源作为美术资源，有以下优势： 1 优化内存 合成图集时会去除每张图片周围的空白区域，加上可以在整体上实施各种优化算法，合成图集后可以大大减少游戏包体和内存占用。 2 减少CPU运算 多个 Sprite 如果渲染的是来自同一张图集的图片时，这些Sprite可以使用同一个渲染批次来处理，大大的减少CPU的运算时间，提高运行效率。 3.2 支持图集打包的格式 LayaAirIDE支持对PNG与JPG两种资源格式打包为图集。但是图集打包的原始资源，推荐使用PNG，因为JPG的体积会较大。 Tips： 需要注意的是，PNG原始资源的位深度不能超过32，否则打包出来的图集会出现花屏。打进图集的资源 Texttrue Type 属性要设置为 SpritetTextrue 。另外，PNG与JPG资源不能是其它格式的资源改名为PNG与JPG格式的。 3.3 用LayaAir IDE制作图集的方式 用LayaAir IDE制作图集有两种方式，第一种方式更为细致，第二种方式更为简单快捷，开发者可以自行选择。 3.3.1 自动生成 自动将图片资源打包只有在LayaAir IDE发布时才可以，但是需要添加和设置图集打包配置文件，这里我们通过一个示例来讲解，如图3-2所示： （图3-2） 1，所有的图片资源都放在 assets/resources 目录下，上文提到，由于项目开发中图片可能会使用代码的使用方式，因此在不指定“始终包含的资源目录”的情况下，放在resources目录下会直接发布到输出目录中。 2，resources目录下的atlas目录，用来存放一些散图和子文件夹（里面也有散图），这么做的好处是对资源做好分类管理，往往resources目录下还有其它资源目录，尽量把图片资源和其它资源分开存放。 3，atlas目录下，有三个图片（img_head，img_head2 和 layaAir）和子文件夹 comp 和 ui，里面分别有很多散图，同时ui目录下还有 a子文件夹 如果不进行图集打包，那么在发布后，输出目录下的 atlas 目录里都是散图。下面来看看如何打包图集： 第一步：添加配置文件 如动图3-3所示，在atlas目录下添加配置文件。 （动图3-3） 在assets目录下，点击左上角的 + 按钮，选择“自动图集设置”，则会创建一个AtlasConfig文件，拖入这个文件到atlas目录下。放到atlas下的目的，是可以对atlas目录中的图片和子文件夹下的图片同时进行图集打包（支持单张图集和多个子文件夹图集）。同时开发者可以对此文件改名。 第二步：图集设置文件属性 点击 AtlasConfig 文件，如图3-4所示： （图3-4） 子文件夹处理： One texture per folder：每个子文件夹打包一个图集。 One texture：所有子文件夹和同级目录中的图片打包成一个大图集。 包含子文件夹： 勾选后，支持将子文件夹打包图集，不勾选，只处理同一级目录中的图片打包图集。 图集最大宽\\高度： 默认值为2048×2048，该值决定单个图集的最大尺寸。如果原始图片过多，超过单个图集最大宽高时，则会在打包时生成新的图集文件（多个图集）。 单图最大宽\\高度： 默认值为512×512，超过这个尺寸的单图将不会被打包到图集中。 Tips：超过512×512的单图不建议打包到图集中，可以单独预加载此图，但是，加载单图也不能超过1024×1024，否则会对性能有影响。 纹理集缩放： 这里可以通过缩放减少图集体积，比如改为0.5，IDE会按原图宽高分别乘0.5生成到图集中，显示的时候会保持会通过拉伸保持原图大小，这样处理后，虽然图集的尺寸会变小，但是显示的效果也会有所影响，可以视为一种图集的另类压缩方案。如果要保持设计时的图片精度，尽量不要调整默认值。 二次幂限制： 如果勾选，则生成的图集图片宽高将会是2的整次幂。这里，建议美术在设计的时候，就按2的整次幂来设计，通过图集工具强行保持2的整次幂，肯定会导致图集的体积变大。所以，除非是面临某些强制要求按2的整次幂优化的Runtime环境，常规情况下无需勾选，尽量提要求给美术设计人员，按32、64、128、256等2的整次幂来设计图片的宽高。 剪裁图片周边空白： 如果勾选，则生成的图集图片会自动把原始图片中空白区域裁剪掉。默认是是勾选状态，不要去掉。 纹理格式： png32为默认格式，此格式支持透明度和更多的颜色；png24，无透明度；纹理压缩参考文档《纹理压缩》。 第三步：发布生成图集 当设置好后，在“构建发布”进行发布，等待发布成功，这时来看看发布后的目录，如图3-5所示： （图3-5） 1、生成了3个图集（Atlas_ui，Atlas_comp 和 Atlas），由于选择了 One texture per folder 方式，ui 和 comp 各自生成一个图集，atlas下的图生成一个图集。 2、layaAir.png 没有打入图集，是由于此图尺寸超过了512x512，因此单独不打入图集 3、ui目录，是因为ui目录下存在一个a的目录，打包图集过程中并不支持子文件夹下的子文件夹，因此 ui/a 目录保留，下面还是散图。 3.3.2 工具制作 第二种方式更为快捷简单，但无法做到像第一种方式那样进行细致的属性设置，此方法在《动画节点》中也有提到，下面来为大家演示。 首先点击”工具“菜单中的”制作图集“。 （图3-6） 然后将所需要打包的文件夹拖入图片所在文件夹中，点击制作。 （图3-7） 也可以点击文件夹图标自行选择路径，如图3-8所示。 （图3-8） 点击制作之后，输入文件名点击保存如图3-9所示。 （图3-9） 这样图集就制作好了。 当我们对图集中包含的图片有增删时，只需要重复一次上面的流程，点击.atlas文件，点击是，即可成功替换，如图3-10所示。 （图3-10） [!Tip] 如果使用第二种图集打包方式，那么开发者要保证，此目录会非常稳定，后续不会进行图片资源的增删修改，如果不能保证稳定的目录，那么最好使用第一种打包方式。 3.4 打包生成的图集文件介绍 3.4.1 打包生成的图集文件 打包图集后，会生成图集专用资源（分别是同名的.atlas文件和.png文件） 3.4.2 atlas后缀文件 .atlas是LayaAirIDE特有的图集格式，仅用于图集，所以在加载.atlas时不需要填写类型，和加载普通的单图方式一样，更加方便，是推荐的图集加载方式。atlas方式加载图集的示例代码为： //atlas方式图集使用示例 Laya.loader.load(\"resources/atlas/Atlas_ui.atlas\").then( ()=>{} ); 3.5 如何在项目中使用图集中的小图 在项目中如果用到图集中的资源，则需先预加载图集资源，然后设置图片的皮肤（skin）属性值为“原小图目录名/原小图资源名.png”。 例如：现在我们将图3-5中原来的小图 img_head2.png 和 comp 目录下的 image.png 在项目中通过图集的方式显示出来，示例代码如下： let resArr: Array = [ { url: \"resources/atlas/Atlas.atlas\", type: Laya.Loader.ATLAS }, { url: \"resources/atlas/Atlas_ui.atlas\", type: Laya.Loader.ATLAS }, { url: \"resources/atlas/Atlas_comp.atlas\", type: Laya.Loader.ATLAS }]; Laya.loader.load(resArr).then( ()=>{ //创建Image1实例 var img1 = new Laya.Image(); //设置皮肤（取图集中小图的方式就是 原小图目录名/原小图资源名.png） img1.skin = \"resources/atlas/img_head2.png\"; //添加到舞台上显示 Laya.stage.addChild(img1); //创建Image2实例 var img2 = new Laya.Image(); //设置皮肤（取图集中小图的方式就是 原小图目录名/原小图资源名.png） img2.skin = \"resources/atlas/comp/image.png\"; //添加到舞台上显示 Laya.stage.addChild(img2); } ); 运行效果，如图3-11所示： （图3-11） 至此，打包图集就介绍完了，开发者需要提前规划好图片的目录管理，可以根据功能划分，每个功能创建一个子文件夹，这样图集的尺寸能尽量控制在合理范围内，按功能划分的好处也是方便查找。开发者在使用过程中如果遇到问题，欢迎随时和我们交流。 四、发布原生资源 原生资源是指通过原生JS实现DOM元素加载的资源，在项目开发中通常会用到，因此有的开发者希望在index.html里写入一些实现DOM的JS代码来加载这些图片或者视频资源，在预览运行时，由于index.html在bin目录下，因此这些资源只能存放在bin目录下。如图4-1所示： （图4-1） LayaAir 3.0.0 beta5 版本开始，会支持发布bin目录下原生资源的功能 在项目Web发布后，默认情况下，所有bin目录下的资源都会发布到web目录中，如图4-2所示： （图4-2） 同时，LayaAir3.0 IDE也为开发者提供了排除资源规则，在这里添加规则可以指示打包器排除bin文件夹下的部分文件或文件夹，例如排除一个文件夹可以使用‘abc/**’等，如图4-3所示 （图4-3） 点击发布后，上述bin文件夹下的原生资源都已经排除了，如图4-4所示： （图4-4） 推荐调用原生对象，下面来讲讲用LayaAir调用原生对象的好处。 我们来举一个例子 ，在bin目录下的index.html中加入一个img标签添加了一些样式，src指定为bin目录下的bg2.png，同时有点击图片隐藏图片的功能，如图4-5所示。发布后，这段DOM的代码也会一同发布到web目录下的index.html中。 （图4-5） 我们运行web目录下的index.html是没有问题的，但是bg2.png必须放在bin目录下，如果项目的开发中也可能会使用到这张图，也就是说assets目录下也会同样存放一张bg2.png，那么开发者就需要在两个地方维护同样的图，造成了一定的麻烦。因此我们推荐开发者使用LayaAir提供的调用原生对象的方式来处理，代码如下： //创建原生img对象 let img:any = Laya.Browser.document.createElement(\"img\"); //设置样式 img.style = \"position:absolute;left:10;top:10;cursor:pointer;\"; //指定资源地址 img.src = Laya.URL.postFormatURL(Laya.URL.formatURL(\"resources/bg2.png\")); //设置img元素的属性 img.setAttribute(\"onclick\", \"this.style.display=\\'none\\'\"); //添加到页面 Laya.Browser.document.body.appendChild(img); 我们把bin目录下index.html中的DOM代码删掉，并且把bg2.png剪切到assets的resources目录下，再次发布 这种情况下，web目录下的index.html没有任何DOM代码了，bg2.png也在resources目录下只有一份，同时运行效果也与之前一样！ 通过使用 Laya.URL.postFormatURL(Laya.URL.formatURL(\"resources/bg2.png\")); 在IDE的预览时和发布后运行时，LayaAir引擎都会使用 resources/bg2.png 作为原生img的src的图片地址，开发者可以自己来试一试。 到这里，通过LayaAir调用原生对象的方式就介绍完了，开发者可以根据自己的需求来使用。 注意：beta5之前的老项目导入，需要手动删除bin里index.html，预览时会重新生成新的模板 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-06-09 19:57:34 "},"released/miniGame/readme.html":{"url":"released/miniGame/readme.html","title":"小游戏发布","keywords":"","body":"小游戏发布一、什么是小游戏？二、小游戏与HTML5的差异2.1 运行底层的差异2.2 包体的差异2.3 缓存与其它小游戏接口三、LayaAir适配哪些小游戏平台小游戏发布 一、什么是小游戏？ 小游戏最早是来自于微信，微信小游戏的火爆开始带动其他平台的跟进。 那么小游戏到底是什么呢？ 微信小游戏官方的解释是： [!Note] 微信小游戏是微信小程序的一个类目，它即点即玩，无需下载安装，体验轻便，可以和微信内的好友一起玩，比如PK、围观等。 其表象体验的核心是：无需下载安装、即点即玩。至于好友关系链，并非所有平台的小游戏都适合利用关系链来推广。 其它特性将在其它章节介绍。 我们需要知道的是，尽管大多数平台延续了微信小游戏的命名，也叫XX小游戏，但也有其它的命名，例如华为与小米，均叫XX快游戏。 无论什么名称，但各平台的基本体验与特性都大同小异，所以我们可以泛指这些都是小游戏。 二、小游戏与HTML5的差异 那无需下载安装、即点即玩，HTML5不是也可以做到吗？那又和小游戏有着怎样的区别？ 2.1 运行底层的差异 HTML5链接通常是基于浏览器或webView直接运行的。 而发布成APP的时候，LayaAir引擎支持基于C++编写的自研Runtime底层引擎来运行LayaAir引擎项目。 小游戏的原理与LayaAir发布Native APP的机制类似。也是采用了平台内置的Runtime去兼容Canvas和WebGL的接口，从而实现HTML5无需下载安装与即点即玩的体验。 所以，严格上讲小游戏并非是HTML5游戏，因为小游戏并非支持HTML5所有的标准与图形API接口。 当然，LayaAir引擎已适配主流的小游戏平台，开发者采用LayaAir引擎开发项目，无需修改，即可直接发布成为小游戏产品。 2.2 包体的差异 HTML5的资源包与代码，是需要通过网络进行加载后使用的。 而小游戏的代码包，必须放到小游戏的平台里，通过上传小游戏的代码包与审核，可以让平台加强知识产权的监管等好处。 从技术上看，小游戏的代码包和资源包的体量控制，可以让开发人员根据小游戏的规则控制好项目包体的大小，保障游戏的加载体验不至于过久。 2.3 缓存与其它小游戏接口 除了以上游戏本身项目关系密切的介绍，其实小游戏更大的好处是，提供了比HTML5更多的开放接口，例如更多的设备接口、AI接口、支付接口、广告接口、缓存文件管理接口、好友关系链接口等等。 三、LayaAir适配哪些小游戏平台 LayaAir 3.0当前适配了以下平台： 微信小游戏 字节跳动小游戏 OPPO小游戏 vivo小游戏 小米快游戏 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/miniGame/wechat/readme.html":{"url":"released/miniGame/wechat/readme.html","title":"微信小游戏","keywords":"","body":"微信小游戏一、概述二、发布为微信小游戏2.1 选择目标平台2.2 发布后的小游戏目录介绍三、用微信开发者工具创建小游戏项目3.1 开发者帐号登录，选择项目类型3.2 导入小游戏项目3.3 微信开发者工具的编译3.4 真机测试与调试四、微信小游戏的4M本地包与动态资源加载4.1 分包4.2 网络动态加载五、微信小游戏的50M物理缓存管理微信小游戏 一、概述 微信小游戏的运行环境并不是浏览器，也不能在浏览器中运行，而是运行于微信APP中的Runtime。尽管微信小游戏的接口兼容大部分Canvas和Webgl，具有即点即玩，无需下载安装的HTML5特性。显然，从严格的定义来讲，微信小游戏不是标准的HTML5游戏。 强烈推荐要看一看微信小游戏官方的文档，LayaAir引擎的文档更多的是引擎相关的，当然也会混合了一些小游戏接口的应用介绍，但是仔细看看微信官方文档肯定没错。 链接如下： https://developers.weixin.qq.com/minigame/dev/index.html 下载并安装微信开发者工具 微信开发者工具主要用于小游戏产品的预览与调试、真机测试、上传提交等。是小游戏开发的必备工具。 开发工具下载地址： https://developers.weixin.qq.com/minigame/dev/devtools/download.html 如果是采用微信官方API开发的话，还是要有一些要注意的，比如不支持DOM与BOM、小游戏只能有一个画布、不支持Eval、不支持XML等等…… 但是，对于LayaAir引擎的开发者来讲，不用刻意去了解到底有哪些差异，照正常的LayaAir引擎开发规则去开发就可以了。 微信小游戏API地址： https://developers.weixin.qq.com/minigame/dev/api/ 二、发布为微信小游戏 2.1 选择目标平台 点击构建项目，在弹出的构建项目界面里，选择发布平台为微信小游戏。如图2-1所示 （图2-1） 2.2 发布后的小游戏目录介绍 发布后的目录结构如图2-2所示 （图2-2） js 项目文件 与 libs 引擎库目录 项目代码和类库 resources资源目录 与 Scene.js resources资源目录和资源文件Scene.js，小游戏由于初始包的限制，建议将初始包的内容在规划好，最好能放到统一的目录下，便于初始包的剥离。 game.js微信小游戏的入口文件 游戏项目入口JS文件与适配库JS等都是在这里进行引入。IDE创建项目的时候已生成好，一般情况下，这里不需要动。 game.json 小游戏的配置文件 开发者工具和客户端需要读取这个配置，完成相关界面渲染和属性设置。比如屏幕的横竖屏方向，状态栏的显示、小游戏分包等，都是在这里配置。具体如何配置，以及参数的使用，可以查看微信小游戏的开发文档。 fileconfig.json 小游戏的项目配置文件 文件里包括了小游戏项目的一些信息，如果想修改appid等信息，可以直接在这里面编辑。 项目参数libVersion的值一定要是game，这里一般不会出错。但是，万一出现了LayaAirIDE里发布正常，也引用了适配库，发布为小游戏后，在开发者工具里还是有报错的话，可以检查libVersion里的值是不是game。不是的话要改为game。 weapp-adapter.js 微信小游戏适配库文件 三、用微信开发者工具创建小游戏项目 3.1 开发者帐号登录，选择项目类型 打开”微信web开发者工具“，用开发者的微信扫码登录。然后选择小游戏点击进入项目设置，选择导入，如图3-1所示。 （图3-1） 3.2 导入小游戏项目 选择项目目录，就是在LayaAirIDE发布后的目标目录（通常在项目根目录下的release\\wxgame） （图3-2） 选择wxgame目录之后，如图3-3所示 （图3-3） AppID 测试账号，可以点击注册，不输入也可以开发调试，可以使用测试号，不过功能会受到限制。所以最好还是输入 AppID 3.3 微信开发者工具的编译 完成小游戏项目的创建后，即可在工具内预览效果和调试。如图3-4所示 （图3-4） 3.4 真机测试与调试 由于LayaAirIDE里也可以调试项目效果，除非是适配相关的问题，基本上两边的效果不会有不一一致的情况。所以这里最重要的是点击预览功能，通过手机微信扫码，在微信内进行真机测试与调试。如图3-5所示 （图3-5） 注意：上传真机的时候，默认不能超过4M，配置分包不能超过8M 至此，一个完整的小游戏开发流程就结束了。是不是很简单。采用LayaAirIDE开发的小游戏项目，基本上是无缝用于微信小游戏项目。 四、微信小游戏的4M本地包与动态资源加载 比如示例中引用的就是本地路径， Laya.Texture2D.load(\"res/layabox.png\"); 如果项目的目录中，全部大小加起来不超过4M的话，只要能找到本地的资源，怎么写也没问题。 但是， 微信小游戏的本地包有4M的限制，一旦超过这个限制，那就不允许上传，不允许真机预览。 所以，我们的项目要是大于4M后，怎么处理呢？ 4.1 分包 一种方案是分包， 微信小游戏分包限制： 整个小游戏所有主包+分包大小不超过 20M 主包不超过 4M 单个普通分包不限制大小 单个独立分包不超过 4M 请参考微信小游戏官方文档。 下面来介绍LayaAir IDE给微信小游戏分包的方法，开发者可以先看一下《Web发布》的分包。 如图4-1所示，在构建发布中，开启分包后，选择要分包的文件夹，即可完成分包。 （图4-1） 与Web分包不同的是，小游戏分包不可以使用远程包，另一个就是代码引用的资源的方法不同。在web平台中，使用loadPackage方法加载包的参数有三个，而小游戏分包需要使用两个参数的重载方式，两个参数的重载方式不仅仅用于微信小游戏，别的小游戏平台也同样适用。下面给出一段代码加载分包的示例代码： const { regClass, property } = Laya; @regClass() export class Script extends Laya.Script { //declare owner : Laya.Sprite3D; @property({ type: Laya.Scene3D }) scene3d: Laya.Scene3D; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { //小游戏加载分包 Laya.loader.loadPackage(\"sub1\", this.printProgress).then(() => { Laya.loader.load(\"sub1/Cube.lh\").then((res: Laya.PrefabImpl) => { let sp3: Laya.Sprite3D = res.create() as Laya.Sprite3D; this.scene3d.addChild(sp3); }); }) Laya.loader.loadPackage(\"sub2\", this.printProgress).then(() => { Laya.loader.load(\"sub2/Sphere.lh\").then((res: any) => { let sp3 = res.create(); this.scene3d.addChild(sp3); }); }) } printProgress(res: any) { console.log(\"加载进度\" + JSON.stringify(res)); } } 下面重点介绍一下printProgress打印的内容，在微信开发者工具打开并编译我们导出的项目后，会打印如下日志： （图4-2） wx.loadSubpackage() 返回的一个 LoadSubpackageTask，可以通过它获取当前下载进度。 参考微信小游戏官方文档。 打印的参数的意义分别是： progress：下载进度； totalBytesWritten：已经下载的数据长度； totalBytesExpectedToWrite：预期需要下载的数据总长度。 4.2 网络动态加载 另一种方案就是网络动态加载， 我们在本地包内，JS代码是必须要放进去的，因为JS是不允许网络加载动态创建的。所以如果本地包内JS超过4M，首先考虑的是如何优化JS体积，比如混淆压缩，和UI代码分离。还是不行的话，只能是通过小游戏的分包方案解决。如果JS没有超过4M，那还可以视情况再放一些预加载用的基础资源。 总之，对于绝大多数小游戏而言，网络动态加载是必须使用的方式。 那网络动态加载的路径怎么处理呢。在本地加载的load()方法之后使用URL.basePath方法。 例如： material.diffuseTexture = Laya.Texture2D.load(\"res/layabox.png\"); box.meshRender.material = material; Laya.URL.basePath = \"https://XXXX.com\";//请把XXXX换成自己的真实网址； //在此之下，再使用load加载资源，都会自动加入URL网址。从网络上动态加载。 使用URL.basePath方法后，再使用load加载本地路径，都会自动加上URL.basePath里的网址。这样就实现了本地与网络加载的结合。 这样就结束了吗？并没有！ 按刚刚的写法，res/layabox.png明明已经上传到微信小游戏的本地目录，但是如果在使用URL.basePath之后，再次加载res/layabox.png并不会从本地加载使用，而是从网络动态加载使用。这并不是我们要的结果。 所以，引擎针对使用URL.basePath之后，如何再次使用本地加载，进行了特殊目录和文件的处理，也就是本地包白名单机制。如下例所示： MiniAdpter.nativefiles = [ \"wxlocal\", \"res/atlas/houzi.atlas\", \"res/atlas/houzi.png\", \"common/tishi.png\", \"common/bg.png\", \"ui.json\", \"newLb/bg031.png\" ]; 只要是MiniAdpter.nativefiles里存在的目录名或文件，引擎会自动将该目录视为本地目录，即便使用了URL.basePath，对于包含在nativefiles白名单内的目录名或文件，都不会从网络动态加载，只会从本地加载。 五、微信小游戏的50M物理缓存管理 物理缓存的意义 微信小游戏除了本地包之外，还允许开发者使用50M的物理缓存空间。也就是说首次加载后，在物理缓存中的资源，无需远程动态加载，直接使用本地的缓存资源即可。这样，不仅让玩家节省了大量的下载流量，还拥有了如同原生APP游戏一样的打开速度。 LayaAir引擎默认的缓存管理机制 在LayaAir引擎里，引擎层已经自动帮开发者做好了缓存管理的机制，默认启动的是自动缓存管理机制。 在自动缓存的管理模式下，如果检测到资源没有在本地缓存，就将远程的资源自动缓存起来。需要注意的是，自动缓存模式下只缓存图片和声音文件，如果有其它格式的文件需要缓存，那可以通过设置MiniAdpter.AutoCacheDownFile = true; //是否自动缓存非图片声音文件 或者手动缓存的接口进行下载并缓存。 缓存文件如果超过50M，将自动清理最早缓存的内容，每次清理5M的空间，如此循环写入，保障缓存里存的永远是最新下载的50M文件。 LayaAir引擎手动管理缓存的接口 1、取消自动缓存 如果游戏常用资源大于50M，采用自动管理缓存的文件未必能达到开发者的预期。尤其是早期加载的资源，如果是常用资源，那么后面加载的资源缓存超过50M后，会将早期缓存的资源清理，那么下次使用的时候又要重新加载一次。所以常用资源大于50M的时候，建议开发者自行权衡哪些资源缓存起来意义更大，对用户体验更好。这时候，就可以取消自动缓存模式。 如果不需要引擎自动管理缓存，可以将MiniAdpter.autoCacheFile设置为false。需要注意的是，自动缓存关闭后，由于不会自动清理，超过50M后将会导致写入缓存失败，所以一定要建立好缓存策略，决定哪些文件要缓存，哪些文件需要手动清理。 2、手动下载文件并缓存本地 当不打算使用自动缓存功能，或者在自动缓存模式下，缓存json等自动缓存并不缓存的文件内容时，可以使用downLoadFile方法，去下载目标文件并缓存到本地。 /** * 下载文件 * @param fileUrl 文件地址(全路径) * @param fileType 文件类型(image、text、json、xml、arraybuffer、sound、atlas、font) * @param callBack 文件加载回调,回调内容[errorCode码(0成功,1失败,2加载进度) * @param encoding 文件编码默认 ascill，非图片文件加载需要设置相应的编码，二进制编码为空字符串 */ public static function downLoadFile(fileUrl:String, fileType:String = \"\",callBack:Handler = null,encoding:String = \"ascii\"):void 3、清除缓存文件 由于微信小游戏的缓存上限是50M物理空间，所以无论自动管理缓存还是手动管理缓存，达到上限后都需要清理缓存。每次清理的缓存大小默认为5M，如果想改变每次缓存清理的默认值，通过修改 MiniAdpter.minClearSize属性即可。 如果要删除指定的缓存文件或全部缓存文件时，可以使用remove或removeAll方法。 /** * 删除指定缓存文件 * @param fileUrl文件路径(绝对地址) * @param callBack 删除回调函数 */ public static function remove(fileUrl:String,callBack:Handler):void {} /** * 清空缓存空间全部文件内容 */ public static function removeAll():void{} Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-06-08 11:04:44 "},"released/miniGame/byteDance/readme.html":{"url":"released/miniGame/byteDance/readme.html","title":"字节跳动小游戏","keywords":"","body":"字节跳动小游戏一、概述二、发布为字节跳动小游戏2.1 选择目标平台2.2 发布后的小游戏目录介绍三、用小游戏开发工具创建小游戏项目3.1 开发者帐号登录，选择项目类型3.2 导入小游戏项目3.3 字节开发者工具的编译3.4 真机测试与调试四、分包加载字节跳动小游戏 一、概述 字节跳动小游戏是基于字节跳动全产品矩阵开发，不需用户进行下载，点开即玩的全新游戏类型。 相较 APP，小游戏有着开发周期短、开发成本低等特性，能够让开发者更简单的参与到开发过程中。实现快速上线，快速变现。 小游戏有无需下载、玩法简单等特性，与图文、视频等场景有着天然的搭配性。字节跳动全产品矩阵以内容分发为核心，通过内容带动小游戏分发，由内容为小游戏带量以及裂变。 推荐要看一看字节跳动小游戏的官方文档，LayaAir引擎的文档更多的是引擎相关的，当然也会混合了一些小游戏接口的应用介绍，但是仔细看看字节官方文档肯定没错。 下载并安装小游戏开发者工具 小游戏开发工具主要用于小游戏产品的预览与调试、真机测试、上传提交等。是小游戏开发的必备工具。 二、发布为字节跳动小游戏 2.1 选择目标平台 点击构建项目，在弹出的构建项目界面里，选择发布平台为字节跳动小游戏。如图2-1所示： （图2-1） 2.2 发布后的小游戏目录介绍 发布后的目录结构如图2-2所示 ： （图2-2） js 项目文件 与 libs 引擎库目录 项目代码和类库 resources资源目录 与 Scene.js resources资源目录和资源文件Scene.js，小游戏由于初始包的限制，建议将初始包的内容在规划好，最好能放到统一的目录下，便于初始包的剥离。 game.js字节小游戏的入口文件 游戏项目入口JS文件与适配库JS等都是在这里进行引入。IDE创建项目的时候已生成好，一般情况下，这里不需要动。 game.json 小游戏的配置文件 开发者工具和客户端需要读取这个配置，完成相关界面渲染和属性设置。比如屏幕的横竖屏方向。 projectconfig.json 小游戏的项目配置文件 文件里包括了小游戏项目的一些信息，如果想修改appid等信息，可以直接在这里面编辑。 microgame-adapter.js 字节小游戏适配库文件 三、用小游戏开发工具创建小游戏项目 自 2022 年 9 月 2 日起，字节跳动开发者工具已经改为抖音开发者工具 3.1 开发者帐号登录，选择项目类型 关于抖音开发平台的帐号创建与登录，以及小游戏项目的创建，工具的使用，产品的发布，可以查看抖音的小游戏开发者文档。打开”抖音开发者工具“，用“抖音”APP扫码登录。然后选择小游戏点击进入项目设置，选择新建，如图3-1所示。 （图3-1） 3.2 导入小游戏项目 选择导入目录，就是在LayaAir IDE发布后的目标目录（通常在项目根目录下的release\\bytedancegame） （图3-2） 选择bytedancegame目录之后，如图3-3所示 （图3-3） AppID 测试账号，可以点击注册，不输入也可以开发调试，可以使用测试号，不过功能会受到限制。所以最好还是输入 AppID 3.3 字节开发者工具的编译 完成小游戏项目的创建后，即可在工具内预览效果和调试。如图3-4所示 （图3-4） 3.4 真机测试与调试 由于LayaAir IDE里也可以调试项目效果，除非是适配相关的问题，基本上两边的效果不会有不一一致的情况。所以这里最重要的是点击预览功能，通过抖音扫码，在抖音内进行真机测试与调试。如图3-5所示 （图3-5） 四、分包加载 下面来介绍LayaAir IDE给字节跳动小游戏分包的方法，开发者可以先看一下《Web发布》的分包。可以通过以下步骤进行分包加载，如图4-1所示，点击构建发布后，勾选开启分包，然后选择要分包的文件夹即可。 （图4-1） 字节跳动小游戏分包限制： 整个小玩法整体包（主包+分包）大小不超过 20M 单个主包不超过 4M 单个分包大小无限制 请参考字节跳动小游戏官方文档。 小游戏不可以使用远程包。IDE自动加载分包需要在发布时勾选分包的“启动时自动加载”选项。如果是代码引用资源，方法与web发布略有不同，加载代码示例如下： const { regClass, property } = Laya; @regClass() export class Script extends Laya.Script { //declare owner : Laya.Sprite3D; @property({ type: Laya.Scene3D }) scene3d: Laya.Scene3D; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { //小游戏加载分包 Laya.loader.loadPackage(\"sub1\", this.printProgress).then(() => { Laya.loader.load(\"sub1/Cube.lh\").then((res: Laya.PrefabImpl) => { let sp3: Laya.Sprite3D = res.create() as Laya.Sprite3D; this.scene3d.addChild(sp3); }); }) Laya.loader.loadPackage(\"sub2\", this.printProgress).then(() => { Laya.loader.load(\"sub2/Sphere.lh\").then((res: any) => { let sp3 = res.create(); this.scene3d.addChild(sp3); }); }) } printProgress(res: any) { console.log(\"加载进度\" + JSON.stringify(res)); } } 这里主要介绍一下printProgress打印的内容，在抖音开发者工具打开并编译我们导出的项目后，会打印如下日志： （图4-2） tt.loadSubpackage会返回一个LoadSubpackageTask，可以通过它获取当前下载进度。 参考字节小游戏官方文档。 打印的参数的意义分别是： name：分包的名字； progress：分包下载进度百分比； totalBytesWritten：已经下载的数据长度，单位 Bytes； totalBytesExpectedToWrite：预期需要下载的数据总长度，单位 Bytes。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-06-08 11:31:11 "},"released/miniGame/OPPO/readme.html":{"url":"released/miniGame/OPPO/readme.html","title":"OPPO小游戏","keywords":"","body":"OPPO小游戏一、概述二、发布为OPPO小游戏2.1 选择目标平台2.2 发布后的小游戏目录介绍三、用OPPO小游戏调试器3.1 OPPO小游戏发布、调试环境准备3.2 OPPO小游戏发布与接入完整流程3.3 真机调试与Chrome输出3.4 发布未成功的处理经验四、OPPO小游戏分包OPPO的分包调试OPPO小游戏 一、概述 推荐要看一看OPPO小游戏官方的文档，LayaAir引擎的文档更多的是引擎相关的，当然也会混合了一些小游戏接口的应用介绍，但是仔细看看OPPO官方文档肯定没错。 链接如下： https://ie-activity-cn.heytapimage.com/static/minigame/CN/docs/index.html OPPO小游戏中没有可视化开发调试工具，所以只能是LayaAirIDE中配置好相关参数，然后直接在LayaAirIDE内一键发布成功（生成一个rpk的包）。至于调试方式，则是通过OPPO手机里安装一个apk调试环境，在apk里选择打开rpk的文件，然后通过chrome在PC上用数据线连接手机进行调试。 二、发布为OPPO小游戏 2.1 选择目标平台 点击构建项目，在弹出的构建项目界面里，选择发布平台为OPPO小游戏。如图2-1所示 （图2-1） 下面我们来介绍一下这些功能参数的填写 1、游戏名称 一般都填写中文汉字，英文也可以。用于应用商店、桌面图标、弹窗等游戏入口处。一个好的名字是游戏能不能吸量的重要元素。OPPO是6个汉字以内可以 2、游戏包名 游戏包名的格式是 com.company.module 第一位com不要变，第二位是公司名，第三位是项目名。都要写英文，例如：com.layabox.demoGame。 3、游戏图标 游戏图标也是重要的游戏入口标识，和游戏名称一样，是非常重要的吸量元素，如果游戏图标设计的好，游戏名称起的好。同样的位置会获得比其它游戏更多的点击率。游戏图标需要提供 192*192 的正方形尺寸。 4、游戏版本名称 游戏版本名称是真实的版本，一般是用于功能性版本的区别。比如我有个大版本改动。原来是1.0，可以变成2.0，如果只是改改Bug，那1.0完全可以改成1.1。以此类推，我们建议采用浮点数命名。比如“0.1”、“1.3”、“5.0”…… 5、游戏版本 游戏版本与版本名称用处不同，这里是渠道平台用于区别版本更新。每次提审都要至少递归+1，自己测试无所谓。但是提审这里的值必须要比上次提审的值至少要+1，+N也是可以的，绝对不能等于或者小于上个版本值，建议是提审版本号递归+1。这里需要注意的是，游戏版本必须为正整数。 6、最小平台号 最小平台号，按调试器上显示的平台版本号，进行填写即可。 7、日志等级 七种日志等级，先级从高到底依次为OFF、ERROR、WARN、INFO、DEBUG、TRACE、ALL，可以方便地知道当前程序的运行状态。 8、是否使用正式版签名 如果只是测试版本调试，这里可以不用勾选。正式上线发布前（提版本到平台）必须勾选。 如果勾选了，就会启用正式版签名。关于release签名: ①对于公司,一般一个公司只用一个签名，如果公司已经有签名了，推荐使用公司的签名。如果没有的话，IDE中的发布集成了这个功能，方便开发者生成签名。 ②对于个人开发者，可以多个项目使用一个正式签名。只需要生成一次即可。 如果已经release签名了，将签名文件放到Laya项目 sign/release 文件夹下 9、设置分包 让开发者在开发完成后，能够按照分包配置将需要分包的文件夹内的 js 或者某个 js， 打包签名生成 .rpk 文件；将项目中分包之外的其他文件打包成主包；再将整个包打成 .rpk 文件。 整个小游戏的所有分包总和不超过 10M； 单个分包/基础包大小不能超过 5M； 整体压缩包（包含原整包和所有分包；）不超过20M。 com.application.quickgame.rpk 整体压缩包(包名+.rpk) （最大20M） --->com.application.quickgame.rpk 原整包(包名+.rpk) （最大10M） --->main.rpk 分包主包(main+.rpk) （主包，最大5M） --->sub1Name.rpk sub1分包(子包名+.rpk) （单个分包，最大5M） --->sub2Name.rpk sub2分包(子包名+.rpk)（单个分包，最大5M） 2.2 发布后的小游戏目录介绍 点击版本发布，由于在发布前会检查rpk发布环境（用于生成rpk包），如果没有发布环境的，则会开始下载。 发布后的目录结构如图2-2所示 （图2-2） js 项目文件 与 libs 引擎库目录 项目代码和类库 resources资源目录 与 Scene.js resources资源目录和资源文件Scene.js，小游戏由于初始包的限制，建议将初始包的内容在规划好，最好能放到统一的目录下，便于初始包的剥离。 main.jsOPPO小游戏的入口文件 游戏项目入口JS文件与适配库JS等都是在这里进行引入。IDE创建项目的时候已生成好，一般情况下，这里不需要动。 manifest.json 小游戏的项目配置文件 文件里包括了小游戏项目的一些信息，如果想修改，可以直接在这里面编辑。 三、用OPPO小游戏调试器 3.1 OPPO小游戏发布、调试环境准备 1、OPPO品牌的手机。 2、下载安装OPPO真机测试APP “快应用”（OPPO 小游戏调试器 ） 前往OPPO官网文档（https://ie-activity-cn.heytapimage.com/static/minigame/CN/docs/index.html#/） 我们找到安装 runtime.apk 包到 OPPO 手机上这个栏目，通常会选择新版本，进行下载。 要注意的是，调试器的版本，文档中有注明最小平台版本号。LayaAirIDE发布的时候，要和这里最小平台版本号对应上。 3、PC电脑的chrome浏览器与手机数据连接线。 4、安装nodejs 环境，建议安装 8.x 稳定版本 [node官网：https://nodejs.org/en/] 就是下载安装，比较简单，也不细介绍。能在命令行里调起npm命令就算是成功了。 5、安装ADB OPPO发布时，是通过 ADB 把rpk包推到手机的games目录上去，所以这个必须要装。 [ ADB官网下载: http://adbshell.com/downloads ] 提示一下，下载 ADB Kits，下载后的压缩包，建议解压放到一个路径简单一些的目录（如: D:\\adb）。要记得添加环境变量（不知如何添加环境变量的可自行百度）。 3.2 OPPO小游戏发布与接入完整流程 为了让发布OPPO顺利一些，有一些检查工作我们要做。 第一、PC里，node环境、ADB、Chrome这些，都必须要安装好。 第二、在OPPO的手机里，进入设置-> 其它设置-> 开发者选项 ，开发者选项与USB调试必须开启，如图3-1所示。 (图3-1) 另外要确保安装好OPPO小游戏调试环境“快应用”，如图2所示。 (图3-2) 第三、将PC电脑与手机用USB数据线相连，电脑里，可以出现类似图3一样的界面。比如，点击图3-3左上角的OPPO R9m，就可以进入手机存储。 (图3-3) 手机里要注意的是，屏幕保持点亮打开，在PC的IDE发布OPPO小游戏时，如果手机出现授权信息请求的时候，一定要点确定允许。如图3-4所示。 （图3-4） 3.3 真机调试与Chrome输出 OPPO的调试必须基于真机调试，PC的chrome只能输出信息，看不到画面。 如果准备工作没问题的话，正常情况下，LayaAirIDE里成功发布OPPO小游戏之后，是rpk的包会自动出现在小游戏的OPPO小游戏列表中的（IDE通过调用ADB推到指定的目录中），如图3-5所示。 （图3-5） 图3-5中的OPPO测试就是我们在发布的时候填写的游戏名称。如果我们看到自己对应的游戏名称，说明是正常发布成功了。点击秒开，就可以打开我们发布的游戏。 如果想看调试信息。这时就需要打开chrome浏览器。然后在输入栏里输入： chrome-devtools://devtools/bundled/inspector.html?v8only=true&ws=10.10.82.111:12345/00010002-0003-4004-8005-000600070008 上面示例的IP地址10.10.82.111替换成自己手机上的IP就行。IP地址不知道怎么查的，自行百度。这里重点提示的是，PC电脑必须要和手机处于同一个网段的局域网环境下。 如果没问题，效果如图3-6所示。 （图3-6） 发布与调试，顺利的话至此就完成了。 3.4 发布未成功的处理经验 发布文档中只讲功能使用，上面的文档是顺利情况下的流程。然而开发者可能不会那么顺利，那这里我们讲一讲经验。 调试列表中未见游戏，是什么情况 如果我们发布的时候没能将rpk自动发到小游戏目录内，那图5的列表中，就没办法直接看到刚发布的小游戏。 这时候就可以使用adb来确认环境了。 在ide的终端或者cmd中 输入 adb devices 指令。 1.连接非正常情况： （图3-7-1） 此时就开发者需要检查手机连接，和权限是否正确。 2.在连接正常情况下： （图3-7-2） 这时说明手机已经连接成功，并且已经开起来了开发者模式与usb调试。此时可以尝试重启OPPO的快应用apk，再查看列表信息。 在连接正常的情况下，如果再出现问题。可能就和windows权限有关系，需要确保使用管理员权限启动LayaAirIDE。 关于adb相关，或者手机权限相关的问题，开发者可以自行了解。 另一方案，使我们可以采用手工模式，把rpk包，复制到手机存储的games目录下，如果没有games目录则自己手工创建一下。 rpk包位于项目的release/OPPOgame/quickgame/dist 目录下，如图3-8所示。 （图3-8） 将发布生成的rpk文件，复制到手机存储的games目录下，如图9所示。 （图3-9） 这种方法稳定性更高。 在 .rpk 文件生成成功的情况下，实际上发布流程已经结束。 如果打包流程出现问题，可以把问题反馈给Layabox官方团队，Layabox会与OPPO团队共同处理。 四、OPPO小游戏分包 对于一些大型游戏而言，OPPO小游戏的4M初始包远远不够用，因为光JS就会超过4M，所以在2.5.0beta的小游戏基础库推出之前，只能是不断的砍功能，一直砍到JS小于5M。(如果有新手不了解这是为什么？那先去了解一些基础之后，再来看本文)。小游戏基础库从2.5.0beta版本开始支持通过分包的形式，将上传的包体扩大到20M，那如何进行分包呢？ 在分包之前，官方的文档没看过的，一定要先仔细看一看。这非常有用，无论能理解到多少，先尽量看懂文档要点，才能更好的理解分包。链接如下，请先看过后再进行后面的步骤。 https://ie-activity-cn.heytapimage.com/static/minigame/CN/docs/index.html#/develop/subpackage/subpackage 在manifest.json中配置分包名与分包路径的字段 { ... \"subpackages\": [ { \"name\": \"sub1Name\", \"root\": \"sub1/\" // 可以指定一个目录，目录根目录下的 main.js 会作为入口文件，目录下所有资源将会统一打包 }, { \"name\": \"sub2Name\", \"root\": \"sub2.js\" // 也可以指定一个 JS 文件 } ] ... } 这个manifest.json是通过IDE的发布功能自动生成的，打开IDE的构建发布可以看到设置分包选项，如图4-1所示 （图4-1） subpackages里，可以有多个name与root，每一组代表一个分包，单个分包 分包路径可以指定一个目录，根目录下的 main.js 会作为入口文件，目录下所有资源将会统一打包 这里设置的分包文件（夹）要与OPPOgame目录下的文件（夹）对应，这里设置只是自动生成manifest.json里的配置信息，并不会去创建文件夹和文件。一定要手动创建文件与文件夹 OPPO小游戏的分包加载示例代码 OPPO小游戏官方提供了qg.loadSubpackage(Object object) API 来触发分包的下载，调用 qg.loadSubpackage 后，将触发分包的下载与加载，在加载完成后，通过 qg.loadSubpackage 的 success 回调来通知加载完成。示例代码如下： const loadTaskA = qg.loadSubpackage({ name: 'sub1Name', success: function (data) { console.info('加载分包 sub1Name 成功') }, fail: function (err) { console.info('加载分包 sub1Name 失败', err) } } ) 加载成功的同时，qg.loadSubpackage 会返回一个 LoadSubpackageTask，可以通过 LoadSubpackageTask 获取获取分包加载状态。示例代码如下： loadTaskA.onProgressUpdate(res => { console.log('sub1Name 下载进度', res.progress) console.log('sub1Name 已经下载的数据长度', res.totalBytesWritten) console.log('sub1Name 预期需要下载的数据总长度', res.totalBytesExpectedToWrite) } ); OPPO的分包调试 分包成功后的小游戏 rpk 需拷贝到手机的 sdcard/Android/data/com.nearme.instant.platform/files/subPkg 中 之后便可打开 OPPO 小游戏调试器在 GAME 分包标签页下打开对应小游戏 如图： （图4-2） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/miniGame/vivo/readme.html":{"url":"released/miniGame/vivo/readme.html","title":"vivo小游戏","keywords":"","body":"VIVO小游戏一、概述二、发布为vivo小游戏2.1 选择目标平台2.2 发布后的小游戏目录介绍三、用vivo小游戏调试器3.1 vivo小游戏发布、调试环境准备3.2 vivo小游戏发布与接入完整流程四、vivo小游戏分包VIVO小游戏 一、概述 推荐要看一看vivo小游戏官方的文档，LayaAir引擎的文档更多的是引擎相关的，当然也会混合了一些小游戏接口的应用介绍，但是仔细看看vivo官方文档肯定没错。 链接如下： https://minigame.vivo.com.cn/documents/#/guide/ vivo小游戏中没有可视化开发调试工具，所以只能是LayaAirIDE中配置好相关参数，然后直接在LayaAirIDE内一键发布成功（生成一个rpk的包）。至于调试方式，则是通过vivo手机里安装一个apk调试环境，在apk里选择打开rpk的文件，然后通过chrome在PC上用数据线连接手机进行调试。 vivo小游戏调试器下载地址： https://minigame.vivo.com.cn/documents/#/download/debugger 二、发布为vivo小游戏 2.1 选择目标平台 点击构建项目，在弹出的构建项目界面里，选择发布平台为vivo小游戏。如图2-1所示 （图2-1） 下面我们来介绍一下这些功能参数的填写 1、游戏名称 一般都填写中文汉字，英文也可以。用于应用商店、桌面图标、弹窗等游戏入口处。一个好的名字是游戏能不能吸量的重要元素。vivo要求必须是6个汉字以内。 2、游戏包名 游戏包名的格式是 com.company.module 第一位com不要变，第二位是公司名，第三位是项目名。都要写英文，例如：com.layabox.demoGame。 3、游戏图标 游戏图标也是重要的游戏入口标识，和游戏名称一样，是非常重要的吸量元素，如果游戏图标设计的好，游戏名称起的好。同样的位置会获得比其它游戏更多的点击率。游戏图标需要提供 192*192 的正方形尺寸。 4、游戏版本名称 游戏版本名称是真实的版本，一般是用于功能性版本的区别。比如我有个大版本改动。原来是1.0，可以变成2.0，如果只是改改Bug，那1.0完全可以改成1.1。以此类推，我们建议采用浮点数命名。比如“0.1”、“1.3”、“5.0”…… 5、游戏版本 游戏版本与版本名称用处不同，这里是渠道平台用于区别版本更新。每次提审都要至少递归+1，自己测试无所谓。但是提审这里的值必须要比上次提审的值至少要+1，+N也是可以的，绝对不能等于或者小于上个版本值，建议是提审版本号递归+1。这里需要注意的是，游戏版本必须为正整数。 6、最小平台号 vivo目前在官网 最低版本建议填写 1090 7、日志等级 七种日志等级，先级从高到底依次为OFF、ERROR、WARN、INFO、DEBUG、TRACE、ALL，可以方便地知道当前程序的运行状态。 8、是否使用正式版签名 如果只是测试版本调试，这里可以不用勾选。正式上线发布前（提版本到平台）必须勾选。 如果勾选了，就会启用正式版签名。关于release签名: ①对于公司,一般一个公司只用一个签名，如果公司已经有签名了，推荐使用公司的签名。如果没有的话，IDE中的发布集成了这个功能，方便开发者生成签名。 ②对于个人开发者，可以多个项目使用一个正式签名。只需要生成一次即可。 如果已经release签名了，将签名文件放到Laya项目 sign/release 文件夹下 9、设置分包 让开发者在开发完成后，能够按照分包配置将需要分包的文件夹内的 js 或者某个 js， 打包签名生成 .rpk 文件；将项目中分包之外的其他文件打包成主包；再将整个包打成 .rpk 文件。 分包加载的能力首先依赖于编译时工具，根据开发者在manifest.json中配置的subpackages规则，将项目打包成多个分包。这些分包的大小是有限制的，目前vivo小游戏的分包大小有如下限制： com.application.demo.rpk整体压缩包(包名+.rpk) ------------- com.application.demo.rpk 原整包(包名+.rpk) (兼容老版本引擎的原整包=分包主包+分包A+分包B) ------------- main.rpk 分包主包(main+.rpk) （4M） ------------- pkgA.rpk pkgA分包(子包名+.rpk) (A+B 16M) ------------- pkgB.rpk pkgB分包(子包名+.rpk) 目前打出来的包体体积会比之前的大是正常的，为了兼容把原先的整包也打进去了 注意：分包名称不要使用main，这个是主包固定使用的名称 2.2 发布后的小游戏目录介绍 点击版本发布，由于在发布前会检查rpk发布环境（用于生成rpk包），如果没有发布环境的，则会开始下载。 发布后的目录结构如图2-2和图2-3所示 （图2-2） （图2-3） engine 目录下的js 项目文件 与 libs 引擎库目录 项目代码和类库 resources 资源目录 与 Scene.js、atlas、image resources 资源目录和资源文件，小游戏由于初始包的限制，建议将初始包的内容在规划好，最好能放到统一的目录下，便于初始包的剥离。 game.js vivo小游戏的入口文件 游戏项目入口JS文件与适配库JS等都是在这里进行引入。IDE创建项目的时候已生成好，一般情况下，这里不需要动。 manifest.json 小游戏的项目配置文件 文件里包括了小游戏项目的一些信息，如果想修改，可以直接在这里面编辑。 三、用vivo小游戏调试器 3.1 vivo小游戏发布、调试环境准备 1、vivo品牌的手机 2、下载安装vivo的调试APP，下载页面：https://minigame.vivo.com.cn/documents/#/download/debugger 进入页面后，点击 立即下载 ，即可下载安装。至于如何安装vivo调试APP，这里就不介绍了。 3、下载vivo小游戏引擎 当前调试APP内置的vivo引擎版本是1034，这个版本存在已知BUG，我们必须要前往vivo小游戏官网下载最新版本的小游戏引擎apk。 下载页面为： https://minigame.vivo.com.cn/documents/#/download/engine 当前的推荐的版本是1090，下载安装后，我们可以看到vivo快应用调试器的平台版本号那里也是显示的1090。 4、PC电脑的chrome浏览器与手机数据连接线。 5、安装nodejs 环境 [node官网：https://nodejs.org/en/] 就是下载安装，比较简单，也不细介绍。能在命令行里调起npm命令就算是成功了。 6、安装ADB ADB可以用于授权，以及发布推送等，可以前往ADB的官网下载并安装。 [ ADB官网下载: http://adbshell.com/downloads ] 简单提示一下，下载 ADB Kits，下载后的压缩包，建议解压放到一个路径简单一些的目录（如: D:\\adb）。要记得添加环境变量（不知如何添加环境变量的可自行百度）。 3.2 vivo小游戏发布与接入完整流程 3.2.1 安装并进入快应用调试器 要启动电脑PC的chrome调试环境，我们要先安装好vivo小游戏的调试APP（快应用调试器），如图3-1所示。然后点击进入。 （图3-1） 3.2 在快应用调试器界面扫码安装vivo小游戏的rpk包 进入快应用调试器之后，我们可以看到如图3-2所示的APP操作界面。 (图3-2) 把发布目录下/dist目录内的rpk包传到手机里，通过点 本地安装 按钮来安装。 3.2.3 保持物理线路连接以及授权 对于比较有相关经验的开发者，确保USB手机连接线物理线路是已连接状态，并且USB调试授权也没问题的，可以跳过本步骤。 相关操作如下： 1、先用手机连接线将手机与PC保持物理上的连接。 2、在之前打开的命令行下，输入adb shell，如图3-3所示。则是未获得USB调试模式授权。 （图3-3） 此时，我们要关注手机端，是否出现如图3-4所示的提示，如果有，则点 确定 允许USB调试。 （图3-4） 3、再次验证授权。 当USB调试模式授权成功之后，我们再次输入adb shell，应该如图3-5所示。 （图3-5） 总之，在这个环节里，我们要保障PC是有权限调试这个手机设备的。 3.4 启动chrome调试环境 之前扫码安装后，会自动进入刚刚安装的游戏或者DEMO。 要启动调试，就要先退出来。 然后，如图3-6所示，点击开始调试，进入vivo小游戏的调试模式。 （图3-6） 真机进入调试模式后，我们再到PC上打开chrome浏览器。 这时候别忘了，要联接USB数据线，将手机设备与PC相联，权限的问题上面已经说过，不再重复。 我们要在手机端查找到手机的IP（不知道怎么查的自行百度）并记住他。一定要注意的是，手机网要和PC网始终保持在同一个局域网段。 在chrome浏览器的输入栏里输入： chrome-devtools://devtools/bundled/inspector.html?v8only=true&ws={IP}:5086/00010002-0003-4004-8005-000600070008 将{IP}替换为手机IP地址即可，如图3-7所示。 (图3-7) 至此，vivo小游戏从发布到启动chrome调试的完整流程已介绍完。如果想了解关于更多vivo小游戏的接入流程与文档介绍，记住这个网址： https://minigame.vivo.com.cn 四、vivo小游戏分包 在manifest.json中配置分包名与分包路径的字段 { ... \"subpackages\": [ { \"name\": \"package1\", \"root\": \"package1/\" // 可以指定一个目录，目录根目录下的 game.js 会作为入口文件 }, { \"name\": \"package2\", // !!! 注意文件名称只允许出现一个点，不要写成这种 package2.min.js 可能会造成报错 \"root\": \"package2.js\" // 也可以指定一个 JS 文件 } ] ... } 这个manifest.json是通过IDE的发布功能自动生成的，打开IDE的构建发布可以看到设置分包选项，如图4-1所示 （图4-1） subpackages里，可以有多个name与root，每一组代表一个分包，单个分包 分包路径可以指定一个目录，根目录下的 main.js 会作为入口文件，目录下所有资源将会统一打包 这里设置的分包文件（夹）要与vivogame目录下的文件（夹）对应，这里设置只是自动生成manifest.json里的配置信息，并不会去创建文件夹和文件。一定要手动创建文件与文件夹 vivo小游戏的分包加载示例代码 vivo小游戏官方提供了qg.loadSubpackage()API来触发分包的加载，调用qg.loadSubpackage()在加载完成后，通过qg.loadSubpackage()的成功回调来通知加载完成。 示例代码： const loadTask = qg.loadSubpackage({ name: 'package1', success: function(info) { // 分包加载成功后通过 success 回调 }, fail: function(info) { // 分包加载失败通过 fail 回调 }, complete: function(){ // 不关分包加载成功还是失败都会执行此回调 } }) 同时，qg.loadSubpackage()会返回一个 LoadSubpackageTask ，可以通过 LoadSubpackageTask 获取当前下载进度。 示例代码如下： loadTask.onProgressUpdate(res => { console.log('下载进度', res.progress) console.log('已经下载的数据长度', res.totalBytesWritten) console.log('预期需要下载的数据总长度', res.totalBytesExpectedToWrite) }) Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/miniGame/xiaomi/readme.html":{"url":"released/miniGame/xiaomi/readme.html","title":"小米快游戏","keywords":"","body":"小米快游戏一、概述二、发布为小米快游戏2.1 选择目标平台2.2 发布后的小游戏目录介绍三、用小米快游戏调试器3.1 小米快游戏发布、调试环境准备3.2 小米快游戏发布与接入完整流程四、小米快游戏分包小米快游戏 一、概述 推荐要看一看小米快游戏官方的文档，LayaAir引擎的文档更多的是引擎相关的。 小米快游戏中没有可视化开发调试工具，所以只能是LayaAir IDE中配置好相关参数，然后直接在LayaAir IDE内一键发布成功（生成一个rpk的包）。至于调试方式，则是通过小米手机里安装一个apk调试环境，在apk里选择打开rpk的文件，然后通过Chrome浏览器在PC上用数据线连接手机进行调试。 二、发布为小米快游戏 2.1 选择目标平台 点击构建发布，在弹出的构建项目界面里，选择发布平台为小米快游戏。如图2-1所示， （图2-1） 下面我们来介绍一下这些功能参数的填写： 1、游戏名称 一般都填写中文汉字，英文也可以。用于应用商店、桌面图标、弹窗等游戏入口处。一个好的名字是游戏能不能吸量的重要元素。我们的建议是都不要超过6个汉字，游戏名太长没什么好处。 2、游戏包名 游戏包名的格式是 com.company.module 第一位com不要变，第二位是公司名，第三位是项目名。都要写英文，例如：com.layabox.demoGame。 3、游戏图标 游戏图标也是重要的游戏入口标识，和游戏名称一样，是非常重要的吸量元素，如果游戏图标设计的好，游戏名称起的好。同样的位置会获得比其它游戏更多的点击率。游戏图标需要提供 192*192 的正方形尺寸。 4、游戏版本名称 游戏版本名称是真实的版本，一般是用于功能性版本的区别。比如我有个大版本改动。原来是1.0，可以变成2.0，如果只是改改Bug，那1.0完全可以改成1.1。以此类推，我们建议采用浮点数命名。比如“0.1”、“1.3”、“5.0”…… 5、游戏版本 游戏版本与版本名称用处不同，这里是渠道平台用于区别版本更新。每次提审都要至少递归+1，自己测试无所谓。但是提审这里的值必须要比上次提审的值至少要+1，+N也是可以的，绝对不能等于或者小于上个版本值，建议是提审版本号递归+1。这里需要注意的是，游戏版本必须为正整数。 6、最小平台号 最小平台号，按调试器上显示的平台版本号，进行填写即可。 7、日志等级 七种日志等级，先级从高到底依次为OFF、ERROR、WARN、INFO、DEBUG、TRACE、ALL，可以方便地知道当前程序的运行状态。 8、是否使用正式版签名 如果只是测试版本调试，这里可以不用勾选。正式上线发布前（提版本到平台）必须勾选。 如果勾选了，就会启用正式版签名。关于release签名: ①对于公司,一般一个公司只用一个签名，如果公司已经有签名了，推荐使用公司的签名。如果没有的话，IDE中的发布集成了这个功能，方便开发者生成签名。 ②对于个人开发者，可以多个项目使用一个正式签名。只需要生成一次即可。 如果已经release签名了，将签名文件放到Laya项目 sign/release 文件夹下。 2.2 发布后的小游戏目录介绍 点击版本发布，由于在发布前会检查rpk发布环境（用于生成rpk包），如果没有发布环境的，则会开始下载。 发布后的目录结构如图2-2所示： （图2-2） js 项目文件 与 libs 引擎库目录 项目代码和类库 resources资源目录 与 Scene.js resources资源目录和资源文件Scene.js，小游戏由于初始包的限制，建议将初始包的内容在规划好，最好能放到统一的目录下，便于初始包的剥离。 main.js小米快游戏的入口文件 游戏项目入口JS文件与适配库JS等都是在这里进行引入。IDE创建项目的时候已生成好，一般情况下，这里不需要动。 manifest.json 小游戏的项目配置文件 文件里包括了小游戏项目的一些信息，如果想修改，可以直接在这里面编辑。 三、用小米快游戏调试器 3.1 小米快游戏发布、调试环境准备 1、小米品牌的手机（注意必须是MIUI 8.5或以上版本）。 2、下载安装小米的测试APP，进入下载页面后，找到第三步，直接按提示下载即可。 3、PC电脑的Chrome浏览器与手机数据连接线。 4、安装node.js环境，详细步骤在《搭建基础开发环境》中有介绍。 5、安装ADB。 建议安装ADB，因为有些时候，因为授权或者别的莫名其怪的原因。会导致无法正常启动Chrome联真机调试。所以安装ADB 可以验证手机与PC电脑的连接授权。如果确保无USB调试授权问题的，也可以不装。 简单提示一下，下载 ADB Kits，下载后的压缩包，建议解压放到一个路径简单的目录（如: D:\\adb）。要记得添加环境变量（不知如何添加环境变量的可自行百度）。 3.2 小米快游戏发布与接入完整流程 3.2.1 安装并进入快应用调试器 先在手机上安装好小米快游戏的调试APP（快应用调试器），如图3-1所示。然后点击进入。 （图3-1） 3.2.2 在快应用调试器界面扫码安装小米快游戏的rpk包 进入快应用调试器之后，我们可以看到如图3-2所示的APP操作界面。 (图3-2) 可以扫码安装，或者连接USB数据线把发布目录下/dist目录内的rpk包传到手机里，通过点本地安装按钮来安装。 3.2.3 保持物理线路连接以及授权 对于比较有相关经验的开发者，确保USB手机连接线物理线路是已连接状态，并且USB调试授权也没问题的，可以跳过本步骤。 相关操作如下： 1、先用手机连接线将手机与PC保持物理上的连接。打开手机的开发者模式，且打开USB调试。 此时，我们要关注手机端，是否出现如图3-3所示的提示，如果有，则点 确定 允许调试。 （图3-3） 2、验证授权。 当USB调试模式授权成功之后，我们在PC端打开cmd窗口，输入adb devices，应该如图3-4所示。 （图3-4） 总之，在这个环节里，我们要保障PC是有权限调试这个手机设备的。 4.4 启动chrome调试环境 小米快游戏在PC上没有工具的开发调试环境，是通过USB联接到手机设备，然后在PC命令行模式下，通过 npm run debug 命令调起Chrome调试器（前提要保障PC是已安装了Chrome浏览器的）来联调手机真机环境的rpk包，如图3-5所示。当我们能看到Debugger URL opened in Chrome.这个提示的时候，说明chrome已被成功调起。 (图3-5) 或者在Chrome浏览器中输入chrome://inspect/#devices，进入后找到连接的手机选项，点击inspect，如图3-6所示： （图3-6） 操作完成后，如图3-7所示，就可以按Chrome的调试方式来调试小米快游戏项目。 (图3-7) 至此，小米快游戏从发布到启动Chrome调试的完整流程已介绍完。 四、小米快游戏分包 开发者在开发完成后，能够将需要分包的文件夹进行分包，项目中分包之外的其他文件打包成主包。 小米快游戏分包加载包大小的限制 整个小游戏的所有分包总和不超过 10M； 单个分包/基础包大小不能超过 5M； 整体压缩包（包含原整包和所有分包；）不超过20M。 如图4-1所示，点击开启分包后，选择要进行分包的文件夹即可。 （图4-1） 分包加载的API等，可参考小米官方文档。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-06-05 15:26:20 "},"released/native/LayaNative_Introduction/readme.html":{"url":"released/native/LayaNative_Introduction/readme.html","title":"Native打包发布","keywords":"","body":"LayaNative综述LayaNative包含以下内容:1. 测试器：2. 构建工具：3. 反射机制:4. 渠道对接工具内(conchMarket):5. LayaPlayer：6.LayaNative的原理和开发流程LayaNative综述 LayaNative是LayaAir引擎针对移动端原生App的开发、测试、发布的一套完整的开发解决方案，但不局限于LayaAir引擎。LayaNative以LayaPlayer为核心运行时的基础上，利用反射机制、渠道对接方案提供开发者在原生App上进行二次开放和渠道对接，并提供测试器、构建工具，为开发者将html5项目打包、发布成原生App提供便利。 LayaNative包含以下内容: 1. 测试器： 下载安装测试器后，通过扫码URL二维码的方式，帮助开发者快速在移动端看到运行效果, 节省大量反复打包测试的时间； 2. 构建工具： 构建工具可帮助开发者快速构建移动端APP项目工程, 然后使用Android Studio、Eclipce、XCode 等开发工具打开->构建->运行； 3. 反射机制: 通过反射机制,开发者可以实现JavaScript与原生语言(Android/Java 或 iOS/Objective-C)的相互调用，通过反射机制开发者可以很方便的对应用程序进行二次扩展； 4. 渠道对接工具内(conchMarket): 渠道对接工具内嵌了渠道常用对接API，例如: 登录, 分享, 充值,好友关系链等； 5. LayaPlayer： LayaPlayer是LayaNative最核心的部分，它是一个基于JavaScript脚本引擎 + openGLES硬件加速渲染的跨平台引擎，通过对内存与渲染流程进行极致优化，为基于HTML5、WEBGL的多媒体应用、游戏等产品加速，使其性能媲美原生Native-APP。LayaPlayer采用C++语言编写,可嵌入浏览器或操作系统运行，也可以独立运行。 6.LayaNative的原理和开发流程 （1）、使用LayaAir开发的项目，准备在发布成app版本（ios或android）。（2）、LayaNative会使用核心引擎LayaPlayer进行加速。（3）、开发者可以使用测试器，快速安装到移动设备上进行简单的测试。（4）、最终通过命令行或者IDE，构建ios或android的工程，进行编译、执行。（5）、如果需要发布到各大渠道（例如：百度、360、AppStroe、google等），需要通过反射机制进行二次开发（即：对接渠道的SDK，登录、充值、分享等）。（6）、最后构建成app进行安装、测试、发布。 流程如图1所示： ​ ​ 图（1） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/native/native_index/readme.html":{"url":"released/native/native_index/readme.html","title":"LayaNative不是浏览器","keywords":"","body":"LayaNative首页说明1、LayaNative的启动入口2、LayaNative的启动文件配置说明LayaNative首页说明 重要的事情需要说三遍： LayaNative不是浏览器！ LayaNative不是浏览器！ LayaNative不是浏览器！ 1、LayaNative的启动入口 由于LayaNative不是浏览器，也不是通过封装浏览器或者webkit之类的控件来运行html的内容。 所以，LayaNative不能启动和运行html页面文件。 引擎项目bin目录下的index.html可以作为浏览器里的入口，但是不能作为LayaNative的启动入口。 LayaNative的启动入口默认为 通过LayaAirIDE的菜单栏工具--> app构建 ，打开的构建项目窗口里，URL那里配置好即可，配置方式如图1所示。 在图1里，入口默认为index.js 2、LayaNative的启动文件配置说明 入口文件主要确定项目运行时屏幕方向和需要加载的js文件的信息 如果我们使用项目的index.js作为LayaNative的启动入口文件，在点击版本发布后 示例如下： /** * 设置LayaNative屏幕方向，可设置以下值 * landscape 横屏 * portrait 竖屏 * sensor_landscape 横屏(双方向) * sensor_portrait 竖屏(双方向) */ window.screenOrientation = \"portrait\"; // 设置屏幕为竖屏 //-----引擎库开始----- loadLib(\"libs/laya.core.js\") loadLib(\"libs/laya.ui.js\") loadLib(\"libs/laya.d3.js\") //-----引擎库结束------- loadLib(\"js/bundle.js\");//项目代码js 注意： 请不要在index.js文件里编写任何逻辑代码，如果编写可能会发生未知的错误。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/native/build_Tool/readme.html":{"url":"released/native/build_Tool/readme.html","title":"安卓/iOS构建","keywords":"","body":"LayaBox 构建工具1. 运行需求2. 面向用户3. 在IDE中构建项目4. 项目构建界面参数５. 构建好的项目工程的使用6. 手动切换单机版和网络版7. 资源刷新8. 其他注意问题LayaBox 构建工具 　　构建工具用来生成LayaPlayer的移动端App项目，相当于App项目向导。目前支持Android（Eclipse项目、Android studio项目）和iOS(XCode项目)。注意： LayaNative3.0-Android，要求系统最低版本为4.3 LayaNative3.0-iOS，要求系统最低版本为10.0 1. 运行需求 1.1 基础开发环境 ​ 构建项目必须要准备好开发环境。比如：构建iOS项目需要准备好Mac电脑和XCode，android需要准备好Android studio。 2. 面向用户 　无论是构建Android还是iOS项目，则必须要有相应的Android或iOS的App开发基础。 如果不具备，请先去学习了解相关的基础知识。 3. 在IDE中构建项目 使用IDE 发布项目，开发者首先在文件菜单中，打开“构建项目”选项，如动图1所示 （动图1） 　目标平台选择iOS或者Adroid, 由于构建工具需的库文件比较大，因此并没有直接包含在LayaAirIDE中，在第一次使用这个工具的时候，会先下载SDK包，如下图： ​ (图2) 注意 这个文件比较大，所以下载的时候需要耐心等待。 4. 项目构建界面参数 在LayaAirIDE中打开项目构建的界面，如图3所示： (图3) 目标平台 构建生成的项目工程的类型，有Android studio项目、iOS 项目 两种选项，如果需要生成Android项目，可以选择Android-studio。 如果需要生成XCode(iOS)项目，则选择iOS选项。 版本 Native工程的版本，尽量与LayaAir引擎版本一致，否则可能存在版本兼容性问题 单机 如果勾选此选项，则构建的项目打包的App是单机版，否则就是在线版。单机版不需要联网，没有对应的url，不用提供url。但是必须提供游戏资源，否则打包之后无法运行。单机版的地址固定为 http://stand.alone.version/index.js 打包资源 资源是脚本、图片、声音等资源。对于在线游戏，只要有游戏的url就能正常运行，但是把资源直接打进App包中的话，可以避免网络下载，加快资源载入速度。如果是单机游戏，由于没有提供游戏url，就必须给资源目录，把所需的资源全部打包进App。 打包进App的资源依然可以通过我们的dcc工具（资源缓存管理）进行更新。 如果这时候没有设置资源路径，在构建完项目以后，依然可以手动添加资源，添加方法参考 LayaDcc工具。 注意： 　　把资源打包的缺点是会增加包体的大小。 　　打包资源的在线游戏，必须在server端打dcc，否则就会失去打包的优势，依然会下载所有的资源。如何打dcc，参考 LayaDcc工具。 App名称 App的名称。同时也是构建项目的输出目录。 应用ID 应用的包名，这个正常情况下是不可见的。一般采用反域名命名规则（有利于分辨和避免与系统中已经有的APP冲突)。 例如 : com.layabox.runtime.demo　　包名必须是 xxx.yyy.zzz 的格式，至少要有两级，即xxx.yyy 。否则打包会失败。 URL 如果要打包的应用是一个在线项目，则需要提供一个启动url，指向一个js或json文件，是应用的入口。而通过LayaAir生成的项目，会输出一个启动页面，一般是index.js。 在测试的时候，为了方便，通常是使用的本地URL地址在浏览器中测试，当打成Android App的时候，必须有一个真正的webserver的地址， 例如： 　　局域网地址： http://10.10.20.19:8888/index.js 　　实际地址: http://nativetest.layabox.com/layaplayer/index.js ５. 构建好的项目工程的使用 构建好的 App工程，可以用对应的开发工具打开进行二次开发和打包等操作。 Android-studio（android）项目可以使用 android-studio软件进行导入和开发。 XCode（ios）项目可以使用 xcode 软件进行导入和开发。打开XCode(ios)项目后需要选择真正的ios设备进行build。（注意：真正的设备是 armv7、armv7s、arm64 架构。而如果使用ios Simulator 则是 X86 架构，目前 LayaNative 在 ios 设备上尚未支持 X86 架构，如果使用模拟器编译是无法通过的。 参考资源： Android Studio的使用和配置 IOS打包发布App详细流程 ​ 6. 手动切换单机版和网络版 构建完成之后，可以通过直接在项目中修改代码来切换单机版和网络版。 Android 项目 在构建的项目中打开MainActivity.java，搜索 mPlugin.game_plugin_set_option(\"localize\",\"false\"); 单机版需要设置为\"true\"，如mPlugin.game_plugin_set_option(\"localize\",\"true\"); 如果要设置为网络版，就要修改为：mPlugin.game_plugin_set_option(\"localize\",\"false\");， 并且设置正确的地址： mPlugin.game_plugin_set_option(\"gameUrl\", \"http://你的地址/index.js\"); iOS 项目 iOS项目构建完成后，项目目录下的 resource/scripts/index.js 脚本的最后有个执行loadUrl的函数，这里会加载首页地址，修改这里的地址就能切换单机版和网络版，单机版的地址固定为 http://stand.alone.version/index.js。 例如一开始是网络版，地址为： loadUrl(conch.presetUrl||\"http://10.10.20.19:7788/index.js\");要改成单机版的话，修改这句话： loadUrl(conch.presetUrl||\"http://stand.alone.version/runtime.json\");反之亦然。 注意一旦修改了url地址，原来打包的资源就都失效了。这时候，需要手动删除 cache目录下内容，重新用layadcc来生成打包资源，参见LayaDCC工具。 7. 资源刷新 通过IDE构建好工程，如果选择的是单机版和打包资源版本。会在resource/cache目录下，把所有h5项目的资源（包括：脚本、图片、html、声音等）全部打包到了这个目录下。android的目录： assets/cache/iOS的目录： resource/cache/ 但是在开发过程中，h5的项目一直在变化，为了避免每次都重新构建工程，可以通过命令行进行刷新。 资源包版本调用命令：layanative3 refreshres -u http://testgame.layabox.com/index.js单机版本调用命令：layanative3 refreshres Tips1、必须在构建的app工程目录下，执行命令。最明显的标志就是要在navtie.json的目录下，如下图所示： 关于layanative命令行如何安装使用，请参考layanative命令行工具使用 8. 其他注意问题 　　android studio构建完成后，需要根据自己的环境修改android sdk的版本号，现在设置的是23，需要修改的 文件是 app/build.gradle。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/native/screen_orientation/readme.html":{"url":"released/native/screen_orientation/readme.html","title":"横竖屏设置","keywords":"","body":"横竖屏设置一、项目构建前横竖屏的设置二、项目构建后横竖屏的设置2.1 iOS2.2 Android三、执行顺序横竖屏设置 本篇文档进一步全面介绍LayaNative横竖屏的设置。 一、项目构建前横竖屏的设置 如果想设置横竖屏，通过LayaAirIDE的菜单栏工具--> app构建 ，打开的构建项目窗口里，屏幕方向那里配置好即可，配置方式如下图所示。 当设置屏幕方向后，点击版本发布，在index.js中会添加screenOrientation属性： /** * 设置LayaNative屏幕方向，可设置以下值 * landscape 横屏 * portrait 竖屏 * sensor_landscape 横屏(双方向) * sensor_portrait 竖屏(双方向) */ window.screenOrientation = \"portrait\"; // 设置屏幕为竖屏 //-----引擎库开始----- loadLib(\"libs/laya.core.js\") loadLib(\"libs/laya.ui.js\") loadLib(\"libs/laya.d3.js\") //-----引擎库结束------- loadLib(\"js/bundle.js\");//项目代码js 二、项目构建后横竖屏的设置 2.1 iOS iOS项目构建成功后，打开resource/config.ini文件，修改orientation=16的值，如下图所示： 参数的意义如下： orientation=2 //竖屏：IOS home键在下 orientation=4 //竖屏：IOS home键在上 orientation=8 //横屏：IOS home键在左 orientation=16 //横屏：IOS home键在右 orientation的值可以使用按位或的方式进行设置，例如: orientation=6 //代表竖屏可以任意旋转 orientation=24 //代表横屏可以任意旋转 注意： iOS工程项目内的横竖屏设置最好和config.ini设置一致。如果设置的不一致可能会导致未知的情况发生。设置如下图： 2.2 Android android项目构建成功，打开AndroidManifest.xml文件，在activity标签内有一个screenOrientation参数，开发者可以根据自己需求进行修改，如下图所示： 可配置的参数是android的标准，在这不做过多解释，如下所示： \"landscape\",\"portrait\",\"full_sensor\",\"sensor_landscape\",\"sensor_portrait\",\"reverse_landscape\",\"reverse_portrait\" 三、执行顺序 应用程序在启动的时候会先读取iOS的config.ini中设置的屏幕方向或android的AndroidManifest.xml中设置的屏幕方向。当解析到index.js的时候再读取屏幕横竖屏设置的值，并重新设置屏幕方向。 例如：android的AndroidManifest.xml中设置为portrait，index.js中的标签设置为landscape，运行过程中就会发现在android设备上，屏幕会旋转一下，从竖屏旋转成了横屏。 Tips：建议开发者把两个值设定一致，这样避免程序在执行过程中出现屏幕旋转的现象。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/native/loading_view_new/readme.html":{"url":"released/native/loading_view_new/readme.html","title":"启动画面LoadingView","keywords":"","body":"加载界面1.进度条控制2.进度条控制实例3.去掉所有文字显示4.自定义界面和功能5.特别说明加载界面 为了方便开发者，自定义LoadingView，LayaNative使用原生功能实现的新的LoadingView。 应用程序在启动的时候，需要加载必要的html、js、图片，这个时候就需要通过加载界面显示进度，LayaNative在运行项目的时候，默认有一个LoadingView界面，一段时间后，即可进入游戏，如图1所示： ​ 图1 1.进度条控制 ​开发者可以在config.js中，控制LoadingView的背景色、字体颜色、Tips等。 config.js的位置： Android: 工程目录下的assets/scripts/config.js IOS:工程目录下的resources/scripts/config.js config.js中的内容如下所示，开发者可以根据自己的需求进行修改： window.loadingView = new loadingView(); if(window.loadingView) { window.loadingView.loadingAutoClose=true;//true代表引擎控制关闭时机。false为开发者手动控制 window.loadingView.bgColor(\"#FFFFFF\");//设置背景颜色 window.loadingView.setFontColor(\"#000000\");//设置字体颜色 window.loadingView.setTips([\"新世界的大门即将打开\",\"敌军还有30秒抵达战场\",\"妈妈说，心急吃不了热豆腐\"]);//设置tips数组，会随机出现 } 2.进度条控制实例 在实际开发过程中，通常想要精确控制LoadingView的隐藏和显示，那么开发者可以在config.js中这样设置loadingView.loadingAutoClose的值为false 然后在项目中根据加载完成情况，设置进度条的显示进度，调用函数如下: window.loadingView.loading(nPercent);//参数为0-100的整数值，当值为100的时候LoadingView自动关闭 具体的步骤如下： 步骤1： 在config.js中设置loadingView.loadingAutoClose的值为false window.loadingView = new loadingView(); if(window.loadingView) { window.loadingView.loadingAutoClose=false; // 设置值为false，开发者手动控制加载界面的关闭 ... } 步骤2： 调用loadingView.loading(nPercent)更新进度条 伪代码如下： var nPercent=0; var image1 = document.createElement('img'); image1.onload=function() { if(window.loadingView){ nPercent+=33; window.loadingView.loading(nPercent); } } image1.src = \"a.png\"; var image2 = document.createElement('img'); image2.onload=function() { if(window.loadingView){ nPercent+=33; window.loadingView.loading(nPercent); } } image2.src = \"b.png\"; var image3 = document.createElement('img'); image3.onload=function() { if(window.loadingView){ nPercent+=33; window.loadingView.loading(nPercent); } } image3.src = \"c.png\"; Tips： 当loadingView.loading(nPercent)函数传入的值等于100时，加载界面会自动关闭。也可以通过调用loadingView.hideLoadingView()关闭加载界面。 3.去掉所有文字显示 可以去掉所有文字的显示，包括tips和加载百分比，修改config.js，把showTextInfo的值设置为false即可，代码如下： window.loadingView = new loadingView(); if(window.loadingView) { ... window.loadingView.setTips([\"新世界的大门即将打开\",\"敌军还有30秒抵达战场\",\"妈妈说，心急吃不了热豆腐\"]);//设置tips数组，会随机出现 window.loadingView.showTextInfo=false; // 值设置为false } 4.自定义界面和功能 所有代码公开，因此开发者可以根据需要修改代码实现任何所需自定义功能。 5.特别说明 启动画面，Android版本使用原生Java开发，iOS版本使用Object-C开发，代码都是开源的，开发者如果需要自定义界面，可自行修改，如果不会Android和iOS编写界面，那就去学一下吧。 后续LayaBox会有白名单机制，如果开发者购买了授权，便可以去掉LayaBox的Logo，如果没有购买，则需要强制增加LayaBox的logo，引擎内部会有检测机制，随机检测，如果检测不通过，会强制Crash应用程序。 LayaNative不是开源引擎，但免费给开发者使用，如果想要去掉LayaBox的Logo需要付费。开发者可以通过LayaBox公众号、官网等联系LayaBox商务进行购买。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/native/network/readme.html":{"url":"released/native/network/readme.html","title":"关于网络监听","keywords":"","body":"关于网络状态监听1.监听方式2.查询方式关于网络状态监听 由于移动设备网络环境不太稳定，当网络发生变化的时候，项目中经常需要给用户一些提示，在LayaNative中有两种方法，可以获得网络环境变化。 1.监听方式 开发者可以使用注册监听函数的方式进行监听网络变化，代码如下： JS代码如下 if( conch ) { conch.setNetworkEvtFunction(function(type) { alert(type) }); } AS代码如下： if ( Render.isConchApp) { Browser.window[\"conch\"].setNetworkEvtFunction(function(type):void { alert(type) }); } 返回值类为int类型 NET_NO = 0; NET_WIFI = 1; NET_2G = 2; NET_3G = 3; NET_4G = 4; NET_YES = 5; Tips1、conch只能LayaNative环境下调用，在网页版本中是没有conch定义的，所以需要判断一下是否存在。2、或者使用if(Render.isConchApp )进行判断都可以。 2.查询方式 开发者还可以通过主动查询的方式，查询网络状态，代码如下： if( conch ) { var nType = conch.config.getNetworkType(); } 返回值类为int类型 NET_NO = 0; NET_WIFI = 1; NET_2G = 2; NET_3G = 3; NET_4G = 4; NET_YES = 5; Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/native/LocalStrorage/readme.html":{"url":"released/native/LocalStrorage/readme.html","title":"关于LocalStorage","keywords":"","body":"关于LocalStorageAS下的用法JS和TS下的用法错误的用法：关于LocalStorage LayaNative支持LocalStorage的使用，但是有格式要求，必须使用getItem()、setItem()来存储值以及取值 AS下的用法 //存储指定键名和键值，字符串类型。 LocalStorage.setItem(\"LayaBox\",\"H5引擎！\"); //获取指定键名的值。 LocalStorage.getItem(\"LayaBox\"); JS和TS下的用法 //存储指定键名和键值，字符串类型。 Laya.LocalStorage.setItem(\"LayaBox\",\"H5引擎！\"); //获取指定键名的值。 Laya.LocalStorage.getItem(\"LayaBox\"); 错误的用法： 下面js语法的用法在PC端浏览器或者移动端（浏览器裸跑）支持，但是LayaNative下不支持 //存储，LayaNative下不支持 localStorage.test = 100; //取值，LayaNative下不支持 alert(localStorage.test); Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/native/Android_BackPress/readme.html":{"url":"released/native/Android_BackPress/readme.html","title":"处理Android后退按钮","keywords":"","body":"接管android的后退按钮接管android的后退按钮 在LayaNative中可以使用这两个函数， conch.setOnBackPressedFunction(onBack) 和conch.exit(), 接管按下“后退键”的处理方式。接管setOnBackPressedFunction后，当用户按下后退键时便会执行此函数。 一旦调用了这个函数，就屏蔽了引擎中默认按下两次退出的功能，这时候，如果想要退出应用的话，可以通过调用exit()函数来实现。 Tips1、conch只能LayaNative环境下调用，在网页版本中是没有conch定义的，所以需要判断一下是否存在。2、LayaNative只有Android版有这两个函数。 js示例如下： var n=3; if(window.conch){ window.conch.setOnBackPressedFunction(()=>{ console.log('press back '+n); if(n-- Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/native/real_device_debugging/readme.html":{"url":"released/native/real_device_debugging/readme.html","title":"Android真机调试JavaScript","keywords":"","body":"在android真机上调试JavaScript代码一、调试的原理二、调试layaAirIDE构建的Android项目步骤1:步骤2：修改调试模式步骤3：编译并运行项目步骤4：使用Chrome连接工程步骤5：进行调试四、目前版本存在的问题在android真机上调试JavaScript代码 一、调试的原理 JavaScript代码的调试，是使用调试机上的Chrome浏览器进行的。Android测试机上的LayaNative启动的时候，会同时启动一个WebSocket服务器。Chrome浏览器通过WebSocket与LayaNative连接通信，从而实现使用Chrome对项目的JavaScript的调试。 在调试项目中的JavaScript的代码时，有以下两种调试模式可以选择： Debug/Normal模式 在该模式下，Android测试机上的项目可以直接启动并运行，Chrome浏览器可以在项目运行后连接调试。 Debug/Wait模式 在该模式下，Android测试机上的项目启动后，会一直等待Chrome浏览器的连接。当Chrome连接成功后，才会继续执行JavaScript脚本。 当需要对启动时加载的JavaScript脚本进行调试时，请优先选择该模式。 注意：在调试的工程中请确保调试机与Android测试机在同一网络上。 二、调试layaAirIDE构建的Android项目 步骤1: 使用LayaAirIDE对项目进行构建，生成Android的工程。 步骤2：修改调试模式 使用Android Studio打开构建后的工程。 打开android_studio/app/src/main/assets/config.ini，修改JSDebugMode的值,设置需要的调试模式。如图1： 图1 JSDebugMode的取值和含义如下： 取值 含义 0 关闭调试功能 1 Debug/Normal模式 2 Debug/Wait模式 Tips： 当项目正式发布后，请将JSDebugMode的值设置为0，否者会对项目运行时的性能有影响。 步骤3：编译并运行项目 使用Android Studio编译工程。 如果选择的是Debug/Normal模式，等待Android测试机成功启动并运行项目。 图2 Android测试机成功启动并运行项目 如果选择的是Debug/Wait模式，等待Android测试机成功启动项目。 图3 Android测试机成功启动 步骤4：使用Chrome连接工程 打开调试机上的Chrome浏览器，输入以下网址： devtools://devtools/bundled/js_app.html?v8only=true&ws=10.10.82.142:5959/177987ab-1d16-4ea6-afcc-c11c0a1bb9e9 注意： ws=10.10.82.142:5959里的10.10.82.142是Android测试机的ip地址，5959是步骤2中config.ini文件里JSDebugPort设置的端口号值，请根据自己设备的实际情况和需求进行更改。 步骤5：进行调试 连接成功后，便可以使用Chrome对项目中JavaScript进行调试。如图2所示： 图4 四、目前版本存在的问题 下面的问题会在以后的版本里解决，敬请谅解。 在调试器调试的过程中，使用调试器手动添加的断点（非debugger断点)，有几率会出现调试混乱。 如果遇到这种情况，请按以下步骤进行处理： 步骤1：设置的断点如下 图11 步骤2：取消所有的断点 图12 步骤3：重启启动工程，再使用Chrome连接工程。 图13 步骤4：恢复需要的断点 图14 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/native/LayaDcc_Tool/readme.html":{"url":"released/native/LayaDcc_Tool/readme.html","title":"缓存工具-layadcc","keywords":"","body":"LayaDCC工具介绍LayaPlayer资源包的类型安装和使用layadcc1. 安装Node.js2. 安装 layadcc3.使用方法4. 实战操作常见问题附录LayaDCC工具 介绍 LayaDCC：Laya-Dynamic Content Check，是LayaPlayer提供的一种热更新解决方案。其优点是运行时差异更新，能有效减少网络流量。他的主要数据是DCC文件，DCC文件用来描述项目中所有文件的校验值。DCC文件是通过工具 layadcc 来产生的。 layadcc会遍历所有的项目文件，生成一个包含所有文件校验值的二进制文件filetable.bin。LayaPlayer在启动的时候，会从服务器获取这个文件（如果需要的话）来确定需要更新什么文件。 layadcc 还可以用来把生成资源包，用来把资源打包到App中。 LayaPlayer资源包的类型 目前的资源打包方案有三种。 App联网包： App本身不带任何资源，体积最小。LayaPlayer第一次运行时，所有用到的资源都会从服务器端下载，并缓存在本地。第二次及以后运行时，会先从服务器获取dcc文件，然后在需要下载某个文件的时候，检查本地的资源是否需要更新，只有需要更新的时候才真正下载，未更新的资源则直接从本地缓存读取。本地缓存会逐渐增大。 带资源的App联网包： App包本身包含了部分或者全部的游戏资源，包体积较大。数据依然能更新，即每次运行依然会从服务器取dcc文件进行校验，如果发现包中的某个文件已经老了，就会下载新的文件，缓存在本地，以后再运行的时候，只要缓存的文件没改，就依然使用缓存的。在多次更新后，App包的文件可能大部分都无效了，每次都是取的本地缓存，这时候建议重新更新App包，用新的资源来打包。 App离线包（单机包）： 直接把所有的资源都打包到App中，完全不需要网络下载，甚至不需要联网。体积最大。因为是单机版本，没有url，所以无法进行资源动态更新，想要更新资源的话，只能更新App。 安装和使用layadcc layadcc基于Node.js，所以需要Node.js的环境。 1. 安装Node.js 到nodejs官网下载。node.js不能太老，不支持 0.xx的版本，可以用命令查看node版本 例如: $ node -v v4.2.0 这个版本就可以。 2. 安装 layadcc npm install -g layadcc 如果顺利安装完，就可以在命令行中直接执行layadcc。 3.使用方法 layadcc 资源目录 [options] options: -cache 生成资源包. -lwr 文件路径全部转为小写。（一般不需要） -url url 如果要打包资源的话，对应的url. -cout outpath 打包资源的输出目录，如果不设置的话，就是在资源目录下。 例如: layadcc d:/game/wow -cache -url www.game.com 4. 实战操作 4.1 运行环境 确保正确安装了Node.js，npm，layadcc验证方法：图1只要执行layadcc没有报错就可以了。 4.2 html5项目环境 假设有一个游戏项目，放在F:/work/test/bestgame/目录下(启动页index.html在这个目录下)，他的目录结构为： 图2这个项目发布后对应的url地址是： http://www.layabox.com/bestgame/index.html（如果单机版不需要url地址） 4.3 打包资源 现在要把这个html5项目打包，放到App项目中。 layadcc F:/work/test/bestgame -cache -url http://www.layabox.com/bestgame/index.html 如果是单机包的话，输入: layadcc F:/work/test/bestgame -cache -url http://stand.alone.version/index.html 如下图:图3 加了-cache参数后，就会遍历所有的资源文件，输出到-cout指定的目录下，如果没有-cout参数，就在工作目录下创建一个layadccout目录（如上图），输出目录下的cache目录就是打包App的时候需要使用的资源。然后把这个目录拷贝到构建的项目的对应的目录中，就可以编译打包生成App。在不同的开发环境下，需要放到不同的目录中（如果使用LayaAirIDE或者layabox命令行工具，可以自动完成这一步）。 Android Eclipse: （图4） android的资源目录是项目下的assets目录 Android Studio:（图5） iOS XCode: （图6）IOS是resource目录 4.4 更新服务器 这是App发布后最常见的操作。每当更新了html5项目的内容，需要提交到服务器或者本地测试的时候，都要生成新的dcc，以便客户端能更新到最新资源。操作过程如下图：图7 可以看到执行完layadcc后，在指定目录（现在是当前路径 . ）下面会生成一个update目录。然后把这个update目录拷贝到本地或者远程服务器的相同目录即可。Tips:为了方便和不出错误，建议直接在服务器所在目录下执行layadcc。 update目录介绍：图8 allfiles.txt 所有的资源文件的相对路径。assetsid.txt 本次dcc统计的整个资源包的校验码。filetable.bin dcc主文件，里面是每个文件的校验值。filetable.txt 文本格式的dcc文件，除了前三行，每一行代表一个文件和对应的校验值，与allfiles.txt正好对应起来，即第4行对应的文件是allfiles.txt的第一行。filetable1.txt 这个文件不再使用。 注意: 如果web服务器上的目录里面没有update目录，或者update目录里面没有内容，则客户端的dcc更新机制就会关闭，这样所有的资源每次都会重新下载。在开发期间建议用这种方式。 上面的例子是在当前目录下，实际也可以指定其他路径，相对或绝对都可以，例如:layadcc d:/game/bin/h5 或者 layadcc ../bin/h5 4.5 测试 资源打包成功的测试先说包中没有资源的情况，这种情况下所有的资源都会从网上下载，日志如下:图9 可以看到有很多的Download打印信息说明： 这里面的url后面跟着的 @127.0.0.1是调试用的，表示这个文件对应的服务器地址。s=0表示这个文件没有dcc信息， l=xxx表示下载的文件的长度。 如果打了资源包，即cache目录下的东西拷贝到上面指定的目录了，这时候最直观的变化是包变大了。然后运行app，会有从资源包读取资源的打印，如下： 图10打印信息说明打印 found the file in the package: 就表示对应的资源是从包中获取的，没有去网络下载，看到这个日志就表示打包资源成功。如果打的单机版，则所有资源都应该有这个打印，不应该有任何下载。 服务是否有dcc的测试：在浏览器里打开地址： http://www.layabox.com/bestgame/update/filetable.txt注意要改成自己的地址，如果文件存在，表示打过dcc。如下图：图11 更新机制起作用的测试直观的测试就是更新了资源，App产生了对应的改变，例如修改了的图片，能在app上看到。从日志看的话，就是资源获取的时候，凡是没有改变的都是打印 found the file in the package:， 而改变了的都是打印 download [ ] xxxurl。注意 1 Download只执行一次，第二次再进入app，这个资源如果没改，就会直接从缓存取。 2 DCC的机制是运行时更新，所以只有执行到需要这个资源的时候才会下载，而不是一启动就下载所有更新。 总结 凡是有 download [ ] url就表示下载，说明没有dcc或者资源更新了 凡是有found the file in the package:，说明打包资源成功，dcc起作用了。 注意: layadcc执行的时候会修改所有文件的修改时间，目的是为了防止cdn在回源的时候以为文件没有被修改。 上面的地址是虚构的，不存在一个 http://www.layabox.com/bestgame/index.html 的地址。 常见问题 打包资源以后，没感觉速度变快，怀疑所有的资源还是都在下载。 确定是否真的都是在下载，看日志是不是有上面提到的Download和find，如果既有读缓存，也有下载，则没有问题，只是真的下载慢。 如果全部都是Download，没有读缓存 是不是忘了打dcc了，通过浏览器检查服务器是否有dcc信息。 检查打包资源路径是否正确。 App发布后，修改了部分资源，但是没有被App更新到。 是不是忘了打dcc了？ 打了dcc了，但是忘了提交到服务器上（建议在服务器打dcc）？ 打了dcc了，也提交到服务器了，但是由于有cdn，还没有把这个变化分发到你所在的节点。 我确认dcc流程都对了，但是某个资源每次都会重新下载，不走缓存。 确认这个资源是否在打包资源中，即dcc列表中，可以在 update/allfiles.txt中搜索这个文件。 如果在。确认请求这个资源的url是否有search部分，即?xxx, 如果加了的话，是无法走dcc流程的。 如果也没有search，那有可能是这个文件的实际内容与校验值不匹配，dcc会以为是错误的文件，就不缓存了。可能的原因： 打完dcc以后，有人把这个文件的内容又给改了，导致dcc校验值与实际文件内容不匹配。解决方法：重新打dcc 没人改文件内容，但是dcc是在客户端打的，文件在上传到服务器以后，被上传软件修改内容了。这种情况一般发生在文本文件上，例如有的版本管理工具和ftp工具会把windows下的回车换行变成unix的回车。解决方法：用zip的方式传文件，或者在服务器上打dcc。 没有上面的问题，而且错误的是图片。可能原因是有的系统会全局截获http请求，在请求图片的时候，通过自己的服务器来缓存一个被压缩过的图片，来达到所谓的节省流量。这个压缩过的图片的校验值肯定与dcc记录的不一样。解决方法：关掉节省流量功能。 如果没有开流量节省。但是使用了cdn，则还可能是cdn的问题，例如dcc文件被刷新了，但是对应的资源文件没有刷新。确认方法：通过curl命令下载本节点上的资源文件（方法见附录），与源站的资源文件比较，如果不同，即确认。解决方法：强制刷新cdn节点，或者找cdn客服。 开发期间，每次更新都打dcc太麻烦。 不要用layadcc来打dcc，如果已经打了， 把update目录删掉，然后重新安装一下app，以去掉内部的缓存，这样dcc机制就关掉了，每个文件每次请求都会重新下载。 如果某次又打了一下dcc，在服务器端生成了update目录，则缓存又会起作用，想关掉的话，再来一遍上面的操作。 为了减少包的体积，希望只是打包部分资源，正确的姿势是什么？ 无论是初次安装，还是以后升级app，如果只打部分资源的话，要保证资源里的dcc信息是基于完整数据生成的。例如共有100个资源，只想打包50个到app中，需要先在完整资源状态下打dcc，保存生成的dcc信息（主要是filetable.txt），然后删掉50个资源，用layadcc生成cache文件，这时候cache目录下生成dcc信息是不完整的，所以要用上一步生成的文件来覆盖他。 如果使用了不完整的dcc会导致的问题：更新app的时候，native会优先使用app中缓存的dcc文件，导致丢失部分缓存信息，这样不在filetable.txt中的文件会被认为不需要缓存，从而一直下载，直到下次服务器dcc更新。 附录 LayaDCC的流程图12对应的代码在 index.js 中。 下载某个cdn节点上的文件。 curl -H \"Host:www.layabox.com\" http://182.110.238.110/bestgame/index.html >a.html 表示把 182.110.238.110 节点上的 http://www.layabox.com/bestgame/index.html的文件下载下来，保存到 a.html中。 其中的 Host：后面的内容改成自己的域名， http://后面的ip地址改成节点服务器的地址，那怎么获得节点服务器地址呢？在LayaPlayer中，节点服务器通常不会改变，所以可以通过任意一个Download的打印来得到地址，例如: Downloaded http://www.layabox.com/bestgame/bestgame.min.js@182.110.238.110 s=44216b56 l=422 就知道节点地址是182.110.238.110。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/native/Secondary_Development/readme.html":{"url":"released/native/Secondary_Development/readme.html","title":"二次开发","keywords":"","body":"用反射机制实现二次开发1. 调用静态函数3.平台代码（android/ios）主动执行js脚本3.1 IOS/OC执行JS脚本3.2 Android/Java执行JS脚本用反射机制实现二次开发 LayaNative通过提供反射机制来帮助开发者可以方便的进行二次开发, 下面通过示例来了解一下如何进行二次开发. 1. 调用静态函数 使用LayaNative, 可以在JavaScript层调用移动端的原生开发语言(Android下Java, iOS下Objective-C)编写的静态函数。 1.1 JavaScript层: JavaScript层的调用方式: var os = conchConfig.getOS(); var bridge; var obj = {}; if (os == \"Conch-ios\") { bridge = PlatformClass.createClass(\"JSBridge\");//创建脚步代理 } else if (os == \"Conch-android\") { //需要完整的类路径，注意与iOS的不同 bridge = PlatformClass.createClass(\"demo.JSBridge\");//创建脚步代理 } if (os == \"Conch-ios\") { //iOS注意函数签名，注意与Android的不同 alert(bridge.call(\"testString:\",\"hello\")); alert(bridge.call(\"testNumber:\",256.0)); alert(bridge.call(\"testBool:\",false)); obj.value = \"Hello OC!\"; bridge.callWithBack(function(value) { var obj = JSON.parse(value) alert(obj.value); },\"testAsyncCallback:\", JSON.stringify(obj)); } else if (os == \"Conch-android\") { alert(bridge.call(\"testString\",\"hello\")); alert(bridge.call(\"testNumber\",256.0)); alert(bridge.call(\"testBool\",false)); obj.value = \"Hello Java!\"; bridge.callWithBack(function(value) { var obj = JSON.parse(value) alert(obj.value); },\"testAsyncCallback\",JSON.stringify(obj)); } 1.2 Android/Java层 在类JSBridge中添加下列函数: public static String testString(String value) { Log.d(\"JSBridge\", \"java: \" + value); return \"LayaBox\"; } public static double testNumber(double value) { Log.d(\"JSBridge\", \"java: \" + value); return 512; } public static boolean testBool(boolean value) { Log.d(\"JSBridge\", \"java: \" + value); return value ? false : true; } public static void testAsyncCallback(String json) { //js thread try { JSONObject root = new JSONObject(json); Log.d(\"JSBridge\", \"java: \" + root.getString( \"value\" )); } catch (JSONException e) { e.printStackTrace(); } m_Handler.post( new Runnable() { public void run() { //ui thread update ui JSONObject obj = new JSONObject(); try { obj.put(\"value\", \"Hello JS!\"); } catch (JSONException e) { e.printStackTrace(); } ExportJavaFunction.CallBackToJS(JSBridge.class,\"testAsyncCallback\", obj.toString()); } }); } 2.1.4 iOS/OC层 在类JSBridge中添加下列函数: +(NSString*)testString:(NSString*)value { NSLog(@\"OC: %@\",value); return @\"LayaBox\"; } +(NSNumber*)testNumber:(NSNumber*)value { NSLog(@\"OC: %@\",value); return @512; } +(NSNumber*)testBool:(NSNumber*)value { NSLog(@\"OC: %d\",value.boolValue); return [NSNumber numberWithBool:value.boolValue ? NO : YES]; } +(void)testAsyncCallback:(NSString*)json { //js thread NSError* error = nil; NSData* jsonData = [json dataUsingEncoding:NSUTF8StringEncoding]; NSDictionary* dict = [NSJSONSerialization JSONObjectWithData:jsonData options:NSJSONReadingMutableContainers error:&error]; NSLog(@\"OC: %@\", [dict objectForKey:@\"value\"]); dispatch_async(dispatch_get_main_queue(), ^{ //ui thread NSError* error = nil; NSDictionary* dic = [NSDictionary dictionaryWithObject:@\"Hello JS!\" forKey:@\"value\"]; NSData* jsonData = [NSJSONSerialization dataWithJSONObject:dic options:NSJSONWritingPrettyPrinted error:&error]; NSString* jsonStr = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding]; [[conchRuntime GetIOSConchRuntime] callbackToJSWithClass:self.class methodName:@\"testAsyncCallback:\" ret:jsonStr]; }); } 注意： 函数参数只支持布尔、浮点、字符串等基本类型，支持返回值。原生函数运行在脚本线程，更新UI需要转到UI线程，支持异步回调函数。 OC源文件后缀要改成.mm，OC的方法是静态的类方法要用+。 通过上述方法可以很方便的进行原生代码相关的二次开发。 3.平台代码（android/ios）主动执行js脚本 3.1 IOS/OC执行JS脚本 [[conchRuntime GetIOSConchRuntime] runJS:@\"alert('hello')\"]; 3.2 Android/Java执行JS脚本 ConchJNI.RunJS(\"alert('hello world')\"); Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/native/webview/readme.html":{"url":"released/native/webview/readme.html","title":"webview","keywords":"","body":"webview一、介绍1. 接口定义2. 限制二、如何在代码中动态关闭webview页面webview 一、介绍 由于LayaNative不支持标准的html，有时候项目需要显示一个完整的html页面，这时候可以通过LayaNative提供的一个显示webview界面的接口来实现。 1. 接口定义 /** * 显示一个webview * @param url {string} 要显示的url地址。 * @param posx {number} weview的左上角位置 * @param posy {number} webivew的左上角位置 * @param width {number} webview的宽度 * @param height {number} webview的高度 * @param canclose {boolean} webview是否可以被关掉。 */ setExternalLinkEx(url:string,posx:number,posy:number,width:number,height:number,canclose:boolean):void; 这个函数会在画布的最上层显示一个新的view，在其中显示url的内容。 canclose参数用来控制这个webview是否能被关掉： 设置为false时: 代码如下： document.addEventListener('touchstart',()=>{ if(conch){ var l = 50; var t = 50; var w = window.innerWidth - l * 2; var h = window.innerHeight - t * 2; conch.setExternalLinkEx('http://www.layabox.com',l,t,w,h,false); // canclose设置为false //conch.setExternalLink('http://www.baidu.com'); } }); webview显示出来后就无法关闭，效果如下： 图1 设置为true时: 代码如下： document.addEventListener('touchstart',()=>{ if(conch){ var l = 50; var t = 50; var w = window.innerWidth - l * 2; var h = window.innerHeight - t * 2; conch.setExternalLinkEx('http://www.layabox.com',l,t,w,h,true); // canclose设置为true //conch.setExternalLink('http://www.baidu.com'); } }); 在ios下，会有一个小关闭按钮，点击这个按钮，就可以关闭webview。 效果如下： 图2 因为关闭按钮会覆盖部分页面内容，且Android设备上提供了后退键，因此Android设备上webview显示后没有关闭按钮，可以通过后退键关闭webview。如下图： 图3 此时可以点击后退键关闭webview 2. 限制 目前webview无法与app进行交互。 webview的实现依赖于系统，低版本的android可能无法显示。 Tips1、conch只能LayaNative环境下调用，在网页版本中是没有conch定义的，所以需要判断一下是否存在。 二、如何在代码中动态关闭webview页面 调用下面的代码可以动态的关闭webview页面： conch.closeExternalLink(); Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/native/built_in_font/readme.html":{"url":"released/native/built_in_font/readme.html","title":"嵌入字体","keywords":"","body":"嵌入字体1. 字体介绍2.如何嵌入字体3.iOS嵌入字体嵌入字体 1. 字体介绍 由于andriod设备种类繁多、android的字体文件不统一，每个系统默认的中文字体路径有差异（再加之国内很多厂商个性化定制），读取font.ttf是一个难题。 LayaNative的策略是根据android的系统版本号，枚举出字体文件的路径，如果加载成功，则使用系统默认字体，如果加载不成功，就从LayaBox网站下载一个字体存储到本地，第二次进入时，直接读取本地字体。 开发者在打包app的时候，要默认将字体打包到app中，如果在网络上下载4MB的TTF字体，会影响用户体验。 2.如何嵌入字体 1、构建好android项目，找到assets目录，再创建一个font目录，把要植入的字体文件改名为“layabox.ttf”，放到该目录下。如图1所示： Tips: 模板工程默认是内嵌了ttf字体，这样会导致apk体积增加，如果你比较在乎apk大小，可以删除assets/font/layabox.ttf这个字体文件。 3.iOS嵌入字体 1、LayaNative支持iOS嵌入默认字体，具体做法同android，在resource下创建font目录，把要嵌入的字体改名为layabox.ttf即可，如下图2所示： Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/native/zipUpdate/readme.html":{"url":"released/native/zipUpdate/readme.html","title":"zip更新","keywords":"","body":"LayaNative的资源更新方法1. 用户不可见的更新（推荐）。2. 用户可见的，进入游戏前的集中更新。LayaNative的资源更新方法 游戏发布之后必然会遇到更新的问题，这里的更新是指用LayaNative打包的游戏发布后，因为修改bug或者添加功能，想要修改客户端的部分代码和图片等数据。目前LayaNative支持两种资源更新方式： 1. 用户不可见的更新（推荐）。 这是一种持续的，随时进行的更新。这种方式符合网页的更新思想：只有当需要使用某个资源的时候，才会触发资源的更新流程。这种化整为零的更新的机制，可以让用户立即进入游戏，在不知不觉间就完成了更新。这种更新基于LayaNative的DCC机制,LayaDCC的介绍和使用方法见这里。 2. 用户可见的，进入游戏前的集中更新。 大部分传统的app的更新方式，一上来就检查是否需要更新，如果需要更新就下载一个大的zip文件进行整体更新。这种更新的维护成本较高，用户需要较长时间的等待才能进入游戏，而且还明显违反Apple的禁止热更的政策。他的好处是用户可以在有wifi的地方更新，在没有wifi的地方玩，避免在没有wifi的时候浪费数据流量。 LayaNative虽然没有直接支持这种更新，但是通过下面的几个接口（注意这些接口属于内部接口，以后有改变的可能性）也能实现这个功能： 支持断点续传的大文件下载函数downloadBigFile。(注意不要用XMLHttpRequest下载大文件，因为这种方式下LayaNative会把结果先保存在内存中，所以大文件可能会导致内存爆掉，而这个函数是随时存盘的。) /** * @param url 远程地址 * @param local 存到本地文件 * @param onprog 下载进度回调 * @param oncomp 下载完成回调 * @param trynum 重试次数（0无限重试） * @param opttimeout 超时时间（建议足够大） */ declare var downloadBigFile:(url:string, local:string, onprog:(total:number,now:number,speed:number)=>boolean,oncomp:(curlret:number, httpret:number)=>void, trynum:number, opttimeout:number)=>void; 处理zip文件的ZipFile类 interface ZipFile{ setSrc(src:string):boolean; /** * 遍历zip中的文件。 * id: * name:文件名，包含路径 * dir:是否是目录 * sz:文件大小 */ forEach(func:(id:number,name:string,dir:boolean,sz:number)=>void):void; /** * 读取zip中的文件的内容，返回一个ArrayBuffer */ readFile(id:number):ArrayBuffer; close():void; new ():ZipFile; } declare var ZipFile:ZipFile; 手动更新dcc缓存的功能。 interface AppCache{ ... /** * 更新dcc缓存中的一个文件 * @param nameid 更新的文件的id。 * 路径规则：/，表示app根目录。例如：hashstr('/index.html')， 不要带参数，如果带参数的话-- hashstr('/aa/bb.html?ff=2') 会导致谁也找不到这个文件 * @param chksum 校验码，如果0则此函数自己计算。如果是外部版本控制，则这个是hashstr后的版本号。 * @param buf ArrayBuffer 文件内容。 * @param extversion 是否使用外部版本号 * @return boolean 如果返回true则表示更新成功，否则的话，表示校验码不一致，即 * 先要更新dcc才能工作。 */ updateFile(nameid:number,chksum:number,buf:ArrayBuffer,extversion:boolean):boolean; ... } 通过这几个函数，就可以在layaDCC之上实现一个集中更新的功能。例如LayaNative提供的一个封装好了的更新函数updateByZip： ​ /** * 用zip进行更新。 * @param {string} url zip下载地址 * @param {(event:string,downloadPercent:number,curfile:string)=>void} onEvent 事件的回调。 * 其中的event是事件名称，可能的事件如下： * 'downloading' 下载中，这时候downloadPercent有值 * 'downloadError' 下载错误 * 'downloadOK' 下载成功。 * 'updating' 更新中，这时候 curfile有值，表示正在更新的文件 * 'updateError' curfile更新错误。因为curfile不在dcc列表，或者文件内容与dcc内容不一致。少量更新错误可以忽略，因为在实际使用的时候还是会下载 * 'unknownError' * @param {function(localfile:string):void} onEnd 更新完成的回调 */ function updateByZip(url, onEvent, onEnd) 这个函数的实现代码，在引擎的 index.js中。所以如果有特殊需求，也可以参考这个函数来实现自己的更新函数。 ​需要注意的是这个函数实际上只是做了下载zip，然后把里面的每个文件更新到cache中的事情。实际使用的时候，还要自己实现版本管理，界面，下载进度提示等功能。为了实现这些功能可能需要本地读写文件的接口，可以使用下面的全局函数（同样是内部接口，可能会改变）： ​ declare var fs_readFileSync:(file:string)=>ArrayBuffer; declare var fs_writeFileSync:(file:string,data:string|ArrayBuffer)=>boolean; declare var readFileSync:(file:string,encode:string)=>string;//这个直接返回字符串。 如果需要获得缓存路径，需要LayaNative内部的appcache对象： ​ var cachepath = window.appcache.getCachePath() Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/native/apk_expansion/readme.html":{"url":"released/native/apk_expansion/readme.html","title":"APK扩展机制","keywords":"","body":"android文件扩展机制1.机制详解1.生成DCC2.压缩文件3.将zip文件拷贝到设备目录4.修改代码中的扩展路径5.开启外部存储权限5.运行测试2. Google Play APK扩展文件机制android文件扩展机制 LayaNative不仅支持把资源打包在assets目录下，还支持把资源打包成zip文件，放到任意文件路径下。LayaNative文件系统会先在assets目录下查找文件是否存在，如果没有找到，再去指定的zip路径下查找。通过这种zip机制便可以解决GooglePlay规定APK的size超过100MB，要求增加扩展包的问题。 1.机制详解 1.生成DCC 测试项目用DCC工具打包资源 2.压缩文件 把资源包放到扩展文件中，压缩cache文件，文件要求zip格式，文件结构必须保持DCC工具生成的结构相同，如下图： 3.将zip文件拷贝到设备目录 在Android手机上建立目录/storage/emulated/0/Android/test/com.layabox.conch6，上传test.zip到这个目录下 4.修改代码中的扩展路径 修改RuntimeProxy.java中的getExpansionMainPath函数，设置正确的zip路径。 public String getExpansionMainPath() { return \"/storage/emulated/0/Android/test/com.layabox.conch6/test.zip\"; } public String getExpansionPatchPath() { return \"\"; } 5.开启外部存储权限 安卓6.0以上的机器可能不能读取外部存储，需要主动请求权限。请加上如下代码或者Google相关解决方案。 public static boolean isGrantExternalRW(Activity activity) { if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M && activity.checkSelfPermission( Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) { activity.requestPermissions(new String[]{ Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE }, 1); return false; } return true; } TIPS:LayaNative中最多支持两个zip文件，第二个zip修改·getExpansionPatchPath·这个函数 5.运行测试 运行APP，看见下面的日志说明从主扩展包读取资源文件成功 2. Google Play APK扩展文件机制 (https://developer.android.com/google/play/expansion-files.html) Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/native/build_Cmd/readme.html":{"url":"released/native/build_Cmd/readme.html","title":"layanative 命令行工具使用","keywords":"","body":"LayaNative命令行工具1.命令详解1.安装layanative1.查看SDK版本信息2.创建native项目3.刷新native项目资源包4.删除native项目资源包3.应用实例LayaNative命令行工具 layanative命令行工具用来生成Android和iOS原生项目，以及项目的资源刷新功能， 方便项目迭代过程中的资源更新。 1.命令详解 1.安装layanative windows $ npm install -g layanative3 mac $ sudo npm install -g layanative3 1.查看SDK版本信息 SDK就是native项目的模板。listversion命令会列出当前所有可用的SDK版本信息，在下面创建native项目的时候可以通过参数指定需要的版本。 $ layanative3 listversions 2.创建native项目 createapp命令用于创建native项目可以先用下面的命令查看下命令createapp的帮助信息 $ layanative3 createapp --help 用法: layanative3 createapp [-f res_path] [--path output_path] [-s sdk_path | -v version] [-p all|ios|android_studio] [-t 0|1|2] [-u url] [-n project_name] [-a app_name] [--package_name package_name] 参数说明: 关键字 描述 --folder,-f 资源路径：把游戏资源打包进客户端以减少网络下载,选择本地的游戏目录，例如启动index在d:/game/index.js下,那资源路径就是d:/game。t为0时可不填 --path native项目输出目录 [默认值: \".\"] --version，-v SDK版本：自动使用特定版本的SDK，系统会从服务器下载SDK并存放在特定位置。--version和--sdk互相矛盾不能同时指定，都不指定时默认使用最新版本的SDK --platform, -p 项目平台 [可选值: all, ios, android_studio][默认值: all] --type, -t 创建类型 [0: 不打资源包 1: 打资源包 2: 单机版本] [默认值: 0] --url, -u 游戏地址 [当t为0或者1的时候，必须填，当t为2的时候，不用填写] --name, -n 项目名称：native项目的名称 [默认值: LayaBox] --app_name, -a 应用名称：app安装到手机后显示的名称 [默认值: LayaBox] --package_name 包名 [默认值: com.layabox.game] --sdk,-s SDK本地目录：自定义的SDK目录，可选参数。断网情况下使用，一般情况下建议使用参数--version。 当type为1或2时会打资源包到native项目，为0时不打。打包资源底层实际是调用dcc的方法。打包资源dcc相关，参考 LayaDcc工具。可以用--path参数指定项目的输出路径，默认输出到当前路径下。 根据-v使用v2.0版本的SDK $ layanative3 createapp -f SnowBallH5 -t 1 -n SnowBallNative -u http://10.10.20.102:8899/index.js -v v2.0 既没指定-v也没指定-s，使用最新版本的SDK $ layanative3 createapp -f SnowBallH5 -t 1 -n SnowBallNative -u http://10.10.20.102:8899/index.js 用--version或者-v指定版本需要联网环境，断网情况下可以用--sdk或者-s指定SDK目录。SDK下载地址 $ layanative3 createapp -f SnowBallH5 -t 1 -n SnowBallNative -u http://10.10.20.102:8899/index.js -s D:/v2.0 3.刷新native项目资源包 refreshres命令用于刷新native项目的资源包项目迭代过程中，h5项目有了修改，可以用refreshres命令，重新打包刷新资源和代码到native项目中。 用法: layanative3 refreshres [-p all|ios|android_studio] [--path path] [-u url] 参数说明: 关键字 描述 --platform, -p 项目平台 [可选值: all, ios, android_studio][默认值: all] --path native项目路径 [默认值: \".\"] --url, -u 游戏地址 如果创建的项目是单机版，refreshres时不需要输入url。如果输入网络版url，打的是网络版的资源包，那么还需要更改项目代码，才能变成网络版的项目。如果创建的项目是网络版，refreshres时必须输入url。如果输入新的地址，那么还要更改项目中设置url的代码，才能完成URL的替换。如果输入单机版地址，打的是单机版的资源包，那么还需要更改项目代码，才能变成单机版的项目。手动切换单机版和网络版相关，参考 LayaBox 构建工具。 createapp时把资源路径写在了生成的native项目目录下的native.json文件中。如果后来资源移到了别的地方，会报错找不到资源目录。createapp时，如果-t参数指定为0时，不打资源，可以不指定资源路径参数，native.json中写的资源路径为空，这种项目refreshres时会报资源路径为空的错误。上述两种情况可以手动修改native.json文件，指定正确的资源路径。 4.删除native项目资源包 removeres命令用于删除native项目的资源包 用法: layanative3 removeres [--path path] 参数说明: 关键字 描述 --path native项目路径 [默认值: \".\"] 3.应用实例 1.首先建立下图所示的目录结构。jellyfish是html5项目目录 2.查看SDK版本信息3.创建native项目4.生成下图所示目录结构。5.随时刷新资源包在dev目录下，通过--path指定native工程的目录进入native项目目录，不需要指定--path参数了5.如果不需要资源包，删除它在dev目录下，通过--path指定native工程的目录进入native项目目录，不需要指定--path参数了 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/native/Other_settings/readme.html":{"url":"released/native/Other_settings/readme.html","title":"其他","keywords":"","body":"其他说明1. 关于第三方地图2. 关于文件格式3. debug模式和release模式4.关于iOS对接微信5. 关于iOS模拟器6. 获取各种信息7. 屏蔽项目中报错弹框8. 引擎初始化或加载启动脚本过程中的异常处理9. 获取设备型号其他说明 1. 关于第三方地图 LayaNative底层渲染使用openGLES渲染，使用android的GLSurfaceView控件和iOS的GLKView控件，所以无法支持第三方地图，如百度地图。 2. 关于文件格式 项目中的文本格式文件（例如:ini、xml、html、json、js等）都必须是utf8编码格式，因为iOS设备不支持非utf8格式编码的文件。 3. debug模式和release模式 LayaNative底层LOG分为三种： LOGI 普通流程log LOGW 警告log LOGE 错误log 在js脚本中，开发者可以通过以下函数设置Debug模式： if( window.conch ) { //值为0：表示关闭所有日志输出 //值为1：表示所有LOGE全部弹出alert //值为2：表示所有LOGE和LOGW全部弹出alert window.conch.config.setDebugLevel(1); } Tips 1、conch只能LayaNative环境下调用，在网页版本中是没有conch定义的，所以需要判断一下是否存在。 4.关于iOS对接微信 在iOS平台下对接微信SDK，微信1.77版本以后需要增加-Objc的参数，微信的官方文档中默认让增加-Objc -all_load,但是这样会导致编译报错。 遇到到这种情况可以把参数变成 -Objc -force_load libWeChatSDK.a，配置后，如图1所示： 5. 关于iOS模拟器 LayaNative支持iOS模拟器，但是由于模拟器运行效率比较低，建议开发者使用iOS真机调试。 6. 获取各种信息 函数名称 函数说明 返回值说明 备注 getTotalMem() 获得运行设备总内存 单位为KB getUsedMem() 获得当前应用程序占用的内存 单位为KB 返回值不太准确，但是可以作为参考 getAvalidMem() 获得可用的内存 单位为KB 返回值不太准确，但是可以作为参考 getNetworkType() 获得网络状态 返回int值，NET_NO = 0;NET_WIFI = 1;NET_2G = 2;NET_3G = 3;NET_4G = 4;NET_UNKNOWN=5 getRuntimeVersion() 获得Runtime的版本 返回值是一个字符串，类似ios-conch5-0.9.2、android-conch5-0.9 getOS() 获得当前系统 返回值类似“Conch-ios” “Conch-android”字符串 getAppVersion() 获得iOS-App的版本号 返回字符串 1.1 iOS-app的版本号，通过这个版本号，可以做APP的更新提示。 getAppLocalVersion() 获得iOS-App的Local版本号 返回字符串1.2 iOS-app的版本号，通过这个版本号，可以做APP的更新提示。 这些函数都属于conch.config类的函数，调用实例： if( window.conch ) { window.conch.config.getRuntimeVersion(); } Tips 1、conch只能LayaNative环境下调用，在网页版本中是没有conch定义的，所以需要判断一下是否存在。 7. 屏蔽项目中报错弹框 项目运行过程中有时会弹出一些错误的提示，这些提示都是项目中有代码写错了。我们的建议是解决掉这些错误弹框里边的错，如果实在是解决不掉再去屏蔽。报错弹框代码如下所示： window.showAlertOnJsException(false); 8. 引擎初始化或加载启动脚本过程中的异常处理 在LayaNative版本中，当引擎初始化、加载启动脚本过程中，如果发生异常（如网络不稳定），引擎会自动调用到window.onLayaInitError(error)函数，该函数默认在config.js中定义，代码如下： window.onLayaInitError=function(e) { console.log(\"onLayaInitError error=\" + e); alert(\"加载游戏失败，可能由于您的网络不稳定，请退出重进\"); } 开发者可以根据自己需求，修改报错信息和报错方式。 9. 获取设备型号 在LayaNative中，iOS可以通过调用conch.config.getDeviceInfo()获取设备型号。可以用于iPhone X的头帘适配，代码如下： if( window.conch ) { var devInfo = JSON.parse(window.conch.config.getDeviceInfo()); if (devInfo.devicename === 'iPhone10,3' || devInfo.devicename === 'iPhone10,6') { // iPhone X适配 } } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "}}