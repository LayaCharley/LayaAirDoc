{"./":{"url":"./","title":"引擎介绍","keywords":"","body":"LayaAir引擎介绍一、引擎的背景与发展历程1.1 Layabox的前世1.2 Layabox的今生二、LayaAir引擎的服务与生态LayaAir引擎介绍 Author: Charley 欢迎来到LayaAir引擎文档~ 一、引擎的背景与发展历程 1.1 Layabox的前世 Layabox的创始人谢成鸿在2003年将国内三大休闲娱乐平台之一的”可乐吧“以数千万价格卖给清华同方后，创立了3D端游研发公司”中娱在线“。 Layabox公司成立时的引擎技术骨干均来自于追随谢成鸿多年的3D端游引擎核心成员，时间最长者达10多年。 早在2011年底，Layabox的创始人谢成鸿就成立了LAYA实验室，开始研究可同时发布APP和HTML5的通用型引擎。并分别在2012年推出行业首款同屏多人实时交互对战的休闲对战类大型HTML5游戏《疯狂雪球》、2013年推出行业首款HTML5与APP同时发行的大型卡牌策略类HTML5游戏《上吧主公》（曾用名《喵喵三国传》）。并取得不错的商业成绩。2014年完成首款重度动作类HTML5游戏《猎刃2》的测试版，力证HTML5游戏技术与品质表现力已达到APP精品水准。 无论是3D端次世代引擎的积累，还是多年HTML5与APP跨平台大型游戏引擎的积累。为Layabox的成立与爆发奠定了深厚的基础。 1.2 Layabox的今生 Layabox是北京蓝亚盒子科技有限公司打造的引擎服务商与元宇宙服务商品牌。 Layabox成立于2014年，旗下的开源引擎产品LayaAir，截止到2022年,拥有超百万的全球开发者，是HTML5与小游戏领域的3D龙头引擎。 作为技术领航的引擎企业，众多知名企业及上市企业纷纷采用LayaAir引擎研发项目，这些企业如：腾讯、阿里巴巴、美团、网易、三七互娱、完美世界、掌趣、电魂网络、蓝港、光宇游戏、汤姆猫、猎豹移动、第七大道、第九城市、精锐教育、商汤科技等等。 自2018年微信小游戏推出以来，休闲小游戏时代来临，国内外知名流量平台相继携手Layabox建立深入的合作伙伴关系，推进小游戏时代的发展，这些已合作的平台为：微信、手机QQ、百度、小米、OPPO、vivo、支付宝、bilibili、淘宝、优酷、华为。 2021年，Layabox全资收购著名的游戏行业工具软件FairyGUI，并全力打造LayaAir 3.0。 2022年11月8日，元宇宙平台Layaverse正式推出，同一天，LayaAir3.0也开启了测试（面向定向邀请的开发者）。 二、LayaAir引擎的服务与生态 LayaAir引擎开源免费，拥有超百万的开发者生态。 提供了：免费的社区服务、LayaAir集成开发环境（IDE）、丰富的学习资料（文档、API、DEMO、视频）。 引擎官网地址：https://layaair.com/ 引擎社区地址：https://ask.layaair.com/ Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-06-29 22:37:12 "},"basics/readme.html":{"url":"basics/readme.html","title":"引擎功能概述","keywords":"","body":"LayaAir3.0引擎功能概述一、引擎代码1.1 引擎通用部分1.2 2D引擎1.3 3D引擎二、IDE(集成开发环境)2.1 通用模块2.1 2D模块2.2 3D模块三、项目发布3.1 Web版发布3.2 小游戏发布3.3 Native打包发布LayaAir3.0引擎功能概述 Author：Charley LayaAir3.0引擎，包括引擎代码、项目开发工具、项目发布，三大部分。本篇仅对大块功能简要概述，让开发者有一个初步的认知。 一、引擎代码 引擎代码，除了开放式的可编程的渲染管线，全平台的图形引擎架构，次世代PBR渲染流，ClusterLighting多光源技术，Forward+渲染管线，高性能并行渲染器API的接入（WebGPU）等核心基础。对于开发者而言，我们从通用、2D、3D，这三个部分来分别介绍。 1.1 引擎通用部分 网络（HTTP请求、WebSocket请求） 加载（可加载文本、JSON、XML、二进制、音频、视频、骨骼文件、图像文件等资源） ECS组件系统（组件系统、生命周期方法） 场景管理 事件（派发、侦听，捕获） 交互（鼠标、键盘、屏幕touch、VR手柄） 多媒体播放（音频、视频） 缓动 浏览器接口（封装常用的浏览器window功能、调用浏览器window功能） 设备接口（陀螺仪、加速计、地理位置） 节点 屏幕适配 小游戏适配（微信小游戏、抖音小游戏、OPPO、vivo、小米……等） 1.2 2D引擎 2D精灵（2D基础显示对象与容器） 2D视图（视窗、弹窗） 2D动画（图集动画、逐帧动画、缓动动画、时间轴动画、龙骨动画、spine动画） 2D文本（基础文本、HTML文本、BitmapFont位图字体） 2D UI组件（图像、按钮、显示文本、文本输入、文本域、下拉框、多选框、单选框、单选框组、导航标签组、导航容器、位图切片、位图字体切片、 垂直滚动条、水平滚动条、进度条、垂直划动条、水平划动条、取色器、基础容器、列表、树状列表、面板容器） 2D UI效果（遮罩、滤镜） 2D场景继承类（管理UI） 2D绘图（绘制矩形与圆角矩形、绘制圆形与扇形、绘制多边形、绘制线段、绘制折线、绘制曲线、绘制纹理与填充纹理） 2D物理（Box2D） Tiled Map地图 1.3 3D引擎 3D精灵（3D基础显示对象与容器） 3D基础工具（3D坐标系、3D变换、3D数学工具、等） 3D场景（场景管理、环境光、环境反射、场景天空、场景雾、等） 3D摄像机 3D光照（方向光、点光、聚光、区域光、阴影、光效） 3D网格 3D材质（模型材质、粒子材质、拖尾材质、天空材质） 3D纹理 3D粒子系统 3D拖尾 3D物理（bullet 、PhysX） 3D动画（刚体动画、材质动画、骨骼动画、摄像机动画、时间轴动画） 自定义Shader webXR 二、IDE(集成开发环境) IDE的概述，也分为通用模块、2D模块、3D模块进行概要说明。 2.1 通用模块 层级管理面板 项目资源面板 场景视窗 预览窗口 控制台面板 时间轴动画面板 动画状态机面板 属性设置面板 项目设置面板 IDE插件开发 IDE资源商店 2.1 2D模块 2D布局小部件（基础显示对象节点、UI组件、骨骼动画节点） 2D动画编辑 2DUI编辑 2D脚本管理 场景继承类管理 2D预制体 2.2 3D模块 3D场景编辑 3D摄像机 3D灯光设置 3D动画编辑 3D粒子系统 3D材质编辑 3D蓝图编辑 3D预制体 3D物理编辑 三、项目发布 3.1 Web版发布 发布web版是基础的发布方式，可以用于浏览器上运行，也可以用于Native打包发布。 3.2 小游戏发布 提供了各小游戏平台的适配库，以及快捷的各小游戏平台发布功能。 3.3 Native打包发布 支持发布为iOS与安卓平台的安装包。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-08-10 09:56:16 "},"basics/developmentEnvironment/readme.html":{"url":"basics/developmentEnvironment/readme.html","title":"开发环境","keywords":"","body":"熟悉开发环境《搭建基础开发环境》《IDE开发流程界面概述》熟悉开发环境 准备好相关的开发环境，熟悉一下基础的开发工作流，是学习引擎的前置条件哦~ 《搭建基础开发环境》 《IDE开发流程界面概述》 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"basics/developmentEnvironment/download/readme.html":{"url":"basics/developmentEnvironment/download/readme.html","title":"搭建基础开发环境","keywords":"","body":"搭建开发环境一、下载并安装LayaAir IDE二、搭建TS开发环境2.1 下载并安装Node.js2.2 安装TSC三、安装浏览器四、下载安装VSCode搭建开发环境 Author: Charley 在熟悉开发环境之前，请开发者们准备好相关的工具环境~ 一、下载并安装LayaAir IDE IDE内集成了引擎，直接下载IDE即可。 下载地址：https://layaair.com/#/engineDownload 二、搭建TS开发环境 LayaAir 3.0只支持TypeScript语言开发，所以TypeScript的安装环境还是要准备好。 2.1 下载并安装Node.js 2.1.1 检查是否已安装node.js环境 使用TypeScript开发需要Node.js环境，如果没有安装过的，请前往官方下载(建议LTS版本)。 在安装前，如果不确定是否有现成的环境，可以先确认一下node环境是否已安装，打开命令行工具（windows是cmd），输入指令 npm -h npm -h 按回车键后，如果能看到npm的命令说明、版本号，以及安装路径等信息，如图1-1所示（类似信息即可），那说明已经安装过了，如果不影响使用，可以跳过下载和安装node环境的步骤。 (图1-1) 2.1.2 Node.js官网下载并安装 如果没有安装环境，而直接前往node官网下载安装即可，推荐LTS版本，如图1-2所示，URL地址为：https://nodejs.org/en/ （图1-2） 图1-2仅作为参照使用，打开链接直接下载LTS版本即可。 注意：默认链接打开的是window(x64)，非64位的电脑，可以点击Other Downloads，下载对应的版本即可。 下载完成后，找到刚刚下载的Node.js安装包，一步一步的安装即可，安装完全时界面如图1-3所示。 （图1-3） 安装完成之后，可以按2.1小节介绍的方式，在命令行下输入 npm -h 检查一下安装状态。 2.2 安装TSC Node环境没问题后，就可以使用npm来安装TypeScript编译环境了。 2.2.1 命令行安装typescript 直接在命令行工具里输入指令“npm install -g typescript”，按回车键，如图2-1所示，即可开始下载并进行TypeScript环境的安装，此时一定要保持网络的畅通。 npm install -g typescript （图2-1） 开发者如果安装时遇到图2-2的情况，通常是缓存冲突导致。（没遇到的直接跳过本步骤。） （图2-2） 这时候，可以使用缓存清理命令 npm cache clean --force，回车执行该命令，重新输入安装指令即可。 npm cache clean --force [!Tip|label:Tips] 如果没有翻墙，npm可能会安装不太顺利，此时，建议执行npm cache clean --force 把npm缓存清掉。 然后使用cnpm来安装。 当我们看到 “All packages installed”这些字样的时候，可以确认完成了 TypeScript 环境的安装，如图2-3所示，关闭命令行工具即可。 （图2-3） 图3-1中tsc目录中就是我们TypeScript编译环境的安装目录，有了这个，LayaAirIDE里就能通过这个Compiler将TypeScript编译成为JavaScript。 2.2.2 检查TypeScript编译环境版本 在命令行输入“tsc -v” 命令可查看当前TypeScript编译的版本，如图2-4所示。 tsc -v （图2-4） 如果显示出版本号，说明TypeScript Compiler（tsc）安装成功。 三、安装浏览器 推荐采用Chromium内核的浏览器作为LayaAir运行与调试环境，例如windows自带的Edge浏览器或谷歌的chrome浏览器。 chrome官网下载地址： https://www.google.cn/intl/zh-CN/chrome/ 四、下载安装VSCode VSCode是一个应用广泛的编码工具，也是LayaAir引擎推荐的编码工具。 VSCode官网下载地址： https://code.visualstudio.com/Download Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-06-29 22:37:25 "},"basics/IDE/GUI/readme.html":{"url":"basics/IDE/GUI/readme.html","title":"IDE开发流程界面概述","keywords":"","body":"IDE开发工作流模块概述一、IDE帐号登录二、IDE首页2.1 项目列表2.2 导入项目2.3 创建项目2.4 开发者商城2.5 Web链接2.6 帐号设置三、编辑器初始界面3.1 层级管理面板3.2 工程管理面板3.3 UI布局小部件面板3.4 场景视窗3.5 预览窗口3.6 动画状态机面板3.7 项目设置面板3.8 控制台面板3.9 时间轴动画面板3.10 属性设置面板四、其它编辑面板4.1 预制体面板标签4.2 蓝图编辑面板五、项目预览与发布5.1 项目预览5.2 项目发布IDE开发工作流模块概述 Author：Charley && 诗换花 一、IDE帐号登录 LayaAir3.x由于在IDE内使用了资源商店，社区、IDE核心配置云存储等高度依赖网络的功能，因此必须要登录帐号才可以使用IDE。 帐号登录的方式有三种，中文版本帐号支持微信扫码登录与手机帐号登录。英文版本帐号支持邮箱注册登录。 登录界面如图1-1所示。 (图1-1) 公测前只支持微信登录。 二、IDE首页 登录之后的IDE首页，集合了帐号模块、项目列表、创建项目、删除项目引用、项目描述设置、资源商店、web链接（引擎动态、版本日志、开发者社区、引擎文档）等功能。 2.1 项目列表 登录之后的默认模块就是项目列表，此处是导入或创建的项目列表，点击鼠标选中的高亮区，即可打开项目，进入编辑器模式。 效果如图2-1所示。 (图2-1) 默认的项目排列顺序是依据编辑时间的由近到远，如果项目数量较多，也可以在搜索框内输入项目关键字找到对应的项目。 效果如图2-2所示。 (图2-2) 在项目列表单元的右侧菜单里，有着项目相关的设置功能，分别是：设置项目图标、设置项目描述、打开项目的目录、将该项目从列表出移除。效果如动图2-3所示。 (动图2-3) 2.2 导入项目 点击导入项目，可以将其它电脑中创建的3.x项目或被移除列表的项目，导入到项目列表中。操作如图2-4所示。 (图2-4) 2.3 创建项目 如果要创建一个新的项目，我们可以点击创建项目，如图3-1所示，创建一个新的项目。 （图3-1） 2.3.1 选择模板 在创建新项目的界面，我们有三种类型的模板供开发者选择，如图3-2所示。 (图3-2) 核心模板是指2D与3D的空项目模板，适合已经上手的开发者创建一个纯净的模板环境。 示例模板是功能相对简单和独立的功能模块示例，适用于针对具体某些功能进行理解。 学习模板是指模板里的项目功能相对完整与丰富，适合项目开发的入门学习借鉴。 2.3.2 项目名称 如图3-3所示。 (图3-3) 2.3.3 项目位置 如图3-4所示。 (图3-4) 2.3.4 创建项目 完成以上选项后，点击创建项目，如图3-5所示。即可完成项目的创建，进入IDE编辑界面。如图3-5所示。 (图3-5) 2.4 开发者商城 开发者商城正在建设中，稍晚推出。 2.5 Web链接 链接功能正在建设中，稍晚推出。 2.6 帐号设置 帐号设置功能，当前仅支持退出登录。其它功能正在建设中。如图4-6所示。 (图4-6) 三、编辑器初始界面 编辑器的初始界面，包括层级管理面板、工程管理项目、UI布局小部件面板、场景视窗、预览窗口、动画状态机面板、项目设置面板、控制台、时间轴动画面板、属性面板。 3.1 层级管理面板 层级管理面板，主要包括了2D节点与3D节点，如果是存粹的2D项目，也可以只包括2D节点。面板如图5-1所示。 (图5-1) 层级的关系就代表着父子节点的关系，子节点会受到父节点的影响，例如父节点改变了位置，或旋转了角度，子节点也会同步产生变化。 3D节点的根节点是Scene3D，2D节点的根节点是Scene2D。2D与3D节点之间不可以混合形成父子层级关系。 3.2 工程管理面板 工程管理面板里，包括了项目全部的资源与代码。资源位于assets目录，代码位于src目录。面板如图5-2所示。 (图5-2) 3.3 UI布局小部件面板 UI布局小部件面板，包括了2D基础显示对象、UI组件、骨骼节点三部分，用于UI的排版与布局。面板如图5-3所示。 (图5-3) 3.4 场景视窗 场景视窗是编辑2D场景与3D场景的地方，是开发者可视化编辑虚拟世界的窗口。面板如动图5-4所示。 （动图5-4） 3.5 预览窗口 预览窗口是通过开发者布局编辑与代码逻辑展示给用户的视觉效果预览窗口。面板如图5-5所示。 （图5-5） 3.6 动画状态机面板 动画状态机，是控制时间轴动画逻辑的工具，动画状态机面板包括动画图层与状态机相关的功能。面板如图5-6所示。 （图5-6） 3.7 项目设置面板 项目设置面板包括了屏幕适配设置、引擎初始化设置、项目启动设置等。面板如图5-7所示。 （图5-7） 3.8 控制台面板 控制台面板用来打印日志信息，可以复制和清空所打印的日志信息。面板如图5-8所示。 （图5-8） 3.9 时间轴动画面板 时间轴动画面板用于2D与3D动画的编辑，有两个模式，分别是关键帧模式和曲线模式。如图5-9所示。 （图5-9） 3.10 属性设置面板 属性面板就是用于设置对象或文件属性的地方， 例如，IDE层级面板中的2D与3D对象属性，资源文件的属性设置或预览查看。以及组件的添加。 对象属性设置，如图6-1所示： （图6-1） 资源属性设置，如图6-2所示： （图6-2） 代码预览，如图6-3所示： （图6-3） 添加组件（自定义的属性），如图6-4所示： （图6-4） 四、其它编辑面板 除了初始界面所显示的面板外，还有通过预制体文件打开的预制体面板标签，以及通过蓝图文件打开的蓝图编辑面板。 4.1 预制体面板标签 场景文件打开的标签，都是同一个。点击预制体文件，会形成独立的预制体面板标签。效果如动图7-1所示。 （动图7-1） 预制体面板标签，其实并没有专属于自己的独有面板。仅仅是层级管理面板的根节点与场景文件的根节点不同。 4.2 蓝图编辑面板 蓝图编辑面板可以不写代码就快捷的编写自定义的材质，大幅降低开发者的使用门槛。 打开Shader蓝图文件或Shader蓝图函数文件，即可进入蓝图编辑面板。如图动图7-2所示。 (动图7-2) 五、项目预览与发布 5.1 项目预览 项目预览用来查看项目在不同环境中的运行效果。 项目预览分为三种模式，分别是IDE内预览，浏览器预览，移动端预览。如图8所示。 （图8） 在开启IDE内预览后会出现两个按钮，分别是重新启动和打开开发者工具。 5.1.1 重新启动 重新启动顾名思义，对当前预览运行场景进行重启，如图8-1所示。 （图8-1） 5.1.2 打开开发者工具 点击打开开发者工具会调出Developer Tools，方便开发者进行调试，也可以通过 Ctrl + Alt + I 快捷键来打开开发者工具。 （图8-2） 5.2 项目发布 项目发布是将开发版本发布成为网页版本、小游戏版本、Naitve APP版本。 通过File菜单的Build调出发布界面，如图9所示。 （图9） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-08-18 17:02:53 "},"basics/essentialSkills/readme.html":{"url":"basics/essentialSkills/readme.html","title":"引擎学习必备技能","keywords":"","body":"引擎学习的必备技能《TS语言基础》《DevTools调试工具》《LayaTree调试工具》引擎学习的必备技能 LayaAir引擎面向有计算机语言基础的开发者，需要熟悉JavaScript语言、TypeScript语言。 日常开发，查BUG，需要熟悉调试工具DevTools等。 《TS语言基础》 《DevTools调试工具》 《LayaTree调试工具》 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"basics/language/readme.html":{"url":"basics/language/readme.html","title":"TS语言基础","keywords":"","body":"语言基础一、 JavaScript 基础教程二、 JavaScript ES6 教程三、 TypeScript 基础教程四、 TypeScript 进阶教程语言基础 LayaAir引擎支持开发者采用TypeScript语言开发项目，由于TypeScript语言是JavaScript语言带类型的超集，所以我们也要熟悉JavaScript语言的基础用法。 [!Note|label:建议：] 新手如果不是学生，没有大量充足的精力。 无需把语言全部都理解。掌握基础语法后即可学习引擎。 多看引擎示例源码，在理解引擎API的过程中，边用边学，遇到不理解的再进行查询即可。 一、 JavaScript 基础教程 《JavaScript 语言入门教程》：https://wangdoc.com/javascript/ 二、 JavaScript ES6 教程 《ES6 标准入门》：https://wangdoc.com/es6/ 三、 TypeScript 基础教程 《TypeScript中文手册》：https://www.tslang.cn/docs/ 四、 TypeScript 进阶教程 《深入理解 TypeScript》：https://jkchao.github.io/typescript-book-chinese/ Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"basics/DevTools/readme.html":{"url":"basics/DevTools/readme.html","title":"DevTools调试工具","keywords":"","body":"DevTools调试工具DevTools开发工具概述：调试 JavaScript 入门：DevTools调试工具 最常用的调试工具就是DevTools了，Chrome浏览器或者是基于Chromium内核的浏览器（例如Edge），都可以使用DevTools。 这个必须要掌握，否则遇到问题无法定位。 DevTools开发工具概述： https://learn.microsoft.com/zh-cn/microsoft-edge/devtools-guide-chromium/overview 调试 JavaScript 入门： https://learn.microsoft.com/zh-cn/microsoft-edge/devtools-guide-chromium/javascript/ 这里仅提供两个基础的文档入口，其实文档很全面，请自行根据文档的菜单列表查看学习。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:13 "},"basics/LayaTree/readme.html":{"url":"basics/LayaTree/readme.html","title":"LayaTree调试工具","keywords":"","body":"LayaTree调试工具一、LayaTree安装1.1 通过Chrome应用商店添加1.2 手动下载并安装二、LayaTree 使用2.1 使用的入口2.2 使用技巧三、工具服务LayaTree调试工具 Author：李尔 [!Note] LayaTree是LayaAir引擎开发者李尔专门为LayaAir引擎广大的开发者而设计的Chrome浏览器插件工具，该工具能在项目运行时阶段进行调试和修改。 一、LayaTree安装 1.1 通过Chrome应用商店添加 [!Tip|label:Tips] 通过Chrome应用商店添加需要科学上网(vpn翻墙) LayaTree已在chrome浏览器网上商店上架，搜索laya即可。如下图所示： 商店地址：https://chrome.google.com/webstore/ 也可以直接在Chrome里输入安装地址：https://chrome.google.com/webstore/detail/laya-tree/jnmdcbmpmfhnlchjdkcngihpjmgofajm?hl=zh-CN&authuser=0 如下图所示： 1.2 手动下载并安装 也可以通过作者提供的国内zip包地址（ v1.0.5）下载： LayaTree zip包：https://womenzhai.cn/LayaTree_V1.0.5.zip zip包安装方法 打开Chrome浏览器进入chrome://extensions/ 页面 打开开发者模式， 将解压后crx文件拖入该页面即可，安装成功后重启浏览器。 [!Tip|label:Tips] 需要注意的一点是: 如果需要调试的页面是文件网址，需要打开允许访问文件网址。否则无法识别当前laya引擎; 二、LayaTree 使用 2.1 使用的入口 在需要调试的项目页面(需未混淆代码)，打开开发者工具页面(F12或 Ctrl+Shift+I) 选择LayaTree页签，如下图所示 2.2 使用技巧 2.2.1 更新节点树列表的方式 LayaTree设计的本意是尽可能少的影响到游戏，做一个安安静静的的幕后操作者。所以不会去实时更新当前页面的节点树。 所以需要手动点击捕获刷新按钮来更新节点树列表。或者勾选自动刷新节点树的选项。如下图所示： 开启自动刷新节点树功能后，能够实时看到场景层级的变化，不需要手动捕获刷新，当场景层级非常多的时候会轻微影响到性能调试的准确性。如果在进行性能调优，建议不要开启（默认关闭）。日常调试开发未有影响。 2.2.2 运行时调整参数：操作Camera相机节点 示例：操作Camera相机节点,可以通过鼠标拖放或输入数值操作节点的位移,旋转和缩放。 通过便捷的下拉框切换相机的clearFlag.开启或关闭HDR. 此外相机的FOV,远近裁面和比例都可以快速的动态修改,极大的便利了镜头调整. 加入了正交相机开关orthographic。 2.2.3 运行时调整参数：设置点击事件与穿透控制 操作Sprite节点,除了常规节点的位移,旋转和缩放.还能够动态设置层级关系zOrder,锚点,尺寸 此外还有开发中经常需要用到的设置点击事件与穿透控制 2.2.4 运行时调整参数：文本内容直接编辑 操作文本节点,文本内容直接编辑 非常好用的基于拾色器的颜色调整​ 使用下拉框来选择文本的水平对齐和垂直对齐方式 字体大小,粗细,描边,overflow超出行为随意调节 2.2.5 基于AOP的暂停与单帧调试运行 基于AOP的暂停与单帧调试运行,能够在不修改源码的情况下控制引擎循环（需要注意的是，暂停时修改的属性需要下一帧才会更新渲染，所以修改数据时要点击单帧后查看） 支持TimeScale时间缩放,最高支持50倍速,尽享鬼畜与丝滑 2.2.6 cacheAs优化技巧 cacheAs为\"none\"，不做任何缓存.当值为\"bitmap\"时，webgl模式下显示对象使用renderTarget缓存成静态图像可以大幅提升渲染效率.但是额外创建的renderTarget对象，会增加内存开销.通过该选项可以便捷的切换模式,找到优化方向. 2.2.7 标记选中 增加标记选中功能,勾选后,选中2d节点时,会显示红框标记 三、工具服务 LayaTreeQQ群： 200482074 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-08-09 19:52:06 "},"basics/IDE/readme.html":{"url":"basics/IDE/readme.html","title":"IDE基础","keywords":"","body":"IDE基础IDE基础 LayaAir IDE的基础包括，对IDE各组成部分的基础认知，以及基础的交互操作。 通过该部分的文档，开发者将会对IDE有一个全局性的了解，掌握了基础的操作方式。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:14 "},"basics/IDE/layouts/readme.html":{"url":"basics/IDE/layouts/readme.html","title":"自定义界面布局","keywords":"","body":"自定义IDE界面布局一、调整为更方便资源预览二、调整为更方便层级展开三、调整为即时预览的方式自定义IDE界面布局 Author：Charley && 诗换花 LayaAir 3.0 IDE允许开发者按照自己的习惯或喜好，对各块功能进行任意布局排版。 一、调整为更方便资源预览 当我们创建一个空项目，例如3D空项目，界面布局如图1-1所示。 （图1-1） 默认的模式比较简洁，有的开发者也许对资源的预览要求更高一些，我们不妨调整为这样的效果，界面如图1-2所示。 (图1-2) 操作方式如动图1-3所示： （动图1-3） 二、调整为更方便层级展开 假如开发者的节点层级较多，并且需要展开查看的时候，纵向全屏查看，显然更加方便，效果如图2-1所示。 (图2-1) 操作方式如动图2-2所示： (动图2-2) 三、调整为即时预览的方式 有的时候，开发者还需要一边编辑场景（2D和3D），一边查看实时预览效果。那么我们可以将Game面板独立出来，效果如图3-1所示。 (图3-1) 操作方式如动图3-2所示： (动图3-2) [!Note] 以上三种方式，仅供参照，掌握好IDE面板的位置调整方式，就可以按自己的需求与喜好进行布局了~ Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:14 "},"basics/IDE/projecFolders/readme.html":{"url":"basics/IDE/projecFolders/readme.html","title":"项目工程目录说明","keywords":"","body":"项目工程目录说明一、目录构成概述1.1 工程文件1.2 ts编译配置文件二、日常开发的目录2.1 项目资源目录assets2.2 项目源码目录src三、其它目录3.1 vscode配置目录.vscode3.2 本地运行目录bin3.3 项目库目录engine项目工程目录说明 Author：Charley 一、目录构成概述 LayaAir IDE创建的项目工程，由五个可见目录与几个根目录的文件构成，效果如图1所示。 （图1） 1.1 工程文件 .laya 后缀的文件是LayaAir引擎项目工程文件，用于识别是否是LayaAir引擎项目，版本信息，以及不同名称的项目。 1.2 ts编译配置文件 由于LayaAir3.0项目只支持TS语言开发，所以也默认创建了一个tsconfig.json。 tsconfig.json是用来配置 TS 编译选项的，位于项目的根目录。 如果想了解该配置的详细信息，请直接前往TS语言的文档： https://www.tslang.cn/docs/handbook/tsconfig-json.html https://www.tslang.cn/docs/handbook/compiler-options.html 二、日常开发的目录 在LayaAir3.0的项目工程目录结构里，开发者真正需要关心的只有两个目录，项目资源目录assets与项目源码目录src。其它的目录，大家知道其作用即可。 2.1 项目资源目录assets assets目录是比较重要的项目目录，我们所有的场景与资源都在assets目录，IDE对项目资源的管理，都是来自于该目录。 效果如图2-1所示： （图2-1） 该目录与最终的发布有着密切的关联， 例如，场景Scene中在assets里引入的资源会自动复制到发布目录。 代码里引用的资源，必须放到resources目录里，才会被复制到发布目录里。 2.2 项目源码目录src src里源码目录，如图2-2所示。 (图2-2) [!Tip] 源码目录比较容易理解， 对于LayaAir1.0与2.0的用户，需要注意的是，Main.ts不再是入口，仅仅是默认创建的一个示例脚本。 入口是IDE里设置的启动场景，启动场景绑定的runtime类或脚本，会跟随启动场景运行，作为项目的入口。 三、其它目录 其它的目录，开发者知道其作用即可，日常开发中，开发者基本上不需要去处理。 3.1 vscode配置目录.vscode 由于LayaAir项目的推荐编码环境是vscode，所以在创建项目的时候，在.vscode里创建 了settings.json，如图3-1所示： （图3-1） settings.json里当前只配置了一些需要隐藏显示的文件，让项目看起来更“整洁”一些， .DS_Store是MacOS系统下产生的一些系统文件，所以没必要看到。 .meta是IDE用于识别与管理文件的文件，开发者也无需关注。 library、temp、local、settings这些目录，也是IDE仅供系统配置使用，不希望开发者修改，也给隐藏了起来。 3.2 本地运行目录bin bin目录内，开发者通常也不需要去管。在开发的过程中，assets目录作为资源使用的根目录即可。 bin目录内仅是测试运行的index.html首页的入口，以及IDE内置的代码入口。如图3-2所示： (图3-2) [!Tip] 开发者尽量不要去修改这里的入口，以及在bin目录下存放资源，这与LayaAir1.0与2.0有很大的不同。 3.3 项目库目录engine engine目录里存放的是引擎库的声明文件，如图3-3所示，通常不需要动。 （图3-3） 如果开发者有引用第三方的类库，也可以将声名文件放到这里。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2024-02-21 17:22:35 "},"basics/IDE/projectSettings/readme.html":{"url":"basics/IDE/projectSettings/readme.html","title":"项目设置详解","keywords":"","body":"项目设置详解一、运行设置1.1 分辨率设置1.2 引擎初始化设置1.3 项目启动设置1.4 调试启动设置二、编辑器设置2.1 3D预制体编辑场景2.2 资源导入时启用纹理压缩2.3 自动烘焙IBL2.4 预览服务器2.5 3D节点层级设置项目设置详解 Author：Charley、孟星煜 IDE的项目设置包括两个部分，运行设置与编辑器设置。 一、运行设置 1.1 分辨率设置 分辨率的设置会影响IDE内的预览效果，以及项目运行时的画布宽高、适配模式、对齐方式，画布背景色等。可设置属性如图1-1所示： （图1-1） 1.1.1 画面宽高适配 影响产品画面宽高的三个设置，分别是设计宽高（Design Width、Design Height），缩放适配模式(Scale Mode)。 设计宽高，就是我们在IDE里的设置并看到的宽高， 这个宽高会影响在IDE里的UI场景背景大小，以及IDE的预览运行模式下，也是基于这个宽高查看效果。 在实际的运行环境里，例如不同的手机。由于屏幕比例的不同，肯定不可能与设计宽高完全吻合。 所以，就需要用引擎自带的缩放适配模式，进行缩放，从而来满足开发者的屏幕需求。 缩放适配模式涉及画布、舞台、适配算法等诸多知识点，我们在另一篇文档《屏幕适配》里详细介绍。 1.1.2 横竖屏适配 有的时候，我们需要根据屏幕的比例强制横竖屏设置，在IDE中可以通过设置屏幕模式（Screen Mode）来设置。 横竖屏有三种适配模式，如图1-2所示。 （图1-2） 1，无变化：none none时，无论屏幕方向如何旋转，游戏的水平方向都不会产生跟随屏幕旋转的变化。 效果如动图1-3所示。 (动图1-3) 通过动图1-3发现，none值时，当屏幕发生旋转后，基于竖屏设计的界面在横屏下就会变的不适合，同理，基于横屏设计的界面在竖屏下，也会变的不适合。 当然，如果我们的布局策略运用的比较合理，也许也可以兼顾横竖屏的体验。效果如动图1-4所示。 (动图1-4) 虽然不那么难看了，但为了达到最佳的效果，最好的方案，还是竖屏始终与设备竖屏的方向保持一致，横屏与设备横屏的方向保持一致。 2，始终横屏：horizontal 当我们设置的宽高就是横屏产品时，horizontal无疑是最佳的体验，效果如动图1-5所示。 (动图1-5) 通过动图1-5发现，screenMode属性值设置为horizontal时，无论屏幕方向如何旋转，设计上的水平方向都会与屏幕最短的边始终保持垂直，所以用户设备竖屏时看到横屏画面，自然就会把设备横过来，从而吻合了产品的设计。 3，始终竖屏：vertical 当我们设置的宽高就是竖屏产品时，vertical无疑是最佳的体验，效果如动图1-6所示。 (动图1-6) 通过动图1-6发现，screenMode属性值设置为vertical时，无论屏幕方向如何旋转，游戏的水平方向都会与屏幕较长的边始终保持垂直。所以用户哪怕是把设备横屏了，仍然看到的是竖屏画面，自然就会把设备恢复竖屏，从而吻合了产品的设计。 [!Tip] 需要注意的是，浏览器中运行的时候，引擎的自动横屏和自动竖屏，只能对画布进行旋转，如果用户的手机锁屏了，虽然画面自动旋转过来了，但是浏览器没有旋转过来，会导致输入法依然按浏览器的方向弹出，此时，可能会导致输入法与浏览器的显示呈90度。 在小游戏平台中运行，由于小游戏底层有横屏还是竖屏的配置，不会出现这个问题。 1.1.3 画布对齐适配 引擎中的提供的alignV（垂直对齐）与alignH（水平对齐）是对画布进行对齐。设置方式如图1-7所示： （图1-7） 参数说明如下： AlignV垂直对齐的参数为：top（顶部对齐）、middle（垂直居中对齐）、bottom（底部对齐）。 AlignH水平对齐的参数为：left（居左对齐）、center（水平居中对齐）、right（居右对齐）。 [!Tip] 画布对齐不能理解为UI界面基于stage舞台的对齐，只是画布canvas相对于整个物理屏幕的对齐。 该设置在移动端，基本用不上，移动端绝大多数都需要全屏适配。当画布已经铺满整个屏幕时，设置就没有了意义。 通常是在PC端，非全屏的模式下使用，例如在画布非全屏适配的模式（showall和noscale）的情况下使用。 1.1.4 画布背景色设置 画布背景色，其实就是给画布设置一个颜色，默认值为#888888，如图1-8所示： （图1-8） 1.2 引擎初始化设置 有一些引擎的配置项，需要在引擎初始化的时候设置，而设置的入口就是如图1-9所示： （图1-9） 2D属性参数说明： 属性名称 属性说明 每秒帧数FPS 设备帧率；用于计算两帧之间的渲染最大间隔时长，通常设备上的帧率是最大60，也就是一秒钟内最多只有 60 帧会出现在屏幕上，那么两帧之间的时长为1000ms/60。对于高帧率设备，我们可以修改FPS值，例如120帧的设备，那两帧之间的时长则为1000ms/120。 画布抗锯齿 是否开启抗锯齿；用于设置webGL上下文的antialias抗锯齿开关属性，会产生额外的性能消耗，主要用于2D非矩形的矢量绘图抗锯齿，无矢量绘制图形或性能压力大时，可以选择不开启。3D抗锯齿推荐使用摄像机的Fxaa或Msaa。 视网膜画布模式 是否使用高清画布模式；开启后无论任何适配模式，画布均采用物理分辨率大小，开启后会比不采用物理分辨率多一些性能消耗，但会让文本等保持最佳清晰度。 画布透明 是否画布透明；默认状态画布有背景色，开启后，可以设置画布为无色透明。 顶点缓存优化 是否分配最大的VB缓冲区；开启后，渲染2D的时候，每次创建vb直接分配足够64k个顶点的缓存。这样可以提高效率。关闭后，可节省64k显存，但会牺牲性能效率，如果包含2D时，建议保持默认开启。 默认字体 文本的默认字体；设置以后，IDE中新建的文本默认字体都采用该处的设置。 默认字号 文本的默认字号；设置以后，IDE中新建的文本默认字号都采用该处的设置。 3D属性参数说明： 属性名称 属性说明 静态合批 是否启用静态合批；开启静态合批后，可以减少可见网格绘制调用之间渲染状态更改的次数。 动态合批 是否启用动态合批；开启动态合批后，满足 实例合并（同Mesh且同材质） ，即可减少RenderBatches渲染批次与Shader提交次数。 物理功能初始化内存 初始化3D设置时，默认物理功能初始化内存，单位为M。 开启UniformBuffer 启用Uniform Buffer；当启用Uniform Buffer缓存后，可以减少CUP传递至GPU的数据量。 分辨率倍数 设置3D的分辨率倍数，默认值为1 ；降低3D分辨率，不会影响2D UI的分辨率，适当的调节可降低性能的消耗。 多光源 是否开启多光源；如果不需要多光源，关闭后可减少性能的消耗。 最大光源数量 默认值为32个。 光照集群数量 x、y、z轴的光照集群数量；z值会决定Cluster受区域光（点光、聚光）影响的数量，Math.floor(2048 / lightClusterCount.z - 1) * 4 为每个Cluster的最大平均接受区域光数量,如果每个Cluster所接受光源影响的平均数量大于该值，则较远的Cluster会忽略其中多余的光照影响。 最大形变数量 网格渲染器的最大形变数量。默认值为32。 是否使用BVH裁剪 是否使用BVH裁剪；开启后，可以设置：一个BVH节点最大的cell数（超过这个数会分离—）、最大BVH节点的大小、最小cellbuild数（如果小于这个数，不会BVH构建）。 1.3 项目启动设置 1.3.1 入口启动场景 LayaAir 3.0项目运行入口的设置有两种方式，一种是将当前场景Current Scene（正编辑的场景）作为项目运行的入口，另一种是设置一个固定的项目入口场景。 当我们在构建发布里设置了启动场景，并且勾选了启动场景作为入口，如图1-10所示。在运行项目时，引擎初始化之后，就会先运行设置的启动场景。 （图1-10） 1.3.2 引擎库模块 LayaAir引擎由多个模块组件，默认只引入了较为基础的模块，如图1-11所示。 (图1-11) 如果应用到其它模块，需要勾选对应的模块，才可以使用其API，否则项目运行时会导致报错。 引擎库模块说明： 引擎库模块名 引擎库模块说明 laya.d3 3D基础模块，使用3D的必选库 laya.ui ui模块，包括常用的ui组件，使用2D UI组件的必选库 laya.ani 2D动画模块，包括2D节点动画（序列帧、图集动画）、内置的骨骼动画等 laya.device 陀螺仪、加速计、地理位置、摄像头、麦克风等设备接口调用封装 laya.tiledmap tiledmap地图接口封装 laya.particle 2D粒子的封装，不推荐使用 laya.gltf 代码直接使用gltf模型的加载解析库 laya.physics Box2D物理库的封装 laya.physics3D Bullet 3D物理库 laya.physics3D.wasm WebAssembly的Bullet 3D物理库 laya.spine spine动画引擎库 laya.workerloader WorkerLoader异步解码图片 1.3.3 启动页配置 启动页是指，在游戏开始前，显示的图标。如果不进行设置，则会使用引擎默认的图标。开发者可以自定义图标，如图1-12所示： （图1-12） 参数说明： 参数 说明 激活 勾选后，在游戏开始前，会显示启动页。 背景颜色 勾选后，可以设置启动页的背景颜色。 图片 启动页显示的图标，默认是引擎图标。自定义图标时，图片路径必须放在bin目录下。 适配 图标的屏幕适配。有center、fill、contain、cover四种模式。 最小显示时间 启动页的最小显示时间，单位为秒。 允许在预览中激活 勾选后，在预览模式下可以看到启动页。否则，只有在发布后才可以看到启动页。 1.4 调试启动设置 如图1-13所示，LayaAir IDE可以开启以下调试模块： （图1-13） 1.4.1 显示统计信息 勾选显示统计信息之后，可以查看当前帧率、内存占用、节点等信息，用于项目的分析与优化。如图1-14所示。 （图1-14） 如想了解更详细的统计信息面板上的参数，请查阅文档《性能统计与优化》 1.4.2 显示移动端调试工具 VConsole 在移动端调试，通常需要联到电脑端的浏览器上。 如果开发者不需要断点，只是一些常用的日志打印、加载等查看等，开启V Console，在移动端会出现如图1-15所示的调试工具面板。 （图1-15） 1.4.3 弹窗显示全局错误 如果捕获全局错误window.onerror，勾选弹窗显示全局错误可以弹窗抛出详细错误堆栈。例如，可以自定义一个全局错误，代码如下： //自定义一个全局错误 let err = new Error(\"自定义的Error\"); Laya.Browser.window.onerror(err.message, \"\", \"\", \"\", err); 运行时，就会弹窗抛出异常，效果如图1-16所示。 （图1-16） 1.4.4 显示2D物理调试 在LayaAir IDE中，如果给2D节点添加了物理属性（刚体、碰撞盒等），此时勾选显示2D物理调试，添加了物理属性的节点会显示出阴影效果，如动图1-17所示： （动图1-17） 二、编辑器设置 2.1 3D预制体编辑场景 默认情况下，3D预制体是位于一个专用的系统空场景（DefaultPrefabEditEnv）的环境下进行编辑。 如果我们通过3D预制体编辑场景，指定了一个目标场景，相当于直接位于某个3D场景中进行编辑，这样当切换到3D场景中，就会更加符合需求。操作如图2-1所示： （图2-1） 效果如图2-2所示： （图2-2） 2.2 资源导入时启用纹理压缩 勾选资源导入时启用纹理压缩后，当从外部导入纹理资源（PNG与JPG）到IDE时，如图2-3所示，会将该资源自动启动PC平台的纹理压缩，启用该操作后会增加运行效率，但会影响显示质量。 （图2-3） 该操作对启用该功能之前的旧资源不产生影响。 2.3 自动烘焙IBL 勾选自动烘焙IBL后，如图2-4所示，如果在Scene3D中更换了天空盒材质（Material由skybox更换为其它材质），此时Reflection Probe的IBL Tex无需手动点击烘焙按钮，保存场景后，IDE会自动进行重新烘焙。 （图2-4） 只有Reflection Probe的Source为Skybox时，才会自动烘焙。Custom无法自动烘焙。 2.4 预览服务器 预览服务器可以设置在浏览器中预览的地址和端口号。设置好后刷新IDE，即可应用，效果如图2-5所示。 （图2-5） 2.5 3D节点层级设置 3D节点，可以选择层级并设置，而编辑设置中，正是增加、删除层级，以及为层级命名的地方。效果如图2-6所示。 (图2-6) 关于层级Layer的更多介绍，可前往IDE文档《使用3D精灵》进行查看。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-08-08 19:48:07 "},"basics/IDE/entry/readme.html":{"url":"basics/IDE/entry/readme.html","title":"项目入口说明","keywords":"","body":"项目入口说明一、启动场景1.1 LayaAir2.0用户必看，入口变了1.2 设置启动场景1.3 项目入口之前的引擎配置项1.4 预览运行的入口设置二、入口的逻辑脚本2.1 自定义组件脚本的基础使用流程2.2 UI组件脚本三、自定义初始化项目入口说明 Author：Charley 、孟星煜 项目入口是在引擎初始化之后，项目首先要执行的地方。 对于大型项目通常是资源预加载与全局初始化的入口，无需预加载的微型产品，通常是主界面与全局入口逻辑。 一、启动场景 1.1 LayaAir2.0用户必看，入口变了 LayaAir2.x引擎中，是通过Main类来作为项目的入口类，所以一些引擎的初始化配置工作只能是在入口类中通过代码进行设置（如图1-1）。 （图1-1） 但是在LayaAir3.0中，为了简化开发者的理解与流程，项目的入口不再是以入口类的形式出现。项目的入口变为了启动场景。引擎的初始化配置工作仅需要在IDE里可视化的配置，即可完成。下文会详细介绍。 LayaAir2.0的老用户们，不要再找Main入口类了，已被干掉~ 1.2 设置启动场景 LayaAir 3.0引擎，只能在IDE里设置启动场景作为项目的入口。如果需要初始化引擎全局配置，直接在IDE的项目设置中配置。如果需要代码逻辑，直接为场景关联脚本，即可以执行代码逻辑。 本小节，我们先来介绍如何设置启动场景。 我们在文件导航菜单中打开 构建发布 面板。如图1-2所示， （图1-2） 构建发布面板的启动场景用于指定项目的启动场景，如图1-3所示。 （图1-3） 开发者可以在弹出的面板中，选择一个场景文件，指定为启动场景。操作如动图1-4所示， （动图1-4） 1.3 项目入口之前的引擎配置项 在执行项目入口之前，开发者也可以先配置一些引擎的初始化设置，如图1-5，我们打开项目设置面板，直接在引擎选项里进行配置即可。 （图1-5） 具体的参数设置说明，请查阅文档《项目设置详解》 。 1.4 预览运行的入口设置 启动场景在构建发布里进行线上版本的发布后，毫无疑问是作为项目的入口来率先加载与显示的。 但是在项目预览运行调试的时候，我们有的时候并不希望将启动场景优先显示，这会使得调试流程变的很长。 所以，点击图1-6红圈中的下拉箭头，可以通过点击勾选的方式，将启动场景或者当前场景作为预览运行的入口。 （图1-6） 当前场景是指，当前在IDE里正处于打开编辑状态的场景。 二、入口的逻辑脚本 虽然这个知识点并不属于项目入口的专属，但我们还是概要的讲一下流程。 首先，LayaAir3.0里并不建议开发者采用自定义的脚本作为项目的入口。所以从正常的流程上，代码的逻辑必须要跟随入口场景，通过入口场景激活与添加到舞台等引擎的生命周期方法来执行对应的逻辑。 对于场景的3D根节点Scene3D，可以绑定的脚本只有自定义的组件脚本。场景的2D根节点Scene2D，除了自定义的组件脚本还可以绑定UI组件脚本。 关于自定义的组件脚本与UI组件脚本区别与使用，请查阅相关文档，本篇仅介绍项目入口的核心流程。 自定义的组件脚本（装饰器暴露属性、事件方法、生命周期方法等）请参考《实体组件系统（ECS）》 UI组件脚本（关联UI组件、与自定义组件脚本的区别等）请参考《UI继承类》 2.1 自定义组件脚本的基础使用流程 自定义的组件脚本继承自Laya.Script类，定义了组件的事件方法和自身生命周期方法。 动图2-1演示了如何给Scene2D节点添加自定义的组件脚本。在属性设置面板中，点击增加组件->新建组件脚本，然后可以对要新建的脚本进行重命名（图中重命名为aaa），最后点击创建并添加即可创建脚本。 （动图2-1） 按以上动图添加的自定义组件脚本aaa.ts，生成了名称为aaa的脚本模板类，如图2-2，直接在该脚本中编写代码即可。 （图2-2） [!Tip] 具体的组件脚本使用文档请参考《实体组件系统（ECS）》 2.2 UI组件脚本 除了自定义的组件脚本以外，也可以使用UI组件脚本作为项目入口的逻辑代码。 UI组件主要是用于2D场景中，需要管理的节点比较多的时候，以及需要在打开场景的时候需要为场景传递参数（例如弹窗的动态提示等）的应用场景。 UI组件可以独立使用，也可以与组件脚本同时使用。 UI组件脚本需要在UI运行时（Runtime）属性入口进行添加，如图2-3所示。并且，只有在场景的Scene2D节点或2D预制体的属性设置面板中 （图2-3） 2D预制体只要是根节点都有UI运行时（Runtime）这个属性。 下面以Scene2D节点为例，介绍创建UI组件脚本的方式。在UI运行时属性输入框进行鼠标双击操作，IDE会弹窗提示创建UI组件脚本文件，默认是RuntimeScript.ts，开发者可以对其进行重命名，例如动图2-5所示的bbb，点击保存即可创建脚本。 （动图2-5） 建议先学习完自定义的组件脚本及其使用，再学习UI组件脚本的相关内容。 三、自定义初始化 由于之前的流程，是先初始化引擎，然后再加载与启动入口场景。但是在某些特殊的情况下，开发者可能需要在引擎初始化之前执行一些逻辑，例如需要提前判断不同的运行环境等。 那我们也提供了自定义的代码流程，通过Laya.LayaEnv.beforeInit定义引擎初始化之前要执行的逻辑，通过Laya.LayaEnv.afterInit定义引擎初始化之后要执行的逻辑。 例如，在开发者创建项目时会自动生成一个Main.ts，加入下面的代码： Laya.LayaEnv.beforeInit = function(config: Laya.IStageConfig) { //这个方法会在Laya.init前调用 console.log(\"before init\"); //这里可以对config以及Laya.Config、Laya.Config3D进行自定义的修改 } Laya.LayaEnv.afterInit = function() { //这个方法会在Laya.init后调用 console.log(\"after init\"); } const { regClass, property } = Laya; @regClass() export class Main extends Laya.Script { onStart() { console.log(\"Game start\"); } } 要注意的是，需保证这些代码所在的脚本文件是被场景中引用的，否则在发布版本时被消除项目中未使用的代码，那就无效了。 注意：如果没有特殊需求，不推荐使用本小节方法进行游戏初始化。开发者应使用为场景挂载组件脚本的方式。 运行可以看到，输出结果如图3-1所示： （图3-1） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-05-08 10:34:15 "},"basics/IDE/importJsLibrary/readme.html":{"url":"basics/IDE/importJsLibrary/readme.html","title":"引用第三方JS模块","keywords":"","body":"引用第三方JS模块一、使用命令引入第三方模块1.1 支持方式1.2 使用示例二、LayaAir IDE中使用第三方JS文件2.1 支持方式2.2 使用示例引用第三方JS模块 AStar寻路算法是本节举例中用到的内容，所以写在前面，大致介绍一下。在LayaAir3.0引擎的2D入门示例中，如图1所示， （图1） 其中有一个2D的A*寻路的示例，开发者可以先通过此示例来了解2D项目中是怎么使用的，如动图2所示， （动图2） A*算法的工作原理在这里就不做介绍了，开发者可以从网上搜索算法的具体实现方式。简单来说，它是一种很常用的路径查找和图形遍历算法。它有较好的性能和准确度。 一、使用命令引入第三方模块 1.1 支持方式 在开发过程中，如果需要使用一些第三方库，推荐的解决方法是使用JS的模块功能。 步骤如下： 在项目文件夹执行 npm init 初始化项目。 使用npm install xxx --save 安装xxx包。 然后在代码中使用import语句导入即可。 1.2 使用示例 我们用第三方AStar模块来讲解： 1.2.1 npm init 在开发中使用npm init会生成一个pakeage.json文件，这个文件主要是用来记录这个项目的详细信息的，它会将我们在项目开发中所要用到的包，以及项目的详细信息等记录在这个项目中。 执行npm init是需要在DOS窗口执行的，我们可以windows+r键来打开窗口，然后输入CMD执行，然后就可以打开DOS窗口了。打开窗口之后，在DOS窗口中进入自己项目所在的目录。进入到项目所在的目录之后我们就可以直接执行npm init，执行了npm init之后，会让我们填写一些配置信息，如果还不知道怎么填写的话可以一路回车。 package name：项目名字； version： 版本号； description： 对项目的描述； entry point： 项目的入口文件； test command：项目启动的时候要用什么命令来执行脚本文件； git repository：如果要将项目上传到git中的话，那么就需要填写git的仓库地址（这里就不写地址了）； keywirds： 项目关键字（这里就不写了）； author：作者的名字（这里就不写了）； license：发行项目需要的证书（这里就不写了）； 如图1-1所示， （图1-1） 1.2.2 npm install xxx --save 以npm安装AStar为例，如图1-2所示， （图1-2） 会把astar包安装到node_modules目录中，并且会在package.json的dependencies属性下添加astar。 看一下package.json里的内容： { \"name\": \"test\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"bin\": { \"test\": \"bin/bundle.js\" }, \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": { \"astar-typescript\": \"^1.2.5\" } } 接下来在我们的代码中可以使用 import AstarFinder 了，示例代码如下： import { AStarFinder } from \"../node_modules/astar-typescript/dist/astar\"; const { regClass, property } = Laya; @regClass() export class Main extends Laya.Script { private aStarInstance: AStarFinder; onStart() { console.log(\"Game start\"); // 0表示通路，1表示障碍 let myMatrix = [ [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 1, 0, 1, 1, 0], [0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 1, 0], [1, 1, 1, 0, 1, 0, 1, 0], [0, 0, 0, 0, 1, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0] ]; this.aStarInstance = new AStarFinder({ grid: { // 列主序矩阵 matrix: myMatrix } }); let startPos = { x: 0, y: 0 }; let goalPos = { x: 7, y: 7 }; let myPathway = this.aStarInstance.findPath(startPos, goalPos); console.log(myPathway); } } 通过在IDE中运行此脚本，可以获得从 0,0 点到 7,7 点的最短路线，如图1-3所示 （图1-3） 到此为止，第三方模块已经成功导入到项目中了，在IDE中会自动加载，预览和运行都能正常使用。通过开发者工具调试可以看到，引入的AStarFinder类已经成功的集成到发布的代码中了，如图1-4所示 （图1-4） 二、LayaAir IDE中使用第三方JS文件 在某些特殊情况下，如果需要直接使用一些第三方的JS文件，IDE也提供了单独导入的功能。 2.1 支持方式 首先将JS文件放置到项目的assets文件夹或src文件夹下： 导入为插件 在属性设置里勾选“导入为插件”。如动图2-1所示， （动图2-1） 勾选后，默认勾选了允许运行时加载和自动加载，即这个脚本会在运行时自动加载。 允许编辑器加载 如果勾选“允许编辑器加载”，则脚本在编辑器环境也会载入。 注意，JS脚本不要出现对全局环境的修改，否则影响编辑器稳定。另外，JS脚本一旦载入，没有卸载和刷新功能，如果修改了JS文件，需要刷新编辑器才生效。如果不勾选，这个脚本会在预览、运行或者发布中才会载入。 允许发布时压缩 勾选“允许发布时压缩”，构建发布时，若设置了“压缩JS文件”，则此脚本会被压缩。 依赖其它 “依赖其它”可以设置多个脚本，这些脚本将会安排优先载入。 2.2 使用示例 在2D入门示例中，如果在没有导入astar.js的情况下，运行“进阶使用”下的“A*寻路”，点击任何区域，人物没有任何移动，如图2-2所示 （图2-2） 由于IDE本身不支持Astar的类库，同时也没有导入Astar类库，运行时会报错，如图2-3所示 （图2-3） 因此，我们需要引入Astar.js来支持A*算法，从 https://github.com/bgrins/javascript-astar 官网下载 astar.js 将 astar.js 放入 assets 目录下，或者 src 目录下，这里以 assets 为例，如图2-4所示 （图2-4） 点击 astar.js ，在属性面板中，勾选“导入为插件”，并点击“应用”，如图2-5所示 （图2-5） 此时，astar.js 已作为插件导入IDE中，在预览运行、发布中会自动载入。 再次运行2D示例查看A*寻路示例，如动图2-6所示 （动图2-6） 运行正常了，接下来我们测试一下发布，如图2-7所示，在发布后的web目录下，astar.js 已经发布到js目录下， （图2-7） 并在release\\web\\index.html中被引入，如图2-8所示， （图2-8） 运行发布后的项目，A*寻路依然正常运行。开发者还可以对“允许编辑器加载”和“依赖其它”进行使用。 运行发布后的项目参考《Web发布》。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-08-13 11:19:45 "},"basics/IDE/Hierarchy/readme.html":{"url":"basics/IDE/Hierarchy/readme.html","title":"层级面板说明","keywords":"","body":"层级面板说明一、层级面板的作用二、层级面板的通用操作2.1 创建节点2.2 搜索节点2.3 隐藏节点2.4 锁定节点2.5 节点的收缩与展开2.6 节点排序2.7 右键菜单的通用功能2.8 节点树三、3D场景节点操作3.1 3D场景根节点的删除与创建3.2 3D基础节点3.3 创建3D渲染节点四、2D场景节点操作4.1 2D基础节点4.2 UI节点4.3 骨骼节点层级面板说明 一、层级面板的作用 层级管理面板，提供了节点的可视化操作，方便节点之间的管理。主要包括了2D节点与3D节点，如果是纯粹的2D项目，也可以只包括2D节点。面板如图1-1所示。 （图1-1） 层级的关系就代表着父子节点的关系，子节点会受到父节点的影响，例如父节点改变了位置，或旋转了角度，子节点也会同步产生变化。 3D节点的根节点是Scene3D，2D节点的根节点是Scene2D。2D与3D节点之间不可以混合形成父子层级关系。 二、层级面板的通用操作 2.1 创建节点 可以创建的3D节点有： Sprite3D（这是一个空节点）； 基础3D节点（Cube、Sphere、Cylinder、Capsule、Cone、Plane）； 特效（Particle3D、PixelLine、Trail）； 灯光（DirectionLight、PointLight、SpotLight、AreaLight）； 相机。 可以创建的2D节点有： 基础2D节点（Sprite、Animation、Text、SoundNode、VideoNode）； UI组件（Box、HBox、VBox、Image、Clip、Button、CheckBox、Radio、RadioGroup、ComboBox、Label、TextInput、TextArea、FontClip、ProgressBar、HSilder、VSlider、List、Panel、Tree、Tab、ViewStack、HScrollBar、VScrollBar、ColorPicker、View、Dialog、OpenDataContextView）； 2D骨骼动画（Spine、Skeleton）。 以上列出了可以创建的节点类型，下面就来介绍创建节点的方式，主要有两种：一种是创建的无父级关系的单独节点，即3D节点在Scene3D下，2D节点在Scene2D下；另一种是创建在某个节点下，作为其子节点。 如图1-1中的Sprite就是单独节点，Sphere是Cube的子节点。 2.2.1 单独节点 如果不选中某个确定的节点，如动图2-1所示，假设选中了，可以点击空白处取消选中，这时点击+可以创建节点，这时创建的节点是单独的节点。 （动图2-1） 如动图2-2所示，不选中节点时，空白处单击右键进行创建，此时创建的也是一个单独节点。 （动图2-2） 细心的开发者可能会发现，创建的菜单栏中有两个地方可以创建Sprite，如图2-3所示，一种是直接选择创建Sprite，一种是在2D节点->Sprite下进行创建。这两种方式创建的Sprite是一样的，方式1是为了操作的方便，方式2是因为Sprite作为基础的显示精灵，在分类上属于基础的2D节点。 （图2-3） 注：创建空节点的快捷键可参考文档《IDE快捷键与鼠标交互操作大全》1.3.1节。 2.2.2 父子节点 如动图2-4所示，如果选中某个节点进行创建，不论是点击+创建，还是右键进行创建，都是创建选中节点的子节点。 （动图2-4） 2.2 搜索节点 在搜索栏中，可以根据节点名称，搜索已经创建的节点，如下动图所示，搜索Sphere节点： （动图2-5） 还可以结合项目资源面板，比如，项目资源面板中有一个图片LayaAir.png，将场景中Image组件的皮肤设置为这张图片，这时，可以右键此图片，选择在场景中查找引用，如动图2-6所示，这样就可以搜索到引用此资源的组件了。 （动图2-6) 2.3 隐藏节点 按动图2-7所示，可以隐藏节点，但是，此时的隐藏效果仅仅是在场景面板中，预览运行时该节点仍然存在。 （动图2-7） 如果是父子节点，隐藏子节点，则仅仅隐藏节点本身，如果隐藏父节点，则子节点跟着也会被隐藏，效果如动图2-8所示。 （动图2-8） 2.4 锁定节点 按动图2-9所示，可以锁定节点，锁定节点后，该节点在场景面板中，不会被操作。例如，动图中在锁定前可以选中Cube进行移动，但是锁定后就无法选中Cube了。 （动图2-9） 如果是父子节点，如动图2-10所示，锁定子节点，不会影响父节点。如果锁定父节点，则子节点也会跟着锁定。 （动图2-10） 这里需要注意，锁定节点，仅仅是让鼠标无法在场景面板中选中它，在属性设置面板中仍然可以对其进行操作。该功能常用于背景图片，将背景图设置好后，为了防止误选，可以先将背景图锁定。 2.5 节点的收缩与展开 IDE提供了一个全部收缩按钮，如动图2-11所示，点击后可以收缩全部子节点。 （动图2-11） 注：展开全部子节点的快捷键可参考文档《IDE快捷键与鼠标交互操作大全》1.3.2节。 2.6 节点排序 3D节点在三维坐标系中，它们的遮挡关系与它们的坐标以及相机的位置有关。但对于2D节点来说，如果按顺序添加，在层级面板中会逐个向下增加，如动图2-12所示，则先添加的会被后添加的覆盖掉。此时，如果想修改它们的遮挡关系，可以更改ZOrder属性。 （动图2-12） 当然，除了修改ZOrder属性，还可以通过拖拽目标节点来改变遮挡关系，主要有以下三种： 拖拽为目标节点的下级节点； 拖拽为目标节点的同级之后； 拖拽为目标节点的同级之前。 注：拖拽目标节点的操作演示可参考文档《IDE快捷键与鼠标交互操作大全》1.3.3节。 2.7 右键菜单的通用功能 右键菜单除了2.1中创建节点的功能外，还有一些通用功能： 复制、粘贴：如动图2-13所示，选中节点进行复制（也可以选中多个节点），然后进行粘贴，粘贴后如果有重名节点，IDE会自动进行重命名。 （动图2-13） 2D节点只能粘贴到Scene2D下，3D节点只能粘贴到Scene3D下。 重命名：如动图2-14所示，可以对选中节点进行重命名。 （动图2-14） 生成副本：如动图2-15所示，可以将选中节点生成一个副本，它保留了原节点的属性（位置、大小、特有属性等）。 （动图2-15） 删除：如动图2-16所示，可以删除选中节点，删除父节点，子节点会跟着被删除。 （动图2-16） 注：以上操作的快捷键可参考文档《IDE快捷键与鼠标交互操作大全》1.2节。 2.8 节点树 在运行时，层级面板会显示运行状态的节点树。如动图2-17所示，切换到哪个场景，就显示哪个场景的节点树。 （动图2-17） 动图中的示例为“2D入门示例”。 三、3D场景节点操作 3.1 3D场景根节点的删除与创建 在本篇的开始提到，如果是纯粹的2D项目，可以只包括2D节点。也就是说，可以将3D节点删除，包括3D的根节点Scene3D。如动图3-1所示，就是删除根节点Scene3D。删除后就是一个纯粹的2D场景了。 （动图3-1） 如果创建了一个纯2D项目，想增加3D场景，那么只需要添加需要的3D节点即可，如动图3-2所示，这时会自动创建该节点到Scene3D下。 （动图3-2） 3.2 3D基础节点 在2.1节中已经列出了可以创建的3D节点，本节就来概述说明一下它们的作用，并给出节点对应的文档详解链接。 Sprite3D 这是一个空节点，是最基础的3D节点，包含很多3D精灵基本的功能属性。创建后，可以对其赋予Mesh等属性，使其显示效果。详细的用途和使用方法参考文档《使用3D精灵》。 基础3D节点 包含：Cube、Sphere、Cylinder、Capsule、Cone、Plane。它们是3D基础的显示对象，可以作为3D开发中的辅助工具，例如，初学者用来快速学习3D开发流程、熟练的开发者进行模拟和测试。详细的使用方法请参考文档《3D基础显示对象》。 特效 特效相关的节点有：Particle3D、PixelLine、Trail； Particle3D是3D粒子系统，可以用于模拟烟、雾、水、火、雨、雪、流光等非固定形态的自然现象。详细的做法请参考文档《3D粒子编辑模块》。 PixelLine是像素线，是通过渲染一组带有颜色的线，来绘制3D精灵。详细的介绍请参考文档《像素线》。 Trail是拖尾，拖尾渲染器可以制作物体后面的拖尾效果，比如子弹划过产生的空气柱。详细的内容请参考文档《拖尾》。 灯光 灯光节点总共有四种，分别是DirectionLight（平行光）、PointLight（点光源）、SpotLight（聚光灯）、AreaLight（区域光）。它们决定了环境的颜色和氛围，不同光源会呈现不同的效果。详细的设置方法请参考文档《3D灯光与阴影》。 相机 相机节点相当于眼睛，一切景象都是通过它来渲染。详细的描述请参考文档《使用3D摄像机》。 3.3 创建3D渲染节点 渲染节点是指需要进行渲染的节点，例如MeshSprite3D（静态网格精灵）、SkinnedMeshSprite3D（蒙皮动画网格精灵）等。如图3-3所示，直接从资源面板拖拽到层级面板即可。 （图3-3） 四、2D场景节点操作 在2.1节中已经列出了可以创建的2D节点，本节就来概述说明一下它们的作用，并给出节点对应的文档详解链接。开发者需要注意，Scene2D节点与Scene3D节点不同，它不可以被删除。 4.1 2D基础节点 Sprite是2D精灵，是在屏幕中能够被控制的显示对象。 Animation是节点动画，可以方便的创建图集动画、多帧动画。 Text是静态文本的基础组件。 SoundNode是播放声音的组件。 VideoNode是显示视频的组件。 4.2 UI节点 Box是容器组件的基类，用于装载其它显示对象的组件。 HBox是常用于水平布局的容器组件。 VBox是常用于垂直布局的容器组件。 Image是UI里最常见的显示图像的组件，用来显示位图图像。 Clip组件可用于显示位图切片动画。 Button是按钮组件，可以显示文本标签、图标或者两者同时显示。 CheckBox是多选框组件。 Radio是一个单选框组件。 RadioGroup是单选框按钮组。 ComboBox是一个下拉列表选项框组件。 Label用来显示一段文字。 TextInput是文本输入框，任何需要输入的时候可以使用它。 TextArea是文本域，继承于TextInput。 FontClip对位图从方向上进行等比切割。 ProgressBar用于显示进度。 HSilder是横向滑动条，可以通过在滑块轨道之间移动滑块来选择值。 VSlider是纵向滑动条。 List可显示项目列表。 Panel是一个带有裁剪功能的面板容器类，常用来设置元素的显示区域。 Tree组件用来显示树状结构。 Tab组件用于定义选项卡按钮组。 ViewStack主要用于多页面视图切换。 HScrollBar是一个水平方向滚动条组件 VScrollBar是一个垂直方向滚动条组件。 ColorPicker显示包含多个颜色样本的列表。 Dialog主要用于弹窗面板。 OpenDataContextView是开放数据域要用到的组件。 4.3 骨骼节点 Spine通过将图片绑定到骨骼上，然后再控制骨骼实现动画。 Skeleton可以将一些经常使用的骨骼动画格式转换为LayaAir引擎支持的骨骼动画格式。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-08-02 19:25:47 "},"basics/IDE/assets/readme.html":{"url":"basics/IDE/assets/readme.html","title":"项目资源面板说明","keywords":"","body":"项目资源面板说明一、资源目录1.1 项目资源目录assets1.2 项目源码目录src1.3 右键菜单1.4 2D图片编辑成精灵纹理二、快速创建文件2.1 创建文件夹2.2 创建预制体2.2.1 预制体2D2.2.2 预制体3D2.3 创建场景（scene）2.4 创建着色器2.4.1 着色器2.4.2 着色器蓝图2.4.3 着色器蓝图函数2.5 创建材质及配置2.5.1 材质文件2.5.2 立方体纹理2.5.3 渲染纹理2.5.4 动画遮罩2.6 创建图片类型2.6.1 光照贴图烘焙设置2.6.2 自动图集设置2.7 创建动画状态机2.7.1 2D动画状态机2.7.2 3D动画状态机三、搜索面板3.1 文字搜索3.2 类型搜索四、目录设置面板4.1 两栏显示4.2 全部折叠项目资源面板说明 一、资源目录 LayaAir IDE打开项目工程后，由五个部分构成，效果如图1-1所示 （图1-1） 项目资源目录 项目源码目录 +快捷创建 搜索面板 目录设置按钮 首先我们可以简单了解一下项目资源目录和项目源码目录，然后会对其它三个功能做详解介绍 1.1 项目资源目录assets assets目录是比较重要的项目目录，我们所有的场景与资源都在assets目录，IDE对项目资源的管理，都是来自于该目录。 效果如图1-2所示： （图1-2） 该目录与最终的发布有着密切的关联， 例如，场景Scene中在assets里引入的资源会自动复制到发布目录。 代码里引用的资源，必须放到resources目录里，才会被复制到发布目录里。 1.2 项目源码目录src src里源码目录，如图1-3所示。 (图1-3) 源码目录比较容易理解，通常在安装了代码编辑器后，可以双击源码来打开代码编辑器 1.3 右键菜单 通过鼠标右键任何目录或者文件，可以打开菜单，如图1-4所示 (图1-4) 通过点击“创建”，动图1-5中在assets目录下创建了一个“光照贴图烘焙设置”文件 （动图1-5） 在第二节，我们会对菜单中可以创建的类型进行讲解，下面先介绍其它选项： 在文件管理器中打开：可以快速打开文件管理器查看文件。 在场景中查找引用：可以搜索到引用此资源的组件，可以查看文档《层级面板说明》的2.2节。 重命名、删除、复制、粘贴：对文件的基本操作，不再赘述。 生成副本：可以生成一个副本，它保留了原文件的属性。 重新导入：通常用于导入失败，或者有些外部依赖更改了，比如模型里有个材质，材质引用了外部贴图，但一开始贴图没放进来，后来放进来了，可以使用此功能。 在代码编辑器中打开项目：可以直接打开代码编辑器查看文件信息。 1.4 2D图片编辑成精灵纹理 2D图片资源，assets目录下，默认会作为3D模型的纹理格式，在2D界面开发中，通常要改为2D的图片格式，需要开发者自行编辑。 如图1-6所示，这是一张有透明通道的png图片 （图1-6） 点击图片，看下属性设置，如图1-7所示 （图1-7） 默认值：默认情况下，图片作为3D模型的Texture贴图文件，只能用在材质球上。 精灵纹理：图片作为2D的Sprite对象的图片纹理格式，通常在2D开发中使用。此属性在图片资源按照官方的命名规则去命名的时候自动为精灵纹理，否则就是默认值，会导致资源显示异常。 在不改变图片类型的情况下，将这张图作为2D图片在Image组件中使用并运行，页面背景是蓝色，如图1-8所示 （图1-8） 可以看到图中绿色区域有白色毛边，因此需要更改设置，如图1-9所示 （图1-9） 再看看运行效果，如图1-10所示 （图1-10） 图片还有一些其它属性设置： 平铺模式：选择纹理平铺时的方式，默认选项为重复。 过滤模式：选择纹理在通过3D变换拉伸时如何进行过滤，默认是双线性过滤。 纹理翻转：翻转图片。 纹理旋转：旋转图片。 非2次幂缩放：纹理不是2次幂时，缩放至2次幂的操作模式。 可读写：开启后，可以用脚本动态读取纹理像素。 皮肤相关设置： 九宫格：九宫格信息。 按钮皮肤状态：按钮皮肤的状态数。 纹理格式请参考文档《纹理压缩》。 二、快速创建文件 快速创建文件有两种快速方式 点击 + 快速创建 点击空白处快速创建 1，快速创建是方便开发者可以快速创建特殊类型文件的方式，如动图2-1所示 （动图2-1） 2，点击项目资源面板中的空白处，选择创建，也可以做到快速创建，如动图2-2所示 （动图2-2） 3，这里快速创建的文件只会在assets目录下，如果想放到某个目录中，可以拖住文件放入，如动图2-3所示 （动图2-3） 2.1 创建文件夹 如图2-3所示，在快速创建菜单中，点击“文件夹”会在assets下创建一个文件夹，并可以修改文件夹名字 （图2-3） 2.2 创建预制体 在快速创建菜单中，点击“预制体2D”和“预制体3D”会创建预制体文件 2.2.1 预制体2D 如图2-4所示，创建预制体2D后，点击后打开，预制体只有一个Box根节点，用于2D开发 （图2-4） 同时，我们也可以更改Box组件为Dialog组件，如动图2-5所示 （动图2-5） Dialog是弹窗面板，可以通过设置来实现弹窗效果 2.2.2 预制体3D 如图2-6所示，创建预制体3D后，点击后打开，预制体只包括Sprite3D对象，用于3D对象开发 （图2-6） 通常3D预制体用来创建可以重复使用的3D节点对象，比如场景中的主角，敌人等等 2.3 创建场景（scene） 如图2-7所示，在快速创建菜单中，点击“scene”会在assets下快速创建一个场景 （图2-7） 2.4 创建着色器 2.4.1 着色器 如图2-8所示，在快速创建菜单中，点击“着色器”会选择创建五种类型的shader文件 （图2-8） 通过创建shader，开发者可以对shader进行修改成自定义的shader使用，如图2-9所示 （图2-9） 2.4.2 着色器蓝图 如图2-10所示，在快速创建菜单中，点击“着色器蓝图”会在assets下快速创建一个着色器蓝图文件 （图2-10） 双击蓝图文件，可以通过可视化窗口来编辑 （图2-11） 2.4.3 着色器蓝图函数 如图2-12所示，在快速创建菜单中，点击“着色器蓝图函数”会在assets下快速创建一个着色器蓝图函数文件 （图2-12） 双击蓝图函数文件，可以通过可视化窗口来编辑 （图2-13） 2.5 创建材质及配置 2.5.1 材质文件 如图2-14所示，在快速创建菜单中，点击“Material”会选择创建八种类型的材质文件 （图2-14） 通过创建Material，开发者可以对材质进行修改，方便快速使用 2.5.2 立方体纹理 如图2-15所示，在快速创建菜单中，点击“TextureCube”会在assets下快速创建一个TextureCube文件 （图2-15） 点击Cubemap文件，可以配置 （图2-16） 通常Cubemap文件，用于配置天空盒的贴图，如图2-17所示 （图2-17） 具体如何使用TextureCube，开发者请参考《3D场景环境设置》中的天空盒的详细讲解。 2.5.3 渲染纹理 如图2-18所示，在快速创建菜单中，点击“RenderTexture”会在assets下快速创建一个RenderTexture文件 （图2-18） RenderTexture渲染纹理，用于将3D场景渲染到2D纹理中，混合2D开发使用，如动图2-19所示 （图2-19） 具体如何使用RenderTexture，开发者请参考《混合使用3D》中的详细讲解 2.5.4 动画遮罩 如图2-20所示，在快速创建菜单中，点击“AvatarMask”会创建AvatarMask文件 （图2-20） 通过创建AvatarMask，开发者可以用来描述动画层遮罩，详细内容参考《动画状态机详解》3.5.1节。 2.6 创建图片类型 2.6.1 光照贴图烘焙设置 如图2-21所示，在快速创建菜单中，点击“光照贴图烘焙设置”会创建LightingSettings文件 （图2-21） 通过创建LightingSettings，开发者可以设置光照属性，用来烘焙光照贴图 （图2-22） 具体如何使用灯光设置，开发者请参考《3D场景环境设置》中关于烘焙光照贴图的详细讲解 2.6.2 自动图集设置 如图2-23所示，在快速创建菜单中，点击“自动图集设置”会创建AtlasConfig文件 （图2-23） 通过创建AtlasConfig，开发者可以用来自动打包图集 具体如何使用自动打包图集，开发者请参考《Web发布》中关于图集打包的详细讲解 2.7 创建动画状态机 在快速创建菜单中，点击“动画状态机2D”和“动画状态机3D”会创建动画状态机。 2.7.1 2D动画状态机 如图2-24所示，创建动画状态机2D后，点击后打开 （图2-24） 2.7.2 3D动画状态机 如图2-25所示，创建动画状态机3D后，点击后打开 （图2-25） 动画状态机定义动画状态，以及动画状态之间的切换条件，来驱动对象播放不同的动画，表现出不同的行为。 具体如何使用动画状态机，开发者请参考《动画状态机详解》中的详细讲解 三、搜索面板 由于assets下资源会很多，通常最常用的方式是通过搜索查找 3.1 文字搜索 通过在搜索框中，输入“button”可以快速检索出Button组件，并可快速拖入2D场景中，如动图3-1所示 （动图3-1） 3.2 类型搜索 通过点击类型搜索按钮，选择文件类型，比如选择“LightingSettings”，可以快速检索出所有灯光设置文件，如动图3-2所示 （动图3-2） 四、目录设置面板 4.1 两栏显示 在开发过程中，往往在目录中的文件太多，对目录的反复浏览会比较繁琐，通过点击“两栏显示”按钮，可以解决，如图4-1所示 （动图4-1） 4.2 全部折叠 如果打开的目录太多，开发者可以通过点击“全部折叠”来关闭所有的目录，恢复到只有assets和src目录，如动图4-2所示 （动图4-2） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-11-29 17:33:43 "},"basics/IDE/Inspector/readme.html":{"url":"basics/IDE/Inspector/readme.html","title":"属性设置面板说明","keywords":"","body":"属性设置面板说明一、通用功能1.1 增加组件1.2 上一个、下一个1.3 锁定二、应用场景2.1 节点的属性设置2.2 资源的属性设置2.3 代码预览属性设置面板说明 一、通用功能 1.1 增加组件 在属性设置面板中，可以点击增加组件，来给节点添加对应的组件，如图1-1所示。 （图1-1） 3D节点可以增加的组件有：动画（时间轴动画、动画状态机）、3D物理、网格、特效（粒子、拖尾、像素线）、灯光、渲染（UI3D 、反射探针、体积全局照明、静态合批、LOD组）、自定义组件脚本、新建组件脚本。 2D节点可以增加的组件有：动画（时间轴动画、动画状态机）、2D物理、自定义组件脚本、新建组件脚本。 “自定义组件脚本”是添加已经存在的脚本文件；“新建组件脚本”是新建一个脚本文件。 1.2 上一个、下一个 如图1-2所示，点击可以回到看过的上一个节点，点击>可以看到切换前看到的结点。 （图1-2） 1.3 锁定 如动图1-3所示，点击锁定可以锁定属性面板，切换结点时属性设置面板不切换。 （动图1-3） 二、应用场景 2.1 节点的属性设置 2.1.1 通用属性设置 1，激活 2D节点和3D节点都有激活功能，当取消勾选如图2-1所示选项后，该结点在层级面板会变灰，并且不激活父节点子节点会跟着被不激活。 （图2-1） 取消激活后，对于3D节点将不显示，即使运行时也不显示，如动图2-2所示。 （动图2-2） 但是，对于2D节点，取消激活后并不影响节点本身，只是不激活节点的脚本。例如动图2-3所示，使用脚本改变显示的文本，不激活后文本不会被改变。 （动图2-3） 2，重命名 可以按照如动图2-4所示的方式对节点进行重命名。 （动图2-4） 2.1.2 3D节点 静态： 在游戏场景中，每一个Sprite3D都有静态或者动态的两种状态，当一个物体标记为静态后，就确保这个物体在游戏场景中为静态的、不会移动的物体，进而在游戏的运行过程中让游戏有更加流畅的运行体验。详细的介绍请参考《使用3D精灵》的2.3节。 Layer： 蒙版层，渲染相机根据蒙版层可进行可视遮罩层的控制，对精灵的渲染与否进行控制。详细的介绍请参考《使用3D精灵》的2.4节。 Scene3D没有Layer属性。 2.1.3 2D节点 1，定义变量 勾选后，保存场景，就可以在UI运行时里面进行节点的管理了。详细的做法请参考《UI运行时》的2.3节。 Scene2D中没有定义变量属性。 2，Scene2D特有属性 UI运行时：Runtime入口，详细内容请参考《UI运行时》。 使用设计宽高：勾选后，使用的就是项目设置面板中设置的宽高；不勾选，可以自定义宽高。 预加载资源列表：可以添加一些需要预加载的资源。 2.1.4 预制体 当节点是预制体时，会有以下属性： 编辑：进入预制体的编辑页面。 定位：在项目资源面板中定位预制体资源文件。 覆盖属性：可以将修改覆盖到预制体中。 预制体的详细内容请参考《预制体模块》。 2.2 资源的属性设置 在资源面板中，点击以下资源类型的文件，可以在属性设置面板中，设置对应的属性。 图片：可以设置导入的图片属性，详细内容参考《项目资源面板说明》的1.4节。 位图字体：可以自定义位图字体，详细内容参考《文本进阶使用》的2.2节。 自动图集：发布后可以自动生成图集，详细内容参考《Web发布》的3.3.1节。 材质：可以创建自定义材质，详细内容参考《材质编辑模块》。 动画：有2D动画文件和3D动画文件，详细内容参考《时间轴动画编辑详解》。 光照贴图烘焙：可以设置光照属性，详细内容参考《3D场景环境设置》的第六节。 第三方JS文件：提供了单独导入的功能，详细内容参考《引用第三方JS模块》的第二节。 模型：支持的模型后缀为fbx与gltf的模型文件，详细内容参考《模型与动画的导入使用》。 RenderTexture：可以修改渲染纹理的属性，详细内容参考《混合使用3D》的第二节。 AvatarMask：开发者可以用来设置动作遮罩，详细内容参考《动画状态机详解》3.5.1节。 2.3 代码预览 如图2-5所示，在src文件夹中选中脚本文件，就可以进行代码预览了。开发者可以使用代码编辑器（推荐使用VS Code）进行修改。如果是引用第三方JS文件，则可以进行单独导入的设置。 （图2-5） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-11-29 17:33:43 "},"basics/IDE/Game/readme.html":{"url":"basics/IDE/Game/readme.html","title":"预览运行面板说明","keywords":"","body":"预览运行面板说明一、项目预览1.1 预览运行1.2 预览运行的入口二、IDE预览运行面板的作用2.1 不运行时2.2 运行时三、预览运行面板的功能3.1 分辨率3.2 横屏和竖屏3.3 缩放、恢复1X3.4 静音预览运行面板说明 一、项目预览 1.1 预览运行 项目预览用来查看项目在不同环境中的运行效果。项目预览分为三种模式，分别是IDE内预览，浏览器预览，移动端预览。如图1-1所示。 （图1-1） 预览相关的快捷键可以参考一下《IDE快捷键与鼠标交互操作大全》的1.5节。 在开启IDE内预览后会出现两个按钮，分别是重新启动和打开开发者工具： 重新启动顾名思义，对当前预览运行场景进行重启，如图1-2所示。 （图1-2） 点击打开开发者工具会调出Developer Tools，方便开发者进行调试，也可以通过 Ctrl + Alt + I 快捷键来打开开发者工具。 （图1-3） 1.2 预览运行的入口 启动场景在构建发布里进行线上版本的发布后，毫无疑问是作为项目的入口来率先加载与显示的。如图1-4所示，在构建发布中设置启动场景。 （图1-4） 但是在项目预览运行调试的时候，有的时候并不希望将启动场景优先显示，这会使得调试流程变的很长。所以，点击图1-5红圈中的下拉箭头，可以通过点击勾选的方式，将启动场景或者当前场景作为预览运行的入口。 （图1-5） 当前场景是指，当前在IDE里正处于打开编辑状态的场景。 二、IDE预览运行面板的作用 2.1 不运行时 先自定义界面布局，将预览运行窗口按如动图2-1所示的方式拖动，方便观察效果。 （动图2-1） 这样布局的好处，可以方便开发者进行UI布局排版，这也是预览运行窗口在不运行时的一个作用。如动图2-2所示，在场景面板中，是无法同时显示2D与3D界面的，假如我想在模型下显示一个标签，并且需要将它们的位置对齐，这时就需要在预览运行窗口中观察效果。 （动图2-2） 实际上，在点击运行按钮之前，预览运行窗口只是不执行脚本，其它的效果都会显示。比如粒子效果，如动图2-3所示，但是为了效率，粒子效果在预览运行窗口不会实时显示，它是隔一段时间刷新一次。 （动图2-3） 2.2 运行时 点击运行后，就会连脚本也运行。如动图2-4所示，点击运行按钮会自动跳转到预览运行界面，这里给Main Camera添加了一个通过鼠标和键盘来控制摄像机的脚本（参考文档《使用3D精灵》第六节），如果不点击运行，那么这个脚本就不会被执行。 （动图2-4） 三、预览运行面板的功能 3.1 分辨率 不运行时，如动图3-1所示，预览运行的分辨率就是项目设置中的分辨率。 （动图3-1） 如果是运行时，分辨率有多种选项可以选择，如动图3-2所示，还可以自己创建选项，Dimensions是选项的名称，点击对勾后，就可以设置需要的分辨率数值了。 （动图3-2） 3.2 横屏和竖屏 运行时，点击如动图3-3所示的图标，可以切换横屏和竖屏显示。 （动图3-3） 3.3 缩放、恢复1X 预览运行面板支持缩放，还可以快速恢复为1倍大小，操作如动图3-4所示。 （动图3-4） 3.4 静音 如果项目中有音频，则点击如动图3-5所示的图标，在预览运行时将会静音演示。 （动图3-5） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-12-11 15:55:58 "},"basics/IDE/shortcutKeyCombinations/readme.html":{"url":"basics/IDE/shortcutKeyCombinations/readme.html","title":"IDE快捷键与鼠标交互操作大全","keywords":"","body":"IDE快捷键与鼠标交互操作大全一、通用的基础交互1.1 切换面板显示层级1.2 文件与节点的通用操作1.3 层级面板的常用操作1.4 层级与场景的通用操作1.5 运行预览功能1.6 属性面板操作二、2D场景视窗交互三、3D场景视窗交互3.1 操作视窗摄像机3.2 操作模型四、时间轴动画编辑快捷键4.1 时间轴帧面板的快捷键4.2 时间轴曲线面板的快捷键五、蓝图编辑器快捷键5.1 生成节点快捷键5.2 蓝图鼠标交互IDE快捷键与鼠标交互操作大全 Author: charley IDE的基础交互分为键盘输入、快捷键、鼠标交互、鼠标与键盘的功能组合， 本篇将介绍IDE的基础交互，了解全部的功能键组合，充分发挥双手的优势，提升开发效率。 文档中的按键均以windows系统键盘为例，Mac系统键盘的Command对应ctrl键，不再单独说明。 一、通用的基础交互 层级面板、属性面板、项目面板等，都是各块功能几乎都能用到的地方，所以我们先介绍这些通用的基础交互。 1.1 切换面板显示层级 IDE的功能面板，开发者可任意拖拽布局，当处于同一个窗口时，就会根据面板标签的点击切换来决定显示的层级。如动图1-1所示。 (动图1-1) 除了点击面板标签来切换，我们还可以用如下快捷键来切换一些常用的面板： 功能名称 操作 场景面板Scene Ctrl + 1 运行面板Game Ctrl + 2 属性面板Inspector Ctrl + 3 层级面板Hierarchy Ctrl + 4 项目资源面板Project Ctrl + 5 控制台面板Console Ctrl + 6 时间轴面板Timeline Ctrl + 7 1.2 文件与节点的通用操作 1.2.1 重命名：F2 无论是节点的名字还是文件与文件夹，使用快捷键F2即可可进入重命名模式 如果是鼠标操作，单击选中后间隔半秒再单击，也等同于F2。 1.2.2 复制、粘帖、删除、选中 无论是在层级面板、项目面板、场景面板，选中节点对象或文件，即可用以下快捷键操作： 功能名称 操作 拷贝 Ctrl + C 粘贴 Ctrl + V 删除 Delete 全选 Ctrl + A 选中单个 鼠标左键单击 多选 Ctrl + 鼠标左键单击 不间断多选 Shift + 鼠标左键单击 1.3 层级面板的常用操作 1.3.1 创建空节点 除了通过鼠标右键菜单创建节点，还可以用以下快捷键，快速创建空节点。 功能说明 操作 在根节点下，创建一个空子节点 Ctrl + shift + N 为选中的当前节点，创建一个空子节点 Alt + shift + N 为选中的当前节点（可多选），创建一个空父节点 Ctrl + shift + G 2D的空节点是Sprite，3D的空节点是Sprite3D 1.3.2 展开全部子节点：Alt + 鼠标左键单击 正展情况下，单击节点前的三角箭头，会展开一层子节点。 当使用 Alt + 鼠标左键单击 的组合功能键后，可直接展开其下的所有层级节点，效果如动图1-2所示。 (动图1-2) 1.3.3 层级面板的顺序调整 1.拖拽为目标节点的下级节点 当选中某个节点持续按住鼠标左键，将该节点拖拽到目标节点上，目标节点呈现绿色矩形框时，松开鼠标左键，即可成为目标节点的子节点，效果如动图1-3所示。 (动图1-3) 2.拖拽为目标节点同级之后 当选中某个节点持续按住鼠标左键，将该节点拖拽到目标节点上，绿色线条位于目标节点下方时，松开鼠标左键，可改变该节点位置到目标节点同层级的后面。效果如动图1-4所示。 (动图1-4) 3.拖拽为目标节点同级之前 当选中某个节点持续按住鼠标左键，将该节点拖拽到目标节点上，绿色线条位于目标节点上方时，松开鼠标左键，可改变该节点位置到目标节点同层级的前面。效果如动图1-5所示。 (动图1-5) 需要注意的是，2D节点只能在Scene2D下任意拖拽，3D节点只能在Scene3D下任意拖拽，2D与3D节点不可拖到对方的节点下。 1.4 层级与场景的通用操作 1.4.1 3D节点的视窗聚焦：F 无论是层级面板还是场景中，选中节点后，使用快捷键F，即可实现视窗摄像机对该节点的聚焦。效果如动图1-6所示。 （动图1-6） 鼠标左键双击3D节点，也可实现视窗摄像机对该节点的聚焦。 1.4.2 复制并粘贴节点：Ctrl + D 无论是2D节点还是3D节点，在层级面板或场景面板选中节点后，通过快捷键Ctrl + D，即可实现该节点的复制并粘贴。 1.5 运行预览功能 开发者在LayaAir IDE内编辑完成后，提供了三种运行预览方式，分别是的IDE内运行预览、浏览器内运行预览、手机扫码运行预览，按钮如图1-7所示。 (图1-7) 以上功能除了鼠标点击操作之外，还提供了如下快捷键： 功能说明 操作 IDE内运行预览 Ctrl + P 浏览器内运行预览 Ctrl + Shift + P 手机扫码运行预览 Ctrl + Shift + O 1.6 属性面板操作 1.6.1 属性数值滑动输入 当属性值是数字类型时，鼠标移动到输入框上，鼠标样式会转换为双向箭头样式， 此时可按箭头方向划动改变数值，也可点击直接输入框通过键盘输入。 1.6.2 属性保存：Ctrl + S 无论是在属性面板中改变属性，还是在场景中操作，都会导致属性值的变化。 如果确定改变，可通过快捷键 Ctrl + S进行保存。 保存是全局通用的，后面各功能针对保存都不再重复介绍。 二、2D场景视窗交互 当处于Scene2D节点或2D预制体节点时，会启动2D场景视图窗口。当前支持以下快捷键： 功能说明 操作 平移视图舞台 中键长按拖拽、右键长按拖拽 上下滚动视窗内容 鼠标滚轮 缩放视窗内容 Ctrl + 鼠标滚轮 效果如动图2-1所示： (动图2-1) 三、3D场景视窗交互 3D场景中，主要是两大类基础操作。 一是，改变场景视窗的摄像机位置与角度，让开发者如同自己的眼睛一样观察3D场景世界。 二是，改变模型的位置与角度，将模型摆放到场景中适当位置。 3D场景视窗交互的详细内容可以查看文档《3D场景编辑基础交互》。 3.1 操作视窗摄像机 3.1.1 旋转视窗摄像机：鼠标右键 在3D场景中，只要持续按住鼠标右键即进入视窗摄像机的旋转模式，松开鼠标右键即退出视窗摄像机旋转模式。 在该模式下，在屏幕方向上移动鼠标，可以改变视窗摄像机的角度，对整个场景的任意角度进行观察，效果如动图3-1所示。 (动图3-1) 3.1.2 空间位移视窗摄像机： 当按住鼠标右键 + 键盘功能键，可以让摄像机按上下左右前后，具体功能键如下： 功能说明 操作 摄像机向上位移 鼠标右键 + E 摄像机向下位移 鼠标右键 + Q 摄像机向左位移 鼠标右键 + A 摄像机向右位移 鼠标右键 + D 摄像机向前位移 鼠标右键 + W 摄像机向后位移 鼠标右键 + S 位移视窗摄像机的效果如动图3-2所示。 (动图3-2) 上下前后左右，是一个相对的方向，无论旋转到任何角度，都会按这个相对的方向进行位移。 位移视窗摄像机加速： 在位移视窗摄像机的基础上，按住Shift叠加，可以在原功能基础上进行加速移动。 操作按键为：鼠标右键 + shift + (E、Q、A、D、W、S) 3.1.3 屏幕内位移视窗摄像机：Q \\ 鼠标中键 除了采用鼠标右键 + 键盘功能键（E、Q、A、D）实现视窗摄像机上下左右的位移外，还可以通过快捷键Q或鼠标中键来启动屏幕任意方向位移。 使用快捷键Q时，鼠标左键按下并拖拽，即可实现视窗摄像机在屏幕任意方向位移，效果如动图3-3所示。 (动图3-3) 要想退出该模式，则需要通过其它模式的快捷键，除非是需要持续不断的采用该模式位移视窗摄像机。否则更建议采用鼠标中键来启动屏幕任意方向位移。 鼠标中键的方式，只有在按下并拖拽时才会进入该模式，松开鼠标中键会自动回到其它模式。 3.1.4 视窗摄像机缩放：鼠标滚轮 视窗摄像机缩放本质上就是视窗摄像机的前后位移，只因在位移过程中，观察目标时基于近大远小的透视原理，有种缩放的错觉，所以称为缩放视窗摄像机。效果如动图3-4所示， (动图3-4） 3.1.5 视窗摄像机绕焦点中心旋转：Alt + 左键拖拽 在观察或操作具体某个模型时，我们可能需要找一个非正面的合适角度。此时，之前介绍的方式都不太方便。所以围绕目标进行任意旋转是最适合的操作。 要旋转视窗摄像机之前，我们首先要做的事，就是聚焦，将模型处于视窗摄像机的中心位置。 聚焦的快捷键为F，前文1.4.1已进行介绍。 聚焦后，通过Alt + 左键的组合，左键向任意角度拖拽，即可实现绕焦点中心旋转，效果如动图3-5所示， (动图3-5) 3.2 操作模型 操作模型的工具有四种，分别是位移、旋转、缩放、混合使用。可以通过快捷键 W、E、R、T进行启动不同的工具模式。 快捷键名称 按键 模型位移工具 W 模型旋转工具 E 模型缩放工具 R 混合编辑模型 T 3.2.1 模型位移工具：W 通过快捷键W进入模型位移工具模式后，模型上会出现红绿蓝三色的轴和片。 红绿蓝三个轴分别代表X、Y、Z三个方向，轴的颜色与右上角的坐标轴对应。 箭头所指的方向为正方向，拖动其中一个轴，可使该模型按该轴的正负方向进行位移，效果如动图3-6所示。 (动图3-6) 留意属性面板，如果该模型没有任何旋转（rotation都为0），拖动其中一个轴，只有该轴的属性值会发生变化 。如果有旋转，则会影响其它轴属性值。 三个相邻的面，蓝色为XY面、绿色XZ面、红色为YZ面。 拖动其中一个面，可使该模型在该面范围内任意位移，效果如动图3-7所示。 (动图3-7) 3.2.2 模型旋转工具：E 通过快捷键E进入模型旋转工具模式后，模型上出现红绿蓝三色的交叉弧线和外层白圈，当鼠标划到模型上时，还会出现一个半透明圆。 红绿蓝三色的弧线分别代表X、Y、Z三个轴的方向，颜色与右上角的坐标轴对应。 选中其中一个弧线后，会变成完整的圆圈，代表按该该轴方向进行旋转，效果如动图3-8所示。 (动图3-8) 外层白圈，是基于屏幕的垂直旋转，效果如动图3-9所示。 (动图3-9) 如果鼠标在半透明圆拖拽，则可以任意角度旋转，效果如动图3-10所示。 (动图3-10) 3.2.3 模型缩放工具：R 通过快捷键R进入模型缩放工具模式后，模型上不仅有红绿蓝三色轴，还有中心白块和外层白色圆圈。 红绿蓝三色轴分别代表X、Y、Z三个轴的方向，拉动其中一个轴，可在该轴对模式进行缩放，效果如动图3-11所示。 (动图3-11） 中心的白块与外层白色圆圈均是三轴同时缩放，两者的区别仅是缩放速率差异，效果如动图3-12所示。 (动图3-12） 3.2.4 模型工具集合：T 通过快捷键T进入模型工具集合后，前文介绍的模型操作工具，都会集合到一起。 唯一需要注意的是，混合模式下，中心块缩放不再保留，只能通过外层白色圆圈整体缩放，以及通过拉动各轴的方块从单轴方向缩放，效果如动图3-13所示。 (动图3-13) 3.2.5 模型的多选 多选的方式分别是框选、Shift、Ctrl这几种方式。 模型的框选，就是通过鼠标拉起屏幕矩形区，只要在矩形区内，无论远近都会被选中。 除了框选，也可以通过Shift或Ctrl结合鼠标点击，进行连续多选。 无论是单选，还是多选，选中的模型都会出现红色边框。 四、时间轴动画编辑快捷键 4.1 时间轴帧面板的快捷键 功能说明 按键 插入空白帧 F5 删除空白帧 Shift + F5 删除关键帧 Delete 复制关键帧 Ctrl + C 粘贴关键帧 Ctrl + V 当鼠标处于时间轴帧面板操作时，纵向滚动显示属性 Ctrl+滚轮 4.2 时间轴曲线面板的快捷键 功能说明 按键 锁定帧刻度面板（不缩放），以鼠标指针为中心，无限制缩放属性刻度面板的精度。 Ctrl+滚轮 锁定属性刻度面板（不缩放），以鼠标指针为中心，无限制缩放帧刻度面板的精度。（无限制缩放会导致当缩放拉伸到0帧可见时，不再以缩放前的鼠标指标为中心进行缩放）。 Alt+滚轮 锁定属性刻度面板（不缩放），以鼠标指针为中心，有限制缩放帧刻度面板的精度。（始终保持以鼠标指针为中心进行缩放，当缩放拉伸至0帧可见时，禁止刻度精度缩小，只允许刻度精度放大） Alt+Shift+滚轮 持续按住Shift键，可以使得移动关键帧，始终保持水平方向位移，单个与批量移动均有效。 Shift 持续按住Ctrl键，可以使得移动关键帧，始终保持垂直方向位移，单个与批量移动均有效。 Ctrl 由于时间轴动画相关，有详细的文档说明，这里不再展开介绍，想了解更多，请移步《时间轴动画编辑详解》文档。 五、蓝图编辑器快捷键 5.1 生成节点快捷键 当长按键盘上的快捷键，再鼠标左键点击，即可快捷生成不同类型的蓝图节点。 功能说明 快捷组合键 快速生成Float节点 1 + 鼠标左键 快速生成Vector2节点 2 + 鼠标左键 快速生成Vector3节点 3 + 鼠标左键 快速生成Vector4节点 4+ 鼠标左键 快速生成If节点 i + 鼠标左键 快速生成Boolean节点 b + 鼠标左键 快速生成sampler2D节点 t + 鼠标左键 5.2 蓝图鼠标交互 功能说明 按键 整体移动蓝图节点 鼠标中键\\右键 按下拖拽 整体缩放蓝图节点 鼠标滚轮 由于蓝图编辑器相关，有详细的文档说明，这里不再展开介绍，想了解更多，请移步《蓝图编辑模块》文档。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-08-03 17:24:00 "},"basics/common/readme.html":{"url":"basics/common/readme.html","title":"引擎通用基础","keywords":"","body":"引擎通用基础引擎通用基础 引擎通用基础是指无论是2D项目还是3D项目，都会使用到的引擎基础功能 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"basics/common/terms/readme.html":{"url":"basics/common/terms/readme.html","title":"引擎基础概念","keywords":"","body":"引擎使用的基础概念一、画布二、舞台三、对象四、节点、显示列表、显示对象、容器对象引擎使用的基础概念 Author : Charley 一、画布 画布就是浏览器的canvas，如图1所示： （图1） LayaAir引擎游戏的所有可见画面，都是一帧一帧的绘制出来，连续播放显示的结果。每秒播放的画面帧数代表着游戏是否流畅的性能指标。而画布是引擎每一帧绘图显示的容器，没有了画布，如同画家没有了画纸，不可能凭空作画。 帧数越高画面越流畅，通常是60帧是满帧，但设备的不同会有所差异，有的机型上可以达到90帧满帧或者120帧满帧。 LayaAir画布的大小，取决于我们游戏自己设置的设计宽高以及LayaAir引擎中屏幕适配，如图2所示， (图2) 在不同机型分辨率下，会导致画布大小可能有所变化。这些知识，在屏幕适配的文档会展开介绍。 二、舞台 舞台是引擎的Stage，是LayaAir引擎用来在画布上绘制游戏画面以及交互事件反馈的实际区域。 可以想象一下，一个画家，在一张纸上（画布）只在中心区域作画，还是只留出一点边，或者把整张纸画满。这个规划在引擎里就可以理解为舞台的大小。 游戏中的画面实际上是受限于引擎的舞台，如果舞台不是全屏，光画布全屏，超出舞台的部分也是显示不出来的。如果把设备比喻成桌子，画布是画纸，即便是画纸铺满整个桌子，但是如果规定画家，只能在某一块区块作画，那画家在作画时就不会超出那个区域。所以，对于有全屏适配需求的游戏，不光要让画布的大小达到全屏的大小，也要让舞台的大小占满画布的大小。 舞台的大小，也与设计宽高以及屏幕适配有关，上面那个适配文档同样适用于想深入理解舞台这个概念的同学。 三、对象 对于有编程知识的同学，都能理解，在面向对象编程中，对象是类的实例。 从广义上理解，具有属性结构的数据或者可以设置属性的数据结构，也可以称为对象，例如json对象和空对象{}。 四、节点、显示列表、显示对象、容器对象 LayaAir引擎中，Node（节点）类是可放在显示列表中的所有对象的基类，2D的基础精灵Sprite与3D的基础精灵Sprite3D都继承于Node，不仅于此，所有继承于Node的子类或孙类，也可称为节点，例如：Sprite节点，Image节点。 只有继承于Node的子类或孙类的节点对象，才可以添加子节点对象。 节点中，图片、文字、动画、模型等这种可见的对象为显示对象。有的节点本身不负责渲染显示，仅仅是用于挂载子节点，这种对象称为容器对象。例如Sprite、Sprite3D、Box、等。 Sprite比较特别，当添加了纹理资源后，就是显示对象。不添加纹理，只是用于挂载子节点时，就是容器对象。 显示列表是一个抽象的概念，显示列表可以理解为基于舞台的节点树，无论是显示对象还是容器对象，都在显示列表内。 显示列表用于管理 LayaAir运行时显示的所有对象。需要注意的是，继承自Node的两个子类Sprite与Sprite3D分别是2D的基础显示对象和3D的基础显示对象。两者不能混合添加，也就是说Sprite及其子节点不能作为Sprite3D的子节点，Sprite3D及其子节点不能作为Sprite的子节点。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"basics/common/Component/readme.html":{"url":"basics/common/Component/readme.html","title":"实体组件系统","keywords":"","body":"实体组件系统（ECS）一、 什么是ECS二、组件脚本的内置方法2.1 组件的生命周期方法2.2 组件的事件方法三、组件在IDE的暴露方式3.1 组件脚本的识别@regClass()3.2 组件属性的识别@property()3.3 IDE中执行生命周期方法@runInEditor3.4 @classInfo()四、代码中使用属性4.1 节点类型方式4.2 组件类型的使用4.3 Prefab类型属性实体组件系统（ECS） Author：Charley 、谷主、孟星煜 一、 什么是ECS ECS是Entity-Component-System（实体-组件-系统）的简写，这是一种基于数据驱动的游戏设计模式。 LayaAir的ECS，将场景中每一个有着唯一ID的显示对象节点都被看做一个个的实体。每一个实体都可以为其添加一个或多个不同的组件系统脚本。 在这里，组件系统是组件与系统两个组成部分，组件只包含数据，不包含逻辑，游戏对象的逻辑行为由系统控制，所以系统是实体的逻辑控制部分，组件是系统与外界的数据接口部分。LayaAir通过装饰器将接口暴露在IDE中，方便开发者直观的传入数据。引擎为组件系统提供的生命周期方法与事件方法可以作为系统逻辑控制的入口。 开发者通过继承引擎的组件脚本类Laya.Script，可以实现组件系统脚本的完整功能，我们通常将组件系统脚本简称为组件脚本。然后通过IDE或者代码的方式添加到实体上，实现完整的ECS功能。 组件脚本，在原则上是解耦且具有单一职责的，这样方便多个实体可以共用同一个组件系统。 二、组件脚本的内置方法 继承引擎的组件脚本类Laya.Script之后，就可以直接使用引擎为组件脚本提供内置的生命周期方法与事件方法，这些方法可以用于组件脚本逻辑的执行入口。如下图所示： （图2-1）组件脚本的生命周期方法 2.1 组件的生命周期方法 生命周期方法是指在物体的创建、销毁、激活、禁用等过程中，会自动调用的方法。当使用自定义的组件脚本时，可以实现如下生命周期方法，方便快速开发业务逻辑。可以在每个方法中打印一条日志，方便开发者进行测试。 名称 条件 onAdded 被添加到节点后调用，和Awake不同的是即使节点未激活onAdded也会调用 onReset 重置组件参数到默认值，如果实现了这个函数，则组件会被重置并且自动回收到对象池，方便下次复用。如果没有重置，则不进行回收复用 onAwake 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onEnable 组件被启用后执行，比如节点被添加到舞台后 onStart 第一次执行onUpdate之前执行，只会执行一次 onUpdate 每帧更新时执行，尽量不要在这里写大循环逻辑或者使用getComponent方法 onLateUpdate 每帧更新时执行，在onUpdate之后执行，尽量不要在这里写大循环逻辑或者使用getComponent方法 onPreRender 渲染之前执行 onPostRender 渲染之后执行 onDisable 组件被禁用时执行，比如从节点从舞台移除后 onDestroy 手动调用节点销毁时执行 在代码中的使用如下： //被添加到节点后调用，和Awake不同的是即使节点未激活onAdded也会调用 onAdded(): void { console.log(\"Game onAdded\"); } //重置组件参数到默认值，如果实现了这个函数，则组件会被重置并且自动回收到对象池，方便下次复用。如果没有重置，则不进行回收复用 onReset(): void { console.log(\"Game onReset\"); } //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { console.log(\"Game onAwake\"); } //组件被启用后执行，比如节点被添加到舞台后 onEnable(): void { console.log(\"Game onEnable\"); } //第一次执行update之前执行，只会执行一次 onStart(): void { console.log(\"Game onStart\"); } //每帧更新时执行，尽量不要在这里写大循环逻辑或者使用getComponent方法 onUpdate(): void { console.log(\"Game onUpdate\"); } //每帧更新时执行，在update之后执行，尽量不要在这里写大循环逻辑或者使用getComponent方法 onLateUpdate(): void { console.log(\"Game onLateUpdate\"); } //渲染之前执行 onPreRender(): void { console.log(\"Game onPreRender\"); } //渲染之后执行 onPostRender(): void { console.log(\"Game onPostRender\"); } //组件被禁用时执行，比如从节点从舞台移除后 onDisable(): void { console.log(\"Game onDisable\"); } //手动调用节点销毁时执行 onDestroy(): void { console.log(\"Game onDestroy\"); } 下面以“2D入门示例”中的一个子弹脚本Bullet.ts为例，讲解生命周期方法，以下是此脚本文件的代码： const { regClass, property } = Laya; /** * 子弹脚本，实现子弹飞行逻辑及对象池回收机制 */ @regClass() export default class Bullet extends Laya.Script { constructor() { super(); } onEnable(): void { //设置初始速度 let rig: Laya.RigidBody = this.owner.getComponent(Laya.RigidBody); rig.setVelocity({ x: 0, y: -10 }); } onTriggerEnter(other: any, self: any, contact: any): void { //如果被碰到，则移除子弹 this.owner.removeSelf(); } onUpdate(): void { //如果子弹超出屏幕，则移除子弹 if ((this.owner as Laya.Sprite).y 在游戏中，将子弹添加到舞台上时，每次添加到舞台都得有初速度，但如果将onEnable()换成onAwake()，那么这个初速度就会失效。onUpdate()是每帧执行一次，子弹超出屏幕，则移除子弹，此处的 if 条件判断是每一帧都会判断一次。onDisable()是节点从舞台移除后触发，当子弹超出屏幕被移除时，就触发这个方法，这里是回收子弹到对象池了。 2.2 组件的事件方法 事件方法是指在某些特定的情况下，会根据条件自动触发的方法。当使用自定义的组件脚本时，可以通过事件方法方便快速开发业务逻辑。 2.2.1 物理事件 使用物理引擎时，我们有时候需要根据物理的碰撞事件在代码中实现逻辑交互。为此，LayaAir引擎在物理碰撞的首次发生时、持续碰撞时以及退出碰撞时，均会触发这些特定的物理事件方法。这些方法在引擎中默认不包含具体实现，可以视为待开发者重写的方法。开发者只需继承Laya.Script类，并在其中重写这些方法，就可以实现自定义的逻辑响应，替代默认的空W实现。 这样，通过重写这些特定方法，开发者可以根据物理碰撞的具体阶段执行相应的游戏逻辑或者交互效果，从而使得游戏或应用能够在遇到物理碰撞时，有更自然、更真实的响应。下面表格罗列了全部的物理事件方法： 名称 条件 onTriggerEnter 3D物理触发器事件与2D物理碰撞事件，开始碰撞时执行，仅执行一次 onTriggerStay 3D物理触发器事件与2D物理碰撞事件(不支持传感器)，持续碰撞时执行，每帧都执行 onTriggerExit 3D物理触发器事件与2D物理碰撞事件，结束碰撞时执行，仅执行一次 onCollisionEnter 3D物理碰撞器事件（不适用2D），开始碰撞时执行，仅执行一次 onCollisionStay 3D物理碰撞器事件（不适用2D），持续碰撞时执行，每帧都执行 onCollisionExit 3D物理碰撞器事件（不适用2D），结束碰撞时执行，仅执行一次 通过以上表格可以看出，2D物理事件只有三个事件方法，而3D物理事件，则分为触发器事件和碰撞器事件两类，有六个事件方法。 碰撞器事件是指反生物理反馈的事件，触发器事件是只有物理事件的触发，但没有实际物理碰撞反馈的一种事件，这与2D碰撞体启用了传感器的效果是一样的，只不过2D物理无论是碰撞反馈事件还是启用了传感器的无反馈物体事件，都是只用onTrigger事件。 特别提醒的是，2D物理启用传感器之后，onTriggerStay事件是不被触发的，这一点需要新手开发者注意。 在脚本中的事件使用示例如下： class DemoScript extends Laya.Script { /** * 3D物理触发器事件与2D物理碰撞事件, 在每一次发生物理碰撞的开始时，引擎都会调用一次的事件方法。 * @param other 碰撞目标对象的碰撞体以及所属节点对象等信息 * @param self 自身的碰撞体以及所属节点对象等信息（该参数只有2D物理有，3D物理只有other） * @param contact 物理引擎携带的碰撞信息b2Contact，开发者可以通过查询b2Contact对象来获取两个刚体碰撞有关的详细信息。但是通常用不上，other和self中已存在常规需要的信用，足够用了。（该参数只有2D物理有，3D物理只有other） */ onTriggerEnter(other: Laya.PhysicsComponent | Laya.ColliderBase, self?: Laya.ColliderBase, contact?: any): void { // 假如碰到了炸弹 if (other.label == \"bomb\") { // 此处省略爆炸伤害的逻辑 console.log(\"碰到炸弹：\" + self.label + \"受到伤害，生命值减少xx\"); } else if (other.label == \"Medicine\") { // 假如碰到了药箱 // 此处省略恢复生命值的逻辑 console.log(\"碰到药箱：\" + self.label + \"接受治疗，生命值恢复xx\"); } console.log(\"onTriggerEnter:\", other, self); } /** * 3D物理触发器事件与2D物理碰撞事件(不支持传感器), 发生持续的物理碰撞时，也就是碰撞生命周期内的第二次碰撞到碰撞结束前，每帧都在触发调用的事件方法。 * 尽量不要在该事件方法中执行复杂的逻辑和函数调用，尤其是运算等消耗性能的代码，否则会对性能有明显的影响。 * @param other 碰撞目标对象的碰撞体以及所属节点对象等信息 * @param self 自身的碰撞体以及所属节点对象等信息（该参数只有2D物理有，3D物理只有other） * @param contact 物理引擎携带的碰撞信息b2Contact，开发者可以通过查询b2Contact对象来获取两个刚体碰撞有关的详细信息。但是通常用不上，other和self中已存在常规需要的信用，足够用了（该参数只有2D物理有，3D物理只有other） */ onTriggerStay(other: Laya.PhysicsComponent | Laya.ColliderBase, self?: Laya.ColliderBase, contact?: any): void { //持续碰撞时，打印日志，尽量不使用该事件方法，如果使用不当对性能的消耗会影响较大。 console.log(\"onTriggerStay====\", other, self); } /** * 在每一次的物理碰撞结束时，引擎都会调用一次的事件方法。 * @param other 碰撞目标对象的碰撞体以及所属节点对象等信息 * @param self 自身的碰撞体以及所属节点对象等信息（该参数只有2D物理有，3D物理只有other） * @param contact 物理引擎携带的碰撞信息b2Contact，开发者可以通过查询b2Contact对象来获取两个刚体碰撞有关的详细信息。但是通常用不上，other和self中已存在常规需要的信用，足够用了（该参数只有2D物理有，3D物理只有other） */ onTriggerExit(other: Laya.PhysicsComponent | Laya.ColliderBase, self?: Laya.ColliderBase, contact?: any): void { //模拟角色离开毒气区域，触发逃脱奖励 if (other.label == \"poison\") { // 此处省略逃脱奖励的逻辑 console.log(\"离开毒气区域：\" + self.label + \"获得逃脱奖励，生命值+10\"); } console.log(\"onTriggerExit========\", other, self); } /** * 3D物理碰撞器事件（不适用2D），在每一次发生物理碰撞的开始时，引擎都会调用一次的事件方法。 * @param other 碰撞目标对象 */ onCollisionEnter(other:Laya.Collision): void { //碰撞开始后，物体改变颜色 (this.owner.getComponent(Laya.MeshRenderer).material as Laya.BlinnPhongMaterial).albedoColor = new Laya.Color(0.0, 1.0, 0.0, 1.0);//绿色 } /** * 发生持续物理碰撞时的3D物理碰撞器事件（不适用2D），也就是碰撞生命周期内的第二次碰撞到碰撞结束前，每帧都在触发调用的事件方法。 * 尽量不要在该事件方法中执行复杂的逻辑和函数调用，尤其是运算等消耗性能的代码，否则会对性能有明显的影响。 * @param other 碰撞目标对象 */ onCollisionStay(other:Laya.Collision): void { //持续碰撞时，打印日志，尽量不使用该事件方法，如果使用不当对性能的消耗会影响较大。 console.log(\"peng\"); } /** * 3D物理碰撞器事件（不适用2D），在每一次的物理碰撞结束时，引擎都会调用一次的事件方法。 * @param other 碰撞目标对象 */ onCollisionExit(other:Laya.Collision): void { ////碰撞离开后，物体变回原本颜色 (this.owner.getComponent(Laya.MeshRenderer).material as Laya.BlinnPhongMaterial).albedoColor = new Laya.Color(1.0, 1.0, 1.0, 1.0);//白色 } } 基于上面的代码示例，为3D模型添加脚本。如动图2-2所示。 （动图2-2） 2.2.2 鼠标事件 名称 条件 onMouseDown 鼠标按下时执行 onMouseUp 鼠标抬起时执行 onRightMouseDown 鼠标右键或中键按下时执行 onRightMouseUp 鼠标右键或中键抬起时执行 onMouseMove 鼠标在节点上移动时执行 onMouseOver 鼠标进入节点时执行 onMouseOut 鼠标离开节点时执行 onMouseDrag 鼠标按住一个物体后，拖拽时执行 onMouseDragEnd 鼠标按住一个物体，拖拽一定距离，释放鼠标按键后执行 onMouseClick 鼠标点击时执行 onMouseDoubleClick 鼠标双击时执行 onMouseRightClick 鼠标右键点击时执行 在代码中的使用如下： //鼠标按下时执行 onMouseDown(evt: Laya.Event): void { } //鼠标抬起时执行 onMouseUp(evt: Laya.Event): void { } //鼠标右键或中键按下时执行 onRightMouseDown(evt: Laya.Event): void { } //鼠标右键或中键抬起时执行 onRightMouseUp(evt: Laya.Event): void { } //鼠标在节点上移动时执行 onMouseMove(evt: Laya.Event): void { } //鼠标进入节点时执行 onMouseOver(evt: Laya.Event): void { } //鼠标离开节点时执行 onMouseOut(evt: Laya.Event): void { } //鼠标按住一个物体后，拖拽时执行 onMouseDrag(evt: Laya.Event): void { } //鼠标按住一个物体，拖拽一定距离，释放鼠标按键后执行 onMouseDragEnd(evt: Laya.Event): void { } //鼠标点击时执行 onMouseClick(evt: Laya.Event): void { } //鼠标双击时执行 onMouseDoubleClick(evt: Laya.Event): void { } //鼠标右键点击时执行 onMouseRightClick(evt: Laya.Event): void { } 下面以onMouseDown和onMouseUp为例，在自定义的组件脚本“Script.ts”中加入以下代码： const { regClass, property } = Laya; @regClass() export class Script extends Laya.Script { /** * 鼠标按下时执行 */ onMouseDown(evt: Laya.Event): void { console.log(\"onMouseDown\"); } /** * 鼠标抬起时执行 */ onMouseUp(evt: Laya.Event): void { console.log(\"onMouseUp\"); } } 如图2-3所示，将组件脚本添加到Scene2D的属性面板后，先不勾选 Mouse Through，因为如果勾选它，Scene2D下鼠标事件将不会响应。如果是一个3D场景，它会传递到Scene3D中。 （图2-3） 运行项目，如动图2-4所示，当鼠标按下时执行onMouseDown，打印“onMouseDown”；松开鼠标，鼠标弹起时执行onMouseUp，打印“onMouseUp”。 （动图2-4） 2.2.3 键盘事件 名称 条件 onKeyDown 键盘按下时执行 onKeyPress 键盘产生一个字符时执行 onKeyUp 键盘抬起时执行 在代码中的使用如下： //键盘按下时执行 onKeyDown(evt: Laya.Event): void { } //键盘产生一个字符时执行 onKeyPress(evt: Laya.Event): void { } //键盘抬起时执行 onKeyUp(evt: Laya.Event): void { } 注意：onKeyPress是产生一个字符时执行，例如字母“a”、“b”，“c”等。像上、下、左、右键，F1、 F2等不是字符输入的按键，就不会执行此方法。 三、组件在IDE的暴露方式 在LayaAir 3.0 IDE中，如果想在IDE内展示组件脚本的属性，需要通过装饰器的规则来实现。 3.1 组件脚本的识别@regClass() 开发者编写的组件脚本，需要在类定义之前使用装饰器的标识@regClass()，示例代码如下所示： const { regClass } = Laya; @regClass() export class Script extends Laya.Script { } 如动图3-1所示，只有使用了上述的这个装饰器标识，开发者自定义的组件脚本才会被IDE识别为组件，可以被节点（实体）的属性设置面板 -> 增加组件 -> 自定义组件脚本所添加。 （动图3-1） 一个TS文件只能有一个类使用@regClass() 。 标记了@regClass()的类，在IDE环境内都会被编译，但最终发布时，如果这个类没有被其他类引用，也没有被添加到节点上，或者所在的预制体/场景没有发布，则这个类会被裁剪。 3.2 组件属性的识别@property() 3.2.1 组件属性的常规使用 当开发者想将组件的属性，通过IDE暴露给外界编辑来传入数据。需要在类属性定义之前使用装饰器的标识@property()，示例代码如下所示： const { regClass, property } = Laya; @regClass() export class NewScript1 extends Laya.Script { //装饰器属性的标准写法，适用于IDE的需要显示Tips或属性的中文别名等完整功能需求 @property({ type: String, caption: \"IDE显示用的别名\", tips: \"这是一个文本对象，只能输入文本哦\" }) public text1: string = \"\"; //装饰器属性类型的简写方式，适用于只定义类型的需求 @property(String) public text2: string = \"\"; constructor() { super(); } } @property()是IDE识别组件属性并显示到IDE属性面板上的装饰器标识，类型是装饰器属性标识必须携带的参数。 如果我们不需要给属性写一个tips说明，也不需要给属性重新定义一个在IDE里显示的别名，等需求。那按上面示例的简写方式即可。 如果简写方式有语法警告，请用新版本IDE，并通过IDE的开发者 -> 更新引擎d.ts文件功能来解决，或者使用标准写法来解决。 3.2.2 属性访问器的装饰器使用 有的时候，开发者会通过属性访问器(getter)和属性设置器(setter)来控制属性的读写行为。 当属性访问器和属性设置器同时存在时，装饰器的属性标识@property()直接用于属性访问器之前即可，此时的组件属性与上一小节中介绍的常规使用方式一样，都是可读写的。 如果，该脚本只有属性访问器，那这个属性则是只读的，仅可以在IDE中显示，但不能编辑。 getter和setter同时存在的装饰器使用示例代码如下： const { regClass, property } = Laya; @regClass() class Animal { private _weight: number = 0; @property( { type : Number } ) get weight() : number { return this._weight; } set weight(value: number) { this._weight = value; } } 3.2.3 是否序列化保存 通过装饰器定义为组件属性后，默认状态下，属性名与值都会被序列化保存到组件被添加的场景文件或预制体文件里。例如，scene.ls里添加完自定义组件，通过vscode打开这个scene.ls，可以找到序列化保存后的组件属性名称与值，效果如动图3-2所示。 （动图3-2） 序列化保存后，不仅方便在IDE中直观查看与编辑组件属性值。在运行阶段，也可以直接使用序列化存储的值，对于结构复杂的数据，直接使用序列化的值还可以节省数据结构生成带来的开销。所以，有些时候，即便是不需要在属性面板上显示与编辑，也可以通过装饰器设置为组件属性，将值序列化存储在场景或预制体文件中。 但是，也有的时候，我们的组件属性只是为了方便在IDE中理解与调整，在使用的时候，这些值其实用不到，所以，还提供了是否序列化保存的控制。当装饰器属性定义的时候，对象参数中传入serializable为false，那么该属性就不会被序列化。 例如，开发者的需求是序列化保存弧度值，但弧度值在人为调整数值的时候并不直观，此时，可以在IDE里直接输入角度值但不保存，仅将转换后的弧度值存起来。示例代码如下： const { regClass, property } = Laya; @regClass() export class Main extends Laya.Script { @property({ type: Number }) _radian: number = 0; //带下划线的属性，默认不会出现在IDE的属性面板上，只是用来存储输入的弧度 @property({ type: Number, caption: \"角度\", serializable: false }) //这里设置serializable为false，所以degree不会被保存到场景文件中 get degree() { return this._radian * (180 / Math.PI);//由于自己没有序列化保存，需要把_radian存下来的弧度反算回角度，用于IDE属性面板显示 } set degree(value: number) { this._radian = value * (Math.PI / 180);//把输入的角度值，转成弧度给_radian存起来。 } onStart() { console.log(this._radian); } } 3.2.4 组件属性是否在IDE中显示 在默认情况下，装饰器属性规则只会对非下划线的类属性标记为IDE的组件属性。 对于有下划线的属性，其实是不会被显示到IDE里，此时该组件属性的价值只剩下将值保存到场景文件中了，这一点上文有所提及，示例也有应用。 带下划线的属性如果没有序列化保存到场景文件的需求，那就不必使用装饰器了。 假如，开发者想对有下划线的属性，也要显示到IDE上，也可以做到。将修饰器属性标识的传入对象中，设置参数private为false即可。 示例代码如下： @property({ type: \"number\", private: false }) _velocity: number = 0; private参数不仅可以使得下划线属性显示，也可以通过将private设置为true，使得不带下划线的属性，不在IDE的属性面板出现。 这里，我们将前文的弧度转换示例稍作修改，代码如下： const { regClass, property } = Laya; @regClass() export class Main extends Laya.Script { @property({ type: Number , private: true }) radian: number = 0; //private设置为true之后，radian不会出现在IDE的属性面板上，只是用来存储输入的弧度 @property({ type: Number, caption: \"角度\", serializable: false }) //这里设置serializable为false，所以degree不会被保存到场景文件中 get degree() { return this.radian * (180 / Math.PI);//由于自己没有序列化保存，需要把radian存下来的弧度反算回角度，用于IDE属性面板显示 } set degree(value: number) { this.radian = value * (Math.PI / 180);//把输入的角度值，转成弧度给radian存起来。 } onStart() { console.log(this.radian); } } 3.2.5 装饰器属性标识的类型 装饰器属性标识的类型支持引擎对象类型（例如：Laya.Vector3、Laya.Sprite3D、Laya.Camera等）、自定义的对象类型（需要标记＠regClass()）、以及TS语言的基本类型。 3.2.5.1 引擎对象类型 引擎对象类型的理解比较简单，暴露组件属性之后，直接传入对应类型的值就可以。例如Laya.Sprite3D就只能传入3D节点，试图拖入2D节点或拖入资源都是禁止的。 常用的引擎对象类型使用示例如下： const { regClass, property } = Laya; @regClass() export class Main extends Laya.Script { @property( { type:Laya.Camera } ) //摄像机类型 private camera: Laya.Camera; @property( { type:Laya.Scene3D } ) //3D场景根节点类型 private scene3D: Laya.Scene3D; @property( { type:Laya.DirectionLightCom } ) //DirectionLight组件类型 private directionLight: Laya.DirectionLightCom; @property( { type:Laya.Sprite3D } ) //Sprite3D节点类型 private cube: Laya.Sprite3D; @property( { type:Laya.Prefab } ) //加载 Prefab 拿到的对象 private prefabFromResource: Laya.Prefab; @property( { type:Laya.ShurikenParticleRenderer } ) //ShurikenParticleRenderer组件类型 private particle3D: Laya.ShurikenParticleRenderer; @property( { type:Laya.Node } ) //节点类型 private scnen2D: Laya.Node; @property( { type:Laya.Box } ) //拿到 Box 组件 private box: Laya.Box; @property( { type:Laya.List } ) //拿到 List 组件 private list: Laya.List; @property( { type:Laya.Image } ) //拿到 Image 组件 private image: Laya.Image; @property( { type:Laya.Label } ) //拿到 Label 组件 private label: Laya.Label; @property( { type:Laya.Button } ) //拿到 Button 组件 private button: Laya.Button; @property( { type:Laya.Sprite } ) //拿到 Sprite 组件 private sprite: Laya.Sprite; @property( { type:Laya.Animation } ) //拿到 Animation 组件 private anmation: Laya.Animation; @property( { type:Laya.Vector3 } ) //Laya.Vector3类型 private vector3 : Laya.Vector3; } 如动图3-3所示，将场景中已经添加好的Image拖入到@property暴露的Image属性入口中，这样就获取到了此节点，然后可以在脚本中使用代码控制Image的属性了（参考4.1节）。 （动图3-3） 3.2.5.2 自定义对象类型 自定义对象类型，就是设置一个自定义的引入对象。按该对象的装饰器属性标识来暴露组件属性。 例如，下面这两个TS代码： //MyScript.ts const { regClass, property } = Laya; import Animal from \"./Animal\"; @regClass() export class MyScript extends Laya.Script { @property({ type : Animal }) animal : Animal; } //Animal.ts const { regClass, property } = Laya; @regClass() export default class Animal { @property({ type : Number }) weight : number; } 组件脚本MyScript中引用了Animal对象 ，并将装饰器属性标识的类型设置为Animal，尽管Animal不是继承于Laya.Script的组件脚本，但由于被组件脚本MyScript所引用并暴露给IDE，所以Animal类定义之前也需要标记＠regClass()，该类下使用了@property()标识的属性，也可以出现在IDE属性面板中。 3.2.5.3 TS语言基本类型 最后就是常用的TS语言基本类型，不过需要注意的是，基本类型需要使用字符串的方式来描述，只有数字、字符串、布尔类型，可以用其对象类型来标记。 类型 类型书写示范 类型说明 数字类型 \"number\" 也可以用Number来标记该类型 单行字符串文本类型 \"string\" 也可以用String来标记该类型 布尔值类型 \"boolean\" 也可以用Boolean来标记该类型 整数类型 \"int\" 等价于 { type: Number, fractionDigits: 0 } 正整数类型 \"uint\" 等价于 { type: Number, fractionDigits: 0 , min: 0 } 多行字符串文本类型 \"text\" 等价于 { type: string, multiline: true } 任意类型 \"any\" 类型只会被序列化，不能显示和编辑。 类型化数组类型 Int8Array、Uint8Array、Int16Array、Uint16Array、Int32Array、Uint32Array、Float32Array 支持7种类型化数组类型 数组类型 [\"number\"]、[\"string\"] 用中括号包含数组元素类型， 使用示例代码如下： const { regClass, property } = Laya; //枚举 enum TestEnum { A, B, C }; //字符串形式的枚举 enum Direction { Up = 'UP', Down = 'DOWN', Left = 'LEFT', Right = 'RIGHT' }; @regClass() export class Script extends Laya.Script { @property(Number)//数字类型，等价于{ type : \"number\" } num : number; @property(String)//单行字符串文本类型，等价于 { type: \"string\"} str : string; @property(Boolean)//布尔值类型，等价于 { type: \"boolean\"} bool : boolean; @property(\"int\")//整数类型，等价于 { type: Number, fractionDigits: 0 } int : number; @property(\"uint\") //正整数类型，等价于 { type: Number, fractionDigits: 0 , min: 0 } uint : number; @property(\"text\")//多行字符串文本类型，等价于 { type: String, multiline: true } text : string; @property(\"any\")//any类型只会被序列化，不能显示和编辑。 a : any; @property(Int8Array)//类型化数组类型,除了Int8Array，还支持Uint8Array、Int16Array、Uint16Array、Int32Array、Uint32Array、Float32Array，使用方式都类似 i8a: Int8Array; @property({ type: [\"number\"] })//数组类型，用中括号包含数组元素类型 arr1: number[]; @property({ type: [\"string\"] })//数组类型，用中括号包含数组元素类型 arr2: string[]; //普通的枚举类型（可以类型简写），会显示为下拉框供用户选择 @property(TestEnum) enum: TestEnum; //字符串形式的枚举，不能使用类型简写，如：@property(Direction)。必须下面带type参数指定的标准写法 @property({ type: Direction }) direc: Direction; //字典类型，需要用数组参数来设置类型，下面示例中的Record类型需要放到字符串内作为数组参数的第一个元素，数组参数的第二个元素是字典输入值的类型，用于决定属性面板的输入控件类型 @property({ type: [\"Record\", Number] }) dict: Record; } 示例效果如动图3-4所示： （动图3-4） 3.2.6 组件属性值的输入控件 IDE内置了number（数字输入）、string（字符串输入）、boolean（多选框）、color（颜色框+调色盘+拾色器）、vec2（XY输入组合）、vec3（XYZ输入组合）、vec4（XYZW输入组合）、asset（选择资源），这些输入控件。 通常情况下，IDE会根据组件属性类型自动选择对应的属性值输入控件。 但在某些情况下，也需要强制指定输入控件。例如，数据类型是string，但其实它表达的是颜色，用默认编辑string的控件不适合，需要在这里设置组件属性标识的参数inspector为“color”。示例代码如下： //显示为颜色输入（如果类型是Laya.Color，则不需要这样定义，如果是字符串类型，则需要） @property({ type: String, inspector: \"color\"}) color: string; 注意：按照以上方法得到的颜色，是2D组件的颜色值，例如：rgba(217, 232, 0, 1) 效果如动图3-5所示： （动图3-5） 如果inspector参数为null，则不会为属性构造属性输入控件，这与hidden参数设置为true不同。hidden为true是创建但不可见，inspector为null则是完全不创建。 3.2.7 组件属性分类与排序 组件的属性默认会统一显示在以组件脚本名称的属性分类栏目下，效果如图3-6所示： （图3-6） 如果开发者想对组件内的某些属性进行归类，可以通过装饰器属性标识的对象参数catalog来实现，示例代码如下： @property({ type : \"number\" }) a : number; @property({ type: \"string\"}) b : string; @property({ type: \"boolean\",catalog:\"adv\"}) c : boolean; @property({ type: String, inspector: \"color\" ,catalog:\"adv\"}) d: string; 通过上面的代码可以看出，当为多个属性（c和d）设置相同的catalog名称（“adv”），就会按catalog名称进行分类。效果如图3-7所示： （图3-7） 如果我们想给这个分类再起个中文别名，可以通过参数catalogCaption来实现，示例代码如下（更改上述示例的d属性）： @property({ type: String, inspector: \"color\" ,catalog:\"adv\", catalogCaption:\"高级组件\"}) d: string; 效果如图3-8所示： （图3-8） 在面对多个组件属性分类的时候，我们还可以通过参数catalogOrder对栏目的显示顺序自定义排序。数值越小显示在前面，不提供则按属性出现的顺序。示例代码如下： @property({ type : \"number\", catalog:\"bb\", catalogOrder:1 }) a : number; @property({ type: \"string\"}) b : string; @property({ type: \"boolean\", catalog:\"adv\"}) c : boolean; @property({ type: String, inspector: \"color\", catalog:\"adv\", catalogCaption:\"高级组件\", catalogOrder:0}) d: string; 效果如图3-9所示： （图3-9） 属性分类名称catalogCaption与属性分类排序catalogOrder，在任意一个catalog相同名称的属性里配置即可，无需所有的属性都配置一次。 3.2.8 装饰器属性标识参数总结 上文介绍了常用装饰器属性标识的参数作用（加粗为上文出现过的），这里我们概述总结一下全部的参数。 参数名 参数使用示例 说明 name name: \"abc\" 一般不需要设定 type type: \"string\" 组件属性可输入值的类型，参照上文的介绍 caption caption: \"角度\" 组件属性的别名，常用中文，可以不设置，默认会用组件属性名 tips tips: \"这是一个文本对象，只能输入文本哦\" 组件属性的Tips说明，用于进一步描述该属性的作用等用途 catalog catalog:\"adv\" 为多个属性设置相同的值，可以将它们显示在同一个栏目内 catalogCaption catalogCaption:\"高级组件\" 属性分类栏目的别名，不提供则直接使用栏目名称 catalogOrder catalogOrder:0 栏目的显示顺序，数值越小显示在前面。不提供则按属性出现的顺序 inspector inspector: \"color\" 属性值输入控件，内置有：number,string,boolean,color,vec2,vec3,vec4,asset hidden hidden: \"!data.a\" true隐藏，false显示。可以直接使用布尔值，也可以使用表达式，通过将条件表达式放到字符串里，获得布尔类型的运算结果。字符串表达式内，data是一个固定名字的变量，它是当前类型的所有已注册属性的数据集合。表达式内可以使用所有js语法，但不能引用引擎相关类型，也不能使用Laya等全局对象。 readonly readonly: \"data.b\" true表示只读。可以直接使用布尔值，也可以使用表达式，通过将条件表达式放到字符串里，获得布尔类型的运算结果。（表达式的格式同上） validator validator: \"if (value == data.text1) return '不能与text1值相同' \" 可以使用表达式，将表达式放到字符串里。例如示例中，若在IDE中输入的值和text1的值相等，就会显示”不能与text1值相同“ serializable serializable： false 控制组件属性是否序列化保存，true：序列化保存，false：不序列化保存 multiline multiline: true 字符串类型时，是否为多行输入，true：是，false：不是 password password: true 是否密码输入，true：是，false：不是。密码输入会隐藏输入的内容 submitOnTyping submitOnTyping: false 如果设置为true，那么每次输入一个字符，就会提交一次。如果设置为false，那么只有当输入完成后，并且点击其它地方，让文本输入框失去焦点时，才会提交一次。 prompt prompt: \"文本提示信息\" 在输入文本前，文本框内会有一个提示信息 enumSource enumSource: [{name:\"Yes\", value:1}, {name:\"No\",value:0}] 组件属性以下拉框的形式来展示与输入值 reverseBool reverseBool: true 反转布尔值，当属性值为true时，多选框显示为不勾选 nullable nullable: true 是否允许null值，默认为true min min: 0 数字类型时，数字的最小值 max max: 10 数字类型时，数字的最大值 range range: [0, 5] 数字类型时，组件属性在一个范围内以滑动杆的方式显示与输入值 step step: 0.5 数字类型时，在输入框的鼠标滑动或滚轮滚动的最小更改精度值 fractionDigits fractionDigits: 3 数字类型时，属性值的小数点后保留几位 percentage percentage: true 将range参数设置为[0,1]时，可以让percentage为true，显示为百分比 fixedLength fixedLength: true 数组类型时，固定数组长度，不允许修改 arrayActions arrayActions: [\"delete\", \"move\"] 数组类型时，可限制数组可以进行的操作。如果不提供，表示数组允许所有操作，如果提供，则只允许列出的操作。提供的类型有：\"append\"，\"insert\" ，\"delete\" ，\"move\" elementProps elementProps: { range: [0, 10] } 对数组类型属性适用。这里可以定义数组元素的属性 showAlpha showAlpha: false 颜色类型时，表示是否提供透明度a值的修改。true表示提供，false表示不提供 defaultColor defaultColor: \"rgba(217, 232, 0, 1)\" 颜色类型时，定义一个非null时的默认颜色值 colorNullable colorNullable: true 颜色类型时，设置为true可显示一个checkbox决定颜色是否为null isAsset isAsset: true 说明此属性是引用一个资源 assetTypeFilter assetTypeFilter: \"Image\" 资源类型时，设置加载的资源类型 useAssetPath useAssetPath: true 属性类型是string，并且进行资源选择时，这个选项决定属性值是资源原始路径还是res://uuid这样的格式。默认false，如果是true，则是资源原始路径，一般不使用，因为如果资源改名，路径会丢失。 position position: \"before x\" 属性显示的顺序默认是在类型定义里出现的顺序，position可以人为改变这个顺序。可以使用的句型有：\"before x\"、\"after x\"、\"first\"、\"last\" private private：false 控制组件属性是否显示在IDE里，false：显示，true：不显示 addIndent addIndent:1 增加缩进，单位是层级，注意不是像素 onChange onChange: \"onChangeTest\" 当属性改变时，调用名称为onChangeTest的函数。函数需要在当前组件类上定义 代码示例如下（只列出上文没有介绍过的）： //隐藏控制 @property({ type: Boolean }) a: boolean; @property({ type: String, hidden: \"!data.a\" })//将条件表达式!data.a放在了字符串中，如果a为true（在IDE中为勾选状态），则!data.a返回false，此时hidden属性表示的是显示 hide: string = \"\"; // 只读控制 @property({ type: Boolean }) b: boolean; @property({ type: String, readonly: \"data.b\" })//将条件表达式data.b放在了字符串中，如果b为true（在IDE中为勾选状态），则data.b就返回true，此时readonly属性表示只读 read: string = \"\"; //数据检查机制 @property(String) text1: string; @property({ type: String, validator: \"if (value == data.text1) return '不能与a值相同' \" }) text2: string = \"\"; //密码输入 @property({ type: String, password: true }) password: string; //如果true或者缺省，文本输入每次输入都提交；否则只有在失焦时才提交 @property({ type: String, submitOnTyping: false }) submit: string; //输入文本的提示信息 @property({ type: \"text\", prompt: \"文本提示信息\" }) prompt: string; //显示为下拉框 @property({ type: Number, enumSource: [{name:\"Yes\", value:1}, {name:\"No\",value:0}] }) enumsource: number; //反转布尔值 @property({ type: \"boolean\", reverseBool: true }) reverseboolean : boolean; //允许null值 @property({ type: String, nullable: true }) nullable: string; //控制数字输入的精度和范围 @property({ type: Number, range:[0,5], step: 0.5, fractionDigits: 3 }) range : number; //显示为百分比 @property({ type: Number, range:[0,1], percentage: true }) percent : number; //固定数组长度 @property({ type: [\"number\"], fixedLength: true }) arr1: number[]; //数组允许的操作 @property({ type: [\"number\"], arrayActions: [\"delete\", \"move\"] }) arr2: number[]; //使数组元素编辑时限制最大值和最小值 @property({ type: [Number], elementProps: { range: [0, 100] } }) array1: Array; //如果是多维数组，则elementProps同样需要使用多层 @property({ type: [[Number]], elementProps: { elementProps: { range: [0, 10] } } }) array2: Array>; //不提供透明度a值的修改 @property({ type: Laya.Color, showAlpha: false }) color1: Laya.Color; //颜色类型时，defaultColor定义一个非null时的默认值 @property({ type: String, inspector: \"color\", defaultColor: \"rgba(217, 232, 0, 1)\" }) color2: string; //显示一个checkbox决定颜色是否为null @property({ type: Laya.Color, colorNullable: true }) color3: Laya.Color; //加载Image资源类型，设置资源路径格式 @property({ type: String, isAsset: true, assetTypeFilter: \"Image\" }) resource: string; //x属性出现在testposition属性之前 @property({ type: String }) x: string; //可以用position人为将testposition属性安排在x属性之前显示 @property({ type: String, position: \"before x\" }) testposition: string; //增加缩进，单位是层级 @property({ type: String, addIndent:1 }) indent1: string; @property({ type: String, addIndent:2 }) indent2: string; //当属性改变时，调用名称为onChangeTest的函数 @property({ type: Boolean, onChange: \"onChangeTest\"}) change: boolean; onChangeTest() { console.log(\"onChangeTest\"); } 3.2.9 装饰器属性标识特殊用法 除了以上列出的基本参数属性，@property还有一些特殊的组合用法。 类型属性嵌套数组或字典 示例如下： @property([[\"string\"]]) test1: string[][] = [[\"a\", \"b\", \"c\"], [\"e\", \"f\", \"g\"]]; @property([[\"Record\", \"string\"]]) test2: Array> = [{ name: \"A\", value: \"a\" }, { name: \"B\", value: \"b\" }]; @property({ type: [\"Record\", [Number]], elementProps: { elementProps: { range: [0, 10] } } }) test3: Record = { \"a\": [1, 2, 3], \"b\": [4, 5, 6] }; @property([\"Record\", [Laya.Prefab]]) test4: Record; 它的一个重要应用就是实现动态下拉框。前面3.2.8节介绍过有两种方式可以实现下拉框：一是设置属性类型为Enum，二是通过设置enumSource为数组。这两种方式都可以实现固定的下拉选项列表，但如果想让选项列表是动态的，可以使用以下方式： //这个属性提供一个get方法，返回下拉选项，这个数据一般只用于编辑器，所以设置不保存 @property({ type: [[\"Record\", String]], serializable: false }) get itemsProvider(): Array> { return [{ name: \"Item0\", value: \"0\" }, { name: \"Item1\", value: \"1\" }]; } //将enumSource设置为一个字符串，表示使用该名字的属性作为下拉数据源 @property({ type: String, enumSource: \"itemsProvider\" }) enumItems: string; 3.3 IDE中执行生命周期方法@runInEditor 除了在IDE属性面板上暴露组件属性，开发者还可以通过装饰器标识 @runInEditor来让组件在IDE内加载时也可以触发生命周期方法（onEnable、onStart等所有的组件脚本生命周期方法）。示例代码如下： const { regClass, property, runInEditor } = Laya; @regClass() @runInEditor //重点看这里，要放到类之前，@regClass()与@runInEditor谁先谁后都可以。 export class NewScript extends Laya.Script { @property({ type: Laya.Sprite3D }) sp3: Laya.Sprite3D; constructor() { super(); } onEnable() { console.log(\"Game onStart\", this.sp3.name); } } 除非有特别的需求，我们并不建议这样做，一方面是因为静态物体更有利于IDE内进行编辑。另一方面是因为场景编辑器为了性能优化，帧率刷新要比正常运行慢很多，因此效果会与正常运行有明显差异。 3.4 @classInfo() 装饰器标识@classInfo()主要有两个作用： 3.4.1 加入IDE的组件列表 开发者的自定义组件脚本默认都位于属性设置面板的增加组件->自定义组件脚本的下面，如动图3-10所示。 （动图3-10） 如果我们想在这个组件列表中，将该组件加入自己定义的组件列表分类中，可以使用装饰器标识@classInfo(),示例代码如下所示： const { regClass, property, classInfo } = Laya; @regClass() @classInfo( { menu : \"MyScript\", caption : \"Main\", }) export class Main extends Laya.Script { onStart() { console.log(\"Game start\"); } } 然后我们保存代码，回到IDE，会发现自定义的分类已出现在组件列表中。如动图3-11所示。 （动图3-11） 3.4.2 属性分组 假设用装饰器暴露了A、B、C、D、E，5个属性，显示效果如下： （图3-12） 当属性比较多时，可以将属性分组显示，就要用到@classInfo()了，@classInfo()可以为类型添加非数据类型的属性。例如，将BC两个属性显示在一个组里，实现方式如下： const { regClass, property, classInfo } = Laya; @regClass() @classInfo({ properties: [ { name: \"Group1\", inspector: \"Group\", options: { members: [\"b\", \"c\"] }, position: \"after a\" } ] }) export class NewScript extends Laya.Script { @property(String) public a: string = \"\"; @property(String) public b: string = \"\"; @property(String) public c: string = \"\"; @property(String) public d: string = \"\"; @property(String) public e: string = \"\"; } 其中，members指定了属于这个分组的属性名称列表。如果属性较多，也可以用这种格式 [ \"b~c\" ]，表示从属性b到属性c之间所有的属性。position是可选的，指示这个分组显示在哪里。显示效果如下： （图3-13） 四、代码中使用属性 前文已经介绍了组件组件的添加与识别。相信有一定基础的开发者已经可以直接使用LayaAir的实体组件系统了。 但针对一些新手开发者朋友，本小节通过几种常用类型的属性使用示例，进一步帮助大家理解组件化开发的基础。 4.1 节点类型方式 LayaAir分为2D节点与3D节点类型，当设置为2D节点Laya.Sprite时，不能将3D节点作为其属性值。当设置为3D节点Laya.Sprite3D时，不能将2D节点作为其属性值。 4.1.1 2D节点的使用 首先，如动图4-1所示，将场景中已经添加好的2D节点Sprite拖入到@property暴露的属性入口中，这样就获取到了此节点。 （动图4-1） 然后就可以在脚本中使用代码改变节点的属性了，例如，给Sprite添加纹理等，示例代码如下所示： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { @property({ type : Laya.Sprite}) public spr: Laya.Sprite; onAwake(): void { this.spr.size(512, 313); //设置Sprite大小 this.spr.loadImage(\"atlas/comp/image.png\"); //添加纹理 } } 效果如图4-2所示： （图4-2） 4.1.2 3D节点的基础使用 首先，如动图4-3所示，将场景中已经添加好的3D节点Cube拖入到@property暴露的属性入口中，这样就获取到了此节点。 （动图4-3） 然后就可以在脚本中使用代码改变节点的属性了，例如，可以让Cube绕自身旋转，示例代码如下所示： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { @property({ type : Laya.Sprite3D}) public cube: Laya.Sprite3D; private rotation: Laya.Vector3 = new Laya.Vector3(0, 0.01, 0); onStart() { Laya.timer.frameLoop(1, this, ()=> { this.cube.transform.rotate(this.rotation, false); }); } } 效果如动图4-4所示： （动图4-4） 4.1.3 3D节点的进阶使用 @property( { type :Laya.Sprite3D } ) //节点类型 public p3d: Laya.Sprite3D; onAwake(): void { this.p3d.transform.localPosition = new Laya.Vector3(0,5,5); let p3dRenderer = this.p3d.getComponent(Laya.ShurikenParticleRenderer); p3dRenderer.particleSystem.simulationSpeed = 10; } 通过暴露@property( { type :Laya.Sprite3D } )节点类型属性，来拖入particle节点，可以获得particle节点对象。transform可以直接修改，而simulationSpeed属性则通过getComponent(Laya.ShurikenParticleRenderer).particleSystem的方式获取。 4.2 组件类型的使用 @property( { type : Laya.ShurikenParticleRenderer } ) //组件类型 public p3dRenderer: Laya.ShurikenParticleRenderer; onAwake(): void { (this.p3dRenderer.owner as Laya.Sprite3D).transform.localPosition = new Laya.Vector3(0,5,5); this.p3dRenderer.particleSystem.simulationSpeed = 10; } 通过暴露@property( { type : Laya.ShurikenParticleRenderer } )组件类型属性，来拖入particle节点，可以获得particle的ShurikenParticleRenderer组件。transform可以通过(this.p3dRenderer.owner as Laya.Sprite3D)修改，而simulationSpeed属性则通过this.p3dRenderer.particleSystem的方式获取。 不能通过直接使用Laya.ShuriKenParticle3D作为属性类型，因为IDE无法识别，只有节点和组件类型可以识别。 就算将type类型设置为Laya.Sprite3D，这样IDE虽然标识了属性是Sprite3D节点，但也无法转换为Laya.ShuriKenParticle3D对象。 4.3 Prefab类型属性 当使用Laya.Prefab作为属性时，例如： @property( { type : Laya.Prefab } ) //加载 Prefab 的对象 private prefabFromResource: Laya.Prefab; 此时，需要按动图4-5所示，从assets目录下，拖入prefab资源。运行时会直接获取到加载实例化后的prefab。 （动图4-5） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2024-04-17 11:55:17 "},"basics/common/Loader/readme.html":{"url":"basics/common/Loader/readme.html","title":"资源加载","keywords":"","body":"LayaAir引擎的资源加载方法详解一、加载单个资源1.1 常用资源的加载方式1.2 带类型的加载方式二、加载多个资源2.1 省略类型的多资源加载方式2.2 可带类型的多资源加载方式2.3 统一类型的多资源加载方式三、不解析不缓存的加载资源四、Option参数LayaAir引擎的资源加载方法详解 Author: Charley 资源加载是游戏引擎的核心模块，是必须要使用的功能，LayaAir引擎提供了Loader类用于加载文本、JSON、二进制、图像等资源。 下面我们在本篇文档中彻底掌握各种资源加载的使用。 一、加载单个资源 1.1 常用资源的加载方式 通常，采用Laya.loader.load(\"资源路径\")方法加载单个资源，通过.then(\"回调方法\")来处理加载后的逻辑。 Laya.loader.load(url).then((res)=> {/** 不带类型，用于常规的资源 */}); 完整的脚本示例如下： const { regClass, property } = Laya; @regClass() export class LoaderDemo extends Laya.Script { onAwake(): void { this.loadTexture(\"resources/image/monkey2.png\", 500);//需要在resources/image放入相应的资源 this.loadTexture(\"https://layaair.com/3.x/demo/resources/res/apes/monkey2.png\"); } /**加载并显示图片 */ loadTexture(url: string, x: number = 0, y: number = 0): void { Laya.loader.load(url).then((res: Laya.Texture) => { let img = new Laya.Image(); img.texture = res; // img.skin = url; //ui组件直接设置skin也可以 img.pos(x, y); this.owner.addChild(img); }); } } 1.2 带类型的加载方式 有的时候，网络资源没有后缀名，又或者，图片xxx.png并非是当成Texture使用，需要被定义为TextureCube。所以，这些时候需要通过类型进行区分。 使用方式与不带类型的基本相同，只是增加load第二个参数：类型标识字符串。 Laya.loader.load(url, type).then((res)=> { //带类型，用于区别无后缀，或同一后缀不同作用的资源。 //例如，图片xxx.png被定义为TextureCube，使用load(\"xxx.png\", Laya.Loader.TEXTURECUBE)。得到的是TextureCube。 }); 完整的脚本示例如下： const { regClass, property } = Laya; @regClass() export class LoaderDemo extends Laya.Script { onAwake(): void { //下面的URL未来可能会失效，仅用于示例参考 this.loadHTMLImage(\"https://layaair.com/3.x/demo/resources/res/apes/monkey2.png\"); } /** 加载URL无后缀资源 */ loadHTMLImage(url: string): void { Laya.loader.load(url, Laya.Loader.IMAGE).then((res: Laya.Texture) => { let sp = new Laya.Sprite(); sp.texture = res; this.owner.addChild(sp); }); } } 常用类型如下： 引擎全局变量 类型标识字符串 类型说明 Laya.Loader.TEXT text 文本类型 Laya.Loader.JSON json JSON类型 Laya.Loader.XML xml XML类型 Laya.Loader.BUFFER arraybuffer 二进制类型 Laya.Loader.IMAGE image 纹理类型 Laya.Loader.SOUND sound 声音类型 Laya.Loader.VIDEO video 视频类型 Laya.Loader.ATLAS atlas 图集类型，加载完成后返回图集json信息(并创建图集内小图Texture) Laya.Loader.HIERARCHY HIERARCHY 层级资源，比如：场景ls文件与预制体lh文件 Laya.Loader.FONT font 位图字体类型 Laya.Loader.TTF ttf TTF字体类型 Laya.Loader.MESH MESH Mesh资源 Laya.Loader.MATERIAL MATERIAL Material资源 Laya.Loader.TEXTURE2D TEXTURE2D Texture2D资源 Laya.Loader.TEXTURECUBE TEXTURE2D TextureCube资源 Laya.Loader.SPINE SPINE Spine资源 二、加载多个资源 有很多时候，我们需要把大量的资源在Loading界面进行预加载，这样走完加载进度条再进游戏，就会直接显示资源，不会产生资源空白的加载等待现象。 此时，我们就需要用到多个资源加载的方式。 2.1 省略类型的多资源加载方式 如果我们只是加载比较常用的资源，通过文件后缀就可以识别出来，那么省略类型的方式，肯定更为简洁。 加载多个的API和加载单个基本相同，只是加载多个时，第一个参数是资源地址数组 Laya.loader.load([url1, url2]).then((res:Array)=> { /** 加载多个，不带类型，用于常规的资源 */ }); 完整的脚本示例如下： const { regClass, property } = Laya; @regClass() export class LoaderDemo extends Laya.Script { onAwake(): void { let resArr: Array = [ \"image/bird.jpg\", \"image/cloud.png\", \"https://layaair.com/3.x/demo/resources/res/apes/monkey2.png\" ]; this.loadTextures(resArr); } /** 加载多个资源 * @param url 资源数组 */ loadTextures(url: Array): void { Laya.loader.load(url).then((res: Array) => { let sp: Laya.Sprite = new Laya.Sprite(); this.owner.addChild(sp); let i: number = 0; //每秒重画一次 Laya.timer.loop(1000, this, () => { i == res.length && (i = 0); //清除sp节点的所有绘图（不含子节点） sp.graphics.clear(); //在sp节点上重绘纹理 sp.graphics.drawTexture(res[i]); i++; }); }); } } 2.2 可带类型的多资源加载方式 假如，多数资源不需要带类型，有的资源又需要用类型区别，该如何使用加载方法呢？ 在资源数组里，为需要带类型的传入类型，不需要的传类型的，仍然可以省略。 Laya.loader.load([url1, { url:url2, type: type }]).then((res:Array)=> { /** 加载多个，按需设置类型，满足各种需要 */ }); 完整的脚本示例如下： const { regClass, property } = Laya; @regClass() export class LoaderDemo extends Laya.Script { onAwake(): void { let resArr: Array = [ \"image/bird.jpg\", \"image/cloud.png\", { url: \"https://layaair.com/3.x/demo/resources/res/apes/monkey2.png\", type: \"image\" }, { url: \"https://layaair.com/3.x/demo/resources/res/apes/monkey1.png\", type: Laya.Loader.IMAGE } ]; this.loadTextures(resArr); } /** 加载多个资源 * @param url 资源数组 */ loadTextures(url: Array): void { //加载回调返回的类型，如果是多样的，最好是any Laya.loader.load(url).then((res: Array) => { let sp: Laya.Sprite = new Laya.Sprite(); this.owner.addChild(sp); let i: number = 0; //每秒重画一次 Laya.timer.loop(1000, this, () => { i == res.length && (i = 0); //清除sp节点的所有绘图（不含子节点） sp.graphics.clear(); //在sp节点上重绘纹理 sp.graphics.drawTexture(res[i]); i++; }); }); } } 示例上的类型，故意采用了字符串标识和引擎全局变量标识两种方式。开发者用哪一种都可以。具体参照1.2的类型标识表格。 2.3 统一类型的多资源加载方式 也有的时候，加载的多资源，都需要使用类型标识，而这些类型都是同一种类型，例如，加载的全都是无后缀的URL资源。 这时，我们可以统一设置类型标识。 Laya.loader.load([url1, url2], type).then((res:Array)=> { /** 加载多个，统一类型，简洁实用 */ }); 完整的脚本示例如下： const { regClass, property } = Laya; @regClass() export class LoaderDemo extends Laya.Script { onAwake(): void { let resArr: Array = [ \"image/bird.jpg\", \"https://layaair.com/3.x/demo/resources/res/apes/monkey2.png\", \"image/cloud.png\", \"https://layaair.com/3.x/demo/resources/res/apes/monkey2.png\", ]; this.loadTextures(resArr); } /** 加载多个资源 * @param url 资源数组 */ loadTextures(url: Array): void { //加载回调返回的类型，如果不确定就any Laya.loader.load(url, Laya.Loader.IMAGE).then((res: Array) => { let sp: Laya.Sprite = new Laya.Sprite(); this.owner.addChild(sp); let i: number = 0; //每秒重画一次 Laya.timer.loop(1000, this, () => { i == res.length && (i = 0); //清除sp节点的所有绘图（不含子节点） sp.graphics.clear(); //在sp节点上重绘纹理 sp.graphics.drawTexture(res[i]); i++; }); }); } } 三、不解析不缓存的加载资源 引擎提供的load()方法加载资源，可能会在解析后做一些封装。 比如我们用load()方法加载一个json数据，需要在data里才能取到json文件里的数据。 使用load()方法，示例如下： onEnable(): void { const jsonPath: string = \"json/bagList.json\"; Laya.loader.load(jsonPath).then((json) => { let _json = json.data; if (_json.bagList && _json.bagList.length > 0) { //把json数据传递给list组件的数据源属性array this.bagList.array = _json.bagList; } }); } 而我们使用fetch()方法，则可以直接取到json文件里的数据。但需要注意的是，采用fetch加载的资源不会缓存，只能在加载完成的回调里使用，无法通过getRes读取加载缓存。 使用fetch()方法，示例如下： onEnable(): void { const jsonPath: string = \"json/bagList.json\"; //fetch取到的是原始数据，但没有缓存，无法用getRes获取 Laya.loader.fetch(jsonPath, \"json\").then((_json) => { if (_json.bagList && _json.bagList.length > 0) { //把json数据传递给list组件的数据源属性array this.bagList.array = _json.bagList; } }); } fetch的加载限定为以下类型： 类型标识字符串 资源类型 text string json any xml XMLDocument arraybuffer ArrayBuffer image HTMLImageElement \\ImageBitmap sound HTMLAudioElement 在使用的时候，第二个参数那里填写对应的类型标识字符串即可。 更多fetch加载代码示例请参考《使用二进制图片》文档 Tips​ 除非是明确理解fetch的使用用途，否则不推荐开发者使用。 四、Option参数 当使用load()方法或者fetch()方法加载资源时，可以使用到Option参数，例如代码： //创建Option let option:any = {}; option.blob = this.imgBlob; //通过传递blob对象获得HTMLImageElement Laya.loader.fetch(\"\" ,\"image\", null, option).then((res)=>{ }); 通过Option参数指定fetch()方法，传递blob对象获得HTMLImageElement 目前支持的Option参数： export interface ILoadOptions { type?: string; //资源类型。比如：Loader.IMAGE。 priority?: number; //(default = 0)加载的优先级，数字越大优先级越高，优先级高的优先加载。 group?: string; //分组，方便对资源进行管理。 cache?: boolean; //是否缓存 noRetry?: boolean; //是否重新尝试加载 silent?: boolean; //是否提示加载失败 useWorkerLoader?: boolean; //(default = false)是否使用worker加载（只针对IMAGE类型和ATLAS类型，并且浏览器支持的情况下生效） constructParams?: TextureConstructParams; //图片属性，参考如下 propertyParams?: TexturePropertyParams; //纹理属性，参考如下 blob?: ArrayBuffer; //传递blob对象获得HTMLImageElement noMetaFile?: boolean; //是否不去下载Meta(json)文件 [key: string]: any; } TextureConstructParams { width?: number, height?: number, format?: TextureFormat, mipmap?: boolean, canRead?: boolean, sRGB?: boolean, } TexturePropertyParams { wrapModeU?: number, wrapModeV?: number, filterMode?: FilterMode, anisoLevel?: number, premultiplyAlpha?: boolean, hdrEncodeFormat?: HDREncodeFormat, } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-07-28 19:28:36 "},"basics/common/Scene/readme.html":{"url":"basics/common/Scene/readme.html","title":"场景管理","keywords":"","body":"场景的管理一、IDE中的场景1.1 新建场景1.2 场景划分1.3 autoDestroyAtClosed属性1.4 mouseThrough属性二、代码中使用2.1 场景类2.2 打开场景2.3 关闭场景2.4 场景的加载页面2.5 销毁和垃圾回收场景的管理 LayaAir3.0继续延用2.0开发思路为组件化，脚本化，场景管理开发，项目采用Scene管理方式，来管理场景，LayaAir 已经对Scene做了一系列方案，使得开发者无需考虑场景，关卡，页面的资源，内存管理，只需要单纯的调用接口，管理场景，其他的交给引擎去做，只需专注游戏逻辑开发即可。 在2.0项目开发中，无论是创建场景Scene，页面View，对话框Dialog，3d场景scene3d，文件类型和后缀都是scene。但是3.0中场景的划分有所区别，不再是统一的后缀scene方式。 一、IDE中的场景 1.1 新建场景 使用IDE新建一个3D项目，在IDE中创建一个场景，并保存，默认情况下，会在assets目录下，保存为Scene1.ls。如动图1-1所示 （动图1-1） 通过资源管理器打开assets目录，可以看到Scene1的后缀是ls文件，这个场景ls文件，与2.0的区别是，它包括了Scene3D场景和Scene2D场景。如图1-2所示 （图1-2） Scene3D：编辑3D场景的根节点，可以参考《3D场景编辑的基础交互》文档和《3D场景环境设置》文档来详细了解3D场景的操作和使用，如图1-3所示 （图1-3） Scene2D：编辑2D场景的根节点，可以参考《UI编辑器基础交互》文档和《UI运行时》文档来详细了解2D场景的操作和代码使用，如图1-4所示 （图1-4） 但是重要的一点是，在同一个IDE创建的场景中，可以支持编辑3D场景和2D场景 1.2 场景划分 如果针对某个场景，开发者只需要3D场景或者只需要2D场景，那怎么办呢？ 对于只需要2D场景时，可以点击Scene3D，点击鼠标右键选择删除，那么剩下的场景就是一个单纯的Scene2D场景，如图1-5所示 （图1-5） 对于只需要3D场景时，可以发现Scene2D是不可以删掉的，如图1-6所示 （图1-6） 之所以无法删除，是因为Scene2D有一个很重要的属性 Auto Destroy At Closed 只要不编辑Scene2D，那么Scene2D只是带有属性的一个Sprite节点，不会对3D场景有任何影响 1.3 autoDestroyAtClosed属性 /**场景被关闭后，是否自动销毁（销毁节点和使用到的资源），默认为false*/ autoDestroyAtClosed: boolean = false; 当勾选 Auto Destroy At Closed后，场景在关闭时会自动调用场景的销毁 Destroy() 方法 1.4 mouseThrough属性 另外一个属性是 Mouse Through，默认是勾选的 由于2D场景和3D场景都可以接收鼠标事件，这时可能会有冲突。 如果勾选 Mouse Through，Scene2D下脚本事件 onMouseClick 等将不会响应，会传递到Scene3D中 如果不勾选 Mouse Through，Scene2D下脚本事件 onMouseClick 等将会响应 二、代码中使用 2.1 场景类 /** * 场景类，负责场景创建，加载，销毁等功能 * 场景被从节点移除后，并不会被自动垃圾机制回收，如果想回收，请调用destroy接口，可以通过unDestroyedScenes属性查看还未被销毁的场景列表 */ export class Scene extends Sprite { /**创建后，还未被销毁的场景列表，方便查看还未被销毁的场景列表，方便内存管理，本属性只读，请不要直接修改*/ static readonly unDestroyedScenes: Set = new Set(); /**场景被关闭后，是否自动销毁（销毁节点和使用到的资源），默认为false*/ autoDestroyAtClosed: boolean = false; _scene3D: any; 场景类首先继承自Sprite，也就是本身是一个Scene2D节点，编辑2D界面，实际上就是在它下面添加2D子节点组件。而属性 _scene3D是用来管理Scene3D的，这与IDE中对应的Scene2D和Scene3D相关联。 2.2 打开场景 1，基础使用 首先来看看场景类中最基础的使用方式，打开一个场景 /** * 加载并打开场景 * @param url 场景地址 * @param closeOther 是否关闭其他场景，默认为true（可选），【注意】被关闭的场景，如果没有设置autoDestroyAtClosed=true，则资源可能不能被回收，需要自己手动回收 * @param param 打开页面的参数，会传递给onOpened方法（可选） * @param complete 打开完成回调，返回场景实例（可选） * @param progress 加载进度回调（可选） */ static open(url: string, closeOther: boolean = true, param: any = null, complete: Handler = null, progress: Handler = null): Promise { Scene.showLoadingPage(); return Scene.load(url, Handler.create(null, this._onSceneLoaded, [closeOther, complete, param]), progress); } （图2-1） 例如创建名为 OpenScene 的场景，保存在assets路径下 uiDemo/page/OpenScene.ls，代码中可以这样打开场景，同时不关闭其它场景 Laya.Scene.open(\"uiDemo/page/OpenScene.ls\", false); 也可以打开一个预制体实现的UI，例如代码 Laya.Scene.open(\"dailog.lh\"); 运行效果如动图2-2所示 （动图2-2） 2，传参与接收参数 项目中有Scene.ls和Msg.ls两个场景，可以在Scene场景中通过 Laya.Scene.open 附带传递参数给Msg场景，代码如下所示： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { @property({ type: Laya.Button }) public uiBtn: Laya.Button; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { this.uiBtn.on(Laya.Event.CLICK, this, () => { //点击后，打开Msg场景 Laya.Scene.open(\"Msg.ls\", false, { \"text\": \"点击成功！\" }); }); } } 其中，Scene场景有一个Button组件，需要在IDE中，将其拖入到@property暴露的属性入口中。 Scene场景传递的参数数据为 { \"text\": \"点击成功！\" }，在Msg场景的Runtime中，onOpened方法会接受传入的参数，param.text 的值就是文本 \"点击成功！\"，代码如下所示： const { regClass } = Laya; import { MsgRTBase } from \"./MsgRT.generated\"; @regClass() export class MsgRT extends MsgRTBase { onOpened(param: any): void { console.log(param.text); } } 这样，点击Scene场景中的Button，就会打印日志“点击成功！”，效果如动图2-3所示： （动图2-3） 2.3 关闭场景 1，关闭指定的场景 /** * 根据地址，关闭场景（包括对话框） * @param url 场景地址 * @param name 如果name不为空，name必须相同才能关闭 * @return 返回是否关闭成功，如果url找不到，则不成功 */ static close(url: string, name?: string): boolean { 例如通过传入指定的地址参数，来关闭某一个场景 Laya.Scene.close(\"uiDemo/page/OpenScene.ls\"); 2，关闭当前场景 this.close() （图2-4） 采用Runtime的方式，可以方便使用 this.close() 来关闭场景 3，关闭所有场景（不包括dialog） /** * 关闭所有场景，不包括对话框，如果关闭对话框，请使用Dialog.closeAll() * 【注意】被关闭的场景，如果没有设置autoDestroyAtRemoved=true，则资源可能不能被回收，需要自己手动回收 */ static closeAll(): void { 4，关闭后调用的生命周期方法 /** * 关闭完成后，调用此方法（如果有关闭动画，则在动画完成后执行） * @param type 如果是点击默认关闭按钮触发，则传入关闭按钮的名字(name)，否则为null。 */ onClosed(type: string = null): void { } 场景的Runtime类，当场景关闭的时候，会被调用 onClosed() 方法，可以在方法内实现各种资源的释放 2.4 场景的加载页面 Laya.Scene.setLoadingPage(loadPage: Sprite) 设置loading界面，引擎会在调用open方法后，延迟打开loading界面，在页面添加到舞台之后，关闭loading界面 Laya.Scene.showLoadingPage(param: any = null, delay: number = 500) 显示loading界面，打开参数，如果是scene，则会传递给 onOpened 方法。延迟打开时间，默认500毫秒 Laya.Scene.hideLoadingPage(delay: number = 500) 隐藏loading界面，延迟关闭时间，默认500毫秒。 例如要打开一个新场景，使用加载页面，那么就先定义一个脚本代码，加入可能拖入loading场景的Laya.Prefab属性，代码如下： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { //declare owner : Laya.Sprite3D; @property({ type: Laya.Prefab }) private loadingScenePrefab: Laya.Prefab; private loadingScene: Laya.Node; constructor() { super(); } /** * 第一次执行update之前执行，只会执行一次 */ onStart(): void { //创建Loading场景 this.loadingScene = this.loadingScenePrefab.create(); //设置Loading场景 Laya.Scene.setLoadingPage(this.loadingScene as Laya.Sprite); //手动调用显示Loading场景 Laya.Scene.showLoadingPage(this.loadingScene); Laya.timer.once(3000,this,()=>{ //3秒后跳转到Game场景 Laya.Scene.open(\"Game.ls\"); }) } } 在打开的场景Scene.ls下，挂上脚本，并拖入Loading.lh作为场景。 （图2-5） 这样就可以使用Loading场景作为加载场景了。 2.5 销毁和垃圾回收 /** * 根据地址，销毁场景（包括对话框） * @param url 场景地址 * @param name 如果name不为空，name必须相同才能关闭 * @return 返回是否销毁成功，如果url找不到，则不成功 */ static destroy(url: string, name?: string): boolean { /** * 销毁当前没有被使用的资源,该函数会忽略lock=true的资源。 */ static gc(): void { Resource.destroyUnusedResources(); } 代码使用如下： Laya.Scene.destroy(\"scene.ls\"); Laya.Scene.gc(); Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-07-17 17:44:40 "},"basics/common/Node/readme.html":{"url":"basics/common/Node/readme.html","title":"节点管理","keywords":"","body":"节点的管理添加查找改变移除节点的管理 类似HTML，整个HTML由各种节点组成，根节点就是HTML标签，然后下面就是各个子节点，然后子节点再套子节点，形成了一个节点树，然后浏览器依据这个节点树进行渲染，然后就把我们需要的页面渲染出来，Laya 其实也是一样，不同的组件和场景组成了一个节点树，交给Laya 引擎渲染。 节点是项目开发的基础，只有充分了解如何操作节点，才能更快的实现复杂的需求。每个节点组件类都是继承自Node类，Node类是可放在显示列表中的所有对象的基类。该显示列表管理 Laya 运行时中显示的所有对象。使用 Node 类排列显示列表中的显示对象。Node 对象可以有子显示对象。 下面来熟悉一下Node类的所有基础的功能 添加 添加子节点addChild(node:Node) 在不考虑层级的情况下，我们可以给某个节点添加子节点，可让子节点跟随父节点显示与否，移动，以及方便管理。添加的子节点会加到所有子节点的最后面。 添加子节点到指定的索引位置addChildAt(index:number) 往往要考虑到节点的层级关系或者说遮挡关系，并且已经了解到需要添加到指定的层级位置可使用此方法 批量添加子节点addChildren(...args:any[]) 直接把一组子节点按顺序添加到父节点下，相当于循环调用一次addChild子节点 查找 根据名字，获取子节点对象getChildByName(name: string) 当我们知道某个节点的名字时，可以用个此方法找到父节点下一级的某个子节点 根据子节点的索引位置，获取子节点对象getChildAt(index:number) 当我们知道某个节点的索引位置时，可以用个此方法找到父节点下一级的某个子节点 根据子节点对象，获取子节点的索引位置getChildIndex(node:Node) 当我们想知道某个节点的索引位置时，可以用个此方法可获取子节点 获取子节点对象数量numChildren 通过调用父节点的numChildren属性，可以获得父节点下一级的所有子节点的数量，可用来遍历所有子节点使用，注意不包括子节点下的子节点 获取父节点对象parent 通过调用子节点的parent属性，可以直接获取父节点 当前容器是否包含指定的节点对象contains(node: Node) 判断一个节点下是否包含某个子节点，可以使用此方法，注意此查找过程会遍历所有嵌套的子节点 检查本节点是否是某个节点的上层节点isAncestorOf(node: Node) 改变 设置子节点的索引位置setChildIndex(node:Node,index:number) 如果想改变子节点的显示层级，可以调用此方法，注意index超出父节点的所有节点数会抛出异常 传入新节点替换到已有子节点索引位置replaceChild(newNode: Node, oldNode: Node) 如果想用新的节点替换某个已有节点，可以调用此方法，注意原有的子节点将会被移除，但不会销毁 移除 删除子节点removeChild(node: Node) 删除子节点的时调用此方法，注意子节点将会被移除，但不会销毁 从父容器删除自己removeSelf() 在不需要知道父节点的情况下，调用此方法可直接从父节点删除自己，此方法使用频率比较多 根据名字删除对应子节点removeChildByName(name: string) 当我们知道某个节点的名字时，可以用个此方法从父节点删除子节点 根据索引位置删除对应子节点removeChildAt(index: number) 当我们知道某个节点的索引位置时，可以用个此方法从父节点删除子节点 删除指定索引区间的所有子节点removeChildren(beginIndex: number = 0, endIndex: number = 0x7fffffff) 此方法可以快速删除指定索引区间的所有子节点 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:15 "},"basics/common/Timer/readme.html":{"url":"basics/common/Timer/readme.html","title":"定时器","keywords":"","body":"定时器1. 帧间隔1.1 定时执行一次 (基于帧率)1.2 定时重复执行 (基于帧率)2. 时间间隔2.1 定时执行一次 (单位为毫秒)2.2 定时重复执行(单位为毫秒)3. 暂停定时器执行4. 当前帧延迟执行5. 清理定时器6. 立即执行并删除定时器定时器 定时器 Laya.Timer 是时钟管理类。它是一个单例，不要手动实例化此类，应该通过 Laya.timer 访问。 同时 Laya.Timer 表示游戏主时针，同时也是管理场景、动画、缓动等效果时钟，通过控制本时钟缩放可以达到快进慢播的效果。 1. 帧间隔 1.1 定时执行一次 (基于帧率) Laya.timer.frameOnce，定义如下： /** * 定时执行一次(基于帧率)。 * @param delay 延迟几帧(单位为帧)。 * @param caller 执行域(this)。 * @param method 定时器回调函数。 * @param args 回调参数。 * @param coverBefore 是否覆盖之前的延迟执行，默认为 true 。 */ frameOnce(delay: number, caller: any, method: Function, args: any[] = null, coverBefore: boolean = true): void { this._create(true, false, delay, caller, method, args, coverBefore); } 使用示例如下： const { regClass } = Laya; import { RuntimeScriptBase } from \"./RuntimeScript.generated\"; @regClass() export class RuntimeScript extends RuntimeScriptBase { onAwake(): void { //60帧后，图片的透明度变为0.5 Laya.timer.frameOnce(60, this, () => { this.Image.alpha = 0.5; }) } } 1.2 定时重复执行 (基于帧率) Laya.timer.frameLoop，定义如下： /** * 定时重复执行(基于帧率)。 * @param delay 间隔几帧(单位为帧)。 * @param caller 执行域(this)。 * @param method 定时器回调函数。 * @param args 回调参数。 * @param coverBefore 是否覆盖之前的延迟执行，默认为 true 。 */ frameLoop(delay: number, caller: any, method: Function, args: any[] = null, coverBefore: boolean = true): void { this._create(true, true, delay, caller, method, args, coverBefore); } 使用示例如下： const { regClass } = Laya; import { RuntimeScriptBase } from \"./RuntimeScript.generated\"; @regClass() export class RuntimeScript extends RuntimeScriptBase { onAwake(): void { //每60帧后，图片的透明度减少0.1 Laya.timer.frameLoop(60, this, () => { this.Image.alpha -= 0.1; }) } } 2. 时间间隔 2.1 定时执行一次 (单位为毫秒) Laya.timer.once，定义如下： /** * 定时执行一次。 * @param delay 延迟时间(单位为毫秒)。 * @param caller 执行域(this)。 * @param method 定时器回调函数。 * @param args 回调参数。 * @param coverBefore 是否覆盖之前的延迟执行，默认为 true 。 */ once(delay: number, caller: any, method: Function, args: any[] = null, coverBefore: boolean = true): void { this._create(false, false, delay, caller, method, args, coverBefore); } 使用示例如下： const { regClass } = Laya; import { RuntimeScriptBase } from \"./RuntimeScript.generated\"; @regClass() export class RuntimeScript extends RuntimeScriptBase { onAwake(): void { //1秒后，图片的透明度变为0.5 Laya.timer.once(1000, this, () => { this.Image.alpha = 0.5; }) } } 2.2 定时重复执行(单位为毫秒) Laya.timer.loop，定义如下： /** * 定时重复执行。 * @param delay 间隔时间(单位毫秒)。 * @param caller 执行域(this)。 * @param method 定时器回调函数。 * @param args 回调参数。 * @param coverBefore 是否覆盖之前的延迟执行，默认为 true 。 * @param jumpFrame 时钟是否跳帧。基于时间的循环回调，单位时间间隔内，如能执行多次回调，出于性能考虑，引擎默认只执行一次，设置jumpFrame=true后，则回调会连续执行多次 */ loop(delay: number, caller: any, method: Function, args: any[] = null, coverBefore: boolean = true, jumpFrame: boolean = false): void { var handler: TimerHandler = this._create(false, true, delay, caller, method, args, coverBefore); if (handler) handler.jumpFrame = jumpFrame; } 使用示例如下： const { regClass } = Laya; import { RuntimeScriptBase } from \"./RuntimeScript.generated\"; @regClass() export class RuntimeScript extends RuntimeScriptBase { onAwake(): void { //每1秒后，图片的透明度减少0.1 Laya.timer.loop(1000, this, () => { this.Image.alpha -= 0.1; }) } } 3. 暂停定时器执行 一旦定时器暂停，游戏将处于静止状态： /** * 暂停时钟 */ pause(): void { this.scale = 0; } /** * 恢复时钟 */ resume(): void { this.scale = 1; } 4. 当前帧延迟执行 当前帧执行后立即执行。渲染之前执行，比延迟一帧的定时器，执行优先级更高： /** * 延迟执行。 * @param caller 执行域(this)。 * @param method 定时器回调函数。 * @param args 回调参数。 */ callLater(caller: any, method: Function, args: any[] = null): void { CallLater.I.callLater(caller, method, args); } 使用示例如下： const { regClass } = Laya; import { RuntimeScriptBase } from \"./RuntimeScript.generated\"; @regClass() export class RuntimeScript extends RuntimeScriptBase { onAwake(): void { //循环调用10次，但是定时器回调函数只执行一次，即\"hideImage\"日志只打印一次 for (let i = 0; i 5. 清理定时器 Laya.timer.clear：清理指定的定时器。定义如下： /** * 清理定时器。 * @param caller 执行域(this)。 * @param method 定时器回调函数。 */ clear(caller: any, method: Function): void { var handler: TimerHandler = this._getHandler(caller, method); if (handler) { handler.clear(); } } Laya.timer.clearAll：清理对象指定作用域的所有定时器。定义如下： /** * 清理对象身上的所有定时器。 * @param caller 执行域(this)。 */ clearAll(caller: any): void { if (!caller) return; for (var i: number = 0, n: number = this._handlers.length; i 建议在一个模块功能销毁之前，清理定时器或者清除所有的定时器。 6. 立即执行并删除定时器 Laya.timer.runCallLater：立即执行callLater，执行后删除。定义如下： /** * 立即执行 callLater 。 * @param caller 执行域(this)。 * @param method 定时器回调函数。 */ runCallLater(caller: any, method: Function): void { CallLater.I.runCallLater(caller, method); } 使用示例如下： const { regClass } = Laya; import { RuntimeScriptBase } from \"./RuntimeScript.generated\"; @regClass() export class RuntimeScript extends RuntimeScriptBase { onAwake(): void { //延迟一帧执行hideImage Laya.timer.callLater(this, this.hideImage); //当前帧立即执行hideImage，执行后删除定时器 Laya.timer.runCallLater(this, this.hideImage); } hideImage(): void { console.log(\"hideImage\"); this.Image.visible = false; } } 注：上述示例会打印一个\"hideImage\"，因为LayaAir中的runCallLater执行回调后，会删除定时器。如果不删除定时器，当前帧执行完runCallLater的回调hideImage后，还会执行callLater的回调hideImage，就会打印出两个\"hideImage\"。 Laya.timer.runTimer：立即提前执行定时器，执行之后从队列中删除。定义如下： /** * 立即提前执行定时器，执行之后从队列中删除 * @param caller 执行域(this)。 * @param method 定时器回调函数。 */ runTimer(caller: any, method: Function): void { var handler: TimerHandler = this._getHandler(caller, method); if (handler && handler.method != null) { this._map[handler.key] = null; handler.run(true); } } 使用示例如下： const { regClass } = Laya; import { RuntimeScriptBase } from \"./RuntimeScript.generated\"; @regClass() export class RuntimeScript extends RuntimeScriptBase { onAwake(): void { //如果没有Laya.timer.runTimer，则5秒后才执行hideImage Laya.timer.loop(5000, this, this.hideImage); //立即执行hideImage Laya.timer.runTimer(this, this.hideImage); } hideImage(): void { console.log(\"hideImage\"); this.Image.visible = false; } } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-07-24 16:48:25 "},"basics/common/Event/readme.html":{"url":"basics/common/Event/readme.html","title":"事件管理","keywords":"","body":"事件管理1. 认识事件1.1 什么是事件1.2 事件的分类2. 引擎内置的事件2.1 事件类型 Laya.Event2.2 事件派发 Laya.EventDispatcher2.3 事件处理 Laya.Handler3. 自定义的事件事件管理 1. 认识事件 1.1 什么是事件 事件Event指的是由系统事先设定的、能被对象识别和响应的动作，事件是指对象对于外部动作的响应，当对方发生了某个事件，就会执行于此事件对应的代码。比如用鼠标在一个对象上按下，这个对象预先设定了识别鼠标按下这个事件，就会执行对应的代码。 1.2 事件的分类 1，引擎内置的事件 2，自定义的事件 我们使用的事件可以是引擎内置的事件，也可以是自定义的事件，使用自定义类型的事件叫自定义事件。 2. 引擎内置的事件 LayaAir3.0引擎中的事件主要包含三部分 Laya.Event 事件类型，事件接口，不同的事件类型都要实现此接口。 Laya.EventDispatcher 事件派发，每个传递过来的事件都会由它分发给特定的处理者。 Laya.Handler 事件处理，不同的处理器需实现该接口。 2.1 事件类型 Laya.Event Laya.Event 是事件类型的集合，当事件发生时Laya.Event对象将作为参数传递给事件侦听器。如图2-1，事件类型请参考API文档。 （图2-1） 例如 Laya.Event.CLICK:string = \"click\"。CLICK 静态属性用于定义事件对象的type类型属性值为单击事件。这个事件是由鼠标点击触发后系统派发的事件，开发者也可以调用event()方法派发这些事件，如何派发事件会在下面的内容涉及。 （图2-2） 点击图2-2中3个按钮的任意一个，可以进入对应的功能。我们看看代码是如何使用CLICK 的（以下代码来自“2D入门示例”）： onEnable(): void { console.log(\"IndexRT onEnable\") //侦听ui按钮点击事件 this.uiBtn.on(Laya.Event.CLICK, this, () => { //点击后，打开UI场景示例 console.log(\"uiBtn\"); Laya.Scene.open(\"scenes/UiMain.ls\"); }); //侦听物理按钮点击事件 this.phyBtn.on(Laya.Event.CLICK, this, () => { //点击后，打开物理游戏示例 console.log(\"phyBtn\"); Laya.Scene.open(\"scenes/PhysicsGameMain.ls\"); }); //侦听3D混合按钮点击事件 this.d3Btn.on(Laya.Event.CLICK, this, () => { //点击后，打开3D混合场景示例 console.log(\"d3Btn\"); Laya.Scene.open(\"scenes/D3Main.ls\"); }); } 2.2 事件派发 Laya.EventDispatcher 事件派发Laya.EventDispatcher模式是侦听模式的一种扩展，由事件驱动，每当有事件产生的时候，由事件分发器Laya.EventDispatcher分发给特定的事件处理器Laya.Handler 处理该事件。Laya.EventDispatcher表示事件发送者、事件捕获传递与分发。 Laya.EventDispatcher 事件分发器是可调度事件类的基类，比如作为基础节点的Node类继承自Laya.EventDispatcher类，只要继承此类就可以作为一个事件发送者发送事件给它的侦听者。那么比如上面示例代码中的Button就是继承自Laya.EventDispatcher，可以用.on的方法来侦听CLICK`事件。 Laya.EventDispatcher 具有如下功能： 2.2.1 事件派发 event /** * 派发事件。 * @param type 事件类型。 * @param data （可选）回调数据。注意：如果是需要传递多个参数 p1,p2,p3,...可以使用数组结构如：[p1,p2,p3,...] ；如果需要回调单个参数 p ，且 p 是一个数组，则需要使用结构如：[p]，其他的单个参数 p ，可以直接传入参数 p。 * @return 此事件类型是否有侦听者，如果有侦听者则值为 true，否则值为 false。 */ event(type: string, data: any = null) 用于派发事件，例如我们可以在代码中来派发一个CLICK事件 : //侦听ui按钮点击事件 this.uiBtn.on(Laya.Event.CLICK, this, () => { //点击后，打开UI场景示例 console.log(\"uiBtn\"); Laya.Scene.open(\"scenes/UiMain.ls\"); }); //uiBtn自己派发一个点击事件，由于上面有侦听，则立即执行打开uiMain场景 this.uiBtn.event(Laya.Event.CLICK); 2.2.2 持续事件侦听 on /** * 使用 EventDispatcher 对象注册指定类型的事件侦听器对象，以使侦听器能够接收事件通知。 * @param type 事件的类型。 * @param caller 事件侦听函数的执行域。 * @param listener 事件侦听函数。 * @param args （可选）事件侦听函数的回调参数。 * @return 此 EventDispatcher 对象。 */ on(type: string, caller: any, listener: Function, args: any[] = null) 用于向事件派发器注册指定类型的事件侦听器，使事件侦听器能够接收事件通知。当侦听到事件后，会调用作用域 caller 的回调方法 listener。 上述2.2.1的示例中 this.uiBtn.on 是使用了持续侦听。 2.2.3 单次事件侦听 once /** * 使用 EventDispatcher 对象注册指定类型的事件侦听器对象，以使侦听器能够接收事件通知，此侦听事件响应一次后自动移除。 * @param type 事件的类型。 * @param caller 事件侦听函数的执行域。 * @param listener 事件侦听函数。 * @param args （可选）事件侦听函数的回调参数。 * @return 此 EventDispatcher 对象。 */ once(type: string, caller: any, listener: Function, args: any[] = null) 用于向事件分发器注册指定类型的事件侦听器，使事件侦听器能够接收事件通知，事件侦听器响应一次后会自动移除。例如上述2.2.1示例中的按钮的侦听方式也可以改为单次事件侦听： //侦听一次ui按钮点击事件 this.uiBtn.once(Laya.Event.CLICK, this, () => { //点击后，打开UI场景示例 console.log(\"uiBtn\"); Laya.Scene.open(\"scenes/UiMain.ls\"); }); 2.2.4 删除指定的侦听 off /** * 从 EventDispatcher 对象中删除侦听器。 * @param type 事件的类型。 * @param caller 事件侦听函数的执行域。 * @param listener 事件侦听函数。 * @return 此 EventDispatcher 对象。 */ off(type: string, caller: any, listener: Function, onceOnly: boolean = false) 用于从事件分发器对象中删除侦听器： onDestroy(): void { //删除ui按钮的侦听 this.uiBtn.off(Laya.Event.CLICK, this); } 当这个场景删除销毁时，最好删除按钮的事件侦听，保证释放掉所有引用。 2.2.5 删除指定事件类型的所有侦听 offAll /** * 从 EventDispatcher 对象中删除指定事件类型的所有侦听器。 * @param type （可选）事件类型，如果值为 null，则移除本对象所有类型的侦听器。 * @return 此 EventDispatcher 对象。 */ offAll(type: string = null) 用于从事件分发器对象中删除指定事件类型的所有侦听器。例如，uiBtn按钮注册了多个事件的侦听，可以用offAll方法来一次性删除所有点击事件的侦听 ： onDestroy(): void { //删除ui按钮的侦听 this.uiBtn.offAll(Laya.Event.CLICK); } 2.2.6 删除指定作用域的所有侦听 offAllCaller /** * 移除caller为target的所有事件侦听 * @param caller caller对象 */ offAllCaller(caller: any) 用于从事件分发器对象中删除指定作用域的所有侦听器。例如，uiBtn按钮注册了多个事件的侦听，可以用offAllCaller方法来一次性删除this作用域上的所有侦听 ： onDestroy(): void { //删除this作用域的侦听 this.uiBtn.offAllCaller(this); } 2.2.7 检查是否已注册侦听 hasListener 用于判断事件分发器对象是否为特定类型的事件注册了侦听器。 /** * 检查 EventDispatcher 对象是否为特定事件类型注册了任何侦听器。 * @param type 事件的类型。 * @return 如果指定类型的侦听器已注册，则值为 true；否则，值为 false。 */ hasListener(type: string) 例如： if( this.uiBtn.hasListener( Laya.Event.CLICK ) ) console.log(\"uiBtn有点击事件侦听\"); 2.3 事件处理 Laya.Handler 当侦听到事件后，用来处理事件的处理器 处理器的属性包括： 1，caller: Object | null; 执行域 2，method: Function | null 执行方法 3，args: any[] | null 参数 4，once = false 表示是否只执行一次。如果为true，回调后执行recover()进行回收，回收后会被再利用，默认为false 处理器的方法包括： 1，create() 从对象池内创建一个Handler Laya.Handler 事件处理器，推荐使用Laya.Handler.create()方法从对象池创建，以减少对象创建消耗。当创建的Handler对象不再使用后，可使用Laya.Handler.recover()将其回收到对象池，回收后不要再使用此对象，否则会导致不可预料的错误。需要注意的是，由于鼠标事件也使用了对象池，不正确的回收以及调用，可能会影响事件的执行。 onAwake(): void { console.log(\"Game Start\"); this.Tab.selectHandler = Laya.Handler.create(this,(index:number)=>{ console.log(index); }) } Tab会侦听用户点了某个标签，并从对象池创建一个处理器。 ​ 2，clear(): Handler 清理对象引用 this.Tab.selectHandler.clear(); ​ 3，recover(): void 清理并回收到 Handler 对象池内 this.Tab.selectHandler.recover(); ​ 4，run(): any 执行处理器 this.Tab.selectHandler.run(); //可以自行调用run() ​ 5，runWith(data: any): any 执行处理器，并携带额外数据 this.Tab.selectHandler.runWith(1); //可以自行调用runWith(),并传入参数1 ​ 6，setTo(caller: any, method: Function | null, args: any[] | null, once = false): Handler 设置此对象的指定属性值。 onAwake(): void { console.log(\"Game Start\"); this.Tab.selectHandler = Laya.Handler.create(this,(index:number)=>{ // console.log(index); }) this.Tab.selectHandler.setTo(this,(index:number)=>{ console.log(index); },[],false); } 可以自行更改指定的属性 3. 自定义的事件 大多数情况下，开发者使用的都是引擎内置的事件，有时也需要使用自定义的事件。下面举一个例子来说明派发自定义的事件。 在LayaAir IDE中，新建一个2D空项目，在Scene2D下新建一个自定义的组件脚本，并添加如下代码： onAwake(): void { //侦听自定义的事件\"Click\" this.owner.on(\"Click\",this,()=>{ console.log(\"侦听到自定义的“Click”事件\"); }) } //鼠标点击后执行，发送Click事件。 onMouseClick(evt: Laya.Event): void { //自定义的事件 this.owner.event(\"Click\"); } 示例中的this.owner就是Scene2D，当鼠标点击场景后，就会派发自定义的事件\"Click\"，这个\"Click\"就是自定义的事件。当侦听到\"Click\"时，就会打印\"侦听到自定义的“Click”事件\"的日志。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-07-29 17:15:05 "},"basics/common/Tween/readme.html":{"url":"basics/common/Tween/readme.html","title":"缓动","keywords":"","body":"缓动一、概述二、Ease2.1 匀速运动（linearIn）2.2 加速运动（expoIn）2.3 快速加速运动（strongIn）2.4 往后再反向（backIn）三、Tween3.1 常用API介绍3.2 参数说明3.3 缓动实例3.4 理解Props参数3.5 理解缓动持续时间（duration）与延迟执行（delay）参数3.6 理解ease参数3.7 理解完成回调（complete）参数3.8 通过Props参数实现过程回调缓动 一、概述 缓动的最大用处就是应用在设计的运动表现上，可以结合物理、数学等原理真实地模拟显示生活中的运动现象，更加符合自然规律及人类认知，并使对象按照用户期望的行为交互，提供连续性体验。游戏开发中缓动动画比较常见，它是提升游戏UI体验的重要因素之一，例如对话框弹出、关闭，按钮的动效出现与消失，道具飞入背包等，我们可以直接使用LayaAir引擎提供的Tween缓动类与Ease类来快捷实现。 接下来我们分别介绍 Tween 和 Ease 类 二、Ease Ease 类定义了大量的缓动函数，以便实现 Tween 动画的具体缓动效果。LayaAir引擎的Tween类与Ease类结合使用，能基本满足游戏开发的缓动效果需求。 我们主要看以下几种缓动效果来理解： 2.1 匀速运动（linearIn） 比较少的情况下，会用匀速运动，会显得比较僵硬。不符合物理世界的规律，真实的运动状态下，物体的速度是会随着运动状态发生变化的。 2.2 加速运动（expoIn） 以零速率开始运动，然后在执行时加快运动速度。 2.3 快速加速运动（strongIn） 以零速率开始运动，然后在执行时加快运动速度 2.4 往后再反向（backIn） 开始时往后运动，然后反向朝目标移动 更多的效果可以通过示例查看 三、Tween Tween 缓动类用以实现目标对象属性的缓动，例如目标对象的x或y轴的缓动距离等目标值设置，以及缓动开始、停止、清理等设置。 3.1 常用API介绍 缓动类 Tween 提供了较多的方法，而我们常用的是两种，分别为from()与to()方法，这两个方法的参数设置完全一样，但效果有所不同，from是从缓动目标点向初始位置产生运动（从缓动目标位置来），to是从初始位置向缓动目标的位置产生运动（到缓动目标位置去），后面会结合实例详细说明，开发者可以先了解一下这两个方法的基础说明： /** * 从props属性，缓动到当前状态。 * @param target 目标对象(即将更改属性值的对象)。 * @param props 变化的属性列表，比如{x:100,y:20,ease:Ease.backOut,complete:Handler.create(this,onComplete),update:new Handler(this,onComplete)}。 * @param duration 花费的时间，单位毫秒。 * @param ease 缓动类型，默认为匀速运动。 * @param complete 结束回调函数。 * @param delay 延迟执行时间。 * @param coverBefore 是否覆盖之前的缓动。 * @param autoRecover 是否自动回收，默认为true，缓动结束之后自动回收到对象池。 * @return 返回Tween对象。 */ static from(target: any, props: any, duration: number, ease: Function = null, complete: Handler = null, delay: number = 0, coverBefore: boolean = false, autoRecover: boolean = true): Tween { return Pool.getItemByClass(\"tween\", Tween)._create(target, props, duration, ease, complete, delay, coverBefore, false, autoRecover, true); } /** * 缓动对象的props属性到目标值。 * @param target 目标对象(即将更改属性值的对象)。 * @param props 变化的属性列表，比如{x:100,y:20,ease:Ease.backOut,complete:Handler.create(this,onComplete),update:new Handler(this,onComplete)}。 * @param duration 花费的时间，单位毫秒。 * @param ease 缓动类型，默认为匀速运动。 * @param complete 结束回调函数。 * @param delay 延迟执行时间。 * @param coverBefore 是否覆盖之前的缓动。 * @param autoRecover 是否自动回收，默认为true，缓动结束之后自动回收到对象池。 * @return 返回Tween对象。 */ static to(target: any, props: any, duration: number, ease: Function|null = null, complete: Handler|null = null, delay: number = 0, coverBefore: boolean = false, autoRecover: boolean = true): Tween { return Pool.getItemByClass(\"tween\", Tween)._create(target, props, duration, ease, complete, delay, coverBefore, true, autoRecover, true); } 3.2 参数说明 to()和from()这两种方法都支持静态方法，因此我们不需要去实例化Tween类就可以使用。 to()和from()它们的参数理解起来都较简单，这里我们重点强调一下props、duration、ease、complete、delay参数。 props props 是目标对象需要改变，从而产生缓动效果的属性。对象的公共属性都可以进行设置，比如最常用的x、y位置属性，及alpha透明属性，以及旋转、轴心、大小等其他属性。属性的设置是采用对象数据的形式，比如 {x:100,y:20,ease:Ease.backOut,complete:Handler.create(this,onComplete),update:new Handler(this,onComplete)} duration duration 是执行缓动效果花费的时间，单位是豪秒，时间越多，缓动效果越慢。 ease ease 为缓动类型，它可以使用Ease类下定义的各种函数来改变动画的变化过程。 complete complete 为缓动完成后回调方法。比如按钮出现的缓动，在缓动过程中我们不能让用户点击，这时就可以用到缓动完成回调，在回调函数中再加入按钮监听。 delay delay 是延迟执行的时间，稍后会通过实例中的延迟执行制作出文本缓动的波动效果。 3.3 缓动实例 下列代码中，我们先通过 Tween.from() 方法，实现 “LayaBox” 字符的文本缓动动画。 from() ： //创建缓动文本 private createTween():void{ //\"LayaBox字符串总宽度\" var w:number = 800; //文本创建的起始位置(>>在此使用右移运算符，相当于/2 用>>效率更高) var offsetX:number = Laya.stage.width - w >> 1; //显示的字符串 var demoString:string = \"LayaBox\"; var letterText:Laya.Text; //根据\"LayaBox\"字符串长度创建单个字符，并对每个单独字符使用缓动动画 for(var i:number = 0,len:number = demoString.length;i （动图3-1） 结合实例代码，然后通过动图3-1的运动效果，我们可以看出，文本”Layabox”在初始位置（y轴300）出现之后，瞬间消失，然后从缓动方法 Tween.from 设置的目标{ y : 100 }（y轴100）向初始位置发生运动（从上到下的缓动效果）。 由于这个方法是先在初始位置显示，再瞬间消失从缓动的目标位置向初始位置运动。会产生一个视觉差，感觉更像反弹效果。所以我们继续了解 Tween.to 的效果，开发者可以根据需要选择到底使用哪种缓动方法。 to() ：我们可以继续采用上面的实例，只是将 Tween.from 改变为 Tween.to //对象letterText属性y从初始的y属性向缓动目标的y的100属性运动，缓动效果需要3000毫秒，缓类型采用elasticOut函数方式，延迟间隔1000毫秒执行。 Laya.Tween.to( letterText , {y:100}, 3000, Laya.Ease.elasticOut, null, 1000 ); 运行效果如动图3-2所示 （动图3-2） 3.4 理解Props参数 无论 Tween.from 还是 Tween.to，第二个参数Props（属性）可以影响缓动效果的运动轨迹等。 由于 Tween.from 与 Tween.to 的缓动效果本来就是相反的，所以 Tween.from 有一种向下落的感觉，而动图3-2的 Tween.to 有一种向上弹起的感觉。 如果我们将初始y的属性值 与缓动目标的y属性值对调一下，再来看看，用 Tween.to 实现的落下效果与 Tween.from 有什么不同。 继续延续之前的示例，修改代码如下。 //文本的初始y属性 letterText.y = 100; //Laya.Tween.from(letterText,{y:100},3000,Laya.Ease.elasticOut,null,i*1000);//注释本行改为将Laya.Tween.from改变为Laya.Tween.to Laya.Tween.to(letterText, { y : 300 }, 3000, Laya.Ease.elasticOut, null, i * 1000); 运行效果如动图3-3所示 （动图3-3） 由于动图3-3中，是初始y属性在100，Tween.to 的效果是从初始属性向缓动目标的属性进行运动。所以缓动目标的y属性在300时，就会产生出从初始y轴的100向y轴300进行运动，也就是落下的效果。与 Tween.from 实现落下效果会有明显的不同。所以开发者在运用时要注意两者的效果区别。 3.5 理解缓动持续时间（duration）与延迟执行（delay）参数 继续沿用前面的示例，我们将第三个参数duration修改为1000毫秒，将第六个参数delay修改为100毫秒，效果如动图3-4所示。无论是缓动的速度还是下落间隔的速度都会产生较明显的变化。因此可以看出，通过持续时间或延迟时间的调整也可以实现不同的动画效果目标。这里不再深入，开发者可以自行调节体验。 （动图3-4） 动图3-4效果所修改代码如下： //文本的初始y属性 letterText.y = 100; //Laya.Tween.from(letterText,{y:100},3000,Laya.Ease.elasticOut,null,i*1000);//注释本行改为将Laya.Tween.from改变为Laya.Tween.to Laya.Tween.to(letterText, { y : 300 }, 1000, Laya.Ease.elasticOut, null, i * 100); 3.6 理解ease参数 第四个参数ease对应laya.utils.Ease类的各个方法，本节中我们改为Ease.bounceIn效果，如动图3-5所示。 （动图3-5） 动图3-5效果所修改代码如下： //文本的初始y属性 letterText.y = 100; //Laya.Tween.from(letterText,{y:100},3000,Laya.Ease.elasticOut,null,i*1000);//注释本行改为将Laya.Tween.from改变为Laya.Tween.to Laya.Tween.to(letterText, { y : 300 }, 1000, Laya.Ease.bounceIn, null, i * 100); 3.7 理解完成回调（complete）参数 第五个参数complete用于执行完缓动效果后的回调。我们继续沿用之前的示例，在缓动结束后，增加一个让字体颜色变红的回调方法。 使用示例： Laya.Tween.to(letterText, { y : 300 }, 1000, Laya.Ease.bounceIn, Laya.Handler.create(this,this.changeColor,[letterText]), i * 100); 增加的 changeColor 方法如下 /** * 缓动完成后的回调方法 * txt 缓动对象 */ private changeColor(txt:Laya.Text):void{ //将文本字体改变成红色 txt.color = \"#ff0000\"; } 代码运行效果如动图3-6所示 （动图3-6） 3.8 通过Props参数实现过程回调 complete（完成回调）参数，不仅可以在第五个参数中实现，也可以在第二个参数Props中实现。但是，为了代码更加清晰易读，我们并不建议将完成回调放在Props中实现。 这里我们只介绍一下在Props中实现update更新回调。也就是说如果我们想在缓动过程中就执行回调方法，那第五个参数中是不可能实现的，因为第五个参数一定是缓动结束后才执行。所以，我们继续沿用之前的示例，在Props参数里增加一个字体颜色的更新回调。 使用示例： /** * 对象letterText属性y从100缓动到300的位置，每一帧都通过回调方法更新颜色 * 用1000毫秒完成缓动效果 * 缓动类型采用bounceIn * 单个字符的缓动效果结束后，使用changeColor回调函数将字符改变为红色 * 延迟间隔i*100毫秒执行 */ Laya.Tween.to(letterText, { y : 300, update: new Laya.Handler(this, this.updateColor,[letterText])}, 1000, Laya.Ease.bounceIn, Laya.Handler.create(this,this.changeColor,[letterText]), i * 100); 增加的 changeColor 方法如下 /** * 缓动进行时的回调更新方法 * txt 缓动对象 */ private updateColor(txt:Laya.Text):void{ var c:number = Math.floor(Math.random()*3); switch (c) { case 0: txt.color = \"#eee000\"; break; case 1: txt.color = \"#ffffff\"; break; case 2: txt.color = \"#ff0000\"; break; default: txt.color = \"#eee000\"; break; } } 代码运行时，由于update回调是每一帧都在执行，所以在缓动的过程中，有一种闪光字的效果。如动图3-7所示 （动图3-7） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-07-26 19:46:01 "},"basics/common/Pool/readme.html":{"url":"basics/common/Pool/readme.html","title":"对象池","keywords":"","body":"对象池使用一、概述二、对象池 Pool2.1 获得一个对象池2.2 清理一个对象池2.3 从池中获得对象2.4 回收对象到池中2.5 通过类名，获得和回收对象对象池使用 一、概述 在项目开发过程中，有许多对象会不停的创建与移除，比如角色攻击子弹、特效的创建与移除，NPC（非玩家角色）的被消灭与刷新等，在创建过程中非常消耗性能，特别是数量多的情况下，此时会造成卡顿的现象。 因此使用对象池就可以避免大量对象的创建。如果我们每次对象使用完了都放到池子里，比如怪物，子弹等等，怪物被杀死了，不需要用了，就可以放到池子里，下次使用的时候可以直接从池子里拿，对象池没有才需要创建。 对象池的优点是减少了实例化对象时的开销，且能让对象反复使用，减少了新内存分配与垃圾回收器运行的机会。另外对象移除时并不是立即从内存中抹去，只有认为内存不足时，才会使用垃圾回收机制清空，清空时很耗内存，很可能就会造成卡顿现象。用了对象池后将减少程序的垃圾对象，有效的提高程序的运行速度和稳定性。 接下来，我们来看看在LayaAir中是如何使用对象池（Pool）的。 二、对象池 Pool Pool 是对象池类，用于对象的存贮、重复使用。合理使用对象池，可以有效减少对象创建的开销，避免频繁的垃圾回收，从而优化游戏流畅度。 2.1 获得一个对象池 /** * 根据对象类型标识字符，获取对象池。 * @param sign 对象类型标识字符。 * @return 对象池。 */ static getPoolBySign(sign: string): any[] { return Pool._poolDic[sign] || (Pool._poolDic[sign] = []); } Laya.Pool 是通过对象类型标识符，也就是一个字符串名字来标识和管理对象池的。如果对象池系统中没有这个标识，那么会创建一个标识的对象池。因此我们也可以通过标识来定义多个对象池，分别处理不同类型的对象。比如攻击的子弹是一个对象池，NPC玩家是一个对象池。 所以，当我们想使用一个对象池的话，需要这样在代码中调用： let bulletPool = Laya.Pool.getPoolBySign(\"Bullet\"); 有了对象池，我们可以查看对象池当前的情况，比如查看对象池内对象的数量，继续添加对象等等。比如代码： let bulletPool = Laya.Pool.getPoolBySign(\"Bullet\"); // 查看当前对象池内对象数量 console.log( bulletPool.length ); if( bulletPool.length == 0 ) { // 把子弹放入对象池 pool.push( new Bullet() ); } 2.2 清理一个对象池 /** * 清除对象池的对象。 * @param sign 对象类型标识字符。 */ static clearBySign(sign: string): void { if (Pool._poolDic[sign]) Pool._poolDic[sign].length = 0; } 比如在游戏中，当一场战斗结束时，当没有需要子弹的对象池的需求了，我们可以通过代码来清理对象池： Laya.Pool.clearBySign(\"Bullet\"); 2.3 从池中获得对象 2.3.1 通过标识获得 /** * 根据传入的对象类型标识字符，获取对象池中已存储的此类型的一个对象，如果对象池中无此类型的对象，则返回 null 。 * @param sign 对象类型标识字符。 * @return 对象池中此类型的一个对象，如果对象池中无此类型的对象，则返回 null 。 */ static getItem(sign: string): any { var pool: any[] = Pool.getPoolBySign(sign); var rst: any = pool.length ? pool.pop() : null; if (rst) { rst[Pool.POOLSIGN] = false; } return rst; } 这是最基本的操作，从对象池中拿到一个对象的示例，如果对象池里已经没有可以拿的对象时，返回 null，使用代码如下： let bullet = Pool.getItem(\"Bullet\"); 此时如果拿到的对象是 null，那么我们应该考虑下，有两种情况： 1，对于特别频繁需要创建的某个对象，或者创建这个对象的过程比较消耗性能，我们可以在进入这个场景的加载过程中，预先创建好一组对象，并把这组对象放入对象池中 // 第一次创建子弹的对象池 let bulletPool = Laya.Pool.getPoolBySign(\"Bullet\"); // 创建10个子弹对象，并放入对象池中 for( var i = 0 ; i 2，对于创建对象性能要求不高，我们可以通过下面的方法来创建对象，并随时把对象放入对象池中 2.3.2 通过标识获得，没有则创建 /** * 根据传入的对象类型标识字符，获取对象池中此类型标识的一个对象实例。 * 当对象池中无此类型标识的对象时，则使用传入的创建此类型对象的函数，新建一个对象返回。 * @param sign 对象类型标识字符。 * @param createFun 用于创建该类型对象的方法。 * @param caller this对象 * @return 此类型标识的一个对象。 */ static getItemByCreateFun(sign: string, createFun: Function, caller: any = null): any { var pool: any[] = Pool.getPoolBySign(sign); var rst: any = pool.length ? pool.pop() : createFun.call(caller); rst[Pool.POOLSIGN] = false; return rst; } 基于上述的情况，如果对象池中没有对象了，可以随时利用这个方法创建对象： let bullet = Laya.Pool.getItemByCreateFun(\"Bullet\", function() { // 创建一个子弹 let bullet = new Bullet(); // 拿到子弹的对象池 var pool = Laya.Pool.getPoolBySign(\"Bullet\"); // 把子弹放入对象池，也可以不放入对象池，根据开发者需求 pool.push( bullet ); // 返回子弹对象 return bullet; }); 2.4 回收对象到池中 2.4.1 通过对象进行回收 /** * 将对象放到对应类型标识的对象池中。 * @param sign 对象类型标识字符。 * @param item 对象。 */ static recover(sign: string, item: any): void { if (item[Pool.POOLSIGN]) return; item[Pool.POOLSIGN] = true; Pool.getPoolBySign(sign).push(item); } 比如在游戏的一场战斗过程中，从对象池中拿出的子弹已经结束了它的生命周期时，我们可以通过代码来回收这个子弹对象到对象池中： Laya.Pool.recover(\"Bullet\", bullet); 2.5 通过类名，获得和回收对象 往往我们在做复杂的系统架构过程中，通过使用类名来获得和回收对象是一种很好的处理方式。Laya的Pool对象已经为我们考虑了这种情况，我们先来看看 2.5.1 通过类名获得对象 /** * 根据传入的对象类型标识字符，获取对象池中此类型标识的一个对象实例。 * 当对象池中无此类型标识的对象时，则根据传入的类型，创建一个新的对象返回。 * @param sign 对象类型标识字符。 * @param cls 用于创建该类型对象的类。 * @return 此类型标识的一个对象。 */ static getItemByClass(sign: string, cls: new () => T): T { if (!Pool._poolDic[sign]) return new cls(); var pool = Pool.getPoolBySign(sign); if (pool.length) { var rst = pool.pop(); rst[Pool.POOLSIGN] = false; } else { rst = new cls(); } return rst; } 2.5.2 根据类名进行回收 /** * 根据类名进行回收，如果类有类名才进行回收，没有则不回收 * @param instance 类的具体实例 */ static recoverByClass(instance: any): void { if (instance) { var className: string = instance[\"__className\"] || instance.constructor._$gid; if (className) Pool.recover(className, instance); } } 有了这两种对应的方式，我们可以不用在代码中去关心每个对象的创建和回收，只关心对象的内部逻辑就好了。比如在战斗过程中有很多的技能特效，我们可以对每个特效用统一的方式进行管理对象池： export class EffectA { constructor() { super(); } static create(): EffectA { Pool.getItemByClass(EffectA); } recover(): void { Pool.recoverByClass(this); } } export class EffectB { constructor() { super(); } static create(): EffectB { Pool.getItemByClass(EffectB); } recover(): void { Pool.recoverByClass(this); } } 总结，Laya提供的Pool是一个比较基本的对象池，开发者可以根据自己的需求来扩展对象池的使用，从而更方便的实现更复杂的对象管理。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"basics/common/network/readme.html":{"url":"basics/common/network/readme.html","title":"网络通信","keywords":"","body":"网络通信一、概述二、Http连接2.1 Laya.HttpRequest2.2 GET2.3 POST2.4 扩展HttpRequest三、 WebSocket连接3.1 Laya.Sokcet3.2 Laya.Byte 二进制读写四、ProtocolBuffer使用4.1 Message 定义4.2 项目中添加protobuf 类库4.3 加载协议文件4.4 Message 方法4.5 代码示例网络通信 一、概述 在我们的项目开发过程中，除了单机不需要使用网络通信，开发一个网络项目，难免要处理网络通信。本章将讲解LayaAir的网络通信部分。通常我们使用 Http 和WebSocket 这两种网络通信方式。首先我们来对比一下两者的区别: HTTP： 优点：协议成熟，应用广泛，基于TCP/IP，拥有TCP的可靠性，研发成本低，开发快速，被广泛支持，如nginx/apache/tomcat等。 缺点：无状态无连接，只有PULL模式，不支持PUSH，数据报文较大，每次请求都要带上所有的头信息。 特性：无状态，无连接（短连接），支持C/S模式，适用于文本传输，但也可以传输其他类型的数据，如图片、视频等。 WebSocket： 优点：协议较新，但已趋于成熟，基于TCP/IP，拥有TCP的可靠性，数据报文较小，只有在建立连接时的握手阶段需要较大的头信息，之后的数据交换阶段头信息较小，面向连接，有状态协议，支持服务器主动推送数据（PUSH模式）。 缺点：WebSocket 是应用层协议，虽然数据包较简洁，但相比于TCP/IP协议，其数据包头部信息相对较大，对于非常小的数据包，这可能会导致一些额外的流量消耗。此外，由于需要维持连接，可能会占用更多的服务器资源。 特性：有状态，面向连接，数据报头较小，支持全双工通信，适用于需要实时通信的应用。 通过以上对协议特性分析，建议： 1，对于弱联网类游戏，比如消除类的，卡牌类的，可以直接HTTP协议，考虑安全的话直接HTTPS，或者对内容体做对称加密； 2，对于实时性，交互性要求较高，且team有过相关经验，可以优先选择websocket协议，比如SLG和RPG等大型网络游戏。 二、Http连接 HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。 2.1 Laya.HttpRequest 在LayaAir引擎中 HttpRequest 就是我们发送请求的基本类。HttpRequest 类其实包装的就是原生的 XMLHttpRequest，我们先来了解下 HttpRequest。 2.1.1 原生 XMLHttpRequest 对象 /** * 本对象所封装的原生 XMLHttpRequest 引用。 */ get http(): any { return this._http; } 通过 ._http 属性可以获得XMLHttpRequest。XMLHttpRequest 中文可以解释为可扩展超文本传输请求。它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。 1，属性 属性 类型 描述 onreadystatechange function 一个JavaScript函数对象，当readyState属性改变时会调用它。 readyState unsigned short 请求的五种状态 response varies 响应实体的类型由 responseType 来指定， 可以是 ArrayBuffer ，Blob， Document， JavaScript 对象 (即 “json”)， 或者是字符串。如果请求未完成或失败，则该值为 null responseText DOMString 此次请求的响应为文本，或是当请求未成功或还未发送时为 null只读。 responseType XMLHttpRequestResponseType 设置该值能够改变响应类型。就是告诉服务器你期望的响应格式。 status unsigned short 该请求的响应状态码 (例如，状态码200 表示一个成功的请求).只读 statusText DOMString 该请求的响应状态信息，包含一个状态码和原因短语 (例如 “200 OK“)。 只读 upload XMLHttpRequestUpload 可以在 upload 上添加一个事件监听来跟踪上传过程。 withCredentials boolean 表明在进行跨站(cross-site)的访问控制(Access-Control)请求时，是否使用认证信息(例如cookie或授权的header)。 默认为 false timeout number 请求超时时间 2，方法 abort() 如果请求已经被发送,则立刻中止请求。 getAllResponseHeaders() 返回所有响应头信息(响应头名和值)， 如果响应头还没接受,则返回null。 getResponseHeader() 返回指定的响应头的值, 如果响应头还没被接受,或该响应头不存在,则返回null。 open() 初始化一个请求. send() 发送请求. 如果该请求是异步模式(默认)，该方法会立刻返回。 相反，如果请求是同步模式，则直到请求的响应完全接受以后，该方法才会返回。 setRequestHeader() 给指定的HTTP请求头赋值。在这之前，你必须确认已经调用 open()方法打开了一个url。 因此使用 HttpRequest 的过程中，我们也可以获得 XMLHttpRequest 对象，并对 XMLHttpRequest 对象做相关的操作，在此我们就不对 XMLHttpRequest 做过多讲解，开发者可以自行查阅相关文档。 详细的XMLHttpRequest，请看 W3C的xhr 标准; XMLHttpRequest发各种类型的数据，可以参考发送数据和html5rocks上的这篇文章 了解XMLHttpRequest的基本使用，可以参考MDN的XMLHttpRequest介绍； 想了解跨域请求，则可以参考W3C的 cors 标准; 2.1.2 send() 方法 发送请求， 通常发送的请求是异步方式，其中send的参数类型如下： /** * 发送 HTTP 请求。 * @param url 请求的地址。大多数浏览器实施了一个同源安全策略，并且要求这个 URL 与包含脚本的文本具有相同的主机名和端口。 * @param data (default = null)发送的数据。 * @param method (default = \"get\")用于请求的 HTTP 方法。值包括 \"get\"、\"post\"、\"head\"。 * @param responseType (default = \"text\")Web 服务器的响应类型，可设置为 \"text\"、\"json\"、\"xml\"、\"arraybuffer\"。 * @param headers (default = null) HTTP 请求的头部信息。参数形如key-value数组：key是头部的名称，不应该包括空白、冒号或换行；value是头部的值，不应该包括换行。比如[\"Content-Type\", \"application/json\"]。 */ send(url: string, data: any = null, method: \"get\" | \"post\" | \"head\" = \"get\", responseType: \"text\" | \"json\" | \"xml\" | \"arraybuffer\" = \"text\", headers: any[] | null = null) 2.1.3 支持的事件类型 我们常用的基本就是进度事件，完成事件，错误事件等 /** * 请求进度改变时调度。 * @eventType Event.PROGRESS * */ /*[Event(name = \"progress\", type = \"laya.events.Event\")]*/ /** * 请求结束后调度。 * @eventType Event.COMPLETE * */ /*[Event(name = \"complete\", type = \"laya.events.Event\")]*/ /** * 请求出错时调度。 * @eventType Event.ERROR * */ /*[Event(name = \"error\", type = \"laya.events.Event\")]*/ 2.1.4 在代码中怎么使用 LayaAir引擎中用 HttpRequest 继承的是 EventDispatcher，具有事件派发的功能。加上本身具备发送请求的功能。我们写个简单的例子来看下用法： class LayaSample { constructor() { //创建HttpRequest对象 let http: Laya.HttpRequest = new Laya.HttpRequest(); //设置超时时间 http.http.timeout = 10000; //发送了一个简单的请求 http.send(\"resources/data.txt\", \"\", \"get\", \"text\");//需要在resources文件夹下新建一个data.txt文件 //设置完成事件，添加回调方法 http.once(Laya.Event.COMPLETE, this, this.completeHandler); //设置错误事件，添加回调方法 http.once(Laya.Event.ERROR, this, this.errorHandler); //设置进度事件，添加回调方法 http.on(Laya.Event.PROGRESS, this, this.processHandler); } private processHandler(data:any): void { console.log(\"processHandler\"); } private errorHandler(error:any): void { console.log(\"errorHandler\"); } private completeHandler(data:any): void { console.log(\"completeHandler\"); } } new LayaSample(); 2.2 GET 上面这个示例我们发送了一个简单的请求，方式是get方式。用来获取一个远端的文件，格式为文本的格式。假如我们动态请求远端数据可以改成如下格式： this.hr = new HttpRequest(); this.hr.once(Event.PROGRESS, this, this.onHttpRequestProgress); this.hr.once(Event.COMPLETE, this, this.onHttpRequestComplete); this.hr.once(Event.ERROR, this, this.onHttpRequestError); //发送了一个get请求，携带的参数为 name=myname 和 psword=xxx this.hr.send('http://xkxz.zhonghao.huo.inner.layabox.com/', null, 'get', 'text'); 这里的重点是send方法，这个send方法要和 XMLHttpRequest 的send区分开。 2.3 POST 下面用post方法请求一个数据方式如下： this.hr = new HttpRequest(); this.hr.once(Event.PROGRESS, this, this.onHttpRequestProgress); this.hr.once(Event.COMPLETE, this, this.onHttpRequestComplete); this.hr.once(Event.ERROR, this, this.onHttpRequestError); //发送了一个post请求，携带的参数为 name=myname 和 psword=xxx this.hr.send('http://xkxz.zhonghao.huo.inner.layabox.com/', 'name=myname&psword=xxx', 'post', 'text'); 注意：GET和POST请求是有区别的： GET请求参数是通过URL进行传递的，POST请求的参数包含在请求体当中。 GET请求比POST请求更不安全，因为参数直接暴露在URL中，所以，GET请求不能用来传递敏感信息。 GET请求在url中传递的参数是有长度限制的(在HTTP协议中并没有对URL的长度进行限制，限制是特定的浏览器以及服务器对他的限制，不同浏览器限制的长度不同)，POST对长度没有限制。 GET请求参数会完整的保留在浏览器的历史记录中，POST请求的参数不会保留。 GET请求进行url编码(百分号编码)，POST请求支持多种编码方式。 2.4 扩展HttpRequest 在开发过程中 HttpRequest 可能不能满足我们的需求，比如上传文件，比如设置超时时间，比如操作表单数据等等。扩展 HttpRequest 很简单，你继承HttpRequest，或者干脆自己重写 HttpRequest 这个类都可以，这个看开发者的需求，重写 HttpRequest 建议直接继承 EventDispatcher。重写就是重新包装 XMLHttpRequest 这个类。下面是一个简单的继承的示范： class HttpRequestExtension extends Laya.HttpRequest { constructor() { super(); } public send(url:string,data:any=null,method:string=\"get\", responseType:string=\"text\", headers:any=null):void{ super.send(url,data,method,responseType,headers); this._http.upload.onprogress= function(e:any):void { //上传进度 } this._http.upload.onload= function(e:any):void { } this._http.upload.onerror= function(e:any):void { } this._http.upload.onabort = function(e:any):void { } } } 上面是一个上传文件的示范，添加了 XMLHttpRequest 的upload的一些事件，这里的 super.send 简单的用了父类的方法，开发者可以不用，完全自己另写一套来满足自己的需求。 三、 WebSocket连接 WebSocket是一种基于ws协议的技术，它使得建立双全工连接成为可能。websocket常见于浏览器中，但是这个协议不受使用平台的限制。 websocket发送数据的格式一般为二进制和字符串。LayaAir引擎已经为我们封装好了 Socket 和 Byte 类，收发数据结合Byte类就可以完成。 3.1 Laya.Sokcet 在LayaAir引擎中 Socket 就是我们使用 WebSocket 的基本类。 Socket 封装了 HTML5 WebSocket ，允许服务器端与客户端进行全双工（full-duplex）的实时通信，并且允许跨域通信。在建立连接后，服务器和 Browser/Client Agent 都能主动的向对方发送或接收文本和二进制数据。我们先来了解下 Socket 的用法 3.1.1 Connect 服务器 Socket 连接服务器有三种方式： 方式 说明 构造函数传参 立即连接 比如 new Socket(“192.168.1.2”,8899)；注意这里的host参数没有ws前缀。 connect方法 传递url和端口号，连接服务器；socket.connect(“192.168.0.1.2”，8989)；注意这里的host参数没有ws前缀。 connectByUrl方法 传递整个url，比如 socket.connectByUrl(“ws://localhost:8989”)；这里有ws前缀。 3.1.2 发送数据 发送数据很简单，只需要调用Socket的send函数即可，参数可以是string或者是ArrayBuffer。 发送字符串格式： this.socket.send(\"hello world\");//这是发送字符串的形式。 发送二进制格式的数据： //写入一个字节 this.byte.writeByte(1); //写入一个int16的数据 this.byte.writeInt16(20); //写入一个32位的浮点数据 this.byte.writeFloat32(20.5); // 写入一个字符串； this.byte.writeUTFString(\"hello\"); //这里声明一个临时Byte类型 var by:Laya.Byte = new Laya.Byte(); //设置endian； by.endian = Laya.Byte.LITTLE_ENDIAN; //写入一个int32数据 by.writeInt32(5000); //写入一个uint16 数据 by.writeUint16(16); //把临时字节数据的数据写入byte中，这里注意写入的是by.buffer; this.byte.writeArrayBuffer(by.buffer); //这里是把字节数组的数据通过socket发送给服务器。 this.socket.send(this.byte.buffer); //清除掉数据;方便下次读写； this.byte.clear(); 上面我们看到，通过一个字节数组把我们需要的数据读入一个Byte数组，最后发送给服务器的是byte.buffer，这是一个ArrayBuffer的数据类型。这里一定要注意send的参数是 ArrayBuffer，很多开发者可能不注意，直接传递成了Byte，导致发送数据不正确。假如写成 this.socket.send(this.byte)；这是错误的，这点一定要注意。 3.1.3 接收数据 客户端从服务器接收到的数据都会派发到 Event.MESSAGE 监听函数中。receiveHandler的参数就是服务器发送回来的数据。可能是字符串，也可能是二进制ArrayBuffer。接收到的是字符串我们不用读，拿来直接用就可以。但是接收到的是二进制的话我们需要读取出来，转成我们需要的类型。 private receiveHandler(msg: any = null): void { ///接收到数据触发函数 //.............这里我们假设收到的是二进制ArrayBuffer this.byte.clear(); this.byte.writeArrayBuffer(msg);//把接收到的二进制数据读进byte数组便于解析。 this.byte.pos = 0;//设置偏移指针； ////下面开始读取数据，按照服务器传递过来的数据，按照顺序读取 var a:number = this.byte.getByte(); var b:number = this.byte.getInt16(); var c:number = this.byte.getFloat32(); var d:string = this.byte.getString(); var e:string = this.byte.getUTFString(); } 3.1.4 支持的事件类型 我们常用的基本就是连接建立成功，接收到数据，连接被关闭，出现异常后调度等 /** * 连接建立成功后调度。 * @eventType Event.OPEN * */ /*[Event(name = \"open\", type = \"laya.events.Event\")]*/ /** * 接收到数据后调度。 * @eventType Event.MESSAGE * */ /*[Event(name = \"message\", type = \"laya.events.Event\")]*/ /** * 连接被关闭后调度。 * @eventType Event.CLOSE * */ /*[Event(name = \"close\", type = \"laya.events.Event\")]*/ /** * 出现异常后调度。 * @eventType Event.ERROR * */ /*[Event(name = \"error\", type = \"laya.events.Event\")]*/ 3.1.5 在代码中怎么使用 我们举一个简单的发送和接收数据的 WebSocket 代码示例： private connect(): void { //创建Socket对象 this.socket = new Socket(); //对服务器建立连接 this.socket.connectByUrl(\"ws://echo.websocket.org:80\"); //表示需要发送至服务端的缓冲区中的数据 this.output = this.socket.output; //添加监听事件 this.socket.on(Event.OPEN, this, this.onSocketOpen); this.socket.on(Event.CLOSE, this, this.onSocketClose); this.socket.on(Event.MESSAGE, this, this.onMessageReveived); this.socket.on(Event.ERROR, this, this.onConnectError); } //连接建立成功回调 private onSocketOpen(e: any = null): void { console.log(\"Connected\"); // 发送字符串 this.socket.send(\"demonstrate \"); // 使用output.writeByte发送 var message: string = \"demonstrate \"; for (var i: number = 0; i 3.2 Laya.Byte 二进制读写 在开发项目中，二进制的操作是不可或缺的。在html5时代，对二进制的支持已经有了很大的突破。但是api的繁琐，对开发者开发项目来说不太方便。在页游时代，ActionScript3.0的二进制数组ByteArray，功能完善，api操作简单易懂，因此LayaAir的Byte在参考ByteArray的同时承接了html5的TypedArray类型化数组的特点。下面看下主要的用法 3.2.1 常用方法 构造方法 参数： length ：长度 当传入length参数时，一个内部数组缓冲区被创建,该缓存区的大小是传入的length大小。 typedArray：类型化数组 当传入一个包含任意类型元素的任意类型化数组对象(typedArray) (比如 Int32Array)作为参数时，typeArray被复制到一个新的类型数组。typeArray中的每个值会在复制到新的数组之前根据构造器进行转化。新的生成的类型化数组对象将会有跟传入的数组相同的length(比如原来的typeArray.length==2，那么新生成的数组的length也是2，只是数组中的每一项进行了转化)。 ArrayBuffer：二进制数据缓冲区。 上面的三种方法都可以实例化一个Byte，根据参数的不同创建二进制数据。 //实例化一个二进制数组Byte var byte:Laya.Byte = new Laya.Byte(); //或者传入一个类型化数组 var uint8Byte:Uint8Array = new Uint8Array(10); var byte:Laya.Byte = new Laya.Byte(uint8Byte); //或者传入一个ArrayBuffer类型 var buffer:ArrayBuffer = new ArrayBuffer(20); var byte:Laya.Byte = new Laya.Byte(buffer); writeArrayBuffer(arraybuffer:*, offset:number = 0, length:number = 0):void 写入指定的二进制缓冲数据。指定数据的偏移量和长度，如下： var byte:Laya.Byte = new Laya.Byte(); var byte1:Laya.Byte = new Laya.Byte(); byte1.writeFloat32(20.0);//写入一个四个字节的浮点数 byte1.writeInt16(16);//写入一个两个字节的整数 byte1.writeUTFString(\"hell world\");//写入一个字符串； byte.writeArrayBuffer(byte1.buffer,6);//把byte1的数据从第六个字节开始读入byte中。省略其中的浮点数20.0和整数16 byte.pos = 0;// console.log(byte.readUTFString())//从byte中读出字符串。 读取数据 getByte():number 从字节流中读取带符号的字节。 getInt16():number 从字节流的当前字节偏移量位置处读取一个 Int16 值。 getInt32():number 从字节流的当前字节偏移量位置处读取一个 Int32 值。 getFloat32():number 从字节流的当前字节偏移位置处读取一个 IEEE 754 单精度（32 位）浮点数。 getFloat32Array(start:number, len:number)any 从指定的位置读取指定长度的数据用于创建一个 Float32Array 对象并返回此对象。 getFloat64():number 从字节流的当前字节偏移量位置处读取一个 IEEE 754 双精度（64 位）浮点数。 getInt16():number 从字节流的当前字节偏移量位置处读取一个 Int16 值。 getInt32():number 从字节流的当前字节偏移量位置处读取一个 Int32 值。 getUint8():number 从字节流的当前字节偏移量位置处读取一个 Uint8 值。 getUint16():number 从字节流的当前字节偏移量位置处读取一个 Uint16 值。 getUint32():number 从字节流的当前字节偏移量位置处读取一个 Uint32 值。 getInt16Array(start:number, len:number):any 从指定的位置读取指定长度的数据用于创建一个 Int16Array 对象并返回此对象。 getString():string 读取字符型值。 getUTFBytes(len:number = -1):string 读字符串，必须是 writeUTFBytes 方法写入的字符串。 getUTFString():string 读取 UTF-8 字符串。 写入数据 writeByte(value:number):void在字节流中写入一个字节。 var byte:Laya.Byte = new Laya.Byte(); byte.writeByte(10);//0-255之间 ​ writeFloat32(value:number):void在当前字节偏移量位置处写入 Float32 值。范围是$\\left[-2^{128}, 2^{127}\\right]$，约为-3.4E38—3.4E+38。 var byte:Laya.Byte = new Laya.Byte(); byte.writeFloat32(10.021); ​ writeFloat64(value:number):void写入float64位数值 其数值范围为-1.7E308～1.7E+308。 ​ writeInt16(value:number):void在当前字节偏移量位置处写入 Int16 值。范围-32768 到 +32767之间。 var byte:Laya.Byte = new Laya.Byte(); byte.writeInt16(120); ​ writeInt32(value:number):void在当前字节偏移量位置处写入 Int32 值。-2,147,483,648 到 +2,147,483,647 之间的有符号整数。 **writeUint16**(value:number):void在当前字节偏移量位置处写入 Uint16 值。 ​ writeUint32(value:number):void在当前字节偏移量位置处写入 Uint32 值。 ​ writeUint8(value:number):void在当前字节偏移量位置处写入 Uint8 值。 ​ writeUTFBytes(value:string):void写入字符串，该方法写的字符串要使用 readUTFBytes 方法读取。 ​ writeUTFString(value:string):void将 UTF-8 字符串写入字节流。 clear():void清除数据。 var byte:Laya.Byte = new Laya.Byte(); byte.writeInt16(120); byte.pos =0;//读取位置归零。 getSystemEndian():string[static]获取系统的字节存储顺序。 console.log(Laya.Byte.getSystemEndian());//打印系统的字节顺序 3.2.2 属性 BIG_ENDIAN : string= bigEndian[static] 表示多字节数字的最高有效字节位于字节序列的最前面。 LITTLE_ENDIAN : string= littleEndian[static] 表示多字节数字的最低有效字节位于字节序列的最前面。 posnumber当前读取到的位置。 var byte:Laya.Byte = new Laya.Byte(); byte.writeInt16(120); byte.pos =0;//读取位置归零。 length: number字节长度。 endian : string字节顺序。 var byte:Laya.Byte = new Laya.Byte(); byte.endian = Laya.Byte.BIG_ENDIAN;//设置为大端； bytesAvailable : number[read-only]可从字节流的当前位置到末尾读取的数据的字节数。 var byte:Laya.Byte = new Laya.Byte(); byte.writeFloat32(20.0); byte.writeInt16(16); byte.writeUTFString(\"hell world\"); byte.pos = 6; console.log(byte.bytesAvailable) 3.2.3 代码演示 下面我们通过一个完整的代码来演示下这个类的应用，比如网络连接中，我们接收和发送网络消息。 var msg:any ={name:\"xxx\",age:18,weight:65.5,height:175}; var byte:Laya.Byte = new Laya.Byte(); //实例化byte数组 byte.endian = Laya.Byte.LITTLE_ENDIAN; //设置大小端 byte.writeUTFString(msg.name); //写入数据 byte.writeByte(msg.age); byte.writeFloat32(msg.weight); byte.writeInt16(msg.height); 输出看下结果： //设置pos为0 开始从头开始按照写入的顺序读取读取 byte.pos = 0; console.log(byte.getUTFString()); console.log(byte.getByte()); console.log(byte.getFloat32()); console.log(byte.getInt16()); 3.2.4 类型化数组 Laya的byte封装的就是类型化数组，开发者可以参考mdn的官方api说明。来扩展自己的项目的应用。 DataView 视图提供了一个与平台中字节在内存中的排列顺序(字节序)无关的从ArrayBuffer读写多数字类型的底层接口。 Uint8Array 数组类型表示一个8位无符号整型数组，创建时内容被初始化为0。创建完后，可以以对象的方式或使用数组下标索引的方式引用数组中的元素。 Int8Array :类型数组表示二进制补码8位有符号整数的数组。内容初始化为0。 一旦建立，你可以使用对象的方法引用数组中的元素，或使用标准数组索引语法。 Int16Array();类型数组表示二进制补码16位有符号的数组。 Uint16Array();类型数组表示二进制补码16位无符号的数组 Int32Array();类型数组表示二进制补码32位有符号的数组 Uint32Array();类型数组表示二进制补码32位无符号的数组 Float32Array();类型数组表示32位浮点数数组。 Float64Array();类型数组表示64位浮点数数组。 四、ProtocolBuffer使用 protocolbuffer（以下简称PB）是google 的一种数据交换的格式，它独立于语言，独立于平台。类似于XML，JSON这样的数据表示语言，ProtocolBuffer是用于结构化数据串行化的灵活、高效、自动的方法，格式有点类似XML，可以自己定义数据格式，它是一种二进制格式允许你使用规范的语言定义一个模式。 ProtocolBuffer 作为网络通信的协议格式，是现在一种非常流行的方式，下来我们来了解一下。 4.1 Message 定义 这里简单的给出一个例子，是一个非常简单的请求的message格式 // awesome.proto package awesomepackage; //指定proto版本 syntax = \"proto3\"; //message包含多个种类的fields message AwesomeMessage { string awesome_field = 1; // becomes awesomeField } 上述例子中fields的种类是字符串型的（string），当然也可以指定更加复杂的fields，比如枚举类型enum，或者是嵌套的message类型 上述Message定义好之后，我们把协议文件保存到项目目录中 \"assets/res/protobuf/awesome.proto\"; 4.2 项目中添加protobuf 类库 我们可以从 https://github.com/protobufjs/protobuf.js 下载最新 protobuf 类库，并放到项目的bin目录中，同时在index.html 中引用到 protobuf.js 4.3 加载协议文件 protobuf 类库，通过 load 方法来加载协议文件 /** * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback. * @param {string|string[]} filename One or multiple files to load * @param {Root} root Root namespace, defaults to create a new one if omitted. * @param {LoadCallback} callback Callback function * @returns {undefined} * @see {@link Root#load} */ function load(filename, root, callback) { if (typeof root === \"function\") { callback = root; root = new protobuf.Root(); } else if (!root) root = new protobuf.Root(); return root.load(filename, callback); } 4.4 Message 方法 Message.verify(message: Object): null|string 验证一个Message对象是否满足有效消息的要求。 Message.create(properties: Object): Message 对满足有效消息要求的一组Javascirpt数据创建新消息实例。 Message.encode(message: Message|Object , writer: Writer): Writer 对Message对象进行编码，用于网络通信传输。 Message.decode(reader: Reader|Uint8Array): Message 网络通信传输数据中，解码获得Mesaage对象。 Message.toObject(message: Message , options: ConversionOptions): Object 转换Message对象数据到一组Javascirpt数据。 4.5 代码示例 onAwake(): void { var resPath: string = \"assets/res/protobuf/awesome.proto\"; // 加载protobuf文件 this.ProtoBuf.load(resPath, this.onAssetsLoaded); } private onAssetsLoaded(err: any, root: any): void { if (err) throw err; // 获得一个Message消息类型 var AwesomeMessage: any = root.lookupType(\"awesomepackage.AwesomeMessage\"); console.log(AwesomeMessage); // 初始化数据 var payload: any = { awesomeField: \"AwesomeString\" }; console.log(payload); // 验证数据是否有效 var errMsg: any = AwesomeMessage.verify(payload); // 如果有异常抛出异常并终止 if (errMsg) throw Error(errMsg); // 创建Message的实体 var message: any = AwesomeMessage.create(payload); console.log(message); // 编译Message实体成 Buffer 数据格式，等待发送数据 var buffer: any = AwesomeMessage.encode(message).finish(); console.log(buffer); } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-07-19 20:46:21 "},"basics/common/adaptScreen/readme.html":{"url":"basics/common/adaptScreen/readme.html","title":"屏幕适配","keywords":"","body":"LayaAir屏幕适配及有效抗锯齿一、基础概念1.1 物理分辨率1.2 缩放因子与逻辑分辨率1.3 设备像素比1.4 逻辑宽高1.5 物理宽高（屏幕宽高）1.6 设计宽高1.7 画布宽高1.8 适配宽高1.9 舞台宽高二、抗锯齿相关介绍2.1 锯齿产生的原因2.2 引擎内置的抗锯齿2.3 开启抗锯齿，为什么还有锯齿感2.4 让画布使用物理分辨率三、LayaAir屏幕适配模式详解3.1 最容易理解的适配模式3.2 移动端推荐的适配模式3.3 其它适配模式3.4 刘海屏适配思路3.5 其它适配相关学习LayaAir屏幕适配及有效抗锯齿 Author: Charley 有的时候看到一些3D游戏锯齿感特别明显，与一些开发者沟通后发现，其实很多人并不清楚怎么能去掉明显的锯齿感，而这并不是只有新开发者才遇到的问题，很多游戏研发经验丰富的开发者，甚至是使用LayaAir引擎开发了很多游戏的开发者也会不清楚。另外，最近也遇到有开发者想了解刘海屏如何适配，所以通过本篇文章全面介绍一下。 为了兼顾新手开发者来理解这个事，本篇从基础概念入手，详细介绍LayaAir引擎的各个屏幕适配缩放模式，刘海屏适配思路，以及如何有效的抗锯齿。 一、基础概念 以下基础概念非常重要，会影响到后面引擎适配原理的理解，请大家认真阅读。 1.1 物理分辨率 物理分辨率简单理解就是硬件所支持的分辨率，以像素（px）为单位，所以我们称这个硬件上的每一个像素点为物理像素，也叫设备像素。将屏幕实际存在的像素以行数 × 列数这样的数学表达方式体现出来，就是物理分辨率。 而LayaAir引擎运行于浏览器或其它运行器环境上，进行屏幕适配时，物理分辨率实际上是指浏览器或运行环境上的屏幕分辨率。以屏幕宽的像素数量 × 屏幕高的像素数量这样来体现。因此，横屏与竖屏得到的物理分辨率宽高，会有所差别。 例如：iPhone8 在默认的竖屏状态下，物理分辨率宽高表达为750 × 1334。横屏状态下，物理分辨率宽高表达为1334 × 750 。 1.2 缩放因子与逻辑分辨率 1.2.1 缩放因子 起源 iOS绘制图形是以 point （pt）为单位，在早期的时候1 point=1 pixel。在2010年推出的iPhone4 开始采用 Retina(视网膜) 屏幕显示技术 ，物理分辨率提升了4倍，此时，如果iPhone4 还是1pt=1px这个方案，将会导致如下图一样的显示效果。 （图1） 在图1中，按 iPhone3GS的320 × 480进行全屏设计，那在iPhone4下的显示效果则如图1左侧，原来的满屏内容只占了四分之一，其余部分留空。而按iPhone4分辨率 640 × 960进行全屏设计，那在iPhone3GS的屏幕下显示效果则如图1右侧，大量内容超出可显示区。 很显然，apple不会让图1的事情发生。实际上，iPhone4的缩放因子为@2X，也就是在这个机型上1个point 用2×2的像素矩阵来表示，如图2中效果所示，完美解决图1中可能发生的问题。 （图2） 随着时代的发展，后续的机型物理分辨率也越来越高，1个point占用的物理像素也越来越多，见下图。 （图3） 缩放因子的概念在安卓机型中也适用 1.2.2 逻辑分辨率 逻辑分辨率简单理解就是软件所使用的分辨率，我们设计适配全靠他，也是用乘法数学表达方式来体现。为了更好的理解这个概念，我们先看一组数据表格。 （图4） 通过图4的数据，我们可以看出，随着手机设备的更新，物理分辨率已经越来越高，如果我们按物理分辨率来进行屏幕适配，先不算安卓，光iPhone的机型就很碎片化了，还好，在缩放因子的作用下，我们看到逻辑分辨率基本上变化不大，所以我们后面讲的引擎适配，主要是针对逻辑分辨率进行适配。 1.3 设备像素比 我们基于浏览器开发时，之前介绍的缩放因子概念对应的是DPR (Device Pixel Ratio)，中文叫设备像素比 。LayaAir引擎中通过 Laya.Browser.pixelRatio 可以获得浏览器的DPR值。 这里稍展开讲几句，在浏览器里，默认是由用户来控制缩放的，例如，我们在手机浏览器双指扩张，发现网页会放大，但清晰度并不减小。这就是用户自主缩放导致，并非是由DPR值来决定缩放。如果我们想和APP开发那样，通过逻辑分辨率来适配，让浏览器依据设备的DPR来决定一个CSS像素占用几个物理像素。那需要在入口HTML页面的的meta标签中用 viewport进行了相关的配置。代码如下： 以上代码LayaAir引擎中默认添加，并强制添加不得删除。 通过上面这段viewport的配置，那页面在禁止用户手动缩放的同时，也会按设备的DPR进行自动缩放。 1.4 逻辑宽高 逻辑宽高是指逻辑分辨率的宽高。浏览器里，可以缩放的逻辑分辨率像素是CSS像素，在设置了viewport的情况下，浏览器会根据DPR的值决定一个CSS占用多少个像素，例如DPR为3时，1个CSS像素就占用3×3个物理像素。 LayaAir引擎里可以通过Laya.Browser.clientWidth获取逻辑分辨率的宽，通过Laya.Browser.clientHeight获取逻辑分辨率的高。 在手机等移动设备的竖屏状态下，窄面为宽，长面为高。如果发生了屏幕翻转的横屏状态，则长的一面为宽，窄面为高。 在PC浏览器中，则是获取的浏览器窗口可视宽高。 1.5 物理宽高（屏幕宽高） 物理宽高对应的是之前介绍的物理分辨率概念，也称为屏幕宽高。开发者可以通过引擎封装的接口获得宽高值，通过Laya.Browser.width可以得到屏幕宽上有多少像素，通过Laya.Browser.height可以得到屏幕高上有多少像素。 只有在全屏的时候屏幕宽高是硬件屏幕宽高，开发者需要理解的是，屏幕宽高实际是指运行环境窗口宽高，例如在浏览器上运行就是浏览器显示窗口的宽高。 LayaAir引擎中的物理宽高是通过逻辑宽高*DPR计算而来。而奇葩的iPhone6/7/8各Plus机型，逻辑分辨率是736×414，DPR的值是3，相乘得到的结果显然与真实的各Plus机型物理分辨率1920×1080不符合。 讲到这里，开发者了解到有这回事即可，不用担心适配错误，由于LayaAir引擎在入口网页的meta标签中用 viewport进行了相关的配置，所以会按DPR自动进行缩放，最终会自动缩放到对应到实际的物理分辨率。 至于Plus机型为什么要这样奇葩的设置，这里就不展开讲了，有兴趣的同学可以自行百度搜索答案。 1.6 设计宽高 设计宽高是开发者在设计产品时采用的宽高，面对众多机型，选择哪个作为设计宽高，也是一些新手开发者有点迷茫的，这里简单多说几句。 （图5） 设计宽高，首先要考虑的是优先兼容多数的常用屏幕比例。通过上面图5的表格，我们看到去掉过时的机型，基本上手机屏幕就分两类，一类是宽高比约为1:1.78的非全面屏手机，另一类是宽高比约为1:2.17全面屏手机。各品牌的安卓机型屏幕比例，大多也是这两种或者接近这两种。 基于性能优先的原则，通常开发者都会选择分辨率小一些的作为主效果设计，然后向其它比例屏幕进行适配。比如：常见的宽750高1334或宽720高1280。 以上宽高描述是指竖屏模式设计，横屏需反过来。 打开LayaAir 3.0 IDE 的项目设置面板Project Settings面板，可以直接设置，效果如图6所示。 （图6） 1.7 画布宽高 众所周知，是HTML5中的画布，其 width、heigth 属性就是画布宽高。 画布宽高在noscale、exactfit、noborder这几个LayaAir引擎适配模式下会直接采用设计宽高值，其它适配模式下，会根据适配规则产生变化。画布宽高的值对画面最终的清晰度以及性能都会产生影响，甚至边缘锯齿或画面模糊也与此处画布宽高值有关。 我们在IDE里任意运行一个页面， 在打开的chrome里用F12进入调试模式后，入口页面中找到id为 layaCanvas的canvas标签。记住这个位置，图7中红圈标记的，就是画布的初始宽高，后面理解屏幕适配模式的时候，大家可以多关注这里。 （图7） 1.8 适配宽高 由于Canvas是基于位图像素绘图的，画布宽高对画面质量及性能有影响，又或者诸如plus特殊的分辨率等问题。所以不能通过直接改变画布宽高来适配，否则会出来一些适配问题。在LayaAir引擎中会根据不同的适配模式规则，计算出适配宽高需要缩放的比例，然后通过transform的matrix（矩阵）来对画布缩放至逻辑分辨率范围内，再通过viewport与DPR机制缩放还原。 基于以上种种，我们需要了解，适配宽高才是LayaAir引擎适配规则处理后的最终效果宽高，会直接影响通过DPR还原后的最终效果。 大家在理解各个适配模式的时候，可以在HTML入口页面中观察画布宽高与transform的matrix（矩阵）缩放效果来对比不同模式之间的差异。例如图8中红圈标记所示，适配宽高分别为249.99975和444.666222。还原至物理分辨率大小后，虽然有精度上的细微损失，但已经很难看出。 （图8） 1.9 舞台宽高 舞台宽高是指LayaAir引擎的stage宽高，引擎的节点对象都是在stage上进行添加与控制的，在stage范围内，可以控制显示、进行事件监听，碰撞检测等，所以对stage宽高的适配还是非常重要的。 在DevTools控制台，我们可以通过引擎API(Laya.stage.width和Laya.stage.height)，查看舞台宽高。 默认情况下，stage宽高直接等于设计宽高。在full、fixedwidth、fixedheight、fixedauto的适配模式下，stage宽高会根据适配规则产生变化。本篇第三节会详细介绍。 二、抗锯齿相关介绍 2.1 锯齿产生的原因 我们屏幕的像素点，是由行与列的矩阵序列组成。也就是说屏幕中是不存在斜线的。基于像素绘图的画布，要是画横竖的直线，那绝对是相当的平滑。可是画曲线和斜线怎么办。只能是由两个相邻的像素点不断重复延伸组成，如果这句话不好理解，我们想象一下楼梯，从侧面去看，大概就是这个样子。示意效果如图9-1所示。 （图9-1） 另外，3D模型的基础构成是三角面组成的多边形网格，绘制3D多边形构成的模型，这和我们矢量画斜线、画曲线、画圆，是一样的道理。所以非矩形的矢量图形和3D模型，产生锯齿这是正常的。 2.2 引擎内置的抗锯齿 LayaAir引擎内置了抗锯齿方法， 3D抗锯齿，可以在Camera里设置，LayaAir提供了精度高的MSAA抗锯齿方案，以及性能高的FXAA抗锯齿方案，如图9-2所示。 （图9-2） 了解更多3D抗锯齿参数的区别，可以阅读《使用3D摄像机》文档。 2D抗锯齿，想开启的话可以在Project Settings里设置，如图9-3所示。 （图9-3） 开启抗锯齿后，边缘锯齿会变得平滑模糊，示意效果如图9-4所示。 （图9-4） 模糊后的锯齿相对会平滑一些，在像素密度比较高的屏幕上，肉眼很难看出。从而达到消灭锯齿感的目标。 2.3 开启抗锯齿，为什么还有锯齿感 有的开发者发现，抗锯齿功能开启了，为什么还会感觉到锯齿感呢？ 有两个原因， 第一，是抗锯齿的方案问题，比如3D抗锯齿的MSAA与FXAA在精度上存在着一些细小的差别。 第二，哪怕是精度再高的抗锯齿，也不可能真的去掉锯齿，只是通过一些算法，让边缘过渡的更平滑。从而减轻锯齿现象。在一些像素密度比较大的屏幕上，让肉眼难以识别，并非真的让锯齿消失。 所以，开发者如果想进一步减轻锯齿感，那就让画布保持与物理分辨率同步。否则拉伸缩放画布进行全屏适配的方案，可能会导致抗锯齿效果减弱。 2.4 让画布使用物理分辨率 LayaAir引擎的适配模式里，只有full模式，默认就让画布采用了物理分辨率。 full模式除了让画布保持物理分辨率，相当于没有做适配方案。对于UI布局来说，适配门槛较高，只适用纯3D游戏或UI布局非常简单的3D游戏。 所以，我们推荐另一种方案，通过开启视网膜画布模式useRetinalCanvas配置，让所有适配模式都采用物理分辨率作为画布的大小。 这两种方案，我们可以通过IDE的项目设置面板进行设置，效果如图10所示。 (图10) 2.5.1 动态开启视网膜画布模式 如果想动态控制视网膜画布模式的开和关，也可以在项目代码里添加配置代码。代码如下： if(条件){ Laya.stage.useRetinalCanvas = false; }else{ Laya.stage.useRetinalCanvas = true; } Laya.stage.alignH = \"left\"; 这里需要提醒一下的是，需要同步设置Stage的scaleMode、width、height、alignH、alignV中的任意一个，这样修改才会生效。 因为，设置上面这些属性，会调引擎适配方法，从而修改画布等相关适配数据。 2.5.2 开启视网膜画布模式的利弊 理论上讲，开启视网膜画布模式，在超出设计宽高的机型上，会产生更多的性能消耗。因为画布上的像素越多，性能消耗越大。所以很多2D游戏，都会采用相对小一些的分辨率作为游戏设计宽高。 但从实际应用来讲，物理宽高所带来的性能压力也并没有那么多风险。要知道，一些小游戏平台是强制要求必须物理分辨率的。因此，LayaAirIDE在导出某些小游戏平台版本的时候，会强行开启视网膜画布模式（useRetinalCanvas）。 另外，开启视网膜画布模式，除了能解决一些小游戏平台中的问题，以及可以减轻锯齿现象外，其实还可以让适配变的更简单。因为不使用视网膜画布模式，还想避免锯齿现象，移动端只能使用full模式，而full模式除了让画布和舞台采用了物理分辨率之外，并没有作任何适配，所以对于2D UI，全部需要开发者手工适配。 所以，建议开启视网膜画布模式，尤其是3D游戏。如果考虑某些机型的性能压力，开发者可以在存在压力的机型，或者有性能压力的功能上，通过逻辑控制，动态开启或关闭视网膜画布模式。 三、LayaAir屏幕适配模式详解 LayaAir引擎的适配模式有8种，为了让大家真正理解各适配模式的适配策略，以便更好的进行屏幕适配。本节以LayaAirIDE创建的2D示例项目为例，将设计宽高调整为750×1334的竖屏界面，分别就各个适配模式对比不同机型进行讲解。 在适配对比的机型选择方面，iPhone4的640 × 960代表老旧机型，宽高比为1.5，只是为了对比适配效果。iPhone8的750 × 1334是我们为设计宽高选定的机型，宽高比约为1.78，无论哪个模式都是完美的1：1适配。iPhone8 Plus代表着同样约为1.78宽高比，但物理分辨率和DPR都与iPhone8不同的同比例机型。iPhoneX代表着宽高比大于2的各种全面屏机型。 3.1 最容易理解的适配模式 3.1.1 默认的不缩放模式noscale noscale模式是引擎默认的模式。该模式下，在任何屏幕都会始终保持设计时的物理分辨率原样效果，相当于将不缩放的设计宽高画布直接贴在屏幕上。物理宽高和设计宽高相等的屏幕会全屏显示，物理宽高低于设计宽高的会显示不全，物理宽高超过设计宽高的会漏出屏幕背景（白屏）。 该模式通常不被使用，仅有少数不使用引擎适配方案，有着自定义适配规则的开发者来使用。 noscale模式，不同机型对比效果如图11-1中所示。 （图11-1） 3.1.2 物理分辨率画布模式full full模式表示着画布宽高和舞台宽高一定是完整的全屏状态，但和noscale模式一样，并没有对设计宽高做缩放处理。在full模式下，画布大小直接取值物理分辨率，物理宽高是多少，画布就有多大，该模式下设计宽高参数的设置无意义，直接设置0,0即可。 该模式仍需要自己定义适配规则，多用于3D游戏。如果有UI界面，不想自己定义适配规则的，后面还会介绍更优的3D适配方案。 full模式，不同机型对比效果如图11-2中所示。 （图11-2） 特别说明一下，背景屏幕颜色为黑色的是画布背景色，不是stage背景色。通过Project Settings可以改变默认的画布背景色。 （图11） 在noscale模式下的白屏背景那是浏览器默认的，说明画布就那么大，画布没覆盖到的地方就是白屏背景。 假如在noscale模式下，开启了视网膜画布模式，那显示效果将会与图11-2的full模式效果相同，但区别是，full模式舞台（stage）宽高也是物理宽高，所以在游戏画面覆盖到的地方仍然可以有点击等事件响应。而noscale开启视网膜画布模式，只是强行将画布改为物理宽高，并没有改变舞台宽高，所以游戏画面（设计宽高）外的部分并不会对点击等事件产生响应。 3.1.3 强行拉伸全屏模式exactfit exactfit是一种不等比的全屏拉伸适配模式，画布宽高与舞台宽高会等于游戏设计宽高 。然后完全不考虑比例强行缩放至逻辑宽高全屏。所以除非是设计宽高与物理宽高相等，否则就会有一些因拉伸产生的变形。屏幕分辨率宽高比与设计宽高比差距越大的，变形的越明显。 拉伸至物理宽高全屏，所以除非是设计宽高与物理宽高相等，否则就会有一些因拉伸产业的变形。不同机型的宽高比例差距越大，变形的越明显。 该模式是所有适配模式中，唯一不需要开发者作额外的适配调整，就能保障在任何机型下都可以全屏显示、不留空白、不被裁切的适配模式，缺点也很明显，就是当物理宽高比例与设计宽高比例不同时，会产生拉伸变形，适用于对界面产生形变没有严格要求的开发者。 exactfit模式，不同机型对比效果如图11-3中所示。 （图11-3） 3.2 移动端推荐的适配模式 在移动端，我们通常会需要保持设计宽高等比缩放的全屏适配方案。而以下几种模式正是我们推荐开发者优先采用的适配模式。如果是3D游戏，建议开启视网膜画布（useRetinalCanvas）模式。 3.2.1 保宽适配模式fixedwidth fixedwidth保宽模式就是在保障设计宽的内容一定全屏显示的等比缩放模式。这种模式推荐应用于竖屏游戏。 在这个模式下，画布宽和舞台宽会等于设计宽。但画布高和舞台高会按物理宽与设计宽的比例进行缩放后改变，不采用我们配置的设计高。所以，当改变后的画布和舞台高大于原来的设计高，底部就会露出画布背景色。如果改变后的画布和舞台高小于原来的设计高，那就会被裁剪掉多出的部分。 fixedwidth模式，不同机型对比效果，如图12-1所示。 （图12-1） 看到图12-1的黑色背景色，或者有开发者看到这里会想，我需要的是全屏适配，这个不适合。其实不用担心，这是为了让大家理解fixedwidth的适配规则，故意没有处理。由于在这个模式下，舞台的宽高已经被缩放拉满全屏，所以。开发者完全可以通过相对布局属性（top和bottom），把背景拉到全屏以及按钮拉到屏幕相对位置显示。实现各个屏幕下都做到完美的全屏适配。 3.2.2 保高适配模式fixedheight fixedheight保高模式就是在保障设计高的内容一定全屏显示的等比缩放模式。这种模式推荐应用于横屏游戏。 在这个模式下，画布高和舞台高会等于设计高。但画布宽和舞台宽会按物理高与设计高的比例进行缩放后改变，不采用我们配置的设计宽。所以，当改变后的画布和舞台宽小于原来的设计宽，那就会被裁剪掉多出的部分，如图12-2所示。如果改变后的画布和舞台宽大于原来的设计宽，底部就会露出画布背景色，如图12-3所示。 (图12-2) (图12-3) 图12-2和图12-3仍然是故意没有处理。通过相对布局属性（left和right），把背景拉到全屏以及按钮拉到屏幕相对位置显示。实现各个屏幕下都做到完美的全屏适配。 3.2.3 自动保宽高模式fixedauto fixedauto自动保宽高模式就是在保障设计宽高的内容，在任意机型的分辨率下一定都在全屏内显示。这是一种设计宽高永远不会被裁剪的等比缩放全屏适配模式，但有可能会留出画布的背景色，如图12-4所示。 所以还是需要通过相对布局属性，进行全屏适配。该模式横屏游戏和竖屏游戏都适合。 （图12-4） 这种模式，其实最终采用的是fixedwidth或者fixedheight，是通过物理宽高比和设计宽高比进行对比判断。物理宽高比小于设计宽高比的采用fixedwidth模式，否则就采用fixedheight。 3.3 其它适配模式 3.3.1 显示全部的高清模式showall showall模式的适配结果与fixedauto非常像，也是保障设计宽高一定会在屏幕内全部显示，但区别和问题是，showall模式的画布和舞台并未做到所有分辨率下的全屏适配，而是取（物理宽/设计宽）与（物理高/设计高）的最小比值，进行等比缩放，并且改变了舞台和画布大小。因此，留下的空白部分，就是舞台无法控制的部分，导致在与设计宽高比例不同的手机上，就真正的无法全屏适配了。 但也并非没有好处，好处就是都不需要用相对布局二次适配了，设计效果什么样就一定是什么样，肯定是全部显示，不变形，不被裁切。而且由于改变了画布的大小，在物理分辨率差异比较大的屏幕上，也不会因为设计分辨率小了而导致模糊，仍然是高清的。坏处就是做不到手机全屏适配，所以该模式，通常不会被用到手机适配上， 在PC浏览器运行的横屏页游，推荐使用该模式。 showall模式，不同机型对比效果，如图13-1所示。 （图13-1） showall模式由于画布宽高已经进行了缩放改变，本身就是高清的适配模式，所以这种模式无需使用视网膜画布模式（useRetinalCanvas），用了之后，画布采用了物理分辨率，反而不好。 3.3.2 肯定不留底边的模式noboder noboder的适配规则与showall，恰恰相反，是取（物理宽/设计宽）与（物理高/设计高）的最大比值进行缩放。会导致当分辨率宽高比与设计宽高比不同的屏幕上，设计效果一定会超出屏幕，被裁切掉一部分。所以也就无法留出画布或者舞台的底边了。 另外，该模式画布与舞台宽高会保持与设计宽高相同，所以全屏适配全靠对画布的缩放，没有使用视网膜模式的情况下，物理分辨率远超设计分辨率的时候，会因拉伸产生模糊。 noboder模式，不同机型对比效果，如图13-2所示。 （图13-2） 虽然说该模式，通过相对布局二次适配，也可以让被裁剪的按钮等回归到屏幕内容之中，但二次适配的方式要更加复杂。所以不推荐使用该模式。 3.4 刘海屏适配思路 自从推出iPhoneX全面屏手机以来，全面屏手机越来越多，但实际上绝大多数机型做不到真正的全面，所以就有了凹凸屏，刘海屏，水滴屏等叫法，这就给我们适配带来了麻烦。但找到规律之后，其实也并不是太复杂。下面分享一种常见的处理思路，大家根据这种适配思路来具体调节适配。 3.4.1 如何识别刘海屏 目前市面上的机型，虽然分辨率碎片化严重，但是仔细总结一下，可以发现一个规律，那就是分辨率的宽高比就那么几个。至少，全面屏的机型，宽高比肯定是大于2。所以，我们可以获取屏幕分辨率的宽高，然后计算出宽高比。大于2的，就当成刘海屏进行适配处理。 至于分的更细的，大家可以继续仔细研究。本节只是介绍一种思路。 3.4.2 相对布局 LayaAirIDE的UI组件中提供了基于父容器的相对布局属性，如top、bottom、left、right。我们可以把需要特别处理的按钮都统一放到一个容器组件中，例如box。然后，我们在场景Runtime类的onAwake生命周期中，控制这个容器的相对布局属性，就可以实现在刘海屏下进行特殊的位置处理了。 示例代码如下： onAwake():void{ //宽高比大于2为刘海屏 if((Browser.clientHeight/Browser.clientWidth)>2) { this.scaleGroup.top = 25; //回避顶部刘海示例代码 this.scaleGroup.bottom = 50;//回避底部线示例代码 } } 3.4.3 如何调试 由于Chrome的调试中没有提供刘海遮挡的虚拟机，除了真机调试外，可以在微信小游戏开发工具中进行模拟调试。 3.5 其它适配相关学习 除了适配模式外，还有一些其它适配相关的内容，例如横竖屏适配、画布对齐等。 可以前往IDE的基础文档查看《项目设置详解》。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-07-25 17:33:36 "},"basics/common/Browser/readme.html":{"url":"basics/common/Browser/readme.html","title":"浏览器接口","keywords":"","body":"浏览器接口一、概述二、获得屏幕相关数据2.1 逻辑宽高2.2 物理宽高（屏幕宽高）2.3 设备像素比三、调用原生对象3.1 document Dom3.2 window 窗口3.3 container 画布四、判断运行环境浏览器接口 一、概述 在项目开发中，往往我们需要跟外部运行环境打交道，比如在浏览器运行或者在一些小游戏平台中运行，都需要获取设备信息等等，这些功能的接口，都是通过Laya.Browser 来调用的。Laya.Browser 是浏览器代理类，封装了浏览器及原生 JavaScript 提供的一些功能，也包括小游戏等运行环境的信息。本章将介绍 Laya.Browser 都有哪些功能： 获得屏幕相关数据 调用原生对象 判断运行环境 下面我们分别来详细讲解 二、获得屏幕相关数据 通常我们使用 Chrome 或者 MS Edge等浏览器开发项目，这些浏览器提供了非常方便的 DevTools 工具来调试。可以参考下面链接 https://learn.microsoft.com/zh-cn/microsoft-edge/devtools-guide-chromium/overview 如图2-1所示，浏览器提供了设备仿真模式，利于方便查看和调试 （图2-1） 上图中选择的是iphone 6/7/8 Plus设备，但是以iphone为例，随着型号的提升，屏幕设备的分辨率也在不断变化，如图2-2所示 （图2-2） 从图中看到，物理宽高，DPR，逻辑宽高是不同的 因此，要获得这些屏幕相关信息，Laya.Browser 类为我们提供了如下方法，我们来看下 Laya.Browser 相关API ： /** * 浏览器窗口可视宽度。 * 通过分析浏览器信息获得。浏览器多个属性值优先级为：window.innerWidth(包含滚动条宽度) > document.body.clientWidth(不包含滚动条宽度)，如果前者为0或为空，则选择后者。 */ static get clientWidth(): number { Browser.__init__(); return Browser._clientWidth || Browser._window.innerWidth || Browser._document.body.clientWidth; } static set clientWidth(value: number) { Browser._clientWidth = value; } /** * 浏览器窗口可视高度。 * 通过分析浏览器信息获得。浏览器多个属性值优先级为：window.innerHeight(包含滚动条高度) > document.body.clientHeight(不包含滚动条高度) > document.documentElement.clientHeight(不包含滚动条高度)，如果前者为0或为空，则选择后者。 */ static get clientHeight(): number { Browser.__init__(); return Browser._clientHeight || Browser._window.innerHeight || Browser._document.body.clientHeight || Browser._document.documentElement.clientHeight; } static set clientHeight(value: number) { Browser._clientHeight = value; } /** 浏览器窗口物理宽度。考虑了设备像素比。*/ static get width(): number { Browser.__init__(); return ((ILaya.stage && ILaya.stage.canvasRotation) ? Browser.clientHeight : Browser.clientWidth) * Browser.pixelRatio; } /** 浏览器窗口物理高度。考虑了设备像素比。*/ static get height(): number { Browser.__init__(); return ((ILaya.stage && ILaya.stage.canvasRotation) ? Browser.clientWidth : Browser.clientHeight) * Browser.pixelRatio; } /** 获得设备像素比。*/ static get pixelRatio(): number { if (Browser._pixelRatio -1) Browser._pixelRatio = 2; else { Browser._pixelRatio = (Browser._window.devicePixelRatio || 1); if (Browser._pixelRatio 2.1 逻辑宽高 LayaAir引擎里可以通过 Laya.Browser.clientWidth 获取逻辑分辨率的宽，通过 Laya.Browser.clientHeight 获取逻辑分辨率的高。 在手机等移动设备的竖屏状态下，窄面为宽，长面为高。如果发生了屏幕翻转的横屏状态，则长的一面为宽，窄面为高。 在PC浏览器中，则是获取的浏览器窗口可视宽高。 往往大部分浏览器是通过JavaScript 调用 window.innerWidth 来获得浏览器窗口可视宽度，但是某些特殊的浏览器有差异，因此 Laya.Browser 对这些问题做了很好的封装，只需要调用 Browser.clientWidth 和 Browser.clientHeight 即可。 2.2 物理宽高（屏幕宽高） 物理宽高也称为屏幕宽高。开发者可以通过 Laya.Browser.width 可以得到屏幕宽上有多少像素，通过Laya.Browser.height 可以得到屏幕高上有多少像素。 只有在全屏的时候屏幕宽高是硬件屏幕宽高，开发者需要理解的是，屏幕宽高实际是指运行环境窗口宽高，例如在浏览器上运行就是浏览器显示窗口的宽高。 LayaAir引擎中的物理宽高是通过逻辑宽高*DPR计算而来，DPR 就是下面要介绍的设备像素比。 2.3 设备像素比 图2-2中的DPR就是设备像素比，开发者可以通过 Laya.Browser.pixelRatio 可以得到 通过逻辑宽高。物理宽高，设备像素比 ，我们才能更好的做到屏幕适配，想了解更多详细的屏幕适配，请参考《屏幕适配》文档 三、调用原生对象 通常原生对象有如下几个： document Dom window 窗口 container 画布 Laya.Browser 也为我们封装了对这些对象的调用，看下API： /**浏览器原生 document 对象的引用。*/ static get document(): any { Browser.__init__(); return Browser._document; } /**浏览器原生 window 对象的引用。*/ static get window(): any { return Browser._window || Browser.__init__(); } /**画布容器，用来盛放画布的容器。方便对画布进行控制*/ static get container(): any { if (!Browser._container) { Browser.__init__(); Browser._container = Browser.createElement(\"div\"); Browser._container.id = \"layaContainer\"; Browser._document.body.appendChild(Browser._container); } return Browser._container; } static set container(value: any) { Browser._container = value; } 3.1 document Dom LayaAir引擎里可以通过 Laya.Browser.document 获取原生 document 对象。 同时 Laya.Browser 还提供了对于 Dom 节点元素的使用方法： /** * 创建浏览器原生节点。 * @param type 节点类型。 * @return 创建的节点对象的引用。 */ static createElement(type: string): any { Browser.__init__(); return Browser._document.createElement(type); } /** * 返回 Document 对象中拥有指定 id 的第一个对象的引用。 * @param type 节点id。 * @return 节点对象。 */ static getElementById(type: string): any { Browser.__init__(); return Browser._document.getElementById(type); } /** * 移除指定的浏览器原生节点对象。 * @param type 节点对象。 */ static removeElement(ele: any): void { if (ele && ele.parentNode) ele.parentNode.removeChild(ele); } 通过和原生Dom的交互，可以解决一些问题，例如，LayaAir 使用HTML DOM元素 iframe。 在插入三方的一些网站的时候我们一般会用到 iframe，甚至三方的渠道基本都是用iframe嵌入一个应用。我们项目中也会遇到用iframe的情况。下面的例子就是演示在项目中应用iframe。 代码如下所示： var iframe:any = Laya.Browser.document.createElement(\"iframe\"); iframe.style.position =\"absolute\";//设置布局定位。这个不能少。 iframe.style.zIndex = 100;//设置层级 iframe.style.left =\"100px\"; iframe.style.top =\"100px\"; iframe.src = \"http://ask.layaair.com/\"; Laya.Browser.document.body.appendChild(iframe); 这里面需要提醒开发者的就是定位和层级要记得设置。很多开发者不注意导致 iframe 跑到游戏层的下面看不见了。 3.2 window 窗口 LayaAir引擎里可以通过 Laya.Browser.window 获取原生 window 对象。 比如我们想在项目中使用 window.open(url) 打开另一个网页传输数据，示例代码如下： //Get发送数据 Laya.Browser.window.open(\"https://layaair.com/\"); //Post发送数据 //url必须为真实的地址，content表示要发送的数据 let win2 = Laya.Browser.window.open(url); win2.postMessage(content, url);// 此处最好加延迟 //监听器注册 Laya.Browser.window.addEventListener(\"click\", (event: any) => { console.log(event.type); }) Window.open() 方法、window.postMessage()方法、Window.addEventListener()方法 3.3 container 画布 LayaAir引擎里可以通过 Laya.Browser.container 获取画布容器。 比如，我们可以让画布不显示，只显示 Dom 的页面： Laya.Browser.container.style.display = \"none\"; Style display 属性 四、判断运行环境 在开发跨平台的项目中，往往要处理不同平台的兼容性问题，不同的运行环境，会有不同的处理方式。Laya.Browser 类针对这些运行环境进行了判断，对我们开发者来说，判断运行环境，只直接调用 Laya.Browser 类的接口即可，目前为止，这些接口都可以使用 /** 表示是否在移动设备，包括IOS和安卓等设备内。*/ static onMobile: boolean; /** 表示是否在 IOS 设备内。*/ static onIOS: boolean; /** 表示是否在 Mac 设备。*/ static onMac: boolean; /** 表示是否在 IPhone 设备内。*/ static onIPhone: boolean; /** 表示是否在 IPad 设备内。*/ static onIPad: boolean; /** 表示是否在 Android 设备内。*/ static onAndroid: boolean; /** 表示是否在 QQ 浏览器内。*/ static onQQBrowser: boolean; /** 表示是否在移动端 QQ 或 QQ 浏览器内。*/ static onMQQBrowser: boolean; /** 表示是否在 Safari 内。*/ static onSafari: boolean; /** 表示是否在 Chrome 内 */ static onChrome: boolean; /** 表示是否在 IE 浏览器内*/ static onIE: boolean; /** 表示是否在 微信 内*/ static onWeiXin: boolean; /** 表示是否在 PC 端。*/ static onPC: boolean; /** 微信小游戏 **/ static onMiniGame: boolean; /** 小米小游戏 **/ static onKGMiniGame: boolean; /** OPPO小游戏 **/ static onQGMiniGame: boolean; /** VIVO小游戏 **/ static onVVMiniGame: boolean; /** 抖音小游戏*/ static onTTMiniGame: boolean; /** @private */ static onFirefox: boolean;//TODO:求补充 /** @private */ static onEdge: boolean;//TODO:求补充 /** @private */ static onLayaRuntime: boolean; 例如，我们可以这样在代码中判断： //如果是Chrome浏览器 if (Laya.Browser.onChrome) { console.log(\"Chrome\"); } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-08-10 09:56:40 "},"basics/common/device/readme.html":{"url":"basics/common/device/readme.html","title":"设备接口","keywords":"","body":"设备接口使用音频陀螺仪与加速计获取位置信息使用百度地图设备接口 设备接口是指与硬件设备交互的接口调用，这些部分通常为调用浏览器（或运行环境）的原生API进行封装。 使用音频 陀螺仪与加速计 获取位置信息 使用百度地图 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"basics/common/device/media/readme.html":{"url":"basics/common/device/media/readme.html","title":"使用音频","keywords":"","body":"使用音频一、音乐与音效的应用区别二、音频的兼容性准备三、音频音量的控制四、设备静音控制五、失去焦点的处理使用音频 ​ HTML5的音频播放，在当前有两种主流的方式，一种是Audio标签播放,另一种是WebAudio二进制播放。 ​ Audio属于dom元素，带有ui界面，在移动端Audio属于边下载边播放，适合声音文件比较大的文件，但是Audio在移动端会有手势的限制，gesture-requirement-for-media-playback属性表明必须有用户的手势操作才可以播放。 ​ WebAudio是一种新的声音播放形式，可以加载多个声音进行合成，他是通过二进制文件解码成浏览器支持的格式进行播放。而且用这个接口甚至可以实现音频谱的动画效果，让声音有了合成的功能。 ​ 音乐与音效作为游戏中常用的基础元素，LayaAir引擎封装了WebAudio与Audio，在支持WebAudio的浏览器上，优先使用WebAudio，在不支持WebAudio的浏览器上使用Audio，最大化兼容所有浏览器对音频格式的支持，让开发者可以更加方便的，通过调用laya.media.SoundManager API接口就可以直接播放音频。 一、音乐与音效的应用区别 ​ 音乐：是指游戏用的背景音乐。采用laya.media.SoundManager音频管理类中的playMusic方法进行播放，由于是背景音乐，playMusic方法只能同时播放一个音频文件。 ​ 音效：采用的是laya.media.SoundManager音频管理类中的playSound方法，允许同时播放多个音频文件。 二、音频的兼容性准备 ​ 由于音频播放问题的各个浏览器兼容性不同，在开始应用前，我们要做好前期的兼容准备。 （1）使用“格式工厂”音频文件转换工具。选择 44100Hz，96kbps 进行转换。 （2）音频文件尽量小，不仅仅是带宽的限制，还有浏览器音频解码的效率问题。 三、音频音量的控制 ​ 声音音量的控制，可以通过laya.media.SoundManager音频管理类中的setSoundVolume方法来设置： /** * 设置声音音量。根据参数不同，可以分别设置指定声音（背景音乐或音效）音量或者所有音效（不包括背景音乐）音量。 * @param volume 音量。初始值为1。音量范围从 0（静音）至 1（最大音量）。 * @param url (default = null)声音播放地址。默认为null。为空表示设置所有音效（不包括背景音乐）的音量，不为空表示设置指定声音（背景音乐或音效）的音量。 */ static setSoundVolume(volume: number, url: string = null): void { if (url) { SoundManager._setVolume(url, volume); } else { SoundManager.soundVolume = volume; for (let i = SoundManager._channels.length - 1; i >= 0; i--) { let channel = SoundManager._channels[i]; if (channel.url != SoundManager._bgMusic) { channel.volume = volume; } } } } ​ 通过设置volume参数，可以有效控制url所对应声音文件的音量大小。初始值为1。音量范围从 0（静音）至 1（最大音量）。 四、设备静音控制 如果通过设备静音键让音频自动跟随设备静音。需要将useAudioMusic设置为false。 Laya.SoundManager.useAudioMusic = false; 五、失去焦点的处理 如果不是手机全屏游戏，或者在浏览器里交互。有可能会导致切出游戏后，失去焦点，而失去焦点后，音频也会停止播放，这是浏览器机制导致，开发者有两种方式，来避免。 一种是在入口文件中，将autoStopMusic设置为false。 …… //失去焦点后是否自动停止背景音乐。false不自动停止，一直播。true是自动停止 Laya.SoundManager.autoStopMusic = false; …… 如果不设置这个，当失去焦点停止的时候。需要开发者要自行在失去焦点和恢复的时候，通过侦听失去stage焦点和获得stage焦点进行控制，（在小游戏平台，也要看各小游戏的平台切出规则），浏览器中恢复的参考代码如下： …… //循环播放_sound _sound.play(0); //失去舞台焦点（切出游戏）的处理 Laya.stage.on(Laya.Event.BLUR, this, () => { _sound.stop(); }); //获得舞台焦点（切回游戏）的处理 Laya.stage.on(Laya.Event.FOCUS, this, () => { _sound.play(0); }); …… Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-07-18 17:07:52 "},"basics/common/device/motion/readme.html":{"url":"basics/common/device/motion/readme.html","title":"陀螺仪与加速计","keywords":"","body":"laya.device.motion详解：陀螺仪与加速计1、陀螺仪2、加速计2.1 获取设备物理方向运动信息2.2 获取设备显示方向运动信息laya.device.motion详解：陀螺仪与加速计 laya.device.motion中共有四个类供开发者使用，分别为加速信息AccelerationInfo、加速计Accelerator、陀螺仪Gyroscope、保存旋转信息RotationInfo。本节将详细描述laya.device.motion API的相关内容。 1、陀螺仪 ​ Gyroscope通过change事件对设备方向改变进行监听。该事件有两个回调参数： absolute —— 如果设备提供的方位是基于设备坐标系统和地球坐标系统间的差距，则是true；如果设备无法检测到地球坐标系统，absolute为false。 rotationInfo —— RotationInfo类型，包含alpha、beta、gamma三个值，将在下面详细讨论。 ​alpha、beta和gamma属性必须指示设备的方向，其表现形式为从固定在地球上的坐标系到固定在设备上的坐标系的转换。坐标系必须按照下面的描述调整。 ​地球坐标系是一个位于用户位置的“东、北、上”系。其拥有3个轴，地面相切与1984世界测地系统的spheriod的用户所在位置。 东（X）在地面上，垂直于北轴，向东为正。 北（Y）在地面上，向正北为正（指向北极）。 上（Z）垂直于地面，向上为正。 对于一个移动设备，例如电话或平板，设备坐标系的定义于屏幕的标准方向相关。如果在设备旋转或展开滑动键盘时屏幕方向发生变化，这不会影响关于设备的坐标系的方向。 x在屏幕或键盘平面上，屏幕或键盘的右侧为正。 y在屏幕或键盘屏幕上，屏幕或键盘的上方为正。 z垂直于屏幕或键盘屏幕，离开屏幕或键盘为正。 ​旋转必须使用右手规则，即正向沿一个轴旋转为从该轴的方向看顺时针旋转。从两个系重合开始，旋转应用下列规则： 以设备坐标系z轴为轴，旋转alpha度。alpha的作用域为[0, 360]。 （图1） 以设备坐标系x轴为轴，旋转beta度。beta的作用域为[-180, 180]。 （图2） 已设备坐标系y轴为轴，旋转gamma度。gamma的作用域为[-90, 90]。 （图3） 下面演示获取旋转方位信息： class Gyroscope_Sample { private info: Laya.Text; constructor() { Laya.init(550, 400); this.info = new Laya.Text(); this.info.fontSize = 50; this.info.color = \"#FFFFFF\"; this.info.size(Laya.stage.width, Laya.stage.height); Laya.stage.addChild(this.info); Laya.Gyroscope.instance.on(Laya.Event.CHANGE, this, this.onDeviceorientation); } private onDeviceorientation(absolute: Boolean, rotationInfo: Laya.RotationInfo): void { this.info.text = \"alpha:\" + Math.floor(rotationInfo.alpha) + '\\n' + \"beta :\" + Math.floor(rotationInfo.beta) + '\\n' + \"gamma:\" + Math.floor(rotationInfo.gamma); } } new Gyroscope_Sample(); 2、加速计 ​ Accelerator类定期发送设备的运动传感器检测的活动。此数据表示设备在三维轴上的运动。当设备移动时，传感器检测此移动并返回设备的加速坐标。即使静止的时候，也可以得到包含重力的加速坐标。 ​ change事件的回调函数拥有一个以下参数： acceleration —— AccelerationInfo类型。提供宿主设备相对于地球坐标系的加速信息，其表现形式为定义于陀螺仪章节的主坐标系，单位是m/s^2。 accelerationIncludingGravity —— AccelerationInfo 类型。对于不能提供排除重力影响的加速数据的实现（例如缺少陀螺仪），作为替代，可以提供受重力影响的加速数据。这对于许多应用来说并不好用，但提供这些信息意味着提供了最大力度的支持。在此情况下，accelerationIncludingGravity属性提供宿主设备的加速信息，并加上一个加速度相等方向相反的反重力加速度。其表现形式为定义于陀螺仪章节的主坐标系。加速信息的单位是m/s^2。 rotationRate —— RotationInfo类型。属性提供宿主设备在空间中旋转的速率，其表现形式为定义于陀螺仪章节的的角度变化速率，单位必须是deg/s。 interval —— 从硬件获得数据的间隔，单位是毫秒。 2.1 获取设备物理方向运动信息 加速计轴是设备的物理方向，这表示当你旋转了设备，加速计轴也会随之旋转。 下面演示获取设备运动信息： class Gyroscope_Sample { private info: Laya.Text; constructor() { Laya.init(550, 400); this.info = new Laya.Text(); this.info.fontSize = 50; this.info.color = \"#FFFFFF\"; this.info.size(Laya.stage.width, Laya.stage.height); Laya.stage.addChild(this.info); Laya.Accelerator.instance.on(Laya.Event.CHANGE, this, this.onMotoin); } private onMotoin(acceleration: Laya.AccelerationInfo, accelerationIncludingGravity: Laya.AccelerationInfo, rotationRate: Laya.RotationInfo, interval: number): void { this.info.text = 'acceleration:(' + acceleration.x.toFixed(3) + ', ' + acceleration.y.toFixed(3) + ', ' + acceleration.z.toFixed(3) + ')\\n' + 'accelerationIncludingGravity:(' + accelerationIncludingGravity.x.toFixed(3) + ', ' + accelerationIncludingGravity.y.toFixed(3) + ', ' + accelerationIncludingGravity.z.toFixed(3) + ')\\n' + 'rotationRate: alpha ' + Math.floor(rotationRate.alpha) + ', beta ' + Math.floor(rotationRate.beta) + ', gamma ' + Math.floor(rotationRate.gamma) + '\\n' + 'interval: ' + interval; } } new Gyroscope_Sample(); 2.2 获取设备显示方向运动信息 ​ 由于我们可能需要显示方向上的运行信息，这表示即使旋转了设备，加速计轴不随之改变，如y轴 始终保持着垂直。使用Accelerator.getTransformedAcceleration()即可获取到显示方向上的运行信息。 ​ 在上例的代码的onMotion函数中，使用AccelerationInfo前先使用Accelerator.getTransformedAcceleration()转换信息： private onMotoin(acceleration: Laya.AccelerationInfo, accelerationIncludingGravity: Laya.AccelerationInfo, rotationRate: Laya.RotationInfo, interval: number): void { acceleration = Laya.Accelerator.getTransformedAcceleration(acceleration); accelerationIncludingGravity = Laya.Accelerator.getTransformedAcceleration(accelerationIncludingGravity); ...... } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"basics/common/device/geolocation/readme.html":{"url":"basics/common/device/geolocation/readme.html","title":"获取位置信息","keywords":"","body":"用Geolocation获位置信息地理位置1、获取当前定位2、监视位置改变用Geolocation获位置信息 地理位置 如果设备支持Geolocation，并且所使用的浏览器支持，就可以使用Geolocation获取设备的当前地理位置。可以打开网页http://caniuse.com/#search=geolocation查看有哪些浏览器版本支持Geolocation。显示Supported表示支持。 ​ Geolocation返回的GeolocationInfo，包含以下信息： latitude —— 纬度（度）。 longitude —— 经度（度）。 altitude —— 相对于海平面的海拔高度（米）。如果设备不提供海拔数据，altitude 的值为null。 accuracy —— 返回经纬度的精度，以米为单位。 altitudeAccuracy —— 返回海拔的精度，以米为单位。altitudeAccuracy 可能为null。 heading —— 返回设备的移动方向（角度），指示距离北方的角度。0度表示指向正北方，方向以顺时针旋转（这表示东方是90度，西方是270度）。如果speed是0，heading会是NaN。如果设备无法提供heading信息，值为null。 speed —— 返回设备每秒的移动速度（米）。speed可能为null。 timestamp —— 获取得到设备当前位置的时间。 ​ Geolocation静态属性值包含以下通用设置： enableHighAccuracy —— 布尔值，如果设为true并且设备能够提供更精确地位置，则应用尽可能获取最佳结果。注意着可能导致更长的响应时间和更大的电量消耗（如开启了移动设备的GPS）。如果设置为false，将会得到更快速的响应和更少的电量消耗。默认值为false。 timeout —— 代表返回位置的最大时间（毫秒）限制。默认值是Infinity，意味着getCurrentPosition()直到位置可用时才会返回。 maximumAge —— 代表可返回的可用缓存位置的最大时限。如果设置为0，意味着设备不使用缓存位置，始终尝试获取实时位置。如果设置为Infinity，设备必须返回缓存位置无论其寿命。默认值：0。 1、获取当前定位 使用静态方法Geolocation.getCurrentPosition()获取当前的位置，getCurrentPosition()只触发一次。 /** * 获取设备当前位置。 * @param onSuccess 带有唯一Position参数的回调处理器。 * @param onError 可选的。带有错误信息的回调处理器。错误代码为Geolocation.PERMISSION_DENIED、Geolocation.POSITION_UNAVAILABLE和Geolocation.TIMEOUT之一。 */ static getCurrentPosition(onSuccess: Handler, onError: Handler = null): void { Geolocation.navigator.geolocation.getCurrentPosition(function (pos: any): void { Geolocation.position.setPosition(pos); onSuccess.runWith(Geolocation.position); }, function (error: any): void { onError.runWith(error); }, { enableHighAccuracy: Geolocation.enableHighAccuracy, timeout: Geolocation.timeout, maximumAge: Geolocation.maximumAge }); } 在LayaAir IDE中，给Scene2D添加一个自定义的组件脚本，添加如下代码，实现鼠标点击后，获取地理位置。 const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { constructor() { super(); } onMouseClick(evt: Laya.Event): void { // 尝试获取当前位置 Laya.Geolocation.getCurrentPosition( Laya.Handler.create(this, this.onSuccess), Laya.Handler.create(this, this.onError) ); console.log(\"click\"); } // 成功获取位置后触发 onSuccess(info: Laya.GeolocationInfo): void { console.log('经纬度: (' + info.longitude + '°, ' + info.latitude + '°)，精确度：' + info.accuracy + 'm'); if (info.altitude != null) console.log('海拔：' + info.altitude + 'm' + (info.altitudeAccuracy != null ? ('，精确度：' + info.altitudeAccuracy + 'm') : '')); if (info.heading != null && !isNaN(info.heading)) console.log('方向：' + info.heading + \"°\"); if (info.speed != null && !isNaN(info.speed)) console.log('速度：' + info.speed + \"m/s\"); } // 获取位置失败后触发 onError(err: any): void { var errType: String; if (err.code == Laya.Geolocation.PERMISSION_DENIED) errType = \"Permission Denied\"; else if (err.code == Laya.Geolocation.POSITION_UNAVAILABLE) errType = \"Position Unavailable\"; else if (err.code == Laya.Geolocation.TIMEOUT) errType = \"Time Out\"; console.log('ERROR(' + errType + '): ' + err.message); } } 以上示例代码演示使用getCurrentPosition()获取当前的位置信息，成功时打印地理位置信息，失败时打印错误信息和错误原因。 开发者如果点击IDE内的浏览器预览，上述示例则会打印Permission Denied（没有权限）的错误信息，原因是getCurrentPosition()获取位置信息时，Geolocation中navigator.geolocation的使用，只能使用https协议，普通的http协议是无法执行的，而IDE默认打开的谷歌浏览器里使用的是http协议。 这里提供一种测试办法，开发者可以先Web发布，然后用anywhere命令启动https进行测试。这里要注意，示例中将获取地理位置的方法放在了鼠标点击事件中，原因是navigator.geolocation只有响应用户的手势操作时，才会返回地理信息。所以如果直接放在onStart()等全局方法里面是不行的，得是像onMouseClick()这样的手势事件的响应函数才可以。 获取位置信息需要开启代理。 2、监视位置改变 除了获取当前位置之外，还可以监视位置的改变。使用Geolocation.watchPosition()监视位置改变，该函数返回一个监视器ID值，可以使用Geolocation.clearWatch()并传入该ID值来取消由watchPosition()注册的位置监听器。 /** * 监视设备当前位置。回调处理器在设备位置改变时被执行。 * @param onSuccess 带有唯一Position参数的回调处理器。 * @param onError 可选的。带有错误信息的回调处理器。错误代码为Geolocation.PERMISSION_DENIED、Geolocation.POSITION_UNAVAILABLE和Geolocation.TIMEOUT之一。 */ static watchPosition(onSuccess: Handler, onError: Handler): number { return Geolocation.navigator.geolocation.watchPosition(function (pos: any): void { Geolocation.position.setPosition(pos); onSuccess.runWith(Geolocation.position); }, function (error: any): void { onError.runWith(error); }, { enableHighAccuracy: Geolocation.enableHighAccuracy, timeout: Geolocation.timeout, maximumAge: Geolocation.maximumAge }); } /** * 移除watchPosition安装的指定处理器。 * @param id */ static clearWatch(id: number): void { Geolocation.navigator.geolocation.clearWatch(id); } 以下示例同第1节示例的测试方法相同，需要发布后进行测试。 const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { constructor() { super(); } onKeyDown(): void { // Geolocation.watchPosition函数签名 Laya.Geolocation.watchPosition( Laya.Handler.create(this, this.updatePosition), Laya.Handler.create(this, this.onError)); console.log(\"keydown\"); } updatePosition(info: Laya.GeolocationInfo): void { console.log('经纬度: (' + info.longitude + '°, ' + info.latitude + '°)，精确度：' + info.accuracy + 'm'); } onError(err: any): void { var errType: String; if (err.code == Laya.Geolocation.PERMISSION_DENIED) errType = \"Permission Denied\"; else if (err.code == Laya.Geolocation.POSITION_UNAVAILABLE) errType = \"Position Unavailable\"; else if (err.code == Laya.Geolocation.TIMEOUT) errType = \"Time Out\"; console.log('ERROR(' + errType + '): ' + err.message); } } watchPosition()具有和getCurrentPosition()一样的函数签名。更多关于watchPosition()的应用，可以查看文档《使用百度地图》。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-07-25 15:14:06 "},"basics/common/device/baiduMap/readme.html":{"url":"basics/common/device/baiduMap/readme.html","title":"使用百度地图","keywords":"","body":"使用百度地图显示当前位置一、首先介绍成员变量：二、接着是构造函数：使用百度地图显示当前位置 本节一步步演示使用watchPosition()在百度地图上标注出当前所在位置。watchPosition方法来自于Geolocation API，学习本节前请先阅读Geolocation基础文档或Geolocation API文档。 在开始之前需要在index.html中引入百度地图的脚本文件，这个url在百度地图的官方网站可以免费获取到。演示中使用的url是http://api.map.baidu.com/api?v=2.0&ak=LIhOlvWfdiPYMCsK5wsqlFQD8wW4Bfy6，在 标签中添加的代码如下： 一、首先介绍成员变量： // 百度地图 private map: any;// 地图引用 private marker: any;// 地图标注物 private BMap: any = Laya.Browser.window.BMap;// 百度地图命名空间 private convertor: any;// 坐标转换接口 private mapDiv: any;// 包含百度地图的div容器 二、接着是构造函数： constructor() { Laya.init(1, 1); this.init(); // 使用高精度位置 Laya.Geolocation.enableHighAccuracy = true; Laya.Geolocation.watchPosition(Laya.Handler.create(this, this.updatePosition), Laya.Handler.create(this, this.onError)); // 绑定convertToBaiduCoord作用域 this.convertToBaiduCoord = this.convertToBaiduCoord.bind(this); } } 由于本例不需要使用LayaAir的显示元素，因此舞台尺寸设置为1。百度地图界面的初始化放在init()中。然后是监听设备位置的变化。最后需要注意，函数convertToBaiduCoord()是将获取到的坐标转换至百度地图坐标，由于它是作为convertor.translate()的参数，所以触发时作用域会被改变，因此在这里绑定了该函数的作用域。 2.1 init函数： private init(): void { this.mapDiv = Laya.Browser.createElement(\"div\"); Laya.Browser.document.body.appendChild(this.mapDiv); // 适应窗口尺寸 this.refit(); Laya.stage.on(Laya.Event.RESIZE, this, this.refit); // 初始化地图 this.map = new this.BMap.Map(this.mapDiv); // 禁用部分交互 //this.map.disableDragging(); this.map.disableKeyboard(); this.map.disableScrollWheelZoom(); this.map.disableDoubleClickZoom(); this.map.disablePinchToZoom(); // 初始地点北京，缩放系数15 this.map.centerAndZoom(new this.BMap.Point(116.32715863448607, 39.990912172420714), 15); // 创建标注物 this.marker = new this.BMap.Marker(new this.BMap.Point(0, 0)); this.map.addOverlay(this.marker); } init()函数初始化百度地图。关闭了大部分交互功能，只留下拖动地图。地图初始地点位于北京，缩放系数15。并且添加了一个地图标注物。 2.2 refit函数： private refit(): void { this.mapDiv.style.width = Laya.Browser.width / Laya. Browser.pixelRatio + \"px\"; this.mapDiv.style.height = Laya. Browser.height / Laya. Browser.pixelRatio + \"px\"; } refit()使百度地图充满整个窗口，由于侦听了resize事件，在窗口resize时也会重新填充窗口。 2.3 updatePosition函数： // 更新设备位置 private updatePosition(p: Laya.GeolocationInfo): void { // 转换为百度地图坐标 var point:any = new this.BMap.Point(p.longitude, p.latitude); // 把原始坐标转换为百度坐标，部分设备的浏览器可能获取到的是谷歌坐标，这时第三个参数改为3才是正确的。 this.convertor.translate([point], 1, 5, this.convertToBaiduCoord); } updatePosition()是Geolocation.watchPosition()的触发函数，在每次监测到位置改变后都需要把获取到的原始坐标转换到百度坐标，才能在百度地图上显示正确的位置。 注意有的设备浏览器获取到的坐标可能是谷歌坐标，这时convertor.translate的第三个参数就不是5，而是3。 2.4 convertToBaiduCoord函数： // 将原始坐标转换为百度坐标 private convertToBaiduCoord(data: any): void { if (data.status == 0) { var position: any = data.points[0]; // 设置标注物位置 this.marker.setPosition(position); this.map.panTo(position); } } 在转换完成后设置标注物的位置，并且把视角平移到以标注物为中心的视口中。 2.5 onError函数： private onError(e: any): void { var errType: string; if (e.code = Laya.Geolocation.PERMISSION_DENIED) errType = \"Permission Denied\"; else if (e.code == Laya.Geolocation.POSITION_UNAVAILABLE) errType = \"Position Unavailable\"; else if (e.code == Laya.Geolocation.TIMEOUT) errType = \"Time Out\"; alert('ERROR(' + errType + '): ' + e.message); } 完成以上步骤之后就可以在设备上的浏览器查看效果。如果位置错误，把获取到的坐标当成谷歌坐标试试。注意浏览器本身的安全限制可能需要用户手动允许网页使用地理位置，或者Chrome需要https协议的地址才能够使用地理位置。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-07-27 11:59:06 "},"basics/common/Stat/readme.html":{"url":"basics/common/Stat/readme.html","title":"性能统计与优化","keywords":"","body":"性能统计与优化1、性能统计面板的调用2、FPS相关的介绍2.1 FPS概述2.2 WebGL模式下的FPS2.3 FPS的数值说明3、DrawCall介绍3.1 简介3.2 优化方法3.3 其它类别4、NodeNums的数值说明5、Sprite3D数值说明6、TriangleFace数值说明7、RenderNode数值说明8、SkinRenderNode数值说明9、ParticleRenderNode数值说明10、FrustumCulling数值说明11、GPUMemory数值说明12、TextrueMemory数值说明13、RenderTextureMemory数值说明14、BufferMemory数值说明15、uploadUniformNum数值说明性能统计与优化 　　LayaAir 引擎设计之初，就以性能为第一目标，在引擎内做了大量的性能优化。合理运用好引擎，可以让游戏等引擎产品达到原生APP的体验。如果开发者不能发挥好引擎的优势，那么游戏最终的性能体验或将无从谈起。因此，在制作游戏过程中，掌握游戏以及引擎的优化技巧还是非常有必要的。 要了解引擎的性能，首先要看懂性能统计面板，下面将针对性能统计面板进行详细介绍。 1、性能统计面板的调用 LayaAir引擎内置的性能统计面板可实时检测当前性能。调用统计面板因开发语言的不同，会有所不同。 直接输入TS语言代码 Laya.Stat.show(0,0); 即可调出性能统计面板。 示例Demo.ts编写代码如下： //初始化舞台 Laya.init(1136, 640); //调用性能统计面板方法，(0,0)为面板位置坐标 Laya.Stat.show(0,0); Tips:要注意大小写。 2、FPS相关的介绍 2.1 FPS概述 FPS是每秒传输帧数(Frames Per Second)的缩写。假设游戏的帧速为60FPS，表明游戏运行时每个帧的执行时间为1/60 秒。帧速值越高，视觉上感觉越流畅。 （图2-1） 当前PC与手机等设备的满帧是60帧，如图2-1所示，但某些游戏对画面的流畅度要求并不高，也可以采用引擎的帧速限制方法Stage.FRAME_SLOW，将FPS帧速限制为最高30帧。 由于实际运行环境是在浏览器中，所以性能还取决于JavaScript解释器的效率，因此，同一款游戏的FPS值在不同的浏览器中可能会存在差异。这部分不是开发者能够决定的，开发者能作的是尽可能使用好引擎及优化项目，争取在低端设备或低性能浏览器中，提升FPS帧速。 2.2 WebGL模式下的FPS LayaAir引擎支持WebG的渲染模式。如图2-2所示；FPS(WebGL)是WebGL模式下的帧速， （图2-2） 2.3 FPS的数值说明 图2-1与图2-2中，FPS的第一个黄色值60为当前的FPS帧速，越高越好。 第二个黄色值16为每帧渲染所消耗的时间，单位为毫秒，这个值越小越好。 这两个值如果不能维持在满帧，会在产品操作过程中产生变化，如动图2-3所示。 (动图2-3) 3、DrawCall介绍 DrawCall的次数是决定性能的重要指标，位于统计面板的第三行，如图4所示。DrawCall越少越好，建议开发者尽量限制在100之下。 (图3-1) 3.1 简介 DrawCall可以理解为“绘制指令”，表示CPU调用图形API，给GPU发送图形绘制命令。一般CPU的内存读写或数据处理速度，相对于GPU的渲染速度是很慢的，也就是说GPU处理完数据了，CPU那里还有很多DrawCall 没有处理，此时GPU处于低功率状态。也就是说，根本原因是CPU处理DrawCall不及时，导致了性能下降。所以DrawCall是越少越好。 WebGL模式下DrawCall表示渲染提交批次，CPU每次准备数据并通知GPU渲染绘制的过程称为1次DrawCall，在每1次DrawCall中除了在通知GPU的渲染上比较耗时之外，切换材质与shader也是非常耗时的操作。 3.2 优化方法 要优化DrawCall的次数，可以采取以下几种方法： 合并网格：将多个相同材质的网格合并成一个大的网格，减少渲染调用次数。 使用图集：将多个小的纹理合并成一个大的纹理图集，减少纹理切换次数。 使用批处理：将多个相同材质的物体放在一个批处理中一起渲染，减少渲染调用次数。 使用GPU实例化：使用GPU实例化技术，将多个相同模型的物体实例化渲染，减少渲染调用次数。 减少透明物体：透明物体的渲染需要进行混合操作，会增加DrawCall的次数，可以尽量减少透明物体的数量。 使用静态批处理：将不会发生变化的物体进行静态批处理，减少渲染调用次数。 通过以上优化方法，可以有效减少DrawCall的次数，提高游戏的性能表现。 详细的优化方式请参考《2D性能优化》和《3D性能优化》。 3.3 其它类别 性能统计面板中还有一些不同的类别： OpaqueDrawCall：表示内置渲染管线中，渲染不透明对象的数量。 TransDrawCall：表示内置渲染管线中，渲染透明对象的数量。 DepthCastDrawCall：表示内置渲染管线中，渲染阴影贴图的数量。 InstanceDrawCall：表示DrawCall的实例数。 CMDDrawCall：表示命令流中，渲染指令的数量。 BlitDrawCall：表示用blit将最终图像渲染到屏幕的次数。 4、NodeNums的数值说明 NodeNums是性能统计面板中的一个指标，表示当前场景中节点的数量。NodeNums的值越大，场景中的节点数量越多，对于性能的影响也越大。因此，在开发中应尽量减少场景中的不必要的节点，以提高游戏的性能表现。如图4-1所示。 （图4-1） 5、Sprite3D数值说明 Sprite3D是性能统计面板中的一个指标，表示当前场景中Sprite3D节点的数量。Sprite3D是3D节点的基础类，可以包含3D模型、材质、光照等属性，并且可以进行3D变换、动画等操作。 Sprite3D的数量是影响游戏性能的重要因素之一。Sprite3D数量过多，会导致渲染次数增加，从而影响游戏的帧率和性能表现。因此，在开发中应尽量减少场景中的Sprite3D节点数量，以提高游戏的性能表现。如图5-1所示。 （图5-1） 6、TriangleFace数值说明 TriangleFace是性能统计面板中的一个指标，表示当前场景中渲染的三角形面数。TriangleFace的值越大，表示场景中需要渲染的三角形面数越多，对于性能的影响也越大。 在3D渲染中，每个MeshRenderer（MeshSprite3D、SkinnedMeshSprite3D）都由多个三角形面组成。因此，在开发中应尽量减少需要渲染的三角形面数，以提高游戏的性能表现。如图6-1所示。 （图6-1） 要减少需要渲染的三角形面数TriangleFace，可以采取以下几种方法： 优化模型：使用更简单的模型，减少面数。 合并网格：将多个相同材质的网格合并成一个网格，减少渲染次数。 使用LOD技术：根据距离远近，使用不同细节级别的模型，减少远处模型的面数。 使用遮挡剔除：根据相机的视锥体，剔除不可见的模型，减少渲染的面数。 通过以上方法，可以有效减少需要渲染的三角形面数，提高游戏的性能。 7、RenderNode数值说明 RenderNode是性能统计面板中的一个指标，表示当前场景中渲染节点的数量。渲染节点是指需要进行渲染的节点，包括Sprite、MeshSprite3D、SkinnedMeshSprite3D等。 RenderNode的数量是影响游戏性能的重要因素之一。RenderNode数量过多，会导致渲染次数增加，从而影响游戏的帧率和性能表现。如图7-1所示 。 （图7-1） 8、SkinRenderNode数值说明 SkinRenderNode是性能统计面板中的一个指标，表示当前场景中骨骼动画渲染节点的数量。骨骼动画渲染节点是指需要进行骨骼动画渲染的节点，包括SkinnedMeshSprite3D等。如图8-1所示 。 SkinRenderNode的数量是影响游戏性能的重要因素之一。SkinRenderNode数量过多，会导致渲染次数增加，从而影响游戏的帧率和性能表现。 （图8-1） 9、ParticleRenderNode数值说明 ParticleRenderNode是LayaAir引擎3.0版本中性能统计面板中的一个指标，表示当前场景中粒子渲染节点的数量。粒子渲染节点是指需要进行粒子渲染的节点，包括ParticleSystem。如图9-1所示。 可以通过减少粒子数量，使用合理的粒子发射器设置，进行优化，避免粒子数量过大。 （图9-1） 10、FrustumCulling数值说明 Frustum Culling是性能统计面板中的一个指标，表示当前场景中开启视锥体裁剪的渲染节点数量。视锥体裁剪是指只对在视锥体内的物体进行渲染，超出视锥体的物体不进行渲染，从而减少不必要的渲染，提高游戏的性能表现。如图10-1所示。 Frustum Culling的数量越大，表示场景中开启视锥体裁剪的渲染节点数量越多，对于性能的影响也越大。 （图10-1） 在开发中，可以通过设置合适的视锥体大小和位置，避免视锥体过大或过小，从而减少不必要的渲染。 也可以通过合理的节点管理和视锥体裁剪设置，提高Frustum Culling的效率，进而提高游戏的性能表现。 11、GPUMemory数值说明 GPUMemory是性能统计面板中的一个指标，表示当前场景中占用GPU内存的大小。GPU内存是指用于存储GPU所需数据的内存，包括纹理、缓冲区等。如图11-1所示。 GPUMemory占用过多，会导致游戏卡顿、掉帧等问题。 （图11-1） 12、TextrueMemory数值说明 TextureMemory是LayaAir引擎3.0版本中性能统计面板中的一个指标，表示当前场景中占用纹理内存的大小。纹理内存是指用于存储纹理数据的内存，包括贴图、字体等。如图12-1所示 TextureMemory占用过多，会导致游戏卡顿、掉帧等问题。 （图12-1） 13、RenderTextureMemory数值说明 RenderTextureMemory是性能统计面板中的一个指标，表示当前场景中占用渲染纹理内存的大小。渲染纹理内存是指用于存储渲染纹理数据的内存，包括用于动态生成纹理的RenderTarget等。如图13-1所示。 （图13-1） 在游戏中，RenderTextureMemory的作用是用于存储渲染纹理数据，这些数据可以用于实现一些特效、后期处理、屏幕抓取等功能。渲染纹理可以将场景渲染到一个纹理上，然后再将这个纹理作为材质应用到其他物体上，从而实现一些特殊效果。 然而，渲染纹理的使用会占用一定的内存资源，如果渲染纹理内存占用过多，会导致游戏卡顿、掉帧等问题。因此，在游戏开发中，需要合理使用渲染纹理，避免过多的渲染纹理内存占用，以提高游戏的性能。 14、BufferMemory数值说明 BufferMemory是性能统计面板中的一个指标，表示当前场景中占用缓冲区内存的大小。缓冲区内存是指用于存储缓冲区数据的内存，包括顶点缓冲区、索引缓冲区等。如图14-1所示。 （图14-1） 15、uploadUniformNum数值说明 Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，但uniform和顶点属性有些不同。首先，uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。 Uniform的详细介绍请参考《自定义Shader》。 uploadUniformNum表示Shader里的Uniform更新数量，每增加一个Uniform，就增加一个计数。如图15-1所示，参数位于统计面板的最后一行。 （图15-1） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-10-08 19:29:08 "},"basics/3D/readme.html":{"url":"basics/3D/readme.html","title":"3D引擎基础","keywords":"","body":"3D引擎基础3D概念入门3D变换3D引擎基础 本章节部分，介绍引擎相关的基础概念与API使用 3D概念入门 3D变换 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:13 "},"basics/3D/beginner/readme.html":{"url":"basics/3D/beginner/readme.html","title":"3D概念入门","keywords":"","body":"3D概念入门一、场景与摄像机1.1 摄像机1.2 透视投影与正交投影二、坐标系与坐标2.1 坐标系2.2 顶点坐标与UV坐标三、三角面、网格、模型3.1 三角面3.2 网格3.3 模型四、材质4.1 模型材质4.2 天空材质4.3 粒子4.4 拖尾五、纹理、贴图、面片六、灯光、阴影、反射光6.1 灯光6.2 阴影6.3 反射光七、加色法光效 、环境光、泛光、光照贴图八、Shader（着色器）九、3D物理系统、3D动画系统十、3D基础的常用数学概念10.1 向量10.2 矩阵10.3 欧拉角、四元数10.4 射线10.5 包围体写在最后3D概念入门 Author ：charley 学习最大的障碍就是未知，比如十八般兵器放在你面前都认不出来，又谈何驰骋沙场。更何况3D游戏开发本就是一个门槛不低的工作。本篇抛开引擎的结构，本着初次认知3D游戏世界的逻辑，让没有3D基础的开发者，通过本篇文章，对LayaAir 3D引擎的基础功能以及3D基础概念有一个概览性认识。 至少，我们要了解3D世界的基础都有哪些，然后再依据官方的文档逐个深入学习掌握。 一、场景与摄像机 1.1 摄像机 场景就是游戏中的3D世界，有了场景，才可以在场景中添加一切物体，包括摄像机。 而摄像机相当于3D游戏世界的眼睛， 通过摄像机，玩家才能看到游戏中三维世界，看到场景中的各种物体。 所以，场景里最少要有一台摄像机。 （图1-1） 当我们在写3D游戏的代码时，要先在舞台中添加3D场景，添加3D摄像机。再写其它代码。 摄像机在3D场景中，可以是唯一的，也可以放置多台摄像机，比如，在图1-2的3D场景中出现的弹窗换装面板，或者某些对战游戏的同屏需求时会用到多个摄像机。 （图1-2） 1.2 透视投影与正交投影 摄像机的成相效果，分为透视和正交两种。LayaAir引擎的3D摄像机默认是透视模式，这是一种模拟了人眼的视觉效果，如图1-3所示，近大远小。 （图1-3） 正交则没有透视感，常用于一些2D与3D混合的游戏或模型查看器等。 （图1-4） 二、坐标系与坐标 坐标是3D空间世界的基础之一，干啥都离不开坐标，移动摄像机，定位，绘制图形等等。 在学习LayaAir 3D时，我们需要了解两个坐标，一个是位置坐标， 另一个是UV坐标。 而了解这两种坐标之前，我们先介绍一下空间笛卡尔直角坐标系。 2.1 坐标系 空间笛卡尔直角坐标系是用经过相同原点的xyz三条互相垂直的坐标轴相交而构成。 （图2-1） 坐标系的两个轴正方向一致的情况下，因第三轴正方向相反，所以将坐标系分为左手坐标系与右手坐标系。 这两种坐标系没有好或不好，都应用的都比较广泛，比如Unity等引擎采用的是左手坐标系，LayaAir等引擎采用的是右手坐标系。所以我们有必要理解什么是左手坐标系与右手坐标系，以及两者的区别。 两种3D坐标系之所以用左右手分别命名，是为了便于记忆，分别用左手和右手三根手指的朝向，来代表三个坐标轴的正方向，这三个手指分别是拇指、食指、中指。 无论是左手还是右手，我们要记住，大拇指朝向的方向是x轴正方向，食指的朝向是y轴的正方向，中指的朝向是z轴的正方向。 现在我们面向屏幕，准备好双手来摆造型。先将左右两个手的食指（y轴）指向天空方向（在房间的就指天花板），然后将中指（z轴）冲前（立正站立时眼睛平视的方向），此时两个手的中指应该都与食指保持90度垂直。然后，再伸出大拇指（x轴）与食指和中指都保持90度垂直。可以参照图2-2的手势。 （图2-2） 网络中有不同的左右手坐标系统的说法和介绍，如果图片和轴朝向与本篇介绍的不同，一般也都是摄像机角度的差异，不用管别的，学习LayaAir以本篇为准来理解记忆即可。 摆好后，我们会发现，在保持z轴和y轴正方向相同的情况下，x轴的正方向是相反的。这就是左手坐标系和右手坐标系的区别。 LayaAir引擎unity导出插件就是以x轴取反来自动适配LayaAir引擎。所以，直接在unity里编辑导出，然后在LayaAir引擎中使用，是不需要手工对坐标进行转换的。如果开发者一定要在LayaAir引擎项目中手动来调坐标，那需要注意左手坐标系与右手坐标系在x轴正方向的差异。 2.2 顶点坐标与UV坐标 了解完坐标系，我们了解一下顶点。顶点可以理解为3D空间中的任意一个带xyz坐标的位置点，但顶点不仅包含了坐标位置信息，还有UV、法线、颜色等信息。其它的先不讲，我们继续来了解UV。 UV其实也是坐标， 完整的说应该是UVW（由于xyz已经被顶点坐标轴占用，所以另选三个字母表示）， 这三个轴U是屏幕水平方向，V是屏幕垂直方向，W的方向是垂直于显示器表面的，到目前为止，一般游戏开发是用不上的，所以我们通常就会简称为UV。 去掉了W，如图2-3所示，那UV坐标就是一个2D平面坐标，UV坐标可用于模型纹理贴图等（后面介绍纹理的时候还会提及）。 （图2-3） UV坐标的贴图纹理向右和向下分别是U与V的坐标正方向。取值范围是0-1，不管纹理图片的像素是多少，如图2-4所示，3D美术制作软件导出的模型顶点数据都会对应贴图纹理的UV坐标，以保障渲染时的采样正确。 （图2-4） 相对于UV坐标最终会对应贴图纹理上的像素点，顶点坐标则没有恒定的计量单位，最小的单位是点，无论是现实世界还是3D世界，点都是一个基础的抽象概念，他代表着一个单独的个体，可以无限大，也可以无限小。所以，点可以是1个像素，也可以是1毫米、1纳米、1千米等任意单位的基础单元。最终顶点之间用什么计量单位，通常由3D美术结合游戏设计而设定，3D游戏美术用的比较多的单位是米。所以程序的设定要与美术设定的单位保持统一，否则就会造成视觉效果上的过大或过小，出现与设计不符的效果。 三、三角面、网格、模型 模型是3D游戏中可见物的基础，比如人物，房屋，树木，山川，河流等等，几乎绝大多数可见物体都是以模型为基础构成。 3.1 三角面 要进一步了解模型，我们先从三角形平面（简称三角面）开始，三角面是由三个顶点构成，是显卡唯一能处理的基础多边形。之所以把三角面视为最基本的多边形，其中一个重要原因是，由三个点构成的三角面一定是在同一个平面上，而四个或更多点构成的多边形在三维空间中，不一定会在同一个平面上。 3.2 网格 而网格（ Mesh）则是由一个三角面或多个三角面拼接形成，是构建模型形状的基础。在LayaAir引擎中， 构成各种图形形状的三角面顶点数据以及三角面的索引数据集合就是网格，所以网格在游戏运行时是不可见的，图3-1是使用像素线精灵来表现模型的网格构成。 （图3-1） 3.3 模型 模型是由网格（ Mesh）与材质（ Material）组成。材质内容太多，下一节再展开说明。从构成三维图形形状而言，我们可以理清以下关系，模型的基础是网格，网格的基础是三角面。三角面越多，模型可表现的细节越丰富。图3-2正是40000面和4000面及400面的模型细节表现差异。细节表现比较丰富的，通常被称为精模，细节表现相对较弱的，被称为简模。 （图3-2） 到底使用精模还是简模，这需要研发技术结合整体效果和游戏硬件性能可承受的压力情况向美术提出需求，在这一点上，移动端H5及小游戏与手游APP标准可保持相等标准。 四、材质 之前讲过，网格只是三维形状的数据，网格形状本身是不可见的。怎么可见，那就需要材质（ Material）了。 顾名思义，材质就是材料的质感。例如，木头与金属、玻璃与毛发，从粗糙度、光泽度、反射、透明、颜色、纹理等等方面，不同的材料质感会明显不同。 根据这些物体的差异，我们可以将材质划分为很多种类，LayaAir引擎支持的材质分类为模型材质、天空材质、粒子材质、拖尾材质。 4.1 模型材质 LayaAir引擎的模型材质还可以继续划分，分别为光照材质（BlinnPhongMaterial） 、不受光材质（UnlitMaterial）、PBR材质（PBRMaterial） 。 BlinnPhong材质是默认使用的标准感光材质，而UnlitMaterial材质恰恰相反，并不受光照影响，只显示原贴图的外观图像效果。 图4-1中，图左是光照材质（ BlinnPhongMaterial）被光照射后的效果，图右是同样被光照射后的不受光材质（ UnlitMaterial ）效果。 （图4-1） PBR材质是一种基于物理渲染 (Physicallly Based Rendering) 的材质，通过模拟自然界的物理规律可以让3D模型的质感更为真实，接近或还原现实世界中的质感。例如，图4-2中的桶采用了PBR材质。 （图4-2） 基于网格与材质组成了模型这一概念，理论上一切可见的形状物体，都是模型。但依据开发的易用性，引擎会进一步对一些常用功能进行封装，比如下面介绍的天空、粒子系统、拖尾系统。 4.2 天空材质 LayaAir模拟的3D天空，提供了两种现成的网格，一种是立方体网格（SkyBox），这种天空称为天空盒，采用立方体映射方法。另一种是球形网格（SkyDome），这种可称为天空球或球形天空，采用球映射方法。当然，开发者也可以自定义其它的天空网格创建天空。 球形网格(SkyDome)创建的天空可以展现更真实的天空效果，比如曲面的云层和更真实的地平线。该技术方案相较于立方体网格(SkyBox)，顶点更多，性能的消耗自然要大一些。开发者要根据需求来创建天空。 创建天空后，LayaAir还提供了三种现成的天空材质：天空盒材质（SkyBoxMaterial）、全景天空材质（SkyPanoramicMaterial）、程序化天空材质（SkyProceduralMaterial）。 天空盒材质（SkyBoxMaterial）以6张无缝连接的材质纹理贴图形成，类似盒子拆开平铺。例如图4-3所示的纹理， （图4-3） 全景天空材质（SkyPanoramicMaterial）是只有一张贴图纹理的技术方案，例如图4-4所示的纹理， （图4-4） 程序化天空材质（SkyProceduralMaterial）不需要贴图，如图4-5所示，设置太阳类型等参数即可。但只有球形网格(SkyDome)创建的天空才能使用程序化天空材质，因为这种材质使用的顶点着色，需要更精细的顶点信息。 （图4-5） 4.3 粒子 粒子是一组分散的微小物体集合，通过让这些微小的物体按某种算法运动起来，从而实现诸如火焰、烟、爆炸、流水、等比较灵动的效果。粒子系统并不是一种绘制形式，而是一种动画方法，粒子系统的作用是在粒子产生、运动、变化以及消失这个生命周期内去控制它们。LayaAir引擎的粒子系统包括了粒子发射器、粒子动画器、和粒子渲染器等多个部分。 （图4-6） 4.4 拖尾 拖尾，顾名思义是拖在后面尾巴一样的效果，常用于带条状3D特效，比如，刀光拖尾，跑酷小球游戏的行动轨迹拖尾等。LayaAir引擎内置了拖尾系统和拖尾材质，方便开发者快捷使用3D拖尾。 （图4-7） 五、纹理、贴图、面片 纹理是指物体表面的外观效果，表现为2D位图形式。图5-1为3D地球仪表面的纹理。 （图5-1） 贴图简单通俗的理解，就是将2D纹理贴到3D模型网格的过程。这个将3D顶点坐标与2D纹理的UV坐标映射对应的过程由引擎完成，开发者直接调用API，为材质设置对应的纹理即可。图5-2左侧为仅添加材质，而没有设置贴图的效果。图5-2右侧是对材质添加了纹理的已贴图效果。 （图5-2） 通过效果图5-2可以看出，尽管网格与材质已经可以让模型在3D游戏场景中可见了，但不对材质贴图，没有纹理的情况下，看到的只是不同质感的纯色模型。有了纹理才有了真实丰富的外观。所以纹理也是比较重要的一个知识点，如果展开讲，纹理可以介绍很多。本篇不再详述。 介绍到这里，我们已能初步理解到纹理与贴图的区别。然而，很多时候，在文档或口述交流的时候，很多人会把用于贴图的纹理，也简称为贴图。所以我们应该能理解到贴图在某些应用场景下就是代指纹理。 之所以把面片放到纹理一起介绍，是因为对3D一知半解时，不少人会有一个误区，认为面片就是在3D空间中放了一个2D纹理位图。实际上，在三维空间中，哪怕只有一个三角形平面，也可以构成网格，可以设置材质，那这就是模型。所以面片，与其它多面体模型，本质上都是一样的。如图5-3所示，在3D空间中看到的草地图片，其实是这个草地面片材质的贴图。 （图5-3） 六、灯光、阴影、反射光 光源是3D场景中不可缺少的重要组成部分，网格和纹理决定了物体的形状和外观，光源则可以照明、可以产生阴影、还可以影响场景环境以及3D模型的颜色、亮度、氛围等等。 6.1 灯光 3D中的光源就是灯光，其它如泛光、环境光等都是光效，而非光源。3D灯光有四种：平行光（DirectionLight）、点光（PointLight）、聚光（SpotLight）、区域光（AreaLight）。LayaAir引擎不仅支持这些光源的任意类型，还支持在同一场景下任意添加多个不同类型的光源。 平行光（DirectionLight）是一种模拟大自然太阳光的灯光，来自光源的光线始终都是平行的且没有衰减。LayaAir中可设定光源方向，用于给全场景照亮。 （图6-1） 点光（PointLight）是一种以光源点为中心，向四周呈发射状的光源，光源点位于3D空间中的某个位置。类似于现实中的蜡烛光、篝火、家用电灯等发光的方式，这种光拥有照射范围和衰减半径。光照范围之外的地方则处于无光的黑暗之中。 （图6-2） 聚光（SpotLight）与点光类似，都属于位置光，也是位于3D空间的某个位置，也有照射范围和衰减半径，但是，与向四周发散的无方向点光不同，聚光则拥有光源方向，是一种呈锥形角度的光源，类似于现实中的手电洞、舞台聚光灯等光源效果。 （图6-3） 区域光（AreaLight）可以通过空间中的两个形状之一定义区域光：矩形或圆盘。区域光从该形状的一侧发射光。发射的光在该形状的表面区域的所有方向上均匀传播。由于此照明计算非常占用处理器，因此区域灯光要烘焙到光照贴图中。 6.2 阴影 阴影是灯光照射模型时产生的， 实时阴影随着灯光角度、灯光强度、模型位置等变化而变化。能产生更加强烈的立体感与真实感。 （图6-4） 6.3 反射光 反射光，是指光源在照射到3D模型上，反射产生的光效。为了模拟自然反射现象，根据不同材质，引擎对反射光会使用不同的光照模型，比如，BlinnPhong材质中使用了漫反射和镜面反射模型。我们简单来理解一下两者的差异。 （图6-5） 引擎中的漫反射主要是模拟材质表面粗糙不平的光学反射效果，理想的漫反射材质表面是完全不光滑且没有光泽的，当光源照射到这种材质上，呈现出发散的反射效果。 引擎中的镜面反射用于模拟光滑水平面的光学反射效果，是一种有方向反射，其反射方向以反射平面的法线为中心与入射方向的夹角对等。理想的高光反射材质是表面完全光滑的，比如像镜子一样。镜面反射常用于闪闪发光的视觉效果，且会产生高亮的点状光斑，所以镜面反射有的时候也叫镜面高光。一些材质相关的文档中提到高光颜色或者高光贴图，我们要能理解，这是指针对镜面反射效果的高光颜色和高光贴图。 基于漫反射和镜面反射的光学现象，引擎中使用了多个光照模型，用于模拟自然光中的反射现象。本篇先揭开一点。暂且先有一个初步的认知。我们继续来了解一些其它与光相关的概念。 七、加色法光效 、环境光、泛光、光照贴图 上一小节是介绍的3D灯光以及与灯光息息相关的光效。这个小节还是介绍光，但这些光不属于照射光，只是看起来比较像是光的一些效果。我们将逐个了解LayaAir引擎中的一些其它光效。 加色法光效可以让材质本身就会有发光的效果，这是一种通过加色法模拟出来的光感，并非是受光照产生，比如引擎种的特效材质（EffectMaterial）。这种的自发光效果不会对周围环境及其它模型产生影响，但会被背影色影响。 （图7-1） 环境光类似于全局颜色滤镜。设置白色等亮色，即便没有光源，场景中也都能比较明亮。想表现阴天的感觉，也可以加入一些灰暗的环境光颜色。或者要表现夜视镜效果等等，都可以通过环境光来设置。 （图7-2） 泛光在LayaAir引擎中属于后期效果。即便没有光源的照射，也可以产生一种类似光晕叠加的效果。 （图7-3） 光照贴图是一种通过贴图的方式模拟游戏场景中的光影效果，也是游戏中为了节省性能而常用的一种伪光照视觉效果的制作方式。图7-4中的光效并非是通过灯光实现，是光照贴图的效果。 （图7-4） 八、Shader（着色器） Shader 中文名为着色器， Shader本质上是一段采用GLSL着色语言编写（着色语言好几种，基于webGL只能用GLSL语言）在GPU上运行的程序 ， 用于告诉图形软件如何计算和输出图像。Shader主要分两类：顶点着色器和片段着色器（也叫片元着色器） 。 顶点着色器是用来处理顶点数据的程序，如顶点坐标、法线、颜色和纹理坐标。 它在每个顶点上调用，可将几何图形（例如：三角形）从一个位置转换为另一个位置， 例如，用于顶点变换、纹理坐标生成、 纹理坐标变换等等。 片段着色器用来计算和填充每个像素的颜色，所以也称为像素着色器。可用于插值的运算、 纹理存取、纹理应用 、 雾 、 色彩计算等。 LayaAir提供了自定义Shader功能，可以让开发者实现一些引擎未曾提供的功能或者效果。Shader的实现有一定的门槛，新手先不要急着研究这个，先有个基础的认知即可。 九、3D物理系统、3D动画系统 3D物理系统是通过模拟真实物理属性的方式来计算重力、运动、旋转、碰撞反馈等，LayaAir引擎内置了bullet等3D物理引擎。 动画是交互式游戏不可缺少的组成部分。 LayaAir引擎中支持使用材质动画，刚体动画，摄像机动画，骨骼动画这几种动画类型。 其中，材质动画是以改变材质的颜色与贴图方式的动画。 刚体动画又称为变换动画，是指不改变模型顶点、材质的基础上，只对模型进行旋转、缩放、位移的动画，比如，脚底光环、刀光等。刚体动画也经常与材质动画结合使用。 骨骼动画也称为蒙皮动画，这种动画主要是以改变模型顶点的方式产生动画。 摄像机动画是指通过改变摄像机位置而产生的动画效果。 十、3D基础的常用数学概念 在之前的小节中，我们已经可以对3D游戏和图形开发，有了一个基础的概念性认知。最后简单介绍一些3D数学的基础常用概念。例如： 向量、 矩阵、 欧拉角、四元数、射线、包围体。 10.1 向量 既有大小又有方向的量称之为向量（物理学叫矢量），向量也有维度，例如，2维、3维、4维。与向量对应的是数量（物理学叫标量），数量是只有大小没有方向的量。 有的文章把数量理解为1维向量，而我们通常所指的向量是2维或以上维度，不包括1维。 在LayaAir引擎中，针对2维、3维、4维向量的封装方法示例分别为： Vector2(1, 2) 、Vector3(1, 1, 3)、Vector4(1, 2, 3, 0.5) 。然而LayaAir引擎封装的Vector方法，不仅可以作为向量的使用，还可以用于顶点坐标位置，或者表达颜色的时候使用。比如原点坐标Vector3(0, 0, 0)，颜色值Vector3 (0.6, 0.6, 0.6) 、Vector4(0.9, 0.5, 0.1, 1)。 提到向量，再顺带理解一下分量，我们把一个向量分解成几个方向的向量之和，那这些分解的向量就叫做该向量的分量（也称为向量投影）。 例如，某个向量坐标u为（5，10），那分解的向量坐标w1（5，0）和w2（0，10）都是向量坐标u的分量。在引擎中，我们也可以把向量元素视为分量，比如 Vector3( 0.6, 0.6, 0.5) ，有3个分量，其中的0.5称为这个向量的第3个分量。 10.2 矩阵 在线性代数中，矩阵是以行和列形式组织的矩形数字块。如果把向量定义为1维数组，那么矩阵就是2维数组。这里不要把2维理解为2D，是指来自数组的行与列形成2维。以数组的角度去理解，那向量是数量的数组，矩阵则是向量的数组。 矩阵是在显卡图形API中直接用于描述方位的形式，可立即进行向量的旋转。LayaAir引擎提供了3×3的旋转矩阵Matrix3x3() 和4×4的变换矩阵Matrix4x4()，变换矩阵可用于平移、旋转、缩放计算。 10.3 欧拉角、四元数 欧拉角与四元数都是用于旋转计算的数学方法，刚刚介绍的矩阵明明也可以用于旋转计算，为什么要介绍这两种呢？相对而言，3×3旋转矩阵需要9个数，欧拉角只需3个数（3维向量），四元数只需要4个数（4维向量），明显轻量了很多。那是不是欧拉角最优，也不尽然。尽管欧拉角内存占用小，也更加易用，但欧拉角也有他特有的问题，那就是可能会导致万向节死锁。而四元数则相对于矩阵内存占用小，也不受万向节死锁的困扰，而且在平滑插值方面只能是四元数才能完成。 10.4 射线 射线是只有一个端点无限延长形成的直的线，在LayaAir引擎中的射线 Ray是一个数据对象，拥有起点与发射方向两个属性。常用于基础的碰撞检测，也可以用于鼠标拾取。 10.5 包围体 包围体用于可见检测计算，基本思想是体积稍大且结构简单的包围体来替代结构复杂的被包围体，当进行检测的时候，达到提高检测效率的作用。比如，一旦检测到包围体被遮挡不可见，那无论包围体内是什么样的模型，那全部不可见。LayaAir引擎中提供了盒状包围体（ 包围盒 ）与球状包围体（包围球）。 写在最后 LayaAir在引擎官网中已经提供了大量的引擎文档，尤其是3D文档，示例DEMO，和API说明文档。然而还是会碰到一些开发者在学习3D的时候无从下手，因此产生了本篇这个更为基础的入门文档，应该已经覆盖了大多数基础概念。希望大家在此文启蒙性认知上，进一步学习引擎的使用，以及从本文中涉及到的未能充分理解的概念有针对性的深入研究学习。 本文仅作为一个基础入门的文档，尽可能去多覆盖一些基础概念，然而文档写作的过程中为了保持写作逻辑的延续，对于一些基础概念并没有完全都介绍全面，比如法线、八叉树、齐次坐标等概念并未讲到。开发者可以在官网文档的学习过程中，如果遇到一些陌生的词语，尽可能先购买基础的图形学书籍或者在搜索引擎中找到适合的文章来补补课。也可以在官网的社区进行反馈，我们会针对引擎使用的文档进行补充和完善。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-08-16 16:11:41 "},"basics/3D/Transform/readme.html":{"url":"basics/3D/Transform/readme.html","title":"3D变换","keywords":"","body":"3D变换1. 平移变换2. 旋转变换2.1 rotate()2.2 localRotationEuler()3. 缩放变换4. 其它变换5. 局部空间与世界空间6. 3D世界中的子父关系3D变换 在前面《3D概念入门》讲过了LayaAir中的坐标系和几个基础数学工具，这些基础概念的一个重要应用，就是三维变换，三维变换也是三维图形世界的基础。LayaAir中实现三维变换用到了Transform3D这个类，包含了平移变换、旋转变换、缩放变换等。 本节以一个立方体模型演示这些变换。在LayaAir IDE中创建一个“3D空项目”，打开项目后，IDE已经默认创建了一个立方体。在Scene2D的属性面板中，新建一个组件脚本，添加装饰器暴露cube的属性，代码如下： @property({ type: Laya.Sprite3D }) public cube: Laya.Sprite3D; 然后在IDE中，将Cube节点拖入装饰器暴露的属性入口，即可用代码控制Cube节点了。 1. 平移变换 平移变换的定义如下： /** * 平移变换。 * @param translation 移动距离。 * @param isLocal 是否局部空间。 */ translate(translation: Vector3, isLocal: boolean = true): void { if (isLocal) { Matrix4x4.createFromQuaternion(this.localRotation, Transform3D._tempMatrix0); Vector3.transformCoordinate(translation, Transform3D._tempMatrix0, Transform3D._tempVector30); Vector3.add(this.localPosition, Transform3D._tempVector30, this._localPosition); this.localPosition = this._localPosition; } else { Vector3.add(this.position, translation, this._position); this.position = this._position; } } 平移变换方法translate()有两个参数，第一个translation表示移动的距离，它是一个Vector3类型的变量，既包含移动距离，也包含了移动方向。第二个isLocal判断是否是局部空间，默认为true是局部空间，若传入false则是世界空间。 如果物体在局部空间和世界空间的起始位置都是一样的，并没有经过旋转等变换，那么它在两种空间中移动的结果是相同的，在第5节中会说明二者的区别。 使用平移变换移动立方体，在x、y和z方向上分别移动距离1，示例代码如下： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { @property({ type: Laya.Sprite3D }) public cube: Laya.Sprite3D; // 平移距离 private translate: Laya.Vector3 = new Laya.Vector3(1, 1, 1); constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { // 平移cube this.cube.transform.translate(this.translate, false); } } 效果如图1-1所示，其中1是原位置，2是平移后的位置。 （图1-1） 2. 旋转变换 关于旋转，在Transform3D中提供了两种旋转接口： 2.1 rotate() 第一种是角度/弧度旋转rotate()，定义如下： /** * 旋转变换。 * @param rotation 旋转幅度。 * @param isLocal 是否局部空间。 * @param isRadian 是否弧度制。 */ rotate(rotation: Vector3, isLocal: boolean = true, isRadian: boolean = true): void { var rot: Vector3; if (isRadian) { rot = rotation; } else { Vector3.scale(rotation, Math.PI / 180.0, Transform3D._tempVector30); rot = Transform3D._tempVector30; } Quaternion.createFromYawPitchRoll(rot.y, rot.x, rot.z, Transform3D._tempQuaternion0); if (isLocal) { Quaternion.multiply(this._localRotation, Transform3D._tempQuaternion0, this._localRotation); this.localRotation = this._localRotation; } else { Quaternion.multiply(Transform3D._tempQuaternion0, this.rotation, this._rotation); this.rotation = this._rotation; } } 旋转方法rotate()有三个参数。第一个rotation表示旋转幅度，也就是绕x、y、z方向旋转的角度。第二个isLocal判断是否是局部空间，默认为true是局部空间，若传入false则是世界空间。第三个isRadian判断是否是弧度制，默认为true是弧度制，传入false则表示角度值。 使用旋转变换rotate()旋转立方体，绕y轴不停旋转，采用角度值，示例代码如下： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { @property({ type: Laya.Sprite3D }) public cube: Laya.Sprite3D; // 旋转角度 private rot: Laya.Vector3 = new Laya.Vector3(0, 1, 0); constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { //设置定时器执行,定时重复执行(基于帧率) Laya.timer.frameLoop(1, this, this.animate); } private animate(): void { // 旋转立方体（四元数） this.cube.transform.rotate(this.rot, false, false); } } 旋转的效果如动图2-1所示： （动图2-1） 2.2 localRotationEuler() 第二种是欧拉角旋转localRotationEuler():Vector3，它的使用非常简单，只需要给旋转角度进行赋值即可。将立方体绕x、y、z方向分别旋转45度，采用角度值，示例代码如下： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { @property({ type: Laya.Sprite3D }) public cube: Laya.Sprite3D; // 旋转角度 private rot: Laya.Vector3 = new Laya.Vector3(45, 45, 45); constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { // 旋转立方体（欧拉角） this.cube.transform.localRotationEuler = this.rot; } } 旋转后的效果如图2-2所示： （图2-2） 如果想实现动图2-1所示的效果，即绕Y轴进行旋转动画，则每帧需要增加localRotationEulerY的值，示例代码如下： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { @property({ type: Laya.Sprite3D }) public cube: Laya.Sprite3D; // 旋转角度 private rot: Laya.Vector3 = new Laya.Vector3(0, 1, 0); constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { //设置定时器执行,定时重复执行(基于帧率) Laya.timer.frameLoop(1, this, this.animate); } private animate(): void { // 旋转立方体（欧拉角） this.cube.transform.localRotationEulerY += this.rot.y; } } 3. 缩放变换 缩放变换可以使用方法localScale(): Vector3。如果传入的Vector3是类似（2，2，2）、（3，3，3）这样的x、y、z方向相同的值，那么缩放变换进行的就是等比缩放，即等比放大2倍、3倍。 如果是非等比缩放，例如，将立方体按x轴方向放大为原来的2倍，y和z方向保持不变，示例代码如下： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { @property({ type: Laya.Sprite3D }) public cube: Laya.Sprite3D; // 缩放倍数 private scale: Laya.Vector3 = new Laya.Vector3(2, 1, 1); constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { // 缩放立方体 this.cube.transform.localScale = this.scale; } } 效果如图3-1所示： （图3-1） 4. 其它变换 除了上面介绍的3种常用变换，Transform3D中还有一些其他常用的方法和属性： lookAt(target: Vector3, up: Vector3, isLocal: boolean = false, isCamera: boolean = true): void：观察目标位置。 localPosition:Vector3：局部位置。 localMatrix:Matrix4x4：局部矩阵。 position:Vector3：世界位置。 worldMatrix:Matrix4x4：世界矩阵。 getRight(right: Vector3): void：获取向右方向。 getUp(up: Vector3): void：获取向上方向。 getForward(forward: Vector3)：获取向前方向。 5. 局部空间与世界空间 局部空间，又称为物体空间，是相对于物体自身的坐标系。在局部空间中，物体自己的位置被视为原点（0，0，0），并且每个物体都有自己独立的局部空间。而世界空间是指一套用于描述所有物体位置的公共的，全局的坐标系。局部空间可以使物体的行为（如移动和旋转）变得独立，不受其他物体或全局空间的直接影响。 举一个例子来说明，当立方体绕x轴旋转45度后，在局部空间中移动立方体，是指按照其自身的坐标系方向进行移动，如动图5-1所示： （动图5-1） 相对应的，在世界空间中移动立方体，是指按照全局的、固定的坐标系方向进行移动，如动图5-2所示： （动图5-2） 本篇只是利用简单的立方体说明用法，对于复杂模型的变换与立方体是类似的，详细的示例可以参考”引擎API使用示例“中的TransformDemo场景。 6. 3D世界中的子父关系 在3D世界中父节点变换，其子节点会跟着响应变换。但是子节点发生变换并不会影响父节点。 例如，”引擎API使用示例“中的Sprite3DParent场景，如动图6-1所示，旋转父节点，子节点会跟着旋转。 （动图6-1） 旋转子节点，父节点不受子节点的影响，如动图6-2所示。 （动图6-2） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-08-21 16:36:43 "},"IDE/uiEditor/readme.html":{"url":"IDE/uiEditor/readme.html","title":"UI编辑模块","keywords":"","body":"UI编辑模块UI编辑器基础交互2D基础显示对象UI组件UI继承类混合使用3DUI编辑模块 UI是User lnterface的简称，中文的意思就是用户界面。例如，游戏界面中的进度条、角色头像、排行榜、商城、游戏任务、功能按钮等等。 实际上，UI编辑所指的范围更为广泛，一切可见的2D显示对象布局，界面排版的行为，均属于UI编辑。 UI编辑模块是2D游戏与2D UI界面可视化操作的重要模块，可大幅提升2D游戏与2D UI制作的开发效率。 LayaAirIDE的UI编辑，可实现UI编辑与代码的分离，与可视化排版，使得无编程基础的美术与策划也可以学习与掌握。 也满足程序员用代码管理与控制UI，以及实现交互逻辑。 UI编辑主要包括层级面板、场景面板、UI编辑排版工具、2D预制体、UI小部件（基础显示对象、UI组件、骨骼动画）、等等。 我们可以分别查看各子模块的功能文档： UI编辑器基础交互 2D基础显示对象 UI组件 UI继承类 混合使用3D Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:52 "},"IDE/uiEditor/basic/readme.html":{"url":"IDE/uiEditor/basic/readme.html","title":"UI编辑器基础交互","keywords":"","body":"UI编辑器基础交互1、UI编辑器基础交互图标说明2、视窗摄像机模式3、平移模式4、对齐设置5、宽高设置6、行、列距、列数设置7、显示设置8、缩放设置UI编辑器基础交互 1、UI编辑器基础交互图标说明 先来看一下UI编辑器基础交互的图标，如图1-1所示。 （图1-1） ​ 从左至右依次为视窗摄像机模式、平移模式、左对齐、左右居中对齐、右对齐、上对齐、上下居中对齐、下对齐、相同宽度、相同高度、均匀行距、均匀列距、表格排列、显示设置、缩放设置。 2、视窗摄像机模式 ​ 在2D场景中点击小手图标即可进入视窗摄像机模式，也可以按住鼠标右键直接进入该模式，在该模式下，持续按住鼠标左键或右键，可以往任意方向拖动整个场景，效果如动图2-1所示。 （动图2-1） 3、平移模式 在2D场景中点击箭头图标即可进入平移模式，在该模式下持续按住鼠标左键即可往任意方向拖动所选中的控件。 如场景层级很多，拖动想要移动的组件会比较困难，这时候就可以从层级面板单击选中该组件然后进行拖动，效果如动图3-1所示。 （动图3-1） 如果想一次性移动多个控件，只需要在画布之外长按鼠标左键然后滑过画布就可以了，如动图3-2所示。 （动图3-2） 4、对齐设置 将控件在该控件的父节点上进行平移，可以只移动一个，也可一次性平移多个，方法为在画布之外长按鼠标左键然后滑过画布，点击自己需要的对齐设置即可。 名称 功能 快捷键 左对齐 将所选中的控件以水平方向平移到该控件父节点的最左边。 Ctrl+Alt+1 左右居中对齐 将所选中的控件以水平方向平移到该控件父节点的水平中心。 Ctrl+Alt+2 右对齐 将所选中的控件以水平方向平移到该控件父节点的最右边。 Ctrl+Alt+3 上对齐 将所选中的控件以垂直方向平移到该控件父节点的最上方。 Ctrl+Alt+4 上下居中对齐 将所选中的控件以垂直方向平移到该控件父节点的垂直中心。 Ctrl+Alt+5 下对齐 将所选中的控件以垂直方向平移到该控件父节点的最下方。 Ctrl+Alt+6 5、宽高设置 相同宽度（快捷键Ctrl+Alt+7）：以画布作为类比对象，对所选中的控件修改宽度，如动图5-1所示。 （动图5-1） 相同高度（快捷键Ctrl+Alt+8）：以画布作为类比对象，对所选中的控件修改高度，如动图5-2所示。 （动图5-2） 6、行、列距、列数设置 均匀行距：以像素为单位，对所选控件进行均匀的行距排列,效果如动图6-1所示。 （动图6-1） 均匀列距：以像素为单位，对所选控件进行均匀的列距排列,效果如动图6-2所示。 （动图6-2） 表格排列：对所选控件进行整齐的表格式排列，直接输入数值即可完成，非常的方便，效果如动图6-3所示。 （动图6-3） 7、显示设置 显示设置功能可以用来修改编辑器场景视窗的背景颜色，开发者可自行选择，效果如图7-1所示。 （图7-1） 还可以在Design Image中，设置UI编辑时的参考图（根据美术需求设计UI时，放置在场景中的位图，运行时不显示）。参数设置如下： Source：选择位图作为参考图。 Offset：参考图的位置。 Alpha：参考图的透明度。 In Front：是否位于上层。勾选后，参考图将位于最上层。 8、缩放设置 对当前场景进行缩放，开发者可自行选择。 如图8-1所示。 （图8-1） 缩放设置的快捷键。 按键 功能 ctrl + + 放大 ctrl + - 缩小 ctrl + 1 恢复到100% ctrl + 鼠标滚轮 自由缩放 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-08-23 11:01:26 "},"IDE/uiEditor/widgets/readme.html":{"url":"IDE/uiEditor/widgets/readme.html","title":"UI小部件","keywords":"","body":"UI小部件UI小部件 LayaAir引擎的UI小部件，分为三类。分别是： 1.基础的显示对象：2D精灵、2D节点动画、基础文本、音频节点、视频节点。 2.UI组件：图像、按钮、显示文本、文本输入、文本域、下拉框、多选框、单选框、单选框组、导航标签组、导航容器、位图切片、位图字体切片、 垂直滚动条、水平滚动条、进度条、垂直划动条、水平划动条、取色器、基础容器、列表、树状列表、开放数据域。 3.骨骼：Spine骨骼，内置骨骼。 如图1所示： (图1) 在使用的时候，直接将小部件拖拽到场景视窗中即可。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-08-18 17:23:17 "},"2D/displayObject/readme.html":{"url":"2D/displayObject/readme.html","title":"2D基础显示对象","keywords":"","body":"2D基础显示对象2D基础显示对象 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:43 "},"2D/displayObject/Sprite/readme.html":{"url":"2D/displayObject/Sprite/readme.html","title":"精灵","keywords":"","body":"精灵（Sprite）一、概述二、IDE中使用2.1 创建精灵2.2 基础属性2.3 Sprite的特有属性2.4 其它属性2.5 脚本控制属性三、代码中使用3.1 创建Sprite3.2 显示图片3.3 基础属性3.4 其它属性精灵（Sprite） 一、概述 游戏中Sprite精灵是在屏幕中能够被控制的显示对象，如果屏幕中的显示对象不能被控制那就只是一个节点。准确来说，Sprite精灵是一个能够通过改变自身属性，比如角度、位置、缩放、颜色等，变为可控动画的2D图像。 Sprite 是基本的显示图形的显示列表节点。 通过 graphics 可以绘制图片或者矢量图，支持旋转，缩放，位移等操作。Sprite同时也是容器类，可用来添加多个子节点。Sprite针对不同的情况做了渲染优化，所以保证一个类实现丰富功能的同时，又达到高性能。 另外，在LayaAir 2D UI中，Sprite是所有节点对象的基础类，如图1-1所示，Sprite 类的基础功能会被继承到所有继承的节点对象中（由于篇幅有限，图中只列出了Sprite类部分的子类，全部的继承关系请参考API文档），因此本篇会详解介绍 Sprite 类的基础功能，后续的节点对象重复的将不再介绍。 （图1-1） 二、IDE中使用 2.1 创建精灵 2.1.1 Scene2D中创建 在一个Scene2D的层级窗口中，任何节点下，或者是空白位置，都可以通过鼠标右键来创建精灵，如动图2-1所示： （动图2-1） 此时创建的精灵，是看不到任何效果的，实际上就是创建了一个空的2D精灵节点。 2.1.2 控件中创建 在小部件的2D标签下，可以在任何节点下，创建精灵，如动图2-2所示： （动图2-2） 2.2 基础属性 如图2-3所示，精灵有如下基础属性: （图2-3） 基础属性 功能说明 Position 精灵的位置坐标 Size 精灵的宽高 Anchor 精灵的锚点 Scale 精灵的缩放 Skew 精灵的倾斜角度 Rotation 精灵的旋转度 Visible 精灵是否可见 Alpha 精灵的透明度 我们通过一组操作，来看看这些属性是如何操作的，如动图2-4： （动图2-4） 由于此时的精灵只是一个空节点，没有显示对象，因此 Visible 和 Alpha 的调整是没有任何显示变化的，我们先来看看几个常用的基础属性： 2.2.1 位置Position 精灵的位置说的是精灵锚点/轴心点所处画布的位置。Position有x和y两个参数，以画布的左上角为原点，从左指向右为x轴正向，从上指向下为y轴正向。 2.2.2 大小Size 精灵的大小是指精灵的宽（W）和高（H），单位是像素。 2.2.3 锚点 Anchor 在讲解锚点之前需要先知道轴心点Pivot的概念。一个Sprite精灵对象默认的轴心点位于自身的左上角，设置Sprite精灵的位置时默认是以左上角为基准进行定位的。 轴心点是基准点，决定着Sprite在舞台的位置。轴心点以像素为单位，默认X、Y坐标为(0,0)表示图片左上角作为基准点。当修改了Sprite对象设置默认轴心点，对Sprite对象设置位置Position、缩放Scale、旋转Rotation时，都是以轴心点为基准，而并非默认的Sprite对象左上角的坐标值。改变轴心点可以控制旋转和缩放的中心，还会影响对象位置、缩放中心、旋转中心。 锚点anchor和轴心点pivot都是基准点，决定着Sprite在舞台的位置。锚点则是以Sprite的宽和高的倍数为单位，取值范围是0~1。 改变锚点anchor的同时，轴心点pivot也会随着改变，因此说明修改锚点anchor是改变轴心点pivot的另外一种简单方式。 2.2.4 缩放大小Scale Scale的X和Y是以锚点/轴心点为中心进行水平、垂直大小缩放。 默认为1，不缩放；正数值越大，缩放尺寸越大。 缩放到0，不可见； -1为镜像。负数值越大，镜像后缩放尺寸越大。 2.2.5 倾斜角度Skew Skew的X和Y是以锚点/轴心点为中心进行水平、垂直角度倾斜。 2.2.6 旋转角度Rotation 旋转以锚点/轴心点为中心，正数代表顺时针旋转，负数代表逆时针旋转。 2.2.7 可见性Visialble 这是一个布尔型的值。勾选代表true，表示可见。不勾选代表false，表示不可见，此时如果精灵加载了图片，那么就不会显示到画布上了。 2.2.8 透明度Alpha 如果精灵加载了图片，透明度可以设置图片的透明度，范围为0~1。 2.3 Sprite的特有属性 （图2-5） 如图2-5所示，精灵的自身属性有： Texture：绘制一个图片或者渲染纹理。 Graphics：绘制一个或者一组图形。 2.3.1 Image的Texture 首先，Sprite的Texture是支持通过拖入或者加载一张图片作为纹理Texture绘制的。 如动图2-6所示，来了解下拖入一张图片到Texture属性中的过程： （动图2-6） 注意：在实现项目开发过程中，如果只是绘制一张图片，那么尽量使用Spirte对象通过Texture的方式绘制，性能是最高的。在2D界面开发中，需要将图片编辑成“精灵纹理”，详细请参考《项目资源面板说明》。 2.3.2 RenderTexture的Texture 渲染纹理 （Render Texture）是在运行时不断更新渲染的一种特殊类型纹理 。渲染纹理的一个典型用法是将其设置为摄像机的“目标纹理”属性，这将使摄像机渲染到纹理， 而不是渲染到屏幕。随后可以如同普通纹理 (Texture) 一样在Sprite对象中使用。 如动图2-7所示，是把一张创建好的渲染纹理（制作方法参看混合使用3D）拖入到Sprite的Texture属性中的。 （动图2-7） 注意：只有通过Sprite的Texture属性才能设置渲染纹理，其它任何显示对象组件中设置渲染纹理的方式都是不正确的 2.3.3 Graphics属性 通过使用Graphics属性，我们可以绘制矩形，圆形，多边形等图形，如动图2-8所示 ： （动图2-8） 具体每一种图形的绘制介绍和代码使用方法，请开发者参考《绘制图形》一篇。 2.4 其它属性 杂项属性面板中包括了精灵的其它属性，如图2-9所示： （图2-9） 其它属性 功能说明 Blend Mode 指定要使用的混合模式。目前只支持\"lighter\" Mouse Enabled 是否接受鼠标事件 Mouse Through 鼠标事件与此对象的碰撞检测是否可穿透 Hit Test Prior 指定鼠标事件检测是优先检测自身，还是优先检测其子对象 DrawCallOptimize 是否开启DrawCall优化 Cache As 是否开启静态缓存优化 Mask 设置遮罩节点对象 Hit Area 点击区域 Filters UI滤镜效果 其中Mouse Enabled、Mouse Through、Hit Test Prior、Hit Area统一放在“2.4.6鼠标操作相关属性”中讲解 2.4.1 关于节点层级关系 如图2-10所示，在层级面板中添加了两个Sprite，按顺序添加，则后添加的（sprite2）在场景中显示在上方。 如果开发者想让节点在运行时改变显示层级，则可以在代码中设置ZOrder（Z排序，更改此值，则会按照值的大小对同一容器的所有对象重新排序。值越大，越靠上。默认都为0），参考后面的3.4.1节。 （图2-10） 2.4.2 设置BlendMode 如动图2-11所示，我们在IDE中设置了两个Sprite，原本Sprite2是覆盖Sprite1的，当使用BlendMode为“lighter”后，看看运行的效果，两个Sprite的图的颜色叠加了。 （动图2-11） 注意：在IDE中，只支持lighter模式，原有图形和新图形都显示，交集部分做颜色叠加 2.4.3 设置Draw Call Optim 如果为true，代表开启DrawCall优化。 DrawCall的内容请参考《性能统计与优化》。 2.4.4 设置Cache As （图2-12） 如图2-12所示，可以设置两种类型的静态缓存，我们来看看静态缓存的一些说明： 当游戏中有大量的UI，并且一个UI有多个节点，变化较小时，推荐使用cacheAs（大部分UI都可以使用）。 例如我们使用的LayaAir IDE，软件中的很多面板，例如属性设置器、资源管理器、项目管理器等，它们的节点子对象很多，但不是很频繁的改动，因此我们都使用了cacheAs进行缓存，提高了渲染效率。 对于经常变化的复杂UI，可以把UI分成两层，较少变化的一层使用cacheAs，经常变化的层不使用。 例如有“倒计时”显示的UI，我们也可以把它分成倒计时部分和其他部分，其他部分进行cacheAs，倒计时部分不进行cacheAs。 开发时使用cacheAs需认真学习理解，错误的理解和使用缓存机制反而会降低性能。 cacheAs：缓存组件，是否缓存为静态图像，合理作用能提高性能 。它有”无”，”正常”和”位图”三个值可选。 “无”：表示不做任何缓存。 “正常”：进行命令缓存，它相当于只缓存了子对象遍历过程及程序命令组织，未缓存成一张位图，在游戏每帧渲染时，不用再次去遍历子对象，而是直接把子对象按照遍历好的层级进行显卡渲染，它不会减少drawcall，不会增加内存损耗。渲染性能中等。 “位图”：进行renderTarget缓存，它相当于把多个子对象组成的UI缓存成一张位图并提交给显卡进行每帧渲染，减少了drawcall。渲染性能最高。需注意的是缓存的位图会额外增加一部分内存开销，缓存的位图越大，内存开销越大。且缓存位图大小不能超过2048。这种模式在不断重绘时也会增加CPU的开销。 Tips：当cacheAs选择”正常”和”位图”时，子对象发生变化，会自动重新缓存，同时也可以手动调用reCache方法更新缓存。 2.4.5 设置Mask 根据对象（支持位图和矢量图）的形状进行遮罩显示，遮罩对象坐标系是相对于遮罩对象本身的。 如动图2-13所示，我们来看看设置mask的操作过程，比如我们在Sprite1绘制的图形上设置一个圆形的遮罩Sprite2，其中Sprite2是Sprite1的子节点。 （动图2-13） 2.4.6 鼠标操作相关属性 鼠标操作相关属性说明如下： 属性 功能说明 MouseEnabled 设为true表示接受鼠标事件，设为false不接受鼠标事件（以下属性均将失效） Hit Area 点击区域，自定义区域只支持圆形、矩形、多边形 MouseThrough 默认值为false，如果设置为true，则点击空白区域（不设置Texture、Image等）可以穿透过去，只针对自身有效 Hit Test Piror 当值为true时，并且不穿透（Mouse Through为false）时，会优先检测本节点。当值为false时，会优先检测子节点，一直到stage上的全部节点都递归检测完毕。 1. Mouse Enabled： 默认为false，如果在脚本代码中监听鼠标事件，则会自动设置本对象及父节点的MouseEnabled属性值都为 true。但若将父节点的MouseEnabled的值手动设置为false，即使进行了鼠标事件监听，父节点的MouseEnabled值也是false。 下面来举一个例子说明这一特殊情况。如图2-14所示，“Sprite1”为父节点，“Sprite2”为子节点，在IDE中默认MouseEnabled属性值为false。 （图2-14） 此时，可以在Scene2D下添加一个自定义组件脚本，并添加如下代码： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { //declare owner : Laya.Sprite3D; @property({ type: Laya.Sprite }) public sprite1: Laya.Sprite; @property({ type: Laya.Sprite }) public sprite2: Laya.Sprite; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { this.sprite2.on(Laya.Event.MOUSE_DOWN, this, this.test2);//设置监听，sprite1或sprite2均可 console.log(this.sprite1.mouseEnabled);//打印父节点sprite1的MouseEnabled的值：true console.log(this.sprite2.mouseEnabled);//打印子节点sprite2的MouseEnabled的值：true } test2(e: Laya.Event) { console.log('mouseSprite2') } } 虽然默认的MouseEnabled属性值为false，但是由于在脚本中设置了监听鼠标事件this.sprite2.on，所以此时父节点“Sprite1“和子节点”Sprite2”的MouseEnabled值会自动变为true。代码执行效果如下： （动图2-15） 可以看到，设置监听后，打印的MouseEnabled值变为true。 但如果在代码中给父节点“Sprite1”的MouseEnabled赋值为false，那么即使给“Sprite1”设置了监听也不会改变它的值了： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { //declare owner : Laya.Sprite3D; @property({ type: Laya.Sprite }) public sprite1: Laya.Sprite; @property({ type: Laya.Sprite }) public sprite2: Laya.Sprite; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { this.sprite1.mouseEnabled = false;//父节点的MouseEnabled赋值为false this.sprite1.on(Laya.Event.MOUSE_DOWN, this, this.test1);//设置监听,sprite1 this.sprite2.on(Laya.Event.MOUSE_DOWN, this, this.test2);//设置监听,sprite2 console.log(this.sprite1.mouseEnabled);//打印父节点sprite1的MouseEnabled的值：false console.log(this.sprite2.mouseEnabled);//打印子节点sprite2的MouseEnabled的值：true } test1(e: Laya.Event) { console.log('mouseSprite1') } test2(e: Laya.Event) { console.log('mouseSprite2') } } 但是要注意，此时“sprite2”的MouseEnabled并没有被手动赋值，仍然只有默认初始值，所以给“sprite2”设置监听会让其MouseEnabled值变为true。 事件监听方法参考《事件与交互》。 2. Hit Area： 如果我们对一个图片设置点击事件，那么这个Sprite的长宽所组成的矩形就是它的点击区域。也可以用HitArea为其设置自定义的点击区域Hit（圆形、矩形、多边形）和非点击区域UnHit，如动图2-16设置点击区域： （动图2-16） 3. Mouse Through： 以一个例子来说明这个属性。如图2-17所示，场景中有两个Sprite节点，为了方便观察效果，给Sprite1的”Graphics”加一个矩形并设为白色。Sprite2在Sprite1的上层，它的大小比Sprite1稍小一点，不给它设置“Texture”、“Graphics”等，即Sprite2就是一个空白区域。 （图2-17） 此时，先不勾选“Mouse Through”，在代码中监听鼠标按下事件： onAwake(): void { this.sprite1.on(Laya.Event.MOUSE_DOWN, this, this.test1);//设置监听,sprite1 this.sprite2.on(Laya.Event.MOUSE_DOWN, this, this.test2);//设置监听,sprite2 } test1(e: Laya.Event) { console.log('mouseSprite1') } test2(e: Laya.Event) { console.log('mouseSprite2') } 在运行时，由于Sprite2是空白区域，所以我们无法观察到，但是，Sprite2覆盖在Sprite1的上层，如果点击Sprite2的点击区域，是会被监听到的，效果如动图2-18所示： （动图2-18） 可以看到，控制台打印了mouseSprite2这个日志，但是它没有监听到Sprite1，因为点击的地方，是Sprite2覆盖在了Sprite1的上面。 勾选Sprite2的“Mouse Through”，再次运行，效果如下： （动图2-19） 点击的是Sprite2的区域，但是控制台打印的是mouseSprite1，原因就是这个事件穿过（Mouse Through）了Sprite2，作用在了下层的Sprite1。 4. Hit Test Prior： 如果鼠标不在节点的鼠标碰撞区域内，则会直接中断此节点以及其子节点的检测，这样能减少鼠标碰撞，提高性能。但也因如此，会导致子节点在其父节点的碰撞区域外时，无法响应鼠标事件。 下面以一个例子来说明，如图2-20所示，Sprite1是父节点，绘制了一个白色矩形，子节点Sprite2在父节点的外面，绘制了一个红色矩形。 （图2-20） 上述“3. Mouse Through”中的脚本代码不变，先不勾选Sprite1的“Hit Test Prior”，点击子节点Sprite2，控制台打印Sprite1和Sprite2的两个日志，效果如下： （图2-21） 图2-21的效果表明，当父节点的“Hit Test Prior”值为false时，会优先检测子节点，并一直递归检测到父节点也会响应。 再勾选Sprite1的“Hit Test Prior”，这时，子节点Sprite2不在父节点Sprite1的鼠标碰撞区域内，如果鼠标放在子节点Sprite2上，就会直接中断Sprite1和Sprite2的检测，无法响应鼠标事件，效果如动图2-22所示。 （动图2-22） 可以看到，点击Sprite2没有响应鼠标事件。 2.4.7 设置Filters 滤镜主要是用来实现图像的各种特殊效果，使图像取得最佳艺术效果。滤镜的类型有很多，但是营造不同的效果需要不同的滤镜功能。关于滤镜有单独的一篇进行讲解，请参考《UI滤镜效果》。 2.5 脚本控制属性 在Scene2D的属性设置面板中，增加一个自定义组件脚本。然后，将Sprite节点拖入到其暴露的属性入口中，如动图2-23所示。 （动图2-23） 接着，就可以在组件脚本中用代码对Sprite进行控制了，示例代码如下： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { //declare owner : Laya.Sprite3D; @property({ type: Laya.Sprite }) public sprite: Laya.Sprite; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { this.sprite.loadImage(\"atlas/comp/image.png\"); //纹理：图片路径 this.sprite.pos(Laya.stage.width >> 1, Laya.stage.height >> 1); //位置：屏幕中心 this.sprite.x = Laya.stage.width/2; //x、y分别设置位置 this.sprite.y = Laya.stage.height/2; this.sprite.size(512, 313); //大小 this.sprite.width = 512; //宽、高分别设置大小 this.sprite.height = 313; this.sprite.pivot(this.sprite.width/2, this.sprite.height/2); //轴心点：sprite的中心 this.sprite.pivotX = this.sprite.width/2; //x、y分别设置轴心点 this.sprite.pivotY = this.sprite.height/2; this.sprite.anchorX = 0.5; //锚点:sprite的中心 this.sprite.anchorY = 0.5; this.sprite.scale(0.5, 0.5); //缩放大小 this.sprite.scaleX = 2; //x、y分别设置缩放 this.sprite.scaleY = 2; this.sprite.skew(5, 5); //倾斜度 this.sprite.skewX = 5; //x、y分别设置倾斜度 this.sprite.skewY = 5; this.sprite.rotation = 45; //旋转角度 this.sprite.visible = true; //是否可见：可见 this.sprite.alpha = 0.5; //透明度 } } 三、代码中使用 Laya.Sprite 类位于Core核心类库中，是 laya.display.Sprite 类封装后形成的。LayaAir引擎API设计精简巧妙，核心显示类只有一个Sprite。 3.1 创建Sprite 创建Sprite对象实例，代码如下： onAwake(): void { let sprite = new Laya.Sprite(); // 添加到舞台 Laya.stage.addChild(sprite); } 3.2 显示图片 图片的显示是游戏开发的基础，Sprite类中用于显示图片是 Sprite.loadImage 和 Sprite.texture。 3.2.1 loadImage /** * 加载并显示一个图片。相当于加载图片后，设置texture属性 * 注意：2.0改动：多次调用，只会显示一个图片（1.0会显示多个图片）,x,y,width,height参数取消。 * @param url 图片地址。 * @param complete （可选）加载完成回调。 * @return 返回精灵对象本身。 */ loadImage(url: string, complete?: Handler): Sprite; 我们来看看代码示例： let sprite = new Laya.Sprite(); // 加载并显示一个图片，居中显示 sprite.loadImage(\"atlas/comp/image.png\", null); sprite.pos(Laya.stage.width >> 1, Laya.stage.height >> 1); // 添加到舞台 Laya.stage.addChild(sprite); 3.2.2 set texture /** * 设置一个Texture实例，并显示此图片（如果之前有其他绘制，则会被清除掉）。 * 等同于graphics.clear();graphics.drawImage()，但性能更高 * 还可以赋值一个图片地址，则会自动加载图片，然后显示 */ get texture(): Texture; set texture(value: Texture); 我们来看看代码示例： Laya.loader.load(\"atlas/comp/image.png\").then(() => { let sprite = new Laya.Sprite(); //精灵设置纹理并居中显示 let res = Laya.loader.getRes(\"atlas/comp/image.png\"); sprite.pos(Laya.stage.width >> 1, Laya.stage.height >> 1); sprite.texture = res; // 添加到舞台 Laya.stage.addChild(sprite); }); 3.2.1和3.2.2这两个示例代码的运行效果是一样的，如图3-1所示，开发者可以根据自己的需要来使用。 （图3-1） 3.3 基础属性 我们通过一些代码示例来看看： let sprite = new Laya.Sprite(); // 加载并显示一个图片 sprite.loadImage(\"atlas/comp/image.png\", null); //设置图片的起始位置 sprite.pos(20, 20); //设置锚点 sprite.anchorX = 0.5; sprite.anchorY = 0.5; //设置缩放 sprite.scale(2, 2); //旋转 sprite.rotation = 30; // 添加到舞台 Laya.stage.addChild(sprite); 运行效果如图3-2所示： （图3-2） 3.4 其它属性 3.4.1 设置zOrder 设置 zOrder 的示例代码如下： let sp1 = new Laya.Sprite(); Laya.stage.addChild(sp1); sp1.pos(200, 190); // 加载并显示一个图片1 sp1.loadImage(\"resources/layabox.png\", null); //需要在resources文件夹下放入layabox.png图片 let sp2 = new Laya.Sprite(); Laya.stage.addChild(sp2); // 加载并显示一个图片2 sp2.loadImage(\"atlas/comp/image.png\", null); // 设置zOrder sp1.zOrder = 1; sp2.zOrder = 0; 我们来看看运行结果： （图3-3） 可以看到，sp1原本是先添加的子节点，sp2是后添加的子节点，原本sp2是会覆盖掉sp1的，但是通过修改zOrder，会让sp1在显示最上层。 3.4.2 设置BlendMode 设置 BlendMode 的示例代码如下： let sp1 = new Laya.Sprite(); Laya.stage.addChild(sp1); // 加载并显示一个图片1 sp1.loadImage(\"atlas/comp/image.png\", null); let sp2 = new Laya.Sprite(); Laya.stage.addChild(sp2); // 加载并显示一个图片2 sp2.loadImage(\"resources/layabox.png\", null); sp2.pos(200, 190); // 设置blendMode sp2.blendMode = \"lighter\"; 我们来看看运行结果： （图3-4） 与图3-3对比可以看到，使用“lighter”的blendMode后，sp2图片的颜色和sp1的颜色叠加了。 3.4.3 设置autoSize 指定是否自动计算宽高数据。默认值为 false 。Sprite宽高默认为0，并且不会随着绘制内容的变化而变化，如果想根据绘制内容获取宽高，可以设置本属性为true。示例代码如下： let sprite = new Laya.Sprite(); // 添加到舞台 Laya.stage.addChild(sprite); sprite.autoSize = true; 3.4.4 缓存为静态图像 示例代码如下： let sprite = new Laya.Sprite(); Laya.stage.addChild(sprite); //缓存为静态图像 sprite.cacheAs = \"bitmap\" 3.4.5 设置遮罩mask 代码示例如下： let sprite = new Laya.Sprite(); Laya.stage.addChild(sprite); sprite.loadImage(\"atlas/comp/image.png\", null); //创建遮罩 let mask = new Laya.Sprite(); sprite.addChild(mask); mask.graphics.drawCircle(200, 200, 100, \"#FFFFFF\"); //图片添加遮罩 setTimeout(() => { sprite.mask = mask;//等待1秒执行遮罩 }, 1000); 运行效果如下： （动图3-5） 3.4.6 设置点击区hitArea 鼠标操作相关属性较多，但是代码的使用都类似，这里以hitArea为例，示例代码如下： let sp = new Laya.Sprite(); Laya.stage.addChild(sp); // 加载并显示一个图片 sp.loadImage(\"atlas/comp/image.png\", null); //设置图片的点击事件 sp.on(\"click\", this, () => { Laya.Tween.to(sp, { scaleX: 0.5, scaleY: 0.5 }, 100); }); //设置鼠标点击区域 let hitArea: Laya.HitArea = new Laya.HitArea(); hitArea.hit.drawRect(0, 0, 100, 100, \"#00ff00\"); sp.hitArea = hitArea; 我们来看看运行结果： （动图3-6） 可以看到，点击区域是有点击效果的，其他区域是没有效果的，而如果不设置hitArea，只要是图片范围，都可以接受点击事件。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2024-03-27 20:41:42 "},"2D/displayObject/Animation/readme.html":{"url":"2D/displayObject/Animation/readme.html","title":"动画节点","keywords":"","body":"动画节点（Animation）1. 初步认知Animation节点2. 通过LayaAir IDE创建Animation节点2.1 创建Animation2.2 接收动画数据源2.3 设置自动播放（autoPlay）2.4 控制动画的播放模式（wrapMode）2.5 动画播放的帧间隔时间(interval)2.6 设置播放的起始位置（index）2.7 脚本控制Animation3. 代码创建Animation动画节点（Animation） 1. 初步认知Animation节点 Animation是节点动画，可以方便的创建图集动画、多帧动画。如动图1-1所示，就是由Animation创建的动画效果。Animation节点的API请参考Animation API。 （动图1-1） Animation节点的常用属性 属性 功能说明 images 添加动画图像。 source 添加动画图集。 autoplay 动画图集是否自动播放，默认为false。如果设置为true，则动画被创建并添加到舞台后自动播放。 wrapmode 播放类型：默认为0是正序播放（POSITIVE），1为倒序播放（REVERSE），2为pingpong播放（PINGPONG）。 interval 动画播放间隔，单位为毫秒，默认值为50毫秒。 index 播放位置。 2. 通过LayaAir IDE创建Animation节点 2.1 创建Animation 如动图2-1所示，可以在层级面板中创建Animation节点，点击+或通过右键点击创建。 （动图2-1） 也可以从小部件里直接拖入Animation到IDE的场景编辑器或层级面板中，如动图2-2所示。 （动图2-2） 2.2 接收动画数据源 接收动画数据源有设置Images和Source两种方式。 2.2.1 Images 第一种方法是Images，可以摁住键盘 ↓ 方向键快速选择图片，也可以单击图片进行添加，如动图2-3所示。 （动图2-3） 2.2.2 Source 第二种方法更为简单快捷，直接将打包好的图集放入Source属性中即可，如图2-4所示。 （图2-4） 2.2.3 制作图集 虽然添加图集的方式较为快捷，但是上述的“图集”资源需要开发者自己制作。LayaAir IDE提供了制作图集的工具，如图2-5所示，在导航栏的工具菜单栏中选择制作图集。 （图2-5） 点击后打开的制作图集工具如图2-6所示。 （图2-6） 制作图集时，要将需要放入图集的一系列图片，存放在一个文件夹中（这里存放在了文件夹“role”中）。然后将参数图片所在文件夹设置为存放图片的文件夹“role”中，如图2-7所示。 （图2-7） 勾选二次幂限制，则生成的图集图片宽高将会是2的整次幂。 勾选裁剪图片周边空白，生成图集的图片将会更加密集一些。 点击制作按钮，如图2-8所示，选择图集文件存放的路径，并对图集文件进行命名，然后点击保存。 （图2-8） 图集制作完成后，会显示“成功！”字样的提示（如图2-9）。 （图2-9） 最终生成的图集文件为同名的.atlas文件和.png文件（role.atlas和role.png）。其中，.atlas是LayaAir IDE特有的图集格式，仅用于图集。 2.3 设置自动播放（autoPlay） autoPlay属性可以设置是否自动播放，默认为false，不自动播放。如果设置为true，即勾选状态下，动画被创建并添加到舞台后自动播放。 2.4 控制动画的播放模式（wrapMode） 动画播放模式属性wrapMode有三个值可选。默认值是0，正序播放（POSITIVE）。选1时，倒序播放（REVERSE）。选2时，pingpong（乒乓）模式（PINGPONG），直白一些就是来回播放。下面以加载图集的方式演示三种播放模式。 注意：播放时要勾选AutoPlay参数，即将其设为true。 2.4.1 正序模式播放 默认不设置wrapMode属性或是将wrapMode属性值设为0时，为正序播放模式（POSITIVE）。也就是序列图从前到后的顺序进行播放，如动图2-10所示。 （动图2-10） 2.4.2 倒序模式播放 将wrapMode属性值设为1时，为倒序播放模式（REVERSE）。也就是序列图从后到前的顺序进行播放，与正序播放模式完全相反，如动图2-11所示。 (动图2-11) 2.4.3 pingpong（乒乓）模式播放 将wrapMode属性值设为2时，为pingpong播放模式（PINGPONG）。在这个模式下，同一套动作，正序播放完了，并不是直接回到图集设置的第一帧重头播放，而是从倒序的倒数第二帧播放，从而让动作更加平滑和完整。因此，pingpong模式也是游戏中经常使用的模式之一，在保障效果的前提下，还可以大幅减少美术资源量。效果如动图2-12所示。 (动图2-12) 2.5 动画播放的帧间隔时间(interval) interval属性可以设置动画播放的帧间隔时间(单位：毫秒)，默认值为50毫秒。例如，我们将刚刚播放的动画，放慢一倍，设置为100毫秒。效果如动图2-13所示。 （动图2-13） Tips：如果动画正在播放，设置后会重置帧循环定时器的起始时间为当前时间，也就是说，如果频繁设置interval，会导致动画帧更新的时间间隔会比预想的要慢，甚至不更新。 2.6 设置播放的起始位置（index） index属性可以指定动画的帧索引，默认的索引是0，可以设置为动画中的任意一帧。设置后，将会跳到设定的动画帧，效果如动图2-14所示。 （动图2-14） Tips：该属性仅用于静态指定，比如通过代码或点击事件来手动切换动画帧。如果设置为自动播放，仍会从第0帧开始播放，与索引的设置没有关系。 2.7 脚本控制Animation 在Scene2D的属性设置面板中，增加一个自定义的组件脚本，命名为“Animation.ts”。然后，按照动图2-15，将Animation节点拖入到“Animation.ts”暴露的属性入口中。 （动图2-15） 接着，就可以在脚本文件“Animation.ts”中用代码对Animation进行控制了，示例代码如下： const { regClass, property } = Laya; @regClass() export class Animation extends Laya.Script { //declare owner : Laya.Sprite3D; @property({ type: Laya.Animation }) //在IDE面板中显示属性 ani: Laya.Animation; constructor() { super(); } //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { this.ani.source = \"resources/role.atlas\"; //接收动画数据源为图集 this.ani.autoPlay = true; //开启自动播放 this.ani.wrapMode = 0; //播放模式为正序播放模式（POSITIVE） this.ani.interval = 50; //动画播放的帧间隔时间为50毫秒 } } 运行效果如动图2-16所示： （动图2-16） 3. 代码创建Animation 有时，不想让动画节点一开始就在舞台上，而是在要用的时候才添加，这就要通过代码来创建了。在Scene2D的属性设置面板中，增加一个自定义的组件脚本，在代码中创建Animation。示例代码如下： const { regClass, property } = Laya; @regClass() export class UI_Animation extends Laya.Script { //declare owner : Laya.Sprite3D; constructor() { super(); } //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { this.setup(); } private setup(): void { var Animation: Laya.Animation = new Laya.Animation(); Animation.pos(200, 200); //设置节点位置 Animation.source = \"resources/role.atlas\"; //接收动画数据源为图集 Animation.size(600, 275); //设置节点大小 Animation.interval = 100; //动画播放的帧间隔时间为100毫秒 Animation.autoPlay = true; //开启自动播放 Animation.wrapMode = 2; //播放模式为pingpong播放模式（PINGPONG） this.owner.addChild(Animation) //添加节点 } } 效果如动图3-1所示： （动图3-1） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-06-29 22:37:09 "},"2D/displayObject/Text/readme.html":{"url":"2D/displayObject/Text/readme.html","title":"基础文本","keywords":"","body":"基础文本（Text）1. LayaAir IDE中使用Text1.1 创建Text1.2 属性介绍1.3 Syntax属性1.4 脚本控制Text2. 代码创建Text基础文本（Text） Text继承于Sprite，是静态文本的基础组件。这里我们介绍一下Text专属的组件属性。 1. LayaAir IDE中使用Text 1.1 创建Text 如图1-1所示，可以在层级窗口中右键进行创建，也可以从小部件窗口中拖拽添加。 （图1-1） 1.2 属性介绍 在IDE中，我们将Text组件添加到场景编辑的视图区后，属性面板中Text组件的专属属性如下图所示： （图1-2） 下面我们分别对这些属性进行介绍说明： 属性名 属性说明 text 文本的实际内容 font 文本字体，例如：Microsoft YaHei，这里可以手动输入常用的字体，还可以是位图字体 fontSize 文本字体大小，例如： 50，直接填写正整数 color 文本的颜色，可以直接输入颜色值，例如：#ffffff，也可以点击输入条右侧的拾色器选取颜色 style “B”(bold)是否为粗体，“I”(italic)是否为斜体，“U”是否有下划线 syntax 多样式混排，支持部分HTML语法和UBB语法。还可以勾选模板，能够在字符串中使用变量 align 对齐方式，水平对齐(align)分别是left（居左对齐）、center（居中对齐）、right（居右对齐）;垂直对齐(valign)分别是top（居顶对齐）、middle（居中对齐）、bottom（居底对齐） bgColor 背景颜色，勾选后可以直接输入颜色值，例如：#ffffff，也可以点击输入条右侧的拾色器选取颜色 borderColor 文本边框颜色，勾选后可以直接输入颜色值，例如：#ffffff，也可以点击输入条右侧的拾色器选取颜色 overflow 文本溢出处理，共有五种模式。visible（可见）：默认模式，不进行任何裁切。hidden（隐藏）：不显示超出文本域的字符。scroll（滚动）：不显示文本域外的字符像素，并且支持scroll接口，详见1.4节。shrink（自动收缩）：超出文本域时，文本整体缩小以适应文本框。ellipsis（显示省略号）：超出文本域时，文本被截断，并且文本最后显示省略号 wordWrap 是否自动换行，布尔值选项，默认为false，选择true可以开启自动换行 leading 垂直行间距，当开启自动换行时，文本内容多行时有效。间距以像素为单位，输入正整数即可 padding 文本边距，以像素为单位，由4个整数值组成。“U”表示距上边框的距离、”R“表示距右边框的距离、”D“表示距下边框的距离、”L”表示距左边框的距离 underlineColor 下划线颜色，可以直接输入颜色值，例如：#ffffff，也可以点击输入条右侧的拾色器选取颜色 stroke 描边宽度，范围为0~100 strokecolor 描边颜色，可以直接输入颜色值，例如：#ffffff，也可以点击输入条右侧的拾色器选取颜色 以上属性都比较容易理解，开发者只需调整参数便可在IDE中看到对应的效果。以下只详细介绍一下“syntax”属性。 1.3 Syntax属性 1.3.1 HTML和UBB 如果勾选HTML，则支持部分HTML语法；如果勾选UBB，则支持UBB语法，UBB语法比HTML更简洁一点；如果两个都勾选，则两种语法都支持。 支持的UBB语法如下表所示： 语法结构 示例代码 语句说明 [img]image_url[/img] [img]atlas/comp/image.png[/img] 显示一张图片 [url=link_href]text[/url] [url='www.layabox.com']蓝亚盒子[/url] 显示一个超级链接 [b]text[/b] [b]这些字是粗体[/b] 设置文本为粗体 [i]text[/i] [i]这些字是斜体[/i] 设置文件为斜体 [u]text[/u] [u]这些字有下划线[/u] 设置文本下划线 [color=#FFFFFF]text[/color] [color=#FF0000]这是红色的字[/color] 设置文本颜色 [size=10]text[/size] [size=60]这是字体大小为60的字[/size] 设置文本的字体大小 UBB支持标签之间的嵌套，可以将上表中多个标签嵌套使用，例如，[color=#FF0000][size=60]红色且大小为60的字[/size] [/color]。 支持的HTML语法如下表所示： 语法结构 示例代码 语句说明 Text 这是粗体字 定义粗体字 Text 这是斜体字 定义斜体字 Text 这是下划线文本 定义下划线 Text1 Text2 Text3 苹果 香蕉 橘子 定义列表 显示一张图片，还可以使用百分比指定图片的大小 link text 蓝亚盒子 显示一个超级链接 Text 文本的最外层 div容器标签 Text 多个span之间不会自动换行，除非是达到了宽度限制 行内元素 Text 多个p标签之间会自动换行，每个完整的p标签是一个单独的段落 段落 Text1Text2 换行后面的就换行了 换行 &nbsp; 这里&nbsp;空一格 空格 下面来看一个具体的例子，如图1-3所示，勾选HTML和UBB后，就可以在Text属性中输入符合语法的语句： （图1-3） Text中输入的示例语句如下： [url='www.layabox.com']蓝亚盒子[/url] [size=60]text[/size] [color=#FF0000]text[/color] [u]text[/u] [color=#FF0000][size=60]text[/size][/color] 上述这6条语句分别对应图1-3所示的6种效果：加载图片、显示链接、字体大小为60、字体颜色为红色、下划线、嵌套（大小和颜色）。每条语句之间可以不空行，示例中有空行是为了方便观察效果。 1.3.2 模板 “syntax”属性还可以勾选模板选项，勾选后，就可以在字符串中使用变量了。比如，在Text属性中输入Text{n=100}，效果如图1-4所示： （图1-4） 变量n还可以是字符串，例如，输入Text{n=你好},显示的效果就是图1-5所示的了。当然，这个变量不一定必须是n，开发者可以自定义变量名。 （图1-5） 还可以在代码中使用setVar方法动态调节变量n，可以结合1.3节的脚本控制，在脚本中输入如下代码： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { //declare owner : Laya.Sprite3D; @property({ type: Laya.Text }) txt: Laya.Text; constructor() { super(); } onAwake(): void { this.txt.text = \"第{n=1}页\"; //显示文本的初始化内容 } onStart(): void { let page: number = 1; Laya.timer.frameLoop(10, this, () => { page += 1; //在定时器中让变量page每次自增1 this.txt.setVar(\"n\", page); //使用setVar方法，让text文本中变量n的值动态改变 }); } } 效果如动图1-6所示： （动图1-6） 注：变量n还可以是从.json文件中获取的文本，开发者可以自己写一个.json文件，然后在脚本中进行加载，最后利用setVar方法赋值给变量n。 在游戏中比较常用的情况就是，如图1-7所示，当每个玩家进入游戏，都会遇到一段对白，只有不同玩家的角色名称不同。那么，采用文本模板功能之后，无需再去整体修改文本，直接改变文本模板中的变量即可。让局部文本的动态改变更加易用。 （图1-7） 1.4 脚本控制Text 在Scene2D的属性设置面板中，增加一个自定义组件脚本。然后，将Text拖入到其暴露的属性入口中。下面给出一个示例代码，实现脚本控制Text： const { regClass, property } = Laya; @regClass() export class TextControl extends Laya.Script { //declare owner : Laya.Sprite3D; @property( { type : Laya.Text } ) public txt: Laya.Text; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { this.txt.pos(Laya.stage.width >> 1, Laya.stage.height >> 1); //位置 this.txt.size(500, 30); //大小 this.txt.pivot(this.txt.width/2, this.txt.height/2); //轴心点 this.txt.text = \"大家好，欢迎各位开发者使用LayaAir IDE，这里是Text的文本内容，您可以基于此文本进行调试\"; //文本内容 this.txt.font = \"宋体\"; //字体 this.txt.fontSize = 50; //字体大小 this.txt.color = \"#ff0000\"; //字体颜色 this.txt.bold = true; //加粗 this.txt.italic = true; //斜体 this.txt.underline = true; //下划线 this.txt.underlineColor = \"#ff0000\"; //下划线颜色 this.txt.stroke = 5; //描边宽度 this.txt.strokeColor = \"#000000\" ; //描边颜色 this.txt.wordWrap = true; //自动换行 this.txt.leading = 20; //垂直行间距 // this.txt.padding = [10, 10, 10, 10]; //文本边距 this.txt.align = \"center\"; //水平对齐方式 this.txt.valign = \"top\"; //垂直对齐方式 this.txt.overflow = \"visible\"; //文本溢出 } } 下面再来看一个示例，这个是有关overflow属性中的滚动参数，如果文字超出了文本框，将其overflow属性设置为滚动，那么可以添加如下代码，实现通过鼠标拖拽显示超出的文字： const { regClass, property } = Laya; let prevX = 0; let prevY = 0; @regClass() export class UI_Text extends Laya.Script { constructor() { super(); } @property({ type: Laya.Text }) txt: Laya.Text; onAwake(): void { this.txt.text = \"Layabox是HTML5引擎技术提供商与优秀的游戏发行商，面向AS/JS/TS开发者提供HTML5开发技术方案！\\n\" + \"Layabox是HTML5引擎技术提供商与优秀的游戏发行商，面向AS/JS/TS开发者提供HTML5开发技术方案！\\n\" + \"Layabox是HTML5引擎技术提供商与优秀的游戏发行商，面向AS/JS/TS开发者提供HTML5开发技术方案！\\n\" + \"Layabox是HTML5引擎技术提供商与优秀的游戏发行商，面向AS/JS/TS开发者提供HTML5开发技术方案！\\n\" + \"Layabox是HTML5引擎技术提供商与优秀的游戏发行商，面向AS/JS/TS开发者提供HTML5开发技术方案！\\n\" + \"Layabox是HTML5引擎技术提供商与优秀的游戏发行商，面向AS/JS/TS开发者提供HTML5开发技术方案！\"; this.txt.fontSize = 35; this.txt.size(400,150); this.txt.borderColor = \"#fa1515\"; this.txt.overflow = \"scroll\"; this.txt.on(Laya.Event.MOUSE_DOWN, this, this.startScrollText); } /* 开始滚动文本 */ startScrollText() { prevX = this.txt.mouseX; prevY = this.txt.mouseY; Laya.stage.on(Laya.Event.MOUSE_MOVE, this, this.scrollText); Laya.stage.on(Laya.Event.MOUSE_UP, this, this.finishScrollText); } /* 停止滚动文本 */ finishScrollText() { Laya.stage.off(Laya.Event.MOUSE_MOVE, this, this.scrollText); Laya.stage.off(Laya.Event.MOUSE_UP, this, this.finishScrollText); } /* 鼠标滚动文本 */ scrollText() { let nowX = this.txt.mouseX; let nowY = this.txt.mouseY; this.txt.scrollX += prevX - nowX; //水平滚动距离 this.txt.scrollY += prevY - nowY; //垂直平滚动距离 prevX = nowX;//鼠标移动后，归位 prevY = nowY; } } 效果如下： （动图1-8） 这个示例说明，滚动与隐藏不同，它并没有把超出文本框的文字进行裁剪。 2. 代码创建Text 有时，不想让Text节点一开始就在舞台上，而是在要用的时候才添加，这就要通过代码来创建了。在Scene2D的属性设置面板中，增加一个自定义组件脚本，示例代码如下： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { //declare owner : Laya.Sprite3D; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { let txt = new Laya.Text(); // 添加到舞台 Laya.stage.addChild(txt); txt.pos(Laya.stage.width >> 1, Laya.stage.height >> 1); //位置 txt.size(500, 30); //大小 txt.pivot(txt.width/2, txt.height/2); //轴心点 txt.text = \"大家好，欢迎各位开发者使用LayaAir IDE，这里是Text的文本内容，本方法是代码创建Text\"; //文本内容 txt.wordWrap = true; //自动换行 } } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-08-30 20:13:51 "},"2D/displayObject/SoundNode/readme.html":{"url":"2D/displayObject/SoundNode/readme.html","title":"音频节点","keywords":"","body":"音频节点(SoundNode)1. LayaAir IDE中使用音频节点1.1 创建SoundNode1.2 属性介绍1.3 脚本控制SoundNode2.代码创建SoundNode音频节点(SoundNode) 1. LayaAir IDE中使用音频节点 1.1 创建SoundNode 如图1-1所示，可以在层级窗口中右键进行创建，也可以从小部件窗口中拖拽添加。 （图1-1） 1.2 属性介绍 在IDE中，将SoundNode节点添加到场景编辑的视图区后，属性面板中SoundNode的专属属性如下图所示： （图1-2） 下面分别对这些属性进行介绍： 属性名称 属性说明 Source 添加音频文件源 IsMusic 是否为背景音乐。勾选后，当前音频为背景音乐，如果有两个音频都勾选了IsMusic，则不能同时播放，只能播放一个。如果不勾选，当前音频文件可以与背景音乐、其它音频同时播放 Loop 循环播放的次数。设置为0，是无尽循环；设置为1，只播放一次 AutoPlay 运行时，是否自动播放 1.3 脚本控制SoundNode 在Scene2D的属性设置面板中，增加一个自定义组件脚本。然后，将SoundNode拖入到其暴露的属性入口中。下面给出一个示例代码，实现脚本控制SoundNode： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { //declare owner : Laya.Sprite3D; @property({ type: Laya.SoundNode }) public sound: Laya.SoundNode; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { this.sound.source = \"resources/sound.wav\"; //音频路径 this.sound.loop = 0; //循环次数设置，要放在autoPlay参数设置前 this.sound.autoPlay = true; //自动播放 this.sound.isMusic = false; //是否为背景音乐 } } 2.代码创建SoundNode SoundNode节点在运行时只有声音效果，如果不想在IDE中添加并拖拽到装饰器暴露的属性入口，做这么繁琐的操作，那可以通过代码来创建。在Scene2D的属性设置面板中，增加一个自定义组件脚本，示例代码如下： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { //declare owner : Laya.Sprite3D; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { let sound = new Laya.SoundNode(); // 添加到舞台 Laya.stage.addChild(sound); sound.source = \"resources/sound.wav\"; //音频路径 sound.loop = 0; //循环次数设置，要放在autoPlay参数设置前 sound.autoPlay = true; //自动播放 sound.isMusic = false; //是否为背景音乐 } } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-06-28 17:02:59 "},"2D/displayObject/VideoNode/readme.html":{"url":"2D/displayObject/VideoNode/readme.html","title":"视频节点","keywords":"","body":"视频节点(VideoNode)1. LayaAir IDE中使用视频节点1.1 创建VideoNode1.2 属性介绍1.3 脚本控制VideoNode2. 代码创建VideoNode视频节点(VideoNode) 1. LayaAir IDE中使用视频节点 1.1 创建VideoNode 如图1-1所示，可以在层级窗口中右键进行创建，也可以从小部件窗口中拖拽添加。 （图1-1） 1.2 属性介绍 在IDE中，将VideoNode节点添加到场景编辑的视图区后，属性面板中VideoNode的专属属性如下图所示： （图1-2） 它只有一个Source属性，将视频文件添加到Source中即可。 1.3 脚本控制VideoNode 在1.2节中，将视频文件添加到Source后，是无法自动播放的，需要用代码进行控制。在Scene2D的属性设置面板中，增加一个自定义组件脚本。然后，将VideoNode拖入到其暴露的属性入口中。下面给出一个示例代码，实现脚本控制VideoNode： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { @property({ type: Laya.VideoNode }) public video: Laya.VideoNode; constructor() { super(); } // 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { // 鼠标点击触发播放 Laya.stage.on(Laya.Event.MOUSE_DOWN, () => { Laya.loader.load(\"resources/layaAir.mp4\").then(() => { this.video.play(); //播放视频 }); }) } } 如果是在LayaAir IDE中运行，则VideoNode无需通过事件触发播放。但是在Chrome中，自动播放只允许静音自动播放。只有用户进行交互（单击、双击等）后，才允许自动播放声音。 2. 代码创建VideoNode 如果不想让VideoNode节点一开始就在舞台上，而是在要用的时候才添加，这就要通过代码来创建了。在Scene2D的属性设置面板中，增加一个自定义组件脚本，示例代码如下： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { //declare owner : Laya.Sprite3D; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { let video = new Laya.VideoNode; //添加到舞台 Laya.stage.addChild(video); video.pos(200,200); //设置位置 video.source = \"resources/layaAir.mp4\"; //设置视频源文件 video.play(); //开始播放 } } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-11-29 17:33:41 "},"IDE/uiEditor/uiComponent/readme.html":{"url":"IDE/uiEditor/uiComponent/readme.html","title":"UI组件详解","keywords":"","body":"UI组件详解一、什么是UI组件1.1 基础UI组件1.2 容器组件1.3 弹窗视图组件二、UI组件的创建2.1 直接使用组件2.2 右键菜单2.3 通过组件资源命名规则，直接被IDE识别2.4 容器组件的创建与解除三、相对布局UI组件详解 Author: Charley UI组件是2D编辑中的基础组件，我们日常开发的2D UI界面的编辑，都是基于UI组件。 一、什么是UI组件 从引擎类的结构上看，UIComponent类是UI组件的基类，也就是说UI组件有一个共性，都是继承于UIComponent类而实现的组件。 UI组件，又分成基础UI组件和容器UI组件。比较容易理解和识别的方式为，Box和继承于Box的都属于容器类组件。其它的都是基础UI组件。 1.1 基础UI组件 基础UI组件显示对象，一共有17个，直接或间接继承于UIComponent，如图1-1的高亮部分所示。 （图1-1） 1.2 容器组件 继承于Box的组件，加上Box容器本身，容器对象一共有9个。如图1-2的高亮部分所示。 (图1-2) 这些容器单单自己是没有意义的，必须要包括基础的UI组件作为子节点，才能使得组件功能完整。 例如，List必须要有基础UI组件作为列表的渲染单元，单选框组（RadioGroup）是多个单选框（Radio）组件的容器。 1.3 弹窗视图组件 从引擎类的结构上看，弹窗视图组件Dialog并不属于UI组件，它的继承关系如图1-3所示。 （图1-3） 该组件一般用于弹窗面板，与场景的管理息息相关，是UI小部件的一部分，所以不再单独列出一类，只在这里做一个说明。 二、UI组件的创建 UI组件的创建有三种方式：分别是从小部件（Widgets）面板里拖拽UI组件使用、从层级管理（Hierarchy）面板的右键菜单里创建、通过组件资源命名规则为资源命名，然后直接被IDE识别。 2.1 直接使用组件 小部件（Widgets）面板里包括了基础节点，也包括了UI组件，使用时直接拖拽到层级面板或场景编辑窗口内即可。效果如动图2-1所示。 (动图2-1) 2.2 右键菜单 层级管理（Hierarchy）面板的2D节点下，右键菜单里也可以直接创建UI组件，效果如图2-2所示。 (图2-2) 2.3 通过组件资源命名规则，直接被IDE识别 对于一些常用的UI组件，LayaAir引擎与IDE，提供了资源命名的规则。 当图像资源文件按照LayaAir引擎UI组件命名规则命名时，会直接被IDE识别为基础UI组件。 组件资源的命名有两类， 一类是，一个资源就对应一个UI组件的常规资源，例如，img_layabox.png，会被识别为Image组件。 另一类是，多个资源对应一个UI组件的组合资源，例如，progress_loading.png与progress_loading$bar.png组合形成一个progress组件，progress_loading.png为组件名是进度条的背景资源，另一个在progress_loading后面带了一个$bar的是进度条的进度资源。 总结以上，我们会发现两点规律： 无论是哪种资源，下划线_之前是组件规则名称，并且必须要放到文件名的开头。 组合资源，在主资源名称的后面，再通过美元符号$相隔，带一个辅助标识名，方便IDE与引擎识别。 常规资源命名规则如下： 组件名 中文组件名 资源文件名前缀 资源文件名前缀缩写 Image 图像 image_ img_ Button 按钮 button_ btn_ ComboBox 下拉框 comboBox_ combo_ TextInput 文本输入 textInput_ input_ TextArea 文本域 textArea_ area_ CheckBox 多选框 checkBox_ check_ Label 显示文本 label_ 无缩写 RadioGroup 单选框组 radioGroup_ 无缩写 Radio 单选框 radio_ 无缩写 Tab 导航标签组 tab_ 无缩写 Clip 位图切片 clip_ 无缩写 FontClip 位图字体切片 fontClip_ 无缩写 资源前缀不区分大小写 组合资源命名规则如下： 组件名 中文组件名 资源文件名前缀 资源文件名前缀缩写 辅助标识名 VScrollBar 垂直滚动条 vscrollbar_ vscroll_ 垂直划动条$bar、上点击按钮$up 、下点击按钮$down HScrollBar 水平滚动条 hscrollbar_ hscroll_ 水平划动条$bar、左点击按钮$up 、右点击按钮$down ProgressBar 进度条 progressbar_ progress_ 进度条$bar VSlider 垂直划动条 vslider_ 无缩写 垂直划动按钮$bar、进度条资源$progress（可选） HSlider 水平划动条 hslider_ 无缩写 水平划动按钮$bar、进度条资源$progress（可选） 资源前缀不区分大小写 示例说明： 垂直滚动条aa，由四个资源文件构成。分别是vscroll_aa.png、vscroll_aa$bar.png、vscroll_aa$up.png、vscroll_aa$down.png。 进度条bb，由两个资源文件构成。分别是progress_bb.png、progress_bb$bar.png。 水平划动条cc，由两个或三个资源文件构成。分别是hslider_cc.png、hslider_cc$bar.png、hslider_cc$progress.png（可选），若缺少了进度条资源hslider_cc$progress.png不会报错，只是不显示进度。 2.4 容器组件的创建与解除 了解完资源命名规则后发现，除了继承于UI组(UIGroup)的RadioGroup与Tab组件，是可以通过资源前缀规则命名识别的。其它的容器组件均不支持通过资源名称直接识别创建。 除了采用2.1与2.2的方式创建外，还可以在IDE里将一个或多个选中的基础组件通过Ctrl+B快捷键转化为容器组件。如果不想要容器组件了，也可以通过Ctrl+U解除当前选中的容器。 此处有个印象即可，在介绍具体的容器组件时，还会详细描述创建方法与流程。 三、相对布局 相对布局是UI组件的特有属性，如图3-1所示，每一个UI组件都有这样的相对布局属性。而基础显示对象Sprite等就没有相对布局，只有绝对布局。 （图3-1） 在相对布局中，UI组件（如按钮，文本框等）的位置是相对于它们的父节点来确定的。这种布局带来了极大的灵活性，并且可以在不同的屏幕大小和方向下保证 UI 布局的一致性。 至此，我们对UI组件已有了基础的了解，我们将开始对全部的UI组件进行详细介绍。为避免文档的标题过长，对UI组件根据使用的特点进行分类介绍，并不按组件类的继承关系。 下面，通过左侧导航点开UI组件文档了解更多吧~ Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-09-19 10:15:52 "},"IDE/uiEditor/uiComponent/Image/readme.html":{"url":"IDE/uiEditor/uiComponent/Image/readme.html","title":"图像组件","keywords":"","body":"图像组件（Image）一、通过LayaAir IDE创建Image组件1.1 创建image1.2 常用属性1.3 脚本控制Image二、通过代码创建Image组件图像组件（Image） 一、通过LayaAir IDE创建Image组件 1.1 创建image Image 是 UI 里最常见的显示图像的组件，用来显示位图图像。可以设置 Image 组件的 skin 属性来改变 Image 组件呈现的图像。Image 组件支持九宫格数据设定，用于实现图像放大后图像显示不失真的效果。Image 组件的脚本接口请参考 Image API。 如图1-1所示，可以在层级窗口中右键进行创建，也可以从小部件窗口中拖拽添加。 （图1-1） Image 组件拖放到编辑区后显示效果如图1-2所示： (图1-2) 1.2 常用属性 Image组件的特有属性如下： （图1-3） 属性 功能说明 skin 图像组件的纹理，需要添加位图的资源。 use source size 使用位图资源的原大小。 sizeGrid 位图的有效缩放网格数据（九宫格信息）：上边距、右边距、下边距、左边距、是否重复填充。 color 更改图片颜色。 Group 加载分组，设置后可以按组管理资源。 这里详细说明一下九宫格的设置。假设有一张位图，如图1-4所示，它的边框颜色正好符合作为一个弹窗的需求（这里只是举例，具体色彩搭配要根据需求选择），但是图片的长度太短了，要做弹窗需要将其拉长。 （图1-4） 拉长后的效果如图1-5所示，可以看到，黑色边框会跟着被拉长。 （图1-5） 如果只想放大红色区域，黑色边框保持原来的粗细，那么就要用到sizeGrid了。具体的设置如动图1-6所示，最终可以看到，放大后的弹窗边框粗细不变，中间红色部分为有效缩放区域。 （动图1-6） 重复填充指的是，如果勾选，则放大图像时，有效缩放区域会重复填充放大的区域，而不会进行放大。效果如图1-7所示。 （图1-7） 1.3 脚本控制Image 有时，要通过代码设定Image相关的属性，就需要用到脚本了。在Scene2D的属性设置面板中，增加一个自定义组件脚本。然后，将Image组件拖入到其暴露的属性入口中。下面给出一个示例代码，实现脚本控制Image： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { @property({ type: Laya.Image }) public img: Laya.Image; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { this.img.skin = \"resources/layaAir.png\";//设置皮肤 this.img.useSourceSize = true;//设置图片大小为源大小 this.img.color = \"#0000FF\";//设置颜色为蓝色 } } 二、通过代码创建Image组件 有时，不想让图像组件一开始就在舞台上，而是在要用的时候才添加，这就要通过代码来创建了。在Scene2D的属性设置面板中，增加一个自定义的组件脚本，在代码中创建Image。示例代码如下： const { regClass, property } = Laya; @regClass() export class UI_Image extends Laya.Script { constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { this.setup(); } private setup(): void { let img: Laya.Image = new Laya.Image(\"resources/layaAir.png\"); img.pos(165, 62.5); this.owner.addChild(img); } } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-08-22 15:44:09 "},"IDE/uiEditor/uiComponent/Label/readme.html":{"url":"IDE/uiEditor/uiComponent/Label/readme.html","title":"显示文本组件","keywords":"","body":"显示文本组件(Label)一、通过LayaAir IDE创建Label组件1.1 创建Label1.2 Label 属性1.3 脚本控制Label二、通过代码创建Label组件显示文本组件(Label) 一、通过LayaAir IDE创建Label组件 Label 组件用来显示一段文字。Label 组件的脚本接口请参考 Label API。 1.1 创建Label 如图1-1所示，可以在层级窗口中右键进行创建，也可以从小部件窗口中拖拽添加。 （图1-1） Label组件拖放到编辑区后，设置 text 属性的值为 LayaAir IDE 后的显示效果如下： （图1-2） 1.2 Label 属性 （图1-3） 属性 功能说明 text 文本的实际内容 font 文本的字体名称，例如：Microsoft YaHei，这里可以手动输入常用的字体，还可以是位图字体 fontSize 文本字体大小，例如： 50，直接填写正整数 color 文本的颜色，可以直接输入颜色值，例如：#ffffff，也可以点击输入条右侧的拾色器选取颜色 fit content 否（\"no\"）：无操作；高度和宽度（\"yes\"）：Label边框可以根据文字大小和数量，自动调整高度和宽度为合适大小；高度（\"height\"）：Label边框只自动调整高度 style “B”(bold)是否为粗体，“I”(italic)是否为斜体，“U”是否有下划线 syntax 多样式混排，支持部分HTML语法和UBB语法。还可以勾选模板，能够在字符串中使用变量 align 对齐方式，水平对齐(align)分别是left（居左对齐）、center（居中对齐）、right（居右对齐）;垂直对齐(valign)分别是top（居顶对齐）、middle（居中对齐）、bottom（居底对齐） bgColor 背景颜色，勾选后可以直接输入颜色值，例如：#ffffff，也可以点击输入条右侧的拾色器选取颜色 bordercolor 文本边框颜色，勾选后可以直接输入颜色值，例如：#ffffff，也可以点击输入条右侧的拾色器选取颜色 overflow 文本溢出处理，共有五种模式。visible（可见）：默认模式，不进行任何裁切。hidden（隐藏）：不显示超出文本域的字符。scroll（滚动）：不显示文本域外的字符像素，并且支持scroll接口。shrink（自动收缩）：超出文本域时，文本整体缩小以适应文本框。ellipsis（显示省略号）：超出文本域时，文本被截断，并且文本最后显示省略号 wordWrap 是否自动换行，布尔值选项，默认为false，选择true可以开启自动换行 leading 垂直行间距，当开启自动换行时，文本内容多行时有效。间距以像素为单位，输入正整数即可 padding 文本边距，以像素为单位，由4个整数值组成。“U”表示距上边框的距离、”R“表示距右边框的距离、”D“表示距下边框的距离、”L”表示距左边框的距离 underlinecolor 下划线颜色，可以直接输入颜色值，例如：#ffffff，也可以点击输入条右侧的拾色器选取颜色 stroke 描边宽度，范围为0~100 strokeColor 文本的描边颜色，可以直接输入颜色值，例如：#ffffff，也可以点击输入条右侧的拾色器选取颜色 1.3 脚本控制Label 在Scene2D的属性设置面板中，增加一个自定义组件脚本。然后，将Label拖入到其暴露的属性入口中。下面给出一个示例代码，实现脚本控制Label： const { regClass, property } = Laya; @regClass() export class LabelControl extends Laya.Script { //declare owner : Laya.Sprite3D; @property( { type : Laya.Label } ) public lab: Laya.Label; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { this.lab.pos(Laya.stage.width >> 1, Laya.stage.height >> 1); //位置 this.lab.size(500, 30); //大小 this.lab.pivot(this.lab.width/2, this.lab.height/2); //轴心点 this.lab.text = \"大家好，欢迎大家来到LayaAir IDE\"; //文本内容 this.lab.font = \"宋体\"; //字体 this.lab.fontSize = 50; //字体大小 this.lab.color = \"#ff0000\"; //字体颜色 this.lab.bold = true; //加粗 this.lab.italic = true; //斜体 this.lab.underline = true; //下划线 this.lab.underlineColor = \"#ff0000\"; //下划线颜色 this.lab.stroke = 5; //描边宽度 this.lab.strokeColor = \"#000000\" ; //描边颜色 this.lab.wordWrap = true; //自动换行 this.lab.leading = 10; //垂直行间距 this.lab.align = \"left\"; //水平对齐方式 this.lab.valign = \"top\"; //垂直对齐方式 this.lab.overflow = \"visible\"; //文本溢出 // this.lab.fitContent = \"yes\"; //自适应大小 this.lab.bgColor = \"#19a4f1\"; //背景颜色 this.lab.borderColor = \"#f6ff03\" //边框颜色 } } 二、通过代码创建Label组件 在进行项目开发的时候，有时不想让Label一开始就在舞台上，而是在要用的时候才添加，这就要通过代码来创建了。在Scene2D的属性设置面板中，增加一个自定义组件脚本，创建UI_Label类，通过代码创建Label，它的其他属性也可以通过代码来设置。下述示例代码演示了如何通过代码创建不同皮肤（样式）的Label，开发者可以自己通过代码设置Label，创建出符合自己需要的文字效果。 示例代码： const { regClass, property } = Laya; const Label = Laya.Label; @regClass() export class UI_Label extends Laya.Script { constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { this.setup(); } private setup(): void { this.createLabel(\"#FFFFFF\", null).pos(30, 50); this.createLabel(\"#00FFFF\", null).pos(290, 50); this.createLabel(\"#FFFF00\", \"#FFFFFF\").pos(30, 100); this.createLabel(\"#000000\", \"#FFFFFF\").pos(290, 100); this.createLabel(\"#FFFFFF\", \"#00FFFF\").pos(30, 150); this.createLabel(\"#0080FF\", \"#00FFFF\").pos(290, 150); } private createLabel(color: string, strokeColor: string): Laya.Label { const STROKE_WIDTH: number = 4; var label: Laya.Label = new Label(); label.font = \"Microsoft YaHei\"; label.text = \"SAMPLE DEMO\"; label.fontSize = 30; label.color = color; if (strokeColor) { label.stroke = STROKE_WIDTH; label.strokeColor = strokeColor; } this.owner.addChild(label); return label; } } 效果预览： （图2-1） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-06-29 22:39:41 "},"IDE/uiEditor/uiComponent/TextInput/readme.html":{"url":"IDE/uiEditor/uiComponent/TextInput/readme.html","title":"输入文本组件","keywords":"","body":"输入文本组件(TextInput)1. LayaAir IDE中使用TextInput1.1 创建TextInput1.2 TextInput属性1.3 脚本控制TextInput2. Textinput代码创建输入文本组件(TextInput) 1. LayaAir IDE中使用TextInput 文本输入框是游戏中经常会用到的一个UI组件，任何需要输入的时候可以使用TextInput。TextInput类的API可以参考这里。 1.1 创建TextInput 如图1-1所示，可以在层级窗口中右键进行创建，也可以从小部件窗口中拖拽添加。 （图1-1） 1.2 TextInput属性 （图1-2） 属性 功能说明 text 初始显示的文本内容 font 文本的字体名称，例如：Microsoft YaHei，这里可以手动输入常用的字体，还可以是位图字体 fontSize 文本字体大小，例如： 50，直接填写正整数 color 文本的颜色，可以直接输入颜色值，例如：#ffffff，也可以点击输入条右侧的拾色器选取颜色 style “B”(bold)是否为粗体，“I”(italic)是否为斜体，“U”是否有下划线 syntax 多样式混排，支持部分HTML语法和UBB语法。还可以勾选模板，能够在字符串中使用变量 align 对齐方式，水平对齐(align)分别是left（居左对齐）、center（居中对齐）、right（居右对齐）;垂直对齐(valign)分别是top（居顶对齐）、middle（居中对齐）、bottom（居底对齐） bgColor 背景颜色，勾选后可以直接输入颜色值，例如：#ffffff，也可以点击输入条右侧的拾色器选取颜色 bordercolor 文本边框颜色，勾选后可以直接输入颜色值，例如：#ffffff，也可以点击输入条右侧的拾色器选取颜色 overflow 文本溢出处理，共有五种模式。visible（可见）：不进行任何裁切。hidden（隐藏）：不显示超出文本域的字符。scroll（滚动）：默认模式，不显示文本域外的字符像素，并且支持scroll接口。shrink（自动收缩）：超出文本域时，文本整体缩小以适应文本框。ellipsis（显示省略号）：超出文本域时，文本被截断，并且文本最后显示省略号 wordWrap 是否自动换行，布尔值选项，默认为false，选择true可以开启自动换行 leading 垂直行间距，当开启自动换行时，文本内容多行时有效。间距以像素为单位，输入正整数即可 padding 文本边距，以像素为单位，由4个整数值组成。“U”表示距上边框的距离、”R“表示距右边框的距离、”D“表示距下边框的距离、”L”表示距左边框的距离 underlinecolor 下划线颜色，可以直接输入颜色值，例如：#ffffff，也可以点击输入条右侧的拾色器选取颜色 stroke 描边宽度，范围为0~100 strokeColor 文本的描边颜色，可以直接输入颜色值，例如：#ffffff，也可以点击输入条右侧的拾色器选取颜色 skin 设置皮肤，选择对应的图像资源即可。代码中表示皮肤的地址，以字符串表示 sizeGrid 背景图的有效缩放网格数据。数据格式：\"上边距，右边距，下边距，左边距，是否重复填充（值为0：不重复填充，1：重复填充）\"，以逗号分隔。例如：\"4,4,4,4,1\" type 输入框类型，共有十三种类型：text、password、email、url、number、range、date、month、week、time、dateime、dateime—local、search。效果等同HTML的input maxchars 最大字符数，默认为100000。设置字符数量限制时，小于等于0的值将会限制字符数量为100000 restrict 限制输入的字符，在TextInput里只能输入这些。不建议开启，适用于简单的文本，不支持反斜杠 prompt 输入前的提示文本 promptcolor 提示文本的颜色 editable 设置可编辑状态，默认为true multiline 是否是文本域，值为true表示当前是文本域，可多行输入，否则不是文本域。默认为false 1.3 脚本控制TextInput 在Scene2D的属性设置面板中，增加一个自定义组件脚本。然后，将TextInput拖入到其暴露的属性入口中。下面给出一个示例代码，实现脚本控制TextInput： const { regClass, property } = Laya; @regClass() export class TextInputControl extends Laya.Script { //declare owner : Laya.Sprite3D; @property( { type : Laya.TextInput } ) public txtin: Laya.TextInput; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { this.txtin.pos(Laya.stage.width >> 1, Laya.stage.height >> 1); //位置 this.txtin.size(500, 60); //大小 this.txtin.pivot(this.txtin.width/2, this.txtin.height/2); //轴心点 this.txtin.font = \"宋体\"; //字体 this.txtin.fontSize = 50; //字体大小 this.txtin.color = \"#ff0000\"; //字体颜色 this.txtin.bold = true; //加粗 this.txtin.italic = true; //斜体 this.txtin.underline = true; //下划线 this.txtin.underlineColor = \"#ff0000\"; //下划线颜色 this.txtin.stroke = 5; //描边宽度 this.txtin.strokeColor = \"#000000\" ; //描边颜色 this.txtin.wordWrap = true; //自动换行 this.txtin.overflow = \"scroll\"; //文本溢出 // this.txtin.skin = \"atlas/comp/textinput.png\"; //皮肤 this.txtin.bgColor = \"#19a4f1\"; //背景颜色 this.txtin.borderColor = \"#f6ff03\" //边框颜色 this.txtin.editable = true; //可编辑状态 // this.txtin.type = \"password\"; //输入框类型 // this.txtin.maxChars = 5; //最大字符数 // this.txtin.restrict = \"12345\"; //输入限制 // this.txtin.prompt = \"请输入\"; //输入提示 // this.txtin.promptColor = \"#a9a9a9\"; //提示词颜色 // this.txtin.multiline = true; //文本域 } } （为了防止效果杂乱，示例代码中的部分代码先注释掉了，开发者可以自行取消注释观察效果） 2. Textinput代码创建 有时，不想让Textinput组件一开始就在舞台上，而是在要用的时候才添加，这就要通过代码来创建了。在Scene2D的属性设置面板中，增加一个自定义组件脚本，示例代码如下： const { regClass, property } = Laya; @regClass() export class UI_Input extends Laya.Script { private SPACING: number = 100; private Y_OFFSET: number = 50; private skins: any[]; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { this.skins = [\"resources/res/ui/input (1).png\", \"resources/res/ui/input (2).png\", \"resources/res/ui/input (3).png\", \"resources/res/ui/input (4).png\"]; Laya.loader.load(this.skins).then( ()=>{ this.onLoadComplete(); } ); } private onLoadComplete(): void { for (var i: number = 0; i （代码中的图片资源来自“引擎API使用示例”项目，开发者可以自行创建下载） 运行结果： （图2-1） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-06-29 22:40:55 "},"IDE/uiEditor/uiComponent/TextArea/readme.html":{"url":"IDE/uiEditor/uiComponent/TextArea/readme.html","title":"多行输入文本组件","keywords":"","body":"多行输入文本组件(TextArea)1. LayaAir IDE中使用TextArea1.1 创建TextArea1.2 TextArea属性介绍1.3 脚本控制TextArea2. 通过代码创建TextArea多行输入文本组件(TextArea) 由于TextArea继承于TextInput，两者相同点太多这篇文章只介绍两者不同的地方，TextInput介绍到的点这里不再过多讲解。详细内容可以查阅TextArea API。 1. LayaAir IDE中使用TextArea 1.1 创建TextArea 如图1-1所示，可以在层级窗口中右键进行创建，也可以从小部件窗口中拖拽添加。 （图1-1） 1.2 TextArea属性介绍 （图1-2） 属性：text、font、fontSize、color、style、syntax、align、bgColor、bordercolor、overflow、wordWrap（默认为true）、leading、padding、underlinecolor、stroke、strokeColor、skin、sizeGrid、type、maxchars、restrict、prompt、promptcolor、editable、multiline（默认为true）; 以上属性均已在输入文本组件中列出过，这里不在详细描述，与之不同的地方已在括号内标出。 TextArea比TextInput多出的属性如下： 属性 功能说明 vscrollbarskin 添加垂直滚动条皮肤 hscrollbarskin 添加水平滚动条皮肤 scrolltype 文本域的滚动类型，需要配合对应的滚动条皮肤使用。共有四种类型：none：无滚动（默认），horizontal：水平方向滚动，vertical：垂直方向滚动，both：水平与垂直都滚动 TextArea是一个用于多行的文本域，相较于TextInput的区别是它可以添加垂直滚动条皮肤和水平滚动条皮肤。水平方向滚动效果如动图1-3所示，垂直方向滚动效果如动图1-4所示。 （动图1-3） （动图1-4） 1.3 脚本控制TextArea const { regClass, property } = Laya; @regClass() export class TextAreaControl extends Laya.Script { //declare owner : Laya.Sprite3D; @property( { type : Laya.TextArea } ) public txtarea: Laya.TextArea; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { this.txtarea.pos(Laya.stage.width >> 1, Laya.stage.height >> 1); //位置 this.txtarea.size(500, 200); //大小 this.txtarea.pivot(this.txtarea.width/2, this.txtarea.height/2); //轴心点 this.txtarea.text = \"大家好，欢迎各位开发者使用LayaAir IDE，这里是TextArea的文本内容，您可以基于此文本进行调试\"; this.txtarea.font = \"宋体\"; //字体 this.txtarea.fontSize = 50; //字体大小 this.txtarea.color = \"#ff0000\"; //字体颜色 this.txtarea.bold = true; //加粗 this.txtarea.italic = true; //斜体 this.txtarea.underline = true; //下划线 this.txtarea.underlineColor = \"#ff0000\"; //下划线颜色 this.txtarea.stroke = 5; //描边宽度 this.txtarea.strokeColor = \"#000000\" ; //描边颜色 this.txtarea.wordWrap = true; //自动换行 this.txtarea.overflow = \"scroll\"; //文本溢出 this.txtarea.skin = \"atlas/comp/textarea.png\"; //皮肤 this.txtarea.borderColor = \"#f6ff03\" //边框颜色 this.txtarea.scrollType = Laya.ScrollType.Vertical; //滚动方式 this.txtarea.vScrollBarSkin = \"atlas/comp/vscroll.png\"; //滚动条皮肤 } } 开发者注意滚动方式的设置代码：Laya.ScrollType.Vertical，这是垂直方向滚动；Laya.ScrollType.Horizontal，这是水平方向滚动。不同的滚动方式需要设置对应的滚动条皮肤。 2. 通过代码创建TextArea const { regClass, property } = Laya; @regClass() export class UI_TextArea extends Laya.Script { private skin: string = \"resources/res/ui/textarea.png\"; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { Laya.loader.load(this.skin).then( ()=>{ this.onLoadComplete(); } ); } private onLoadComplete(e: any = null): void { let ta: Laya.TextArea = new Laya.TextArea(\"\"); ta.skin = this.skin; ta.font = \"Arial\"; ta.fontSize = 18; ta.bold = true; ta.color = \"#3d3d3d\"; ta.pos(100, 15); ta.size(375, 355); ta.padding = \"70,8,8,8\"; this.owner.addChild(ta); } } （代码中的图片资源来自“引擎API使用示例”项目，开发者可以自行创建下载） 运行结果： （图2-1） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-06-29 22:45:10 "},"IDE/uiEditor/uiComponent/Clip/readme.html":{"url":"IDE/uiEditor/uiComponent/Clip/readme.html","title":"位图切片组件","keywords":"","body":"位图切片组件（Clip）一、通过LayaAir IDE创建Clip组件1.1 创建Clip1.2 Clip 组件的常用属性1.3 脚本控制Clip二、通过代码创建Clip组件位图切片组件（Clip） Clip 组件可以用来播放切片动画，和显示切片动画的某一帧图片。Clip 可以将一张图片，按横向分隔数量 ClipX、竖向分隔数量 ClipY，或横向分割每个切片的宽度 ClipWidth、竖向分割每个切片的高度 ClipHeight，从左向右，从上到下，分割组合为一个切片动画。Clip 的脚本接口参考Clip API。 一、通过LayaAir IDE创建Clip组件 1.1 创建Clip 如图1-1所示，可以在层级窗口中右键进行创建，也可以从小部件窗口中拖拽添加。 （图1-1） 在创建的工程中，LayaAir会自带一个Clip 组件的资源示例（clip_num.png），效果如图1-2。 （图1-2） 1.2 Clip 组件的常用属性 Clip组件的特有属性如下： （图1-3） 属性 功能说明 autoPlay 布尔值，表示是否自动播放当前切片动画。 clipWidth 横向分割图片资源时，每个切片的宽度。（优先级高于clipX） clipHeight 纵向分割图片资源时，每个切片的高度。（优先级高于clipY） clipX 横向分割图片资源时，等宽切割的份数。 clipY 纵向分割图片资源时，等高切割的份数。 index 切片动画当前显示动画帧索引。 interval 切片动画的播放时间间隔。 skin 切片动画的纹理。 sizeGrid 图像资源的有效网格数据（九宫格数据）。 group 加载分组，设置后可以按组管理资源。 这里使用LayaAir自带的资源演示clipWidth和clipX的效果。如动图1-4所示，每个数字的宽度为26，所以将clipWidth设置为26，此时再调节clipX的值就无效了。 （动图1-4） 如果不设置clipWidth，设置clipX为10，则会将十个数字等分，效果如下： （图1-5） 1.3 脚本控制Clip 有时，要通过代码设定Clip相关的属性，就需要用到脚本了。在Scene2D的属性设置面板中，增加一个自定义组件脚本。然后，将Clip组件拖入到其暴露的属性入口中。下面给出一个示例代码，实现脚本控制Clip： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { @property({ type: Laya.Clip }) public clip: Laya.Clip; //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { this.clip.pos(Laya.stage.width >> 1, Laya.stage.height >> 1); // 位置 this.clip.skin = \"atlas/comp/clip_num.png\"; // 皮肤 this.clip.interval = 1000; // 切片动画的播放时间间隔1000毫秒 this.clip.clipX = 10; // 切片x轴数量 this.clip.autoPlay = true; // 动画自动播放 } } 二、通过代码创建Clip组件 在进行书写代码的时候，免不了通过代码控制UI，创建UI_Clip类，通过代码设定Clip相关的属性。 通过代码创建计数器，运行示例效果: （动图2-1） 示例说明： （图2-2） Clip的其他属性也可以通过代码来设置，上述示例演示了如何通过计时器获取每一秒更新clip.clipX切片，通过每秒更新数字实现计时器的功能，有兴趣的读者可以自己通过代码设置Clip，创建出符合自己项目中需要的Clip。 注：需要将图片资源的纹理类型设置为“精灵纹理”。 示例代码： const { regClass, property } = Laya; @regClass() export class UI_Clip extends Laya.Script { // 以下资源来自“引擎API使用示例” private buttonSkin: string = \"resources/res/ui/button-7.png\"; private clipSkin: string = \"resources/res/ui/num0-9.png\"; private bgSkin: string = \"resources/res/ui/coutDown.png\"; counter: any; controller: any; currFrame: any; //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { Laya.loader.load([this.buttonSkin, this.clipSkin, this.bgSkin]).then( ()=>{ this.onSkinLoaded(); } ); } private onSkinLoaded(e: any = null): void { this.showBg(); this.createTimerAnimation(); this.showTotalSeconds(); this.createController(); } private showBg(): void { var bg: Laya.Image = new Laya.Image(this.bgSkin); bg.size(224, 302); bg.pos(Laya.stage.width - bg.width >> 1, Laya.stage.height - bg.height >> 1); this.owner.addChild(bg); } private createTimerAnimation(): void { this.counter = new Laya.Clip(this.clipSkin, 10, 1); this.counter.autoPlay = true; this.counter.interval = 1000; this.counter.x = (Laya.stage.width - this.counter.width) / 2 - 35; this.counter.y = (Laya.stage.height - this.counter.height) / 2 - 40; this.owner.addChild(this.counter); } private showTotalSeconds(): void { var clip: Laya.Clip = new Laya.Clip(this.clipSkin, 10, 1); clip.index = clip.clipX - 1; clip.pos(this.counter.x + 60, this.counter.y); this.owner.addChild(clip); } private createController(): void { this.controller = new Laya.Button(this.buttonSkin, \"暂停\"); this.controller.labelBold = true; this.controller.labelColors = \"#FFFFFF,#FFFFFF,#FFFFFF,#FFFFFF\"; this.controller.size(84, 30); this.controller.on('click', this, this.onClipSwitchState); this.controller.x = (Laya.stage.width - this.controller.width) / 2; this.controller.y = (Laya.stage.height - this.controller.height) / 2 + 110; this.owner.addChild(this.controller); } private onClipSwitchState(e: any = null): void { if (this.counter.isPlaying) { this.counter.stop(); this.currFrame = this.counter.index; this.controller.label = \"播放\"; } else { this.counter.play(); this.counter.index = this.currFrame; this.controller.label = \"暂停\"; } } } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-08-30 17:33:15 "},"IDE/uiEditor/uiComponent/FontClip/readme.html":{"url":"IDE/uiEditor/uiComponent/FontClip/readme.html","title":"字体切片组件","keywords":"","body":"字体切片组件（FontClip）1、使用LayaAir IDE创建FontClip1.1 创建FontClip1.2 FontClip属性介绍1.3 脚本控制FontClip2、代码创建FontClip字体切片组件（FontClip） FontClip组件本质上是对位图从方向上进行等比切割，FontClip继承于Clip。FontClip的组件脚本接口请参考FontClip API。 1、使用LayaAir IDE创建FontClip 1.1 创建FontClip 创建FontClip非常简单，通过IDE的可视化操作，只需要用鼠标就可以实现。如图1-1所示，可以在层级窗口中右键进行创建，也可以从小部件窗口中拖拽添加。 （图1-1） 在LayaAir中，自带了一个字体切片的图像资源（fontClip.png），如图1-2所示， （图1-2） 1.2 FontClip属性介绍 FontClip的特有属性如下： （图1-3） 属性 功能说明 skin 字体切片组件的纹理，需要添加图像资源。 sizeGrid 位图的有效缩放网格数据（九宫格信息）：上边距、右边距、下边距、左边距、是否重复填充。 group 加载分组，设置后可以按组管理资源。 align 水平对齐方式，共有三种方式。left：居左对齐，center：居中对齐，right：居右对齐。 sheet 位图内容范围，位图内容在有换行时需要在换行的位置添加空格。 value 位图数字内容。 spacex X方向项间隔，以像素为单位。 spacey Y方向项间隔，以像素为单位。 direction 位图内容排列方向，共有两个选项。horizontal：水平方向排列，vertical：垂直方向排列。 FontClip相比于Clip更适用于字体切片，所以叫FontClip。FontClip在游戏中比Clip用的更多更广，FontClip也是我们推荐使用的，一些特殊的文本或者字体就会用到FontClip。 1.sheet和value属性使用方法 FontClip如果位图内容是图形的话，可以将其等份切割成一个个独立的单元，按索引处理。 演示一下sheet属性的使用方法，如图1-4所示，sheet值按照位图内容填上对应图1-2所示的15个字符。其中”羊“字和”猴“字中间分段了，所以要在这两个字中间加一个空格，让引擎知道这个位图文本是多行排行的。然后在value中输入想要显示的内容，就可以将其显示出来。 （图1-4） 总之，sheet就相当于一个位图切片样板，value会直接对比sheet中的内容，取值非常方便和灵活。 2.SpaceX和SpaceY属性使用方法 SpaceX用来调节X方向的间隔，需要配合Direction来使用，如图1-5所示，设置Direction方向为horizontal。 （图1-5） SpaceY用来调节Y方向的间隔，需要配合Direction来使用，如图1-6所示，设置Direction方向为vertical。 （图1-6） 1.3 脚本控制FontClip 在Scene2D的属性设置面板中，增加一个自定义组件脚本。然后，将FontClip拖入到其暴露的属性入口中。下面给出一个示例代码，实现脚本控制FontClip： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { @property( { type : Laya.FontClip } ) public fontclp: Laya.FontClip; constructor() { super(); } // 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { this.fontclp.pos(Laya.stage.width >> 1, Laya.stage.height >> 1); //位置 this.fontclp.size(500, 60); //大小 this.fontclp.pivot(this.fontclp.width/2, this.fontclp.height/2); //轴心点 this.fontclp.skin = \"atlas/comp/fontClip_num.png\"; this.fontclp.sheet = \"0123456789\"; this.fontclp.value = \"5201314\"; this.fontclp.direction = \"horizontal\"; //位图排列方向 this.fontclp.spaceX = 50; //水平间隔 // this.fontclp.direction = \"vertical\"; //位图排列方向 // this.fontclp.spaceY = 10; //垂直间隔 } } 2、代码创建FontClip 有时，不想让FontClip组件一开始就在舞台上，而是在要用的时候才添加，这就要通过代码来创建了。在Scene2D的属性设置面板中，增加一个自定义组件脚本，代码运行示例： （图2-1） 示例代码如下： const { regClass, property } = Laya; @regClass() export class UI_FontClip extends Laya.Script { private TestClipNum: string = \"atlas/comp/fontClip_num.png\"; private _ClipNum: string = \"atlas/comp/fontClip_num.png\"; private _ClipNum1: string = \"atlas/comp/fontClip_num.png\"; private TestFontClip: string = \"atlas/comp/fontClip.png\"; private _FontClip: string = \"atlas/comp/fontClip.png\"; //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { Laya.loader.load([this.TestClipNum, this.TestFontClip, this._ClipNum, this._FontClip, this._ClipNum1]).then( ()=>{ this.ShowContent(); } ); } private ShowContent(): void { var clipnum: Laya.FontClip = new Laya.FontClip(this._ClipNum); var fontClip: Laya.FontClip = new Laya.FontClip(this._FontClip); var testFontClip: Laya.FontClip = new Laya.FontClip(this.TestFontClip); var testClipNum: Laya.FontClip = new Laya.FontClip(this.TestClipNum); var clipnum1: Laya.FontClip = new Laya.FontClip(this._ClipNum1); clipnum.pos(240, 400); clipnum.size(250, 50); clipnum.sheet = \"0123456789\"; clipnum.value = \"114499\"; clipnum.spaceY = 10; testClipNum.pos(200, 300); testClipNum.sheet = \"0123456789\"; testClipNum.value = \"0123456789\"; clipnum1.pos(150, 100); clipnum1.direction = \"vertical\"; clipnum1.sheet = \"0123456789\"; clipnum1.value = \"223388\"; fontClip.pos(240, 200); fontClip.sheet = \"鼠牛虎兔龙蛇马羊 猴鸡狗猪年快乐\"; fontClip.value = \"猪年快乐\"; fontClip.spaceY = 10; testFontClip.pos(200, 100); testFontClip.sheet = \"鼠牛虎兔龙蛇马羊猴鸡狗猪年快乐\"; testFontClip.value = \"鼠牛虎兔龙蛇马羊猴鸡狗猪年快乐\"; testFontClip.spaceY = 10; this.owner.addChild(clipnum); this.owner.addChild(fontClip); this.owner.addChild(testFontClip); this.owner.addChild(testClipNum); this.owner.addChild(clipnum1); } } 通常FontClip已经可以满足开发者的基本需求。如果有特殊情况，可以通过BitmapFont位图字体来实现。 位图字体的内容请参考《文本进阶使用》。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-09-01 17:45:13 "},"IDE/uiEditor/uiComponent/Button/readme.html":{"url":"IDE/uiEditor/uiComponent/Button/readme.html","title":"按钮组件","keywords":"","body":"按钮组件（Button）1、LayaAir IDE中使用Button组件1.1 创建Button组件1.2 Button属性1.3 脚本控制Button2、Button代码创建按钮组件（Button） 1、LayaAir IDE中使用Button组件 按钮（Button）组件是最常用的组件之一，可以显示文本标签、图标或者两者同时显示。在LayaAir IDE里的按钮图片（皮肤）资源命名通常是以btn为前缀。Button 组件的属性接口介绍请参考 Button API。 1.1 创建Button组件 使用LayaAir IDE创建Button非常简单，通过IDE的可视化操作，完全不需要程序基础，即可实现组件的创建与布局，也是推荐使用的组件创建方式。如图1-1所示，可以在层级窗口中右键进行创建，也可以从小部件窗口中拖拽添加。 （图1-1） 在这个过程不需要任何程序编码，完全可以交给美术或策划实现。从而减少了与程序员的沟通成本，加快了游戏的开发效率。 1.2 Button属性 Button组件的特有属性如下： （图1-2） 属性 功能说明 toggle 是否切换按钮的显示状态。默认为false，按钮点击后会直接恢复初始状态。勾选后为true，可以通过点击切换按钮显示状态，当点击按钮组件后，按钮会保持在选中（持续按下）状态，再次点击可以还原。 stateNum 按钮皮肤的状态数，支持单态（1）、两态（2）和三态（3）按钮。 selected 按钮是否为选中状态，默认为false。设置为true后，按钮将会一直保持选中（持续按下）的状态，而不会再对其它状态产生变化（除非在代码中进行状态改变）。 skin 按钮的皮肤纹理资源。设置后需要根据皮肤资源设置stateNum皮肤状态数。 sizeGrid 位图的有效缩放网格数据（九宫格信息）：上边距、右边距、下边距、左边距、是否重复填充。 label 按钮的文本标签。 labelFont 文本标签的字体。 labelSize 文本标签的字体大小。 labelBold 文本标签是否加粗，默认为false。 labelColors 鼠标在元素释放时（up）、鼠标移动到元素时（over），鼠标按下时（down）各个状态下的文本标签颜色。 labelAlign 文本标签的水平对齐模式：left、center、right，默认为居中对齐。 labelVAlign 文本标签的垂直对齐模式：top、middle、bottom，默认为居中对齐。 labelPadding 文本标签的边距。格式：上边距、右边距、下边距、左边距。 labelStroke 文本标签的描边宽度，以像素为单位。默认值为0，表示不描边。 labelStrokeColor 文本标签描边的颜色，以字符串表示，默认值为#000000（黑色）。 strokeColors 勾选后，可以根据状态设置文本的描边颜色。分三种状态进行设置：鼠标在元素释放时（up）、鼠标移动到元素时（over），鼠标按下时（down），三种状态可以设置不同的描边颜色。 下面将围绕Button组件中通过文字难以理解的属性给予重点介绍。 1.2.1 按钮皮肤（skin） 按钮的皮肤因切割方式不同，分成单态（1）、两态（2）和三态（3）。这里的态指的是按钮皮肤（skin）的状态。 三态常用于PC浏览器中，是将皮肤图片按竖直方向以等比分割的形式分为3部分。图1-3所示是LayaAir中自带的按钮皮肤（button.png），从上至下依次为：鼠标弹起或离开时的状态皮肤、鼠标经过时的状态皮肤、鼠标按下和选中时的状态皮肤。 （图1-3） 在移动设备上，通常只采用两态，图片以竖直方向被等比切割为两部分，上面的部分为按钮弹起或非选中时的状态皮肤，下面的部分为 按钮选中和按下时的状态皮肤。 单态按钮不切割图片，无论什么状态，按钮的皮肤只有一种，保持不变。 1.2.2 指定按钮皮肤的切割状态（stateNum） stateNum的属性值决定皮肤资源图片的切割方式。默认值为3，也就是说默认按3态按钮进行切割，等比分割为3部分。如果是两态按钮，需要将stateNum的属性值设为2，等比切割为2部分。单态按钮设置为1，不进行切割。 这里需要注意的是，指定按钮状态，需要与按钮皮肤对应好。如果是三态的按钮皮肤，stateNum设置为2，切割后如图1-4所示，是错误的。 （图1-4） 1.2.3 根据状态设置按钮的文本描边颜色（strokeColors） labelStrokeColor可以为按钮的文本描边设置一个统一的颜色（不同状态的颜色一致）。而strokeColors属性可以根据不同的状态设置按钮的描边文本颜色。 如图1-5所示，strokeColors颜色的先后设置顺序格式为：upColor（弹起或离开状态的颜色）、overColor（经过状态的颜色）、downColor（按下和选中状态的颜色）。 （图1-5） 如果想要更清晰的感受描边颜色的变化，可以将按钮大小、文本标签的字体大小和描边宽度等属性值设置大一些，效果如动图1-6所示。 （动图1-6） 1.3 脚本控制Button 有时，要通过代码设定Button相关的属性，就需要用到脚本了。在Scene2D的属性设置面板中，增加一个自定义组件脚本。然后，将Button组件拖入到其暴露的属性入口中。在脚本文件中添加如下示例代码： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { @property({ type: Laya.Button }) public btn: Laya.Button; //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { this.btn.scale(5, 5); //放大五倍 this.btn.skin = \"atlas/comp/button.png\"; //皮肤 this.btn.stateNum = 3; //皮肤状态 this.btn.label = \"确定\"; //文本标签 this.btn.labelFont = \"宋体\"; //文本标签字体 this.btn.labelSize = 20; //文本标签字体大小 this.btn.labelBold = true; //文本标签加粗 this.btn.labelAlign = \"center\"; //文本标签水平居中对齐 this.btn.labelStroke = 3; //文本标签字体描边宽度 this.btn.labelStrokeColor = \"#ffffff\"; //描边颜色 this.btn.strokeColors = \"#000000, #c6ff00, #001aff\"; //各状态下的描边颜色 this.btn.labelColors = \"#0100ff, #16fa0e, #ff0000\"; //各状态下的文本颜色 // this.btn.toggle = true; //是否保持点击状态 // this.btn.selected = true; //是否选中 } } 2、Button代码创建 使用LayaAir引擎创建一个Button组件比较简单，通常只需要几个步骤，加载资源、创建一个Button实例、将Button添加到当前场景上，最后设置Button组件的属性。具体实现可以参考下面的代码与注释： const { regClass, property } = Laya; @regClass() export class UI_Button extends Laya.Script { private COLUMNS: number = 2; private BUTTON_WIDTH: number = 147; private BUTTON_HEIGHT: number = 165 / 3; private HORIZONTAL_SPACING: number = 200; private VERTICAL_SPACING: number = 100; private xOffset: number; private yOffset: number; private skins: any[]; //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { // 以下图片资源来自“引擎API使用示例”项目 this.skins = [\"resources/res/ui/button-1.png\", \"resources/res/ui/button-2.png\", \"resources/res/ui/button-3.png\", \"resources/res/ui/button-4.png\", \"resources/res/ui/button-5.png\", \"resources/res/ui/button-6.png\"]; // 计算将Button至于舞台中心的偏移量 this.xOffset = (Laya.stage.width - this.HORIZONTAL_SPACING * (this.COLUMNS - 1) - this.BUTTON_WIDTH) / 2; this.yOffset = (Laya.stage.height - this.VERTICAL_SPACING * (this.skins.length / this.COLUMNS - 1) - this.BUTTON_HEIGHT) / 2; Laya.loader.load(this.skins).then(() => { this.onUIAssetsLoaded(); }); } private onUIAssetsLoaded(e: any = null): void { for (var i: number = 0, len: number = this.skins.length; i 上述代码运行效果如动图2-1所示： (动图2-1) Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-10-19 15:06:04 "},"IDE/uiEditor/uiComponent/scroll/readme.html":{"url":"IDE/uiEditor/uiComponent/scroll/readme.html","title":"滚动条组件","keywords":"","body":"滚动条组件滚动条组件 滚动条组件主要包括水平滚动条与垂直滚动条组件 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:53 "},"IDE/uiEditor/uiComponent/HScrollBar/readme.html":{"url":"IDE/uiEditor/uiComponent/HScrollBar/readme.html","title":"水平滚动条组件","keywords":"","body":"水平滚动条组件（HScrollBar）一、通过LayaAir IDE创建HScrollBar组件1.1 创建HScrollBar1.2 HScrollBar属性1.3 脚本控制HScrollBar二、通过代码创建HScrollBar组件水平滚动条组件（HScrollBar） 一、通过LayaAir IDE创建HScrollBar组件 HScrollBar组件是一个水平方向滚动条组件。当数据太多以至于显示区域无法容纳时，最终用户可以使用 HScrollBar 组件控制所显示的数据部分。HScrollBar 组件的脚本接口请参考 HScrollBar API。 1.1 创建HScrollBar 如图1-1所示，可以在层级窗口中右键进行创建，也可以从小部件窗口中拖拽添加。 （图1-1） 滚动条由四部分组成：一个轨道图、一个滑块按钮和两个箭头按钮。HScrollBar组件图像资源的命名要符合资源命名规则，LayaAir自带的资源示例如下所示： （图1-2）轨道图 （图1-3）滑块按钮 （图1-4）箭头按钮1 （图1-5）箭头按钮2 创建HScrollBar后的显示效果如下： （图1-6） 1.2 HScrollBar属性 HScrollBar的特有属性如下： （图1-7） 属性 功能说明 skin 滚动条轨道图的图像资源地址。 sizeGrid 滚动条轨道图资源的有效缩放网格数据（九宫格数据）。 max 表示滑块的最大滚动位置（滑块位于最右侧时的value值）。 min 表示滑块的最小滚动位置（滑块位于最左侧时的value值）。 scrollSize 点击按钮滚动量。每一次点击滚动条箭头按钮时，滚动条的值改变的量（滑块移动的量）。 value 滚动条当前进度值（滑块当前位置）。 mouseWheelEnable 是否开启鼠标滚轮滚动，默认值为true。该属性设置滚动对象target以后有效。 touchScrollEnable 是否开启触摸滚动，默认值为true。该属性设置滚动对象target以后有效。 hide 是否隐藏滚动条，默认为false。设为true后，不显示滚动条，但是可以正常滚动。 autoHide 是否自动隐藏滚动条，默认值为false。设为true后，无需滚动时隐藏滚动条，内容需要滚动时显示滚动条。 showButtons 是否显示箭头按钮，默认值为true。设为false后，箭头按钮将不显示。 rollRatio 滚动衰减系数，默认为0.97。 elasticDistance 橡皮筋效果极限距离，0为没有橡皮筋效果。 elasticBackTime 橡皮筋回弹时间，单位为毫秒。 下面展示一些滚动条属性设置的效果： 设置 HScrollBar 的属性 max 的值为 10、属性 min 的值为0、属性 value 的值为3后，显示效果如下： （图1-8） 在运行时，可以拖动滑块或点击箭头按钮控制滚动条的值。设置属性scrollSize为1，那么每次点击滚动条箭头按钮时，滚动条的值value就改变1，效果如下所示： （动图1-9） 设置mouseWheelEnable属性为true后，可以开启鼠标滚轮滚动。但是该属性必须设置滚动对象后才有效，这里的滚动对象以Panel为例，效果如动图1-10所示，通过鼠标滑轮控制水平滚动条。 （动图1-10） 设置touchScrollEnable属性为true后，可以开启触摸滚动。该属性也必须设置滚动对象后才有效，如动图1-11所示，可以对Panel组件进行拖拽，水平滚动条会跟着进行滚动。 （动图1-11） 设置hide属性为true后，不显示滚动条，但是可以正常滚动。效果如下动图所示： （动图1-12） 设置autoHide属性为true后，滚动条会自动隐藏。当操作内容进行滚动时，滚动条会显示出来，当停止滚动时，滚动条会自动隐藏。效果如下： （动图1-13） 设置rollRatio属性，数值越小，滚动的速度变化越小。动图1-14左图是rollRatio设置为1的效果，右图是rollRatio设置为0.1的效果，显然rollRatio的值越大，滚动速度越快。 （动图1-14） 水平滚动条支持橡皮筋技术。动图1-15演示的是设置橡皮筋效果极限距离elasticDistance为200、橡皮筋回弹时间elasticBackTime为500毫秒的效果。 （动图1-15） 1.3 脚本控制HScrollBar 在Scene2D的属性设置面板中，增加一个自定义组件脚本。然后，将HScrollBar拖入到其暴露的属性入口中。需要添加如下的示例代码，实现脚本控制HScrollBar： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { @property({ type: Laya.HScrollBar }) public hscroll: Laya.HScrollBar; //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { this.hscroll.skin = \"atlas/comp/hscroll.png\";//滚动条皮肤 this.hscroll.width = 300;//滚动条的宽度 this.hscroll.pos(300, 300);//滚动条的位置 this.hscroll.min = 0;//滑块的最小滚动位置 this.hscroll.max = 10;//滑块的最大滚动位置 this.hscroll.scrollSize = 1;//点击按钮的滚动量 } } 二、通过代码创建HScrollBar组件 在进行书写代码的时候，免不了通过代码控制UI，创建UI_HScrollBar类，并通过代码设定HScrollBar相关的属性。下述示例演示了如何通过代码创建HScrollBar，并通过一个Text组件显示滚动条的value值。开发者可以自己通过代码设置HScrollBar，创建出符合自己需要的HScrollBar。 示例代码： const { regClass, property } = Laya; @regClass() export class UI_HScrollBar extends Laya.Script { constructor() { super(); } // 文本组件，用于显示滚动条的value值 public text: Laya.Text; // 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { // 创建文本组件 this.text = new Laya.Text(); this.text.pos(300, 260); this.owner.addChild(this.text); // 滚动条皮肤资源 var skins: any[] = []; skins.push(\"atlas/comp/hscroll.png\", \"atlas/comp/hscroll$bar.png\", \"atlas/comp/hscroll$down.png\", \"atlas/comp/hscroll$up.png\"); Laya.loader.load(skins).then(() => { // 创建滚动条 var hs: Laya.HScrollBar = new Laya.HScrollBar(); hs.skin = \"atlas/comp/hscroll.png\"; hs.width = 300; hs.pos(300, 300); hs.min = 0; hs.max = 100; hs.changeHandler = new Laya.Handler(this, this.onChange); this.owner.addChild(hs); }); } private onChange(value: number): void { this.text.text = \"滚动条的位置： value=\" + value; } } 运行效果： （动图2-1） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-09-11 15:17:18 "},"IDE/uiEditor/uiComponent/VScrollBar/readme.html":{"url":"IDE/uiEditor/uiComponent/VScrollBar/readme.html","title":"垂直滚动条组件","keywords":"","body":"垂直滚动条组件（VScrollBar）一、通过LayaAir IDE创建VScrollBar组件1.1 创建VScrollBar1.2 VScrollBar属性1.3 脚本控制VScrollBar二、通过代码创建VScrollBar组件垂直滚动条组件（VScrollBar） 一、通过LayaAir IDE创建VScrollBar组件 VScrollBar 组件是一个垂直方向滚动条组件。当数据太多以至于显示区域无法容纳时，最终用户可以使用 VScrollBar 组件控制所显示的数据部分。VScrollBar 组件的脚本接口请参考 VScrollBar API。 1.1 创建VScrollBar 如图1-1所示，可以在层级窗口中右键进行创建，也可以从小部件窗口中拖拽添加。 （图1-1） 滚动条由四部分组成：一个轨道图、一个滑块按钮和两个箭头按钮。VScrollBar组件图像资源的命名要符合资源命名规则，LayaAir自带的资源示例如下所示： （图1-2）轨道图 （图1-3）滑块按钮 （图1-4）箭头按钮1 （图1-5）箭头按钮2 创建VScrollBar后的显示效果如下： （图1-6） 1.2 VScrollBar属性 VScrollBar的特有属性如下： （图1-7） 属性 功能说明 skin 滚动条轨道图的图像资源地址。 sizeGrid 滚动条轨道图资源的有效缩放网格数据（九宫格数据）。 max 表示滑块的最大滚动位置（滑块位于最高处时的value值）。 min 表示滑块的最小滚动位置（滑块位于最低处时的value值）。 scrollSize 点击按钮滚动量。每一次点击滚动条箭头按钮时，滚动条的值改变的量（滑块移动的量）。 value 滚动条当前进度值（滑块当前位置）。 mouseWheelEnable 是否开启鼠标滚轮滚动，默认值为true。该属性设置滚动对象target以后有效。 touchScrollEnable 是否开启触摸滚动，默认值为true。该属性设置滚动对象target以后有效。 hide 是否隐藏滚动条，默认为false。设为true后，不显示滚动条，但是可以正常滚动。 autoHide 是否自动隐藏滚动条，默认值为false。设为true后，无需滚动时隐藏滚动条，内容需要滚动时显示滚动条。 showButtons 是否显示箭头按钮，默认值为true。设为false后，箭头按钮将不显示。 rollRatio 滚动衰减系数，默认为0.97。 elasticDistance 橡皮筋效果极限距离，0为没有橡皮筋效果。 elasticBackTime 橡皮筋回弹时间，单位为毫秒。 下面展示一些滚动条属性设置的效果： 设置 VScrollBar 的属性 max 的值为 10、属性 min 的值为0、属性 value 的值为3后，显示效果如下： （图1-8） 在运行时，可以拖动滑块或点击箭头按钮控制滚动条的值。设置属性scrollSize为1，那么每次点击滚动条箭头按钮时，滚动条的值value就改变1，效果如下所示： （动图1-9） 设置mouseWheelEnable属性为true后，可以开启鼠标滚轮滚动。但是该属性必须设置滚动对象后才有效，这里的滚动对象以Panel为例，效果如动图1-10所示，通过鼠标滑轮控制垂直滚动条。 （动图1-10） 设置touchScrollEnable属性为true后，可以开启触摸滚动。该属性也必须设置滚动对象后才有效，如动图1-11所示，可以对Panel组件进行拖拽，垂直滚动条会跟着进行滚动。 （动图1-11） 设置hide属性为true后，不显示滚动条，但是可以正常滚动。效果如下动图所示： （动图1-12） 设置autoHide属性为true后，滚动条会自动隐藏。当操作内容进行滚动时，滚动条会显示出来，当停止滚动时，滚动条会自动隐藏。效果如下： （动图1-13） 设置rollRatio属性，数值越小，滚动的速度变化越小。动图1-14左图是rollRatio设置为1的效果，右图是rollRatio设置为0.1的效果，显然rollRatio的值越大，滚动速度越快。 （动图1-14） 垂直滚动条支持橡皮筋技术。动图1-15演示的是设置橡皮筋效果极限距离elasticDistance为200、橡皮筋回弹时间elasticBackTime为500毫秒的效果。 （动图1-15） 1.3 脚本控制VScrollBar 在Scene2D的属性设置面板中，增加一个自定义组件脚本。然后，将VScrollBar拖入到其暴露的属性入口中。需要添加如下的示例代码，实现脚本控制VScrollBar： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { @property({ type: Laya.VScrollBar }) public vscroll: Laya.VScrollBar; //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { this.vscroll.skin = \"atlas/comp/vscroll.png\";//滚动条皮肤 this.vscroll.width = 300;//滚动条的宽度 this.vscroll.pos(300, 300);//滚动条的位置 this.vscroll.min = 0;//滑块的最小滚动位置 this.vscroll.max = 10;//滑块的最大滚动位置 this.vscroll.scrollSize = 1;//点击按钮的滚动量 } } 二、通过代码创建VScrollBar组件 在进行书写代码的时候，免不了通过代码控制UI，创建UI_VScrollBar 类，并通过代码设定VScrollBar相关的属性。下述示例演示了如何通过代码创建VScrollBar，并通过一个Text组件显示滚动条的value值。开发者可以自己通过代码设置VScrollBar，创建出符合自己需要的VScrollBar。 示例代码： const { regClass, property } = Laya; @regClass() export class UI_VScrollBar extends Laya.Script { constructor() { super(); } // 文本组件，用于显示滚动条的value值 public text: Laya.Text; // 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { // 创建文本组件 this.text = new Laya.Text(); this.text.pos(300, 260); this.owner.addChild(this.text); // 滚动条皮肤资源 var skins: any[] = []; skins.push(\"atlas/comp/vscroll.png\", \"atlas/comp/vscroll$bar.png\", \"atlas/comp/vscroll$down.png\", \"atlas/comp/vscroll$up.png\"); Laya.loader.load(skins).then(() => { // 创建滚动条 var vs: Laya.VScrollBar = new Laya.VScrollBar(); vs.skin = \"atlas/comp/vscroll.png\"; vs.height = 300; vs.pos(300, 300); vs.min = 0; vs.max = 100; vs.changeHandler = new Laya.Handler(this, this.onChange); this.owner.addChild(vs); }); } private onChange(value: number): void { this.text.text = \"滚动条的位置： value=\" + value; } } 运行效果： （动图2-1） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-09-11 16:27:32 "},"IDE/uiEditor/uiComponent/slider/readme.html":{"url":"IDE/uiEditor/uiComponent/slider/readme.html","title":"滑动条组件","keywords":"","body":"划动条组件划动条组件 划动条组件包括水平滑动条与垂直滑动条两种 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-09-19 17:46:47 "},"IDE/uiEditor/uiComponent/HSlider/readme.html":{"url":"IDE/uiEditor/uiComponent/HSlider/readme.html","title":"水平滑动条组件","keywords":"","body":"水平滑动条组件（HSlider）一、通过LayaAir IDE创建HSlider组件1.1 创建HSlider1.2 HSlider属性1.3 脚本控制HSlider二、通过代码创建HSlider组件水平滑动条组件（HSlider） 一、通过LayaAir IDE创建HSlider组件 HSlider与VSlider组件都是Slider组件的子类，它们分别表示横向滑动条与纵向滑动条。用户可以通过在滑块轨道之间移动滑块来选择值。常用于如播放器进度控制、音量大小控制，一些UI上的数值调整等。HSlider的详细属性可查看API。 1.1 创建HSlider 如图1-1所示，可以在层级窗口中右键进行创建，也可以从小部件窗口中拖拽添加。 （图1-1） 滑动条可由两部分或三部分组成。如果是两部分，则包含底图资源hslider.png、滑块资源hslider$bar.png，如图1-2所示。资源至少应当有这两个，否则无法实现滑动功能。 （图1-2） 如果是三部分组成的滑动条，则包含滑块资源hslider$bar.png、进度条资源hslider$progress.png 、底图资源hslider.png，如图1-3所示。如果缺少了进度条资源组件也不会报错，只是不显示进度。 （图1-3） 进度条资源hslider$progress.png可以与底图资源hslider.png互换，互换后进度可以反向显示。 LayaAir默认创建的HSlider组件是由两部分组成的，如动图1-4所示，HSlider组件采用水平方向。滑块轨道从左向右扩展，鼠标拖动滑块会显示数值的标签。 （动图1-4） 1.2 HSlider属性 HSlider的特有属性如下： （图1-5） 属性 功能说明 max 滑块拖动到最右边时的值，默认数值为100 min 滑块拖动到最左边时的值，默认数值为0 showLabel 是否显示标签。默认为true，运行时拖动滑块会显示value值 showProgress 是否显示进度条。默认为false，如果存在进度条资源hslider$progress.png，则可以勾选该项 skin 滑动条的底图资源 sizeGrid 滑动条底图资源的有效缩放网格数据（九宫格数据） tick 滑动条刻度值的最小单位。每次拖动滑块value值改变的量，默认值为1 value 当前所在刻度，即滑块目前所处的数值，应当等于max或min，或是它们之间的值 allowClickBack 是否允许通过点击滑动条改变value值。默认为false，禁止通过点击滑动条改变value值，此时只有拖动滑块一种方式改变value值。为true时，可以通过点击滑动条目标区域，使滑块快速跳转到当前所在刻度，改变value值 设置HSlider的属性max的值为20、属性min的值为0、属性value的值为5后，显示效果如下： （图1-6） 设置属性showLabel为true、属性showProgress为true、属性tick值为3，效果如下动图所示： （动图1-7） 进度条资源hslider$progress.png可以与底图资源hslider.png互换，效果如下： （动图1-8） 1.3 脚本控制HSlider 在Scene2D的属性设置面板中，增加一个自定义组件脚本。然后，将HSlider拖入到其暴露的属性入口中。需要添加如下的示例代码，实现脚本控制HSlider： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { @property({ type: Laya.HSlider }) public hslider: Laya.HSlider; //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { this.hslider.pos(300, 300);//滑动条位置 this.hslider.skin = \"resources/hslider.png\";//滑动条底图皮肤 this.hslider.value = 0.5; this.hslider.max = 50; this.hslider.min = 0; this.hslider.tick = 1; this.hslider.showProgress = true;//必须存在hslider$progress.png资源，否则会报错 } } 二、通过代码创建HSlider组件 有时，需要用代码控制UI组件，创建UI_HSlider类，并通过代码设置HSlider。下述示例用代码创建了一个HSlider组件，并在控制台输出其value值。 示例代码： const { regClass, property } = Laya; @regClass() export class UI_HSlider extends Laya.Script { constructor() { super(); } onAwake(): void { let skins: any[] = []; skins.push(\"hslider.png\", \"hslider$bar.png\");//图片资源来自“引擎API使用示例” Laya.loader.load(skins, Laya.Handler.create(this, this.placeHSlider)); } private placeHSlider(): void { let hs: Laya.Slider = new Laya.HSlider(); hs.skin = \"hslider.png\"; hs.width = 300; hs.pos(50, 500); hs.min = 0; hs.max = 100; hs.value = 50; hs.tick = 1; hs.changeHandler = new Laya.Handler(this, this.onChange); this.owner.addChild(hs); } private onChange(value: number): void { console.log(\"滑块的位置：\" + value); } } 运行效果： （动图2-1） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-09-20 15:58:48 "},"IDE/uiEditor/uiComponent/VSlider/readme.html":{"url":"IDE/uiEditor/uiComponent/VSlider/readme.html","title":"垂直滑动条组件","keywords":"","body":"垂直滑动条组件（VSlider）一、通过LayaAir IDE创建VSlider组件1.1 创建VSlider1.2 VSlider属性1.3 脚本控制VSlider二、通过代码创建VSlider组件垂直滑动条组件（VSlider） 一、通过LayaAir IDE创建VSlider组件 HSlider与VSlider组件都是Slider组件的子类，它们分别表示横向滑动条与纵向滑动条。用户可以通过在滑块轨道之间移动滑块来选择值。常用于如播放器进度控制、音量大小控制，一些UI上的数值调整等。VSlider的详细属性可查看API。 1.1 创建VSlider 如图1-1所示，可以在层级窗口中右键进行创建，也可以从小部件窗口中拖拽添加。 （图1-1） 滑动条可由两部分或三部分组成。如果是两部分，则包含底图资源vslider.png、滑块资源vslider$bar.png，如图1-2所示。资源至少应当有这两个，否则无法实现滑动功能。 （图1-2） 如果是三部分组成的滑动条，则包含滑块资源vslider$bar.png、进度条资源vslider$progress.png 、底图资源vslider.png，如图1-3所示。如果缺少了进度条资源组件也不会报错，只是不显示进度。 （图1-3） 进度条资源vslider$progress.png可以与底图资源vslider.png互换，互换后进度可以反向显示。 LayaAir默认创建的VSlider组件是由两部分组成的，如动图1-4所示，VSlider组件采用纵向排列。滑块轨道从上向下扩展，鼠标拖动滑块会显示数值的标签。 （动图1-4） 1.2 VSlider属性 VSlider的特有属性如下： （图1-5） 属性 功能说明 max 滑块拖动到最下边时的值，默认数值为100 min 滑块拖动到最上边时的值，默认数值为0 showLabel 是否显示标签。默认为true，运行时拖动滑块会显示value值 showProgress 是否显示进度条。默认为false，如果存在进度条资源vslider$progress.png，则可以勾选该项 skin 滑动条的底图资源 skinGrid 滑动条底图资源的有效缩放网格数据（九宫格数据） tick 滑动条刻度值的最小单位。每次拖动滑块value值改变的量，默认值为1 value 当前所在刻度，即滑块目前所处的数值，应当等于max或min，或是它们之间的值 allowClickBack 是否允许通过点击滑动条改变value值。默认为false，禁止通过点击滑动条改变value值，此时只有拖动滑块一种方式改变value值。为true时，可以通过点击滑动条目标区域，使滑块快速跳转到当前所在刻度，改变value值 设置VSlider的属性max的值为20、属性min的值为0、属性value的值为5后，显示效果如下： （图1-6） 设置属性showLabel为true、属性showProgress为true、属性tick值为3，效果如下动图所示： （动图1-7） 进度条资源vslider$progress.png可以与底图资源vslider.png互换，效果如下： （动图1-8） 1.3 脚本控制VSlider 在Scene2D的属性设置面板中，增加一个自定义组件脚本。然后，将VSlider拖入到其暴露的属性入口中。需要添加如下的示例代码，实现脚本控制VSlider： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { @property({type:Laya.VSlider}) public vslider: Laya.VSlider; //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { this.vslider.pos(300,300);//滑动条位置 this.vslider.skin = \"resources/vslider.png\";//滑动条底图皮肤 this.vslider.value = 0.5; this.vslider.max = 50; this.vslider.min = 0; this.vslider.tick = 1; this.vslider.showProgress = true;//必须存在vslider$progress.png资源，否则会报错 } } 二、通过代码创建VSlider组件 有时，需要用代码控制UI组件，创建UI_VSlider类，并通过代码设置VSlider。下述示例用代码创建了一个VSlider组件，并在控制台输出其value值。 示例代码： const { regClass, property } = Laya; @regClass() export class UI_VSlider extends Laya.Script { constructor() { super(); } onAwake(): void { let skins: any[] = []; skins.push(\"vslider.png\", \"vslider$bar.png\");//图片资源来自“引擎API使用示例” Laya.loader.load(skins, Laya.Handler.create(this, this.placeVSlider)); } private placeVSlider(): void { let vs: Laya.Slider = new Laya.VSlider(); vs.skin = \"vslider.png\"; vs.height = 300; vs.pos(400, 50); vs.min = 0; vs.max = 100; vs.value = 50; vs.tick = 1; vs.changeHandler = new Laya.Handler(this, this.onChange); this.owner.addChild(vs); } private onChange(value: number): void { console.log(\"滑块的位置：\" + value); } } 运行效果： （动图2-1） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-09-19 17:44:34 "},"IDE/uiEditor/uiComponent/ProgressBar/readme.html":{"url":"IDE/uiEditor/uiComponent/ProgressBar/readme.html","title":"进度条组件","keywords":"","body":"进度条组件（ProgressBar）一、通过LayaAir IDE创建ProgressBar组件1.1 创建ProgressBar1.2 ProgressBar属性1.3 脚本控制ProgressBar二、通过代码创建ProgressBar进度条组件（ProgressBar） 一、通过LayaAir IDE创建ProgressBar组件 ProgressBar经常被用于显示游戏中某个操作的进度，例如加载资源的进度、角色经验或血量的进度。ProgressBar的脚本接口参考 API。 1.1 创建ProgressBar 如图1-1所示，可以在层级窗口中右键进行创建，也可以从小部件窗口中拖拽添加。 （图1-1） ProgressBar组件由两部分组成：底图progress.png和进度progress$bar.png，资源示例如图1-2所示。 （图1-2） LayaAir默认创建的ProgressBar组件效果如下图所示： （图1-3） 1.2 ProgressBar属性 ProgressBar的特有属性如下： （图1-4） 属性 功能说明 skin 进度条的底图资源 sizeGrid 进度条底图资源的有效缩放网格数据（九宫格数据） value 进度条的进度值，范围在0到1之间 设置ProgressBar组件的属性value的值为0.3后，显示效果如下所示： （图1-5） 1.3 脚本控制ProgressBar 有时，需要将加载过程等进度用进度条的方式展示出来，这就需要用脚本代码控制了。 在Scene2D的属性设置面板中，增加一个自定义组件脚本。然后，将ProgressBar拖入到其暴露的属性入口中。再添加一个Text组件，用于描述加载进度。需要添加如下的示例代码： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { @property({ type: Laya.ProgressBar }) public progressBar: Laya.ProgressBar; @property({ type: Laya.Text }) public loadText: Laya.Text; //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { this.progressBar.value = 0.01; //初始进度值 this.loadText.text = \"资源加载中……\"; // 测试加载效果 Laya.timer.loop(100, this, this.changeProgress); } //这里仅模拟加载演示效果 changeProgress(): void { this.progressBar.value += 0.05; //每次进度条的改变量 if (this.progressBar.value == 1) { this.loadText.text = \"资源加载完成\"; Laya.timer.clear(this, this.changeProgress); } } } 效果如下： （动图1-6） 二、通过代码创建ProgressBar 在进行项目开发的时候，免不了通过代码创建UI，创建UI_ProgressBar类，并通过代码设定ProgressBar相关的属性，示例代码如下： const { regClass, property } = Laya; @regClass() export class UI_ProgressBar extends Laya.Script { private progressBar: Laya.ProgressBar; constructor() { super(); } onAwake(): void { // 加载进度条资源，图片资源来自“引擎API使用示例” Laya.loader.load([\"resources/res/ui/progressBar.png\", \"resources/res/ui/progressBar$bar.png\"]).then(() => { // 创建进度条 this.progressBar = new Laya.ProgressBar(\"resources/res/ui/progressBar.png\"); this.progressBar.pos(100, 500); this.progressBar.width = 400; this.progressBar.sizeGrid = \"5,5,5,5\"; this.progressBar.changeHandler = new Laya.Handler(this, this.onChange); this.owner.addChild(this.progressBar); Laya.timer.loop(100, this, this.changeValue); }); } // 模拟进度条加载 private changeValue(): void { if (this.progressBar.value >= 1) this.progressBar.value = 0; this.progressBar.value += 0.05; } private onChange(value: number): void { // 控制台打印输出进度 console.log(\"进度：\" + Math.floor(value * 100) + \"%\"); } } 示例效果如下： （动图2-1） ProgressBar的其他属性也可以通过代码来设置，上述示例演示了如何通过代码创建ProgressBar，有兴趣的开发者可以自己通过代码设置ProgressBar，创建出符合自己需要的进度条。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-09-21 12:05:35 "},"IDE/uiEditor/uiComponent/Box/readme.html":{"url":"IDE/uiEditor/uiComponent/Box/readme.html","title":"容器组件","keywords":"","body":"容器组件（Box）一、什么是容器二、容器有哪些三、Box的属性四、Box与Sprite容器的使用差异容器组件（Box） Author : Charley 一、什么是容器 所谓容器，便是可以包容或装载物品的贮存器。 在LayaAir引擎里，是指本身并不独立使用，用于装载其它显示对象的组件。 不独立使用是常见的情况，某些情况下，容器也可以只用于填充背景色，但这种情况并非容器真正的作用。 例如，List容器组件，没有了其装载的渲染单元子组件，List本身就没有了意义。 又比如，单选框组，没有了单选框的子组件，那这个组本身也失去了意义。 所以，每一个容器主要的作用，都是为了包容或装载其它子组件才能发挥其独有的作用。 二、容器有哪些 容器组件的基类是Box，Box自身与继承自Box的组件，都属于容器。 开发者直接使用的容器对象一共有9个。如图2-1的黄字高亮部分所示。 (图2-1) 三、Box的属性 创建Box可以在层级窗口中右键进行创建，也可以从小部件窗口中拖拽添加。如下图所示： （图3-1） 由于Box继承于UI组件的基类UIComponent，所以父类的属性这里就不再重复介绍。 由于Box是个比较纯粹的容器对象，本身没有什么作用，其作用主要用于装载其它子节点。 如果说唯一可以独立使用的作用，那就是填充背景颜色。 在IDE里的操作，如图3-2所示，先勾选设置背景色状态选框，再点击取色器输入栏，然后在取色器窗口里拾取或输入颜色之后，关闭取色器窗口即可。 （图3-2） 四、Box与Sprite容器的使用差异 Sprite与Box都属于比较常用的基础容器。 由于Sprite更底层，所以对比之下，Sprite的性能消耗要更低于Box。 在没有海量使用的前提下，也没有太大的差距。但是性能至上的原则上，能使用Sprite的时候，当然优先使用Sprite。 那什么时候使用Box呢？ 由于Box属于UI组件，所有UI组件都有一个共同的特性，那就是相对布局与设置数据源。 对于容器，我们考虑是否使用Box，取决于是否有相对布局的需求。 如果有相对布局的需求，就使用Box作为容器，否则就使用Sprite。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2024-04-17 11:55:17 "},"IDE/uiEditor/uiComponent/HBox/readme.html":{"url":"IDE/uiEditor/uiComponent/HBox/readme.html","title":"水平布局容器组件","keywords":"","body":"水平布局容器组件（HBox）一、通过LayaAir IDE创建HBox组件1.1 创建HBox1.2 HBox属性1.3 脚本控制HBox二、通过代码创建HBox组件水平布局容器组件（HBox） HBox其本质是容器类组件，所有的容器类组件都继承自Box，HBox也不例外。HBox是常用于水平布局的容器组件，相较于Box它增加了更加细致的功能。 HBox的详细属性可以查看API。 一、通过LayaAir IDE创建HBox组件 1.1 创建HBox 通过IDE的可视化操作可以直接在层级面板对HBox进行创建，如图1-1所示，可以在层级窗口中右键进行创建，也可以从小部件窗口中拖拽添加。 （图1-1） 1.2 HBox属性 HBox的特有属性如下： （图1-2） 属性 功能 bgColor 背景颜色，勾选后可以直接输入颜色值，例如：#ffffff，也可以点击输入条右侧的拾色器选取颜色 space 子对象之间的水平间隔，以像素为单位。 align 布局元素的垂直对齐模式，共有四个选项。none：不进行垂直对齐，top：居顶垂直对齐，middle：居中垂直对齐，bottom：居底垂直对齐，默认为none。 space属性就是设置子对象之间的水平间隔，以像素为单位，可以自行输入数字，也可以通过鼠标左键长按滑动来输入数值。假设HBox有三个Button组件子对象，调节space属性的效果如动图1-3所示。 （动图1-3） HBox的子节点无论在IDE中怎样排列，在设置了align属性后都会变成相对应的垂直排序，如动图1-4所示。 （动图1-4） 1.3 脚本控制HBox 在Scene2D的属性设置面板中，增加一个自定义组件脚本。然后，将HBox拖入到其暴露的属性入口中，由于只有一个HBox无法查看效果，所以开发者可以在HBox下添加一些子节点。示例代码如下： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { @property({ type: Laya.HBox }) public hbox: Laya.HBox; //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { this.hbox.pos(100, 100); this.hbox.bgColor = \"#ffffff\"; this.hbox.space = 100; this.hbox.align = \"middle\"; } } 二、通过代码创建HBox组件 有时，需要用代码管理UI，创建UI_HBox类用于创建HBox组件。由于单独创建一个HBox组件的意义并不大，所以再创建三个Button组件用于演示效果。示例代码如下： const { regClass, property } = Laya; @regClass() export class UI_HBox extends Laya.Script { private hbox: Laya.HBox; private btn1: Laya.Button; private btn2: Laya.Button; private btn3: Laya.Button; // 按钮皮肤资源 private skins: string = \"atlas/comp/button.png\"; //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { Laya.loader.load(this.skins).then(() => { this.createBtn(); this.createHbox(); // 添加HBox组件 this.owner.addChild(this.hbox); }); } // 创建Button组件 private createBtn(): void { this.btn1 = new Laya.Button(this.skins); this.btn2 = new Laya.Button(this.skins); this.btn3 = new Laya.Button(this.skins); } // 创建HBox组件 private createHbox(): void { this.hbox = new Laya.HBox; this.hbox.pos(100, 100); this.hbox.size(600, 300); this.hbox.bgColor = \"#ffffff\"; this.hbox.addChild(this.btn1); this.hbox.addChild(this.btn2); this.hbox.addChild(this.btn3); this.hbox.space = 100; this.hbox.align = \"middle\"; } } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-09-22 17:43:15 "},"IDE/uiEditor/uiComponent/VBox/readme.html":{"url":"IDE/uiEditor/uiComponent/VBox/readme.html","title":"垂直布局容器组件","keywords":"","body":"垂直布局容器组件（VBox）一、通过LayaAir IDE创建VBox组件1.1 创建VBox1.2 VBox属性1.3 脚本控制VBox二、通过代码创建VBox垂直布局容器组件（VBox） VBox是容器类组件，继承自Box。VBox是用于垂直布局的容器组件，对比Box它增加了更为细致的功能。VBox的详细属性可以查看API。 一、通过LayaAir IDE创建VBox组件 1.1 创建VBox 通过IDE的可视化操作可以直接在层级面板对VBox进行创建，如图1-1所示，可以在层级窗口中右键进行创建，也可以从小部件窗口中拖拽添加。 （图1-1） 1.2 VBox属性 VBox的特有属性如下： （图1-2） 属性 功能 bgColor 背景颜色，勾选后可以直接输入颜色值，例如：#ffffff，也可以点击输入条右侧的拾色器选取颜色 space 子对象之间的垂直间隔，以像素为单位。 align 布局元素的水平对齐，共有四个选项。none：不进行水平对齐，left：居左水平对齐，center：居中水平对齐，right：居右水平对齐，默认为none。 space属性就是设置子对象之间的垂直间隔，以像素为单位，可以自行输入数字，也可以通过鼠标左键长按滑动来输入数值。假设VBox有三个Button组件子对象，调节space属性的效果如动图1-3所示。 （动图1-3） VBox的子节点无论在IDE中怎样排列，在设置了align属性后都会变成相对应的水平排序，如动图1-4所示。 （动图1-4） 1.3 脚本控制VBox 在Scene2D的属性设置面板中，增加一个自定义组件脚本。然后，将VBox拖入到其暴露的属性入口中，由于只有一个VBox无法查看效果，所以开发者可以在VBox下添加一些子节点。示例代码如下： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { @property({ type: Laya.VBox }) public vbox: Laya.VBox; //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { this.vbox.pos(100, 100); this.vbox.bgColor = \"#ffffff\"; this.vbox.space = 30; this.vbox.align = \"center\"; } } 二、通过代码创建VBox 有时，需要用代码管理UI，创建UI_VBox类用于创建VBox组件。由于单独创建一个VBox组件的意义并不大，所以再创建三个Button组件用于演示效果。示例代码如下： const { regClass, property } = Laya; @regClass() export class UI_VBox extends Laya.Script { private vbox: Laya.VBox; private btn1: Laya.Button; private btn2: Laya.Button; private btn3: Laya.Button; // 按钮皮肤资源 private skins: string = \"atlas/comp/button.png\"; //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { Laya.loader.load(this.skins).then(() => { this.createBtn(); this.createvbox(); // 添加VBox组件 this.owner.addChild(this.vbox); }); } // 创建Button组件 private createBtn(): void { this.btn1 = new Laya.Button(this.skins); this.btn2 = new Laya.Button(this.skins); this.btn3 = new Laya.Button(this.skins); } // 创建VBox组件 private createvbox(): void { this.vbox = new Laya.VBox; this.vbox.pos(100, 100); this.vbox.size(600, 300); this.vbox.bgColor = \"#ffffff\"; this.vbox.addChild(this.btn1); this.vbox.addChild(this.btn2); this.vbox.addChild(this.btn3); this.vbox.space = 80; this.vbox.align = \"center\"; } } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-09-22 21:47:34 "},"IDE/uiEditor/uiComponent/Panel/readme.html":{"url":"IDE/uiEditor/uiComponent/Panel/readme.html","title":"面板容器组件","keywords":"","body":"面板容器组件（Panel）一、通过LayaAir IDE创建Panel组件1.1 创建Panel1.2 Panel属性1.3 脚本控制Panel二、通过代码创建Panel组件面板容器组件（Panel） Panel是一个带有裁剪功能的面板容器类，常用来设置元素的显示区域。可以直接将要显示的元素添加到Panel容器中，Panel的宽高就是元素将要显示的宽高。Panel的详细属性可以查看API。 一、通过LayaAir IDE创建Panel组件 1.1 创建Panel 通过IDE的可视化操作可以直接在层级面板对Panel进行创建，如图1-1所示，可以在层级窗口中右键进行创建，也可以从小部件窗口中拖拽添加。 （图1-1） 给Panel设置宽高（例如：200*200）。然后给Panel组件添加子节点，放入一张图片（512*313）。显示效果以及层级结构如图1-2所示。 （图1-2） 由图1-2可以看出放入的图片被裁剪了，图片最终所显示的宽高就是Panel容器的宽高（200*200）。开发者可以直接调整图片的坐标改变其显示的内容。 1.2 Panel属性 Panel组件的特有属性如下： （图1-3） 属性 说明 bgColor 背景颜色，勾选后可以直接输入颜色值，例如：#ffffff，也可以点击输入条右侧的拾色器选取颜色 scrollType 滚动类型，选项有：无滚动、水平方向滚动、垂直方向滚动、水平与垂直都滚动。不同的滚动类型要设置对应的滚动条皮肤 vScrollBarSkin 垂直滚动条皮肤，默认不设置。滚动条皮肤资源要符合资源命名规则 hScrollBarSkin 水平滚动条皮肤，默认不设置。滚动条皮肤资源要符合资源命名规则 elasticEnabled 是否使用橡皮筋回弹效果，默认为false 对Panel组件设置滚动条，可以只设置垂直滚动条VScrollBarSkin，也可以只设置水平滚动条HScrollBarSkin，还可以两者都设置。 如果只设置垂直滚动条，则需要将ScrollType设置为垂直方向滚动；如果只设置水平滚动条，则需要将ScrollType设置为水平方向滚动；如果两者都设置，则需要将ScrollType设置为水平与垂直都滚动。 除List组件外，Panel是唯一一个可以设置滚动条的容器组件。对Panel设置水平与垂直都滚动的效果如下： （动图1-4） 开启橡皮筋回弹效果ElasticEnabled后，当滑块滚动到边界时，滑块会继续滚动一段距离，然后回弹。橡皮筋效果如动图1-5所示，这样可以增加滚动的流畅性和用户体验。 （动图1-5） 1.3 脚本控制Panel 在Scene2D的属性设置面板中，增加一个自定义组件脚本。然后，将Panel组件拖入到其暴露的属性入口中，由于只有一个Panel组件无法查看效果，所以开发者可以在Panel下添加一些子节点。需要添加如下的示例代码，实现脚本控制Panel： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { @property({ type: Laya.Panel }) public panel: Laya.Panel; //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { this.panel.pos(100, 100); this.panel.size(200, 200); this.panel.scrollType = Laya.ScrollType.Both; //滚动类型：水平与垂直都滚动 this.panel.vScrollBarSkin = \"atlas/comp/vscroll.png\"; this.panel.hScrollBarSkin = \"atlas/comp/hscroll.png\"; this.panel.elasticEnabled = true; //橡皮筋效果 } } 二、通过代码创建Panel组件 Panel组件除了可以直接在UI界面中可视化的操作之外，在代码中进行创建也是很简单的。创建UI_Panel类，实现代码创建Panel组件。示例代码如下： const { regClass, property } = Laya; @regClass() export class UI_Panel extends Laya.Script { constructor() { super(); } // 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { // 创建Panel组件 let panel: Laya.Panel = new Laya.Panel(); panel.hScrollBarSkin = \"atlas/comp/hscroll.png\"; panel.size(600, 275); panel.pos(150, 150); this.owner.addChild(panel); // 创建Image组件，作为Panel的子节点 let img: Laya.Image; for (var i: number = 0; i 效果如下动图所示： （动图2-1） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-09-23 15:55:24 "},"IDE/uiEditor/uiComponent/List/readme.html":{"url":"IDE/uiEditor/uiComponent/List/readme.html","title":"列表组件","keywords":"","body":"列表组件（List）一、通过LayaAir IDE创建List组件1.1 List的组成1.2 创建List1.3 List组件常用属性二、通过代码创建List组件列表组件（List） List组件可显示项目列表，默认为垂直方向列表。List的每一个列表通常是一样的，也可以使用编辑器自定义不同样式的列表内容项。List组件的脚本接口请参考List API。 一、通过LayaAir IDE创建List组件 1.1 List的组成 List通常由两个部分组成：列表渲染项（单元格）、滚动条。 列表渲染项可以是Box对象或其它自定义页面对象，也被称为子项模板（Item Template）。子项模板内可以放Label、Image等组件。 滚动条可以设置垂直滚动条或水平滚动条，还可以两者同时设置。 1.2 创建List 1.2.1 添加List组件 如图1-1所示，可以在层级窗口中右键进行创建，也可以从小部件窗口中拖拽添加。 （图1-1） 1.2.2 添加并指定List的列表项 此处以Box对象为例。如图1-2所示，在List组件下添加一个Box组件，并且调整好Box的大小。然后在Box下添加一个Label组件，命名为m_label，并设置一下Label的显示效果，使它更好看一些。 （图1-2） 再将创建好的Box节点拖入到List的Item Template属性中，如图1-3所示，这样就指定List的列表项为子节点Box了。 （图1-3） 1.2.3 添加滚动条皮肤 选择List属性的Scroll Type为垂直方向滚动。V Scroll Bar Skin属性用来设置垂直滚动条的皮肤，从资源面板里选择vscroll.png到该属性中，会立即生成滚动条皮肤。 （图1-4） 注意：当Scroll Type为无滚动时，即使设置了滚动条皮肤，在运行时也不会有滚动效果。 设置Repeat Y为6，表示当列表项超出6个时，会开始滚动。 （图1-5） 1.2.4 设置数据源 必须要在代码中给List组件设置数据源。 const { regClass, property } = Laya; @regClass() export class Script extends Laya.Script { @property({ type: Laya.List }) list: Laya.List constructor() { super(); } // 组件被启用后执行，例如节点被添加到舞台后 onEnable(): void { // 给List对象赋值 var data: Array = []; for (var m: number = 0; m 代码中，m_label的命名要与List列表项下的Label组件命名相同。 1.2.5 运行查看效果 将脚本挂载到Scene2D场景上，然后将List组件拖入到脚本暴露出来的属性即可，如图1-6所示。 （图1-6） 运行效果如下： （动图1-7） 1.2.6 设置List效果 还可以在1.2.4中的代码里添加代码，设置List组件的效果。例如，隐藏滚动条、设置拖拽的橡皮筋效果等。具体的属性请参考1.3节。 const { regClass, property } = Laya; @regClass() export class Script extends Laya.Script { @property({ type: Laya.List }) list: Laya.List constructor() { super(); } // 组件被启用后执行，例如节点被添加到舞台后 onEnable(): void { // 给List对象赋值 var data: Array = []; for (var m: number = 0; m 效果如下所示： （图1-8） 1.3 List组件常用属性 List的特有属性如下： （图1-9） 属性 功能说明 bgColor 背景颜色，勾选后可以直接输入颜色值，例如：#ffffff，也可以点击输入条右侧的拾色器选取颜色 itemTemplate 子项模板，是列表的渲染子项。该属性指定List下的任意子节点为子项模板，通常是Box repeatX 水平方向列表渲染单元的最大数量。当列表数据超出该值时，如果设置了水平滚动条，会显示水平滚动效果 repeatY 垂直方向列表渲染单元的最大数量。当列表数据超出该值时，如果设置了垂直滚动条，会显示垂直滚动效果 elasticEnabled 是否开启橡皮筋回弹效果，默认为false spaceX 水平方向显示的单元格之间的间距（以像素为单位） spaceY 垂直方向显示的单元格之间的间距（以像素为单位） scrollType 滚动类型，需要配合对应的滚动条皮肤使用。共有四种类型：none：无滚动（默认），horizontal：水平方向滚动，vertical：垂直方向滚动，both：水平与垂直都滚动 vScrollBarSkin 垂直方向滚动条皮肤 hScrollBarSkin 水平方向滚动条皮肤 selectEnable 是否可以选中。启用后，选中列表渲染单元，会显示选中后的自定义选项框效果 selectedIndex 当前列表中，选中的渲染单元的索引 disableStopScroll 禁用滚动条停止。用于控制array更新时是否停止滚动条，默认在更新数据时会停止滚动条。当通过滑动滚动条进行动态更新List的cell时，设置为true会让列表滚动的平滑流畅 二、通过代码创建List组件 在进行书写代码的时候，免不了通过代码控制UI，创建UI_List类，通过代码设定List相关的属性。 示例代码： const { regClass, property } = Laya; @regClass() export class UI_List extends Laya.Script { public _list: Laya.List; constructor() { super(); } onAwake(): void { var list: Laya.List = new Laya.List(); list.itemRender = Item; list.repeatX = 1; list.repeatY = 4; list.x = (Laya.stage.width - Item.WID) / 2; list.y = (Laya.stage.height - Item.HEI * list.repeatY) / 2; // 设置List的垂直滚动 list.scrollType = Laya.ScrollType.Vertical; // 设置List的垂直滚动皮肤，不设置或者\"\"就没有滚动条皮肤 list.vScrollBarSkin = \"\"; // 开启橡皮筋效果 list.elasticEnabled = true; // 设置橡皮筋回弹时间，单位为毫秒 list.scrollBar.elasticBackTime = 300; // 设置橡皮筋极限距离 list.scrollBar.elasticDistance = 50; // 设置是否可以选中 list.selectEnable = true; list.selectHandler = new Laya.Handler(this, this.onSelect); // 单元格渲染处理 list.renderHandler = new Laya.Handler(this, this.updateItem); this.owner.addChild(list); // 设置数据源为对应图片的路径 var data: any[] = []; for (var i: number = 0; i 运行效果： （图2-1） List的其他属性也可以通过代码来设置，有兴趣的读者可以自己通过代码设置List，创建出符合自己需要的列表。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-09-27 20:42:32 "},"IDE/uiEditor/uiComponent/Tree/readme.html":{"url":"IDE/uiEditor/uiComponent/Tree/readme.html","title":"树状列表组件","keywords":"","body":"树状列表组件（Tree）一、通过LayaAir IDE创建Tree组件1.1 Tree的组成1.2 创建 Tree 组件1.3 Tree 组件常用属性二、通过代码创建Tree组件树状列表组件（Tree） 一、通过LayaAir IDE创建Tree组件 Tree 组件用来显示树状结构。用户可以查看排列为可扩展树的层次结构数据。Tree 组件的脚本接口请参考 Tree API。 1.1 Tree的组成 1.1.1 Tree 组件主要由两个部分组成： 1.项单元格（可以是 Box、自定义页面） 项单元格通常由四部分组成： （1）一个单元格选择状态切片动画 Clip； （2）一个折叠箭头切片动画 Clip ； （3）一个文件状态切片动画 Clip ； （4）单元格其他内容元素； 2.纵向滚动条 VScrollBar 1.1.2 Tree 组件的图像资源示例 单元格选择状态切片动画 Clip 资源（clip_selectBox.png）： 切片数为2，切片索引从0开始依次代表：单元格悬停状态图（白色）、单元格未选中状态图。 （图1-1） 折叠箭头切片动画 Clip 资源（clip_tree_arrow.png）： 切片数为2，切片索引从0开始依次代表：文件夹节点折叠状态图、文件夹节点展开状态图。 （图1-2） 文件状态切片动画 Clip 资源（clip_tree_folder.png）： 切片数为3，切片索引从0开始依次代表：文件夹节点折叠状态图、文件夹节点展开状态图、非文件夹节点状态图； （图1-3） 1.2 创建 Tree 组件 1.2.1 编辑 Tree 组件的列表项 （1）首先在Scence2D中创建一个Clip组件，设置此Clip 组件对象的 name 属性值为 selectBox，设置属性 ClipY 的值为2，然后从项目资源面板里将一个单元格选择状态的切片动画（ clip_selectBox.png），拖入刚刚创建的Clip组件的Skin属性中，如图1-4所示。 注意：此处的选择状态切片动画 （Clip 组件）对象的 name 属性值必须设置为 selectBox，只有这样程序才能识别它，并实现此 Clip 组件对象的显示状态跟随单元项的选择状态而改变的功能，否则此 Clip 对象将会被识别为此单元项的普通显示对象。 （图1-4） （2）在Scence2D中创建一个Clip组件，设置此Clip 组件对象的 name 属性值为 arrow，设置属性 ClipY 的值为2，然后从项目资源面板里将一个单元格的折叠箭头切片动画（clip_tree_arrow.png），拖入刚刚创建的Clip组件的Skin属性中，如图1-5所示。 注意：此处的折叠箭头切片动画 （Clip 组件）的 name 属性值必须设置为 arrow，只有这样程序才能识别它，并实现点击此 Clip 对象打开或折叠树形节点的功能。否则此 Clip 对象将会被识别为此单元项的普通显示对象。 （图1-5） （3）在Scence2D中创建一个Clip组件，设置此Clip 组件对象的 name 属性值为 folder，设置属性 ClipY 的值为 3，然后从项目资源面板里将一个单元格的文件状态切片动画（clip_tree_folder.png），拖入刚刚创建的Clip组件的Skin属性中，如图1-6所示。 注意：此处的文件状态切片动画（Clip 组件）的 name 属性值必须设置为 folder，只有这样程序才能识别它，并实现此 Clip 组件对象的显示状态跟随单元项的折叠、展开、节点类型（是否有子节点）而改变的功能。否则此 Clip 对象将会被识别为此单元项的普通显示对象。 （图1-6） （4）拖入此单元项的普通显示对象。此处以 Label 为例，从资源面板里选择并拖入一个 Label 组件对象，在此给这个 Label 对象设置一下属性 name 值为 label （注意“l”是小写），方便在脚本中对它进行赋值。再设置一下 Label 对象显示相关的属性，使它看起来更美观。 注意：此name 属性值自定义即可（但要与给 Tree 对象赋值中的名称相同）。 （图1-7） 然后，将（1）~（4）步骤创建的节点，拖入一个Box容器组件，并将它们进行合理的排版，如图1-8所示。 （图1-8） 1.2.2 指定 Tree 组件的列表渲染项 创建一个Tree组件，设置Tree组件的Item Template属性为刚刚1.2.1创建Box，如图1-9所示。 （图1-9） 1.2.3 为 Tree 组件添加滚动条 当Tree的列表项太多时，就需要添加一个滚动条。如图1-10所示，给Tree组件属性scrollBarSkin添加滚动条皮肤。 （图1-10） 这里还设置了背景颜色等属性，属性的详细说明见1.3节。 1.2.4 在代码里给 Tree 对象赋值 在Scene2D的属性设置面板中，增加一个自定义组件脚本。然后将Tree节点拖入到其暴露的属性入口中，在代码里给 Tree 对象赋值的示例如下： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { @property({ type: Laya.Tree }) public tree: Laya.Tree; //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { //初始化树状列表的数据源 let treeData: string = \"\"; //给Tree列表赋值 treeData += \"\" + \"\" + \"\" + \"\" + \"\" + \"\" + \"\" + \"\" + \"\" + \"\" + \"\" + \"\" + \"\" + \"\" + \"\" + \"\" + \"\" + \"\" + \"\" + \"\" + \"\" ; //数据源data标签，需要拼接一个结束标签 treeData += \"\"; //把字符串解析为xml对象并返回 this.tree.xml = new Laya.XML(treeData); } } 这里给Tree列表赋的值，是写死的模拟数据。其中，拼接模拟数据，最多只能是二层结构，不支持层级很深的结构。 上述代码中，标签为一个文件夹，表示一个文件。isOpen='true'表示文件夹的初始状态是否为打开。label='XXX'是对1.2.1中步骤（4）的label组件进行赋值。 注：开发者可以参考第二节的代码中，程序创建的模拟数据的部分，加深理解xml数据规则。 1.2.5 在IDE中运行查看效果 运行的效果如下： （动图1-11） 可以看到，显示选择状态切片跟随单元项的选择状态而改变、折叠箭头切片跟随打开或折叠树形节点而改变、文件状态切片跟随单元项的折叠或展开而改变。 1.3 Tree 组件常用属性 Tree组件的特有属性如下图： （图1-12） 属性 功能说明 bgColor 背景颜色，勾选后可以直接输入颜色值，例如：#ffffff，也可以点击输入条右侧的拾色器选取颜色。 itemTemplate 渲染单元，具体用法已在1.2节的步骤中给出。 scrollBarSkin 滚动条皮肤。 selectedIndex 当前选择的项索引。-1表示初始状态下无选取项。 spaceBottom 每一项之间的间隔距离。单位是像素。 spaceLeft 子项的左侧缩进距离。单位是像素。 keepstatus 数据源发生变化后，是否保持之前打开状态，默认为true。true：保持之前打开状态。false：不保持之前打开状态。 二、通过代码创建Tree组件 开发者在进行书写代码的时候，免不了通过代码控制UI。在LayaAir IDE中，创建自定义的组件脚本，命名为UI_Tree，然后通过代码设定Tree相关的属性。 运行示例效果： （动图2-1） 示例代码： const { regClass, property } = Laya; @regClass() export class UI_Tree extends Laya.Script { constructor() { super(); } // 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { var res: any[] = [\"atlas/comp/vscroll.png\", \"atlas/comp/vscroll$bar.png\", \"atlas/comp/vscroll$down.png\", \"atlas/comp/vscroll$up.png\", \"resources/tree/clip_selectBox.png\", \"resources/tree/clip_tree_folder.png\", \"resources/tree/clip_tree_arrow.png\"]; Laya.loader.load(res).then(() => { this.onLoadComplete(); }); } private onLoadComplete(e: any = null): void { // 初始化树状列表的数据源 var treeData: string = \"\"; //程序创建的模拟数据，模拟树状列表数据，拼接列表的数据源 for (let i: number = 0; i \"; for (let j: number = 0; j \"; } //每一个子项的外层，要有一个完整的结束标签，目录开始用什么标签名就用什么标签名结束。 treeData += \"\"; } //数据源data标签，需要拼接一个结束标签 treeData += \"\"; var tree: Laya.Tree = new Laya.Tree(); tree.scrollBarSkin = \"atlas/comp/vscroll.png\"; // 添加列表渲染项 tree.itemRender = Item; // 解析tree的数据 tree.xml = new Laya.XML(treeData); tree.size(300, 300); tree.x = (Laya.stage.width - tree.width) / 2; tree.y = (Laya.stage.height - tree.height) / 2; tree.bgColor = \"#d25454\"; this.owner.addChild(tree); } } class Item extends Laya.Box { constructor() { super(); this.right = 0; this.left = 0; var selectBox: Laya.Clip = new Laya.Clip(\"resources/tree/clip_selectBox.png\", 1, 2); selectBox.name = \"selectBox\";//设置 selectBox 的name 为“selectBox”时，将被识别为树结构的项的背景。 selectBox.height = 32; selectBox.x = 13; selectBox.left = 12; this.addChild(selectBox); var folder: Laya.Clip = new Laya.Clip(\"resources/tree/clip_tree_folder.png\", 1, 3); folder.name = \"folder\";//设置 folder 的name 为“folder”时，将被识别为树结构的文件夹开启状态图表。 folder.x = 14; folder.y = 4; this.addChild(folder); var label: Laya.Label = new Laya.Label; label.name = \"title\";//设置 label 的name 为“title”时，此值将用于树结构数据赋值。 label.fontSize = 20; label.color = \"#FFFFFF\"; label.padding = \"6,0,0,13\"; label.width = 150; label.height = 30; label.x = 33; label.y = 1; label.left = 33; label.right = 0; this.addChild(label); var arrow: Laya.Clip = new Laya.Clip(\"resources/tree/clip_tree_arrow.png\", 1, 2); arrow.name = \"arrow\";//设置 arrow 的name 为“arrow”时，将被识别为树结构的文件夹开启状态图表。 arrow.x = 0; arrow.y = 5; this.addChild(arrow); } } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-08-28 19:46:00 "},"IDE/uiEditor/uiComponent/optionBox/readme.html":{"url":"IDE/uiEditor/uiComponent/optionBox/readme.html","title":"选项框","keywords":"","body":"选项框选项框 常见的选项框包括下拉选项框、单选框、单选框组、多选框。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:53 "},"IDE/uiEditor/uiComponent/ComboBox/readme.html":{"url":"IDE/uiEditor/uiComponent/ComboBox/readme.html","title":"下拉选项框组件","keywords":"","body":"下拉选项框组件（ComboBox）一、通过LayaAir IDE创建ComboBox组件1.1 创建ComboBox1.2 ComboBox属性1.3 脚本控制ComboBox二、通过代码创建ComboBox组件下拉选项框组件（ComboBox） 一、通过LayaAir IDE创建ComboBox组件 ComboBox是一个下拉选项框组件。ComboBox的脚本请接口参考ComboBox API。 1.1 创建ComboBox 如图1-1所示，点击选择小部件面板里的ComboBox组件，拖放到页面编辑区，或者在层级窗口中通过右键创建，即可添加ComboBox组件到页面上。 （图1-1） ComboBox组件的图像资源示例如下图所示： （图1-2） ComboBox组件由下拉按钮（图1-3上部分1）和下拉选项（图1-3下部分2）构成，运行时点击下拉按钮会弹出下拉选项，在属性设置中这两项是分别进行设置的。 （图1-3） 1.2 ComboBox属性 ComboBox的特有属性如下： （图1-4） 属性 功能说明 skin 组件的图像资源 sizeGrid 组件图像资源的有效缩放网格数据（九宫格数据） stateNum 下拉按钮的状态值 labels 组件的标签文本内容集合字符串，以逗号分隔（英文输入法） labelFont 下拉按钮中，文本的字体 labelSize 下拉按钮中，字体的大小 labelBold 下拉按钮中，文本是否粗体显示 labelColors 下拉按钮中，各状态下的文本颜色值集合。UP：鼠标在元素释放时（抬起移开）；OVER：鼠标移动到元素之上时；DOWN：鼠标按下时 labelPadding 下拉按钮中，文本的边距。U：上边距；R：右边距；D：下边距；L：左边距 itemSize 下拉选项内，字体的大小 itemHeight 下拉选项内，选项框的高度 itemPadding 下拉选项内，文本的边距。U：上边距；R：右边距；D：下边距；L：左边距 itemColors 下拉选项内，可以设置三部分的颜色。背景颜色，UP：鼠标在元素释放时（抬起移开）；OVER：鼠标移动到元素之上时。标签颜色，UP：鼠标在元素释放时（抬起移开）；OVER：鼠标移动到元素之上时。边框颜色，只有一种状态颜色 visibleNum 下拉选项的列表内，可显示的最大行数（最多选项数） scrollType 下拉选项列表的滚动类型，只可以设置：无滚动、垂直方向滚动 scrollBarSkin 下拉选项列表的滚动条图像资源，只可以设置垂直滚动条皮肤 selectedIndex 表示当前选择的项的索引 selectedLablel 按照标签文本labels，设置下拉列表默认选项值，即下拉按钮显示的选项 defaultLablel 未设置下拉列表选项值时（selectedIndex为-1），在下拉按钮显示框中用于提示的文本 其中，labelFont、labelSize、labelBold、labelColors、labelPadding属性为下拉按钮的属性，itemSize、itemHeight、itemPadding、itemColors、visibleNum、scrollType、scrollBarSkin属性为下拉选项相关属性。 使用默认的skin属性，设置stateNum为3，labels属性设置为“item0,item1,item2,item3,item4,item5,item6,item7,item8”。再将selectedIndex设置为0后，selectedLablel会变为item0，效果如图1-5所示。 （图1-5） 由于设置了visibleNum为6，所以最多展示6个选项。 接下来设置下拉选项相关属性，如图1-6所示，设置下拉选项中字体大小为30，选项框的高度为50，设置下拉选项的文本边距为合适大小。itemColors属性保持默认，开发者可以对应观察，其中item1选项为OVER状态。再增加一个垂直滚动条，用于显示item6,item7,item8。 （图1-6） 然后设置下拉按钮相关属性，如动图1-7所示，设置下拉按钮中字体大小为50，仿宋字体并加粗显示。labelColors保持默认，labelPadding设置为合适大小。 （动图1-7） 1.3 脚本控制ComboBox 在Scene2D的属性设置面板中，增加一个自定义组件脚本。然后，将ComboBox拖入到其暴露的属性入口中。需要添加如下的示例代码，实现脚本控制ComboBox： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { @property({ type: Laya.ComboBox }) public combobox: Laya.ComboBox; //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { this.combobox.pos(100, 100); this.combobox.labels = \"item0,item1,item2,item3,item4,item5,item6,item7\"; this.combobox.labelColors = \"#32556b,#32cc6b,#ff0000\"; this.combobox.itemHeight = 60; // itemColors格式：\"悬停或被选中时背景颜色,悬停或被选中时标签颜色,标签颜色,边框颜色,背景颜色\" this.combobox.itemColors = \"#5e95b6,#ffffff,#000000,#ff0000,#ffffff\"; this.combobox.selectedIndex = 1; this.combobox.scrollBarSkin = \"atlas/comp/vscroll.png\"; } } 二、通过代码创建ComboBox组件 在进行书写代码的时候，免不了通过代码控制UI，创建UI_ComboBox类，通过代码设定ComboBox相关的属性。下述示例演示了如何通过代码设置下拉选项，并通过点击获取到选项。 运行示例效果： （动图2-1） 示例代码： const { regClass, property } = Laya; @regClass() export class UI_ComboBox extends Laya.Script { private skin: string = \"resources/res/ui/combobox.png\";//资源来自“引擎API使用示例” pageWidth: number; constructor() { super(); } // 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { Laya.loader.load(this.skin).then(() => { let ComboBox: Laya.ComboBox = new Laya.ComboBox(this.skin, \"item0,item1,item2,item3,item4,item5\"); ComboBox.labelSize = 30; ComboBox.itemSize = 25 this.owner.addChild(ComboBox); ComboBox.autoSize = true; ComboBox.pos(200, 200); }); } } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-10-08 16:38:54 "},"IDE/uiEditor/uiComponent/Radio/readme.html":{"url":"IDE/uiEditor/uiComponent/Radio/readme.html","title":"单选框组件","keywords":"","body":"单选框组件（Radio）一、通过LayaAir IDE创建Radio组件1.1 创建Radio1.2 Radio属性1.3 脚本控制Radio二、通过代码创建Radio组件单选框组件（Radio） Radio继承自Button，它的很多属性也继承自Button，所以前面Button中介绍过的这里就不再过多讲述。Radio的详细用法可以参考Radio API。 一、通过LayaAir IDE创建Radio组件 1.1 创建Radio 使用LayaAir IDE创建Radio非常简单，通过IDE的可视化操作，就可以实现组件的创建与布局，也是推荐使用的组件创建方式。可以从层级面板右键进行创建，也可以选择小部件面板里的Radio组件，拖拽进行添加，如图1-1所示。 （图1-1） 1.2 Radio属性 Radio组件的特有属性如下： （图1-2） 属性 功能说明 stateNum 单选框皮肤的状态数，支持单态（1）、两态（2）和三态（3） selected 单选框是否为选中状态，默认为false。设置为true后，单选框会一直保持选中（持续选中）的状态，而不会再对其它状态产生变化（除非在代码中进行状态改变） skin 单选框的皮肤纹理资源。设置后需要根据皮肤资源设置stateNum皮肤状态数 sizeGrid 位图的有效缩放网格数据（九宫格信息）：上边距、右边距、下边距、左边距、是否重复填充 label 单选框的文本标签 labelFont 文本标签的字体 labelSize 文本标签的字体大小 labelBold 文本标签是否加粗，默认为false labelColors 鼠标在元素释放时（up）、鼠标移动到元素时（over），鼠标按下时（down）各个状态下的文本标签颜色 labelAlign 文本标签的水平对齐模式：left、center、right，默认为居左对齐 labelVAlign 文本标签的垂直对齐模型：top、middle、bottom，默认为居顶对齐 labelPadding 文本标签的边距。格式：上边距、右边距、下边距、左边距 labelStroke 文本标签的描边宽度，以像素为单位。默认值为0，表示不描边 labelStrokeColor 文本标签描边的颜色，以字符串表示，默认值为#000000（黑色） strokecolors 勾选后，可以根据状态设置文本的描边颜色。分三种状态进行设置：鼠标在元素释放时（up）、鼠标移动到元素时（over），鼠标按下时（down），三种状态可以设置不同的描边颜色 Radio继承于Button，是一个单选框组件。相对于按钮组件，单选框组件的特性是，点中之后不会恢复状态，如动图1-3所示。 （动图1-3） 其余属性与Button相同，开发者可以根据按钮组件的文档进行理解。 1.3 脚本控制Radio 在Scene2D的属性设置面板中，增加一个自定义组件脚本。然后，将Radio组件拖入到其暴露的属性入口中。需要添加如下的示例代码，实现脚本控制Radio： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { @property({ type: Laya.Radio }) public radio: Laya.Radio; //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { this.radio.skin = \"atlas/comp/radio.png\"; //皮肤 this.radio.stateNum = 3; //皮肤状态 this.radio.label = \"确定\"; //文本标签 this.radio.labelFont = \"宋体\"; //文本标签字体 this.radio.labelSize = 20; //文本标签字体大小 this.radio.labelBold = true; //文本标签加粗 this.radio.labelVAlign = \"middle\"; //文本标签垂直居中对齐 this.radio.labelStroke = 3; //文本标签字体描边宽度 this.radio.labelStrokeColor = \"#ffffff\"; //描边颜色 this.radio.strokeColors = \"#000000, #c6ff00, #001aff\"; //各状态下的描边颜色 this.radio.labelColors = \"#0100ff, #16fa0e, #ff0000\"; //各状态下的文本颜色 // this.radio.selected = true; //是否选中 } } 二、通过代码创建Radio组件 在进行书写代码的时候，免不了通过代码控制UI，创建UI_Radio类，并通过代码设定Radio相关的属性。下述示例演示了如何通过代码创建一个Radio组件并设置其属性。 示例代码如下： const { regClass, property } = Laya; @regClass() export class UI_Radio extends Laya.Script { constructor() { super(); } // 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { let radio: Laya.Radio = new Laya.Radio(); radio.pos(200, 200); radio.size(160, 64); radio.stateNum = 3; radio.selected = false; radio.skin = \"atlas/comp/radio.png\"; radio.label = \"LayaAir\"; radio.labelSize = 20; radio.labelBold = true; radio.labelVAlign = \"top\"; this.owner.addChild(radio); } } 效果如动图2-1所示： （动图2-1） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-10-10 10:51:44 "},"IDE/uiEditor/uiComponent/RadioGroup/readme.html":{"url":"IDE/uiEditor/uiComponent/RadioGroup/readme.html","title":"单选框组组件","keywords":"","body":"单选框组组件（RadioGroup）一、通过LayaAir IDE创建RadioGroup组件1.1 创建RadioGroup1.2 RadioGroup属性1.3 脚本控制RadioGroup二、创建自定义的RadioGroup组件2.1 准备美术资源2.2 在IDE中创建Radio组件2.3 转换成RadioGroup容器三、通过代码创建RadioGroup单选框组组件（RadioGroup） RadioGroup是单选框按钮组，按钮组之内的组件选项互相排斥，用户每次只能选择一个单选框（Radio）组件，如动图1所示。 （动图1） Radio与RadioGroup不同的是，Radio是一个单选框，而RadioGroup可以通过修改labels属性来增加单选框。RadioGroup组件的详细用法可以参考RadioGroup API。 一、通过LayaAir IDE创建RadioGroup组件 1.1 创建RadioGroup 如图1-1所示，点击选择小部件面板里的RadioGroup组件，拖放到页面编辑区，或者在层级窗口中通过右键创建，即可添加RadioGroup组件到页面上。 （图1-1） RadioGroup组件的默认皮肤资源如下图所示： （图1-2） RadioGroup组件的皮肤无法使用九宫格属性，所以要在资源设计的时候就确定好实际应用时的大小。 1.2 RadioGroup属性 RadioGroup的特有属性如下： （图1-3） 属性 功能说明 bgColor 单选框组背景颜色，勾选后可以直接输入颜色值，例如：#ffffff，也可以点击输入条右侧的拾色器选取颜色 skin 单选框的皮肤纹理资源。设置后需要根据皮肤资源设置stateNum皮肤状态数 stateNum 单选框皮肤的状态数，支持单态（1）、两态（2）和三态（3） labels 单选框组的文本标签集合。可根据文本标签数量，确定单选框组中单选框的数量 space 单选框之间的间隔，以像素为单位 direction 单选框的排列方向。有vertical（垂直排列）和horizontal（水平排列）两种 selectedIndex 选择索引，默认为-1。设置后，单选框会保持选中状态。索引数量会根据labels数量（单选框数量）动态改变 labelFont 文本标签的字体 labelSize 文本标签的字体大小 labelBold 文本标签是否加粗，默认为false labelColors 鼠标在元素释放时（up）、鼠标移动到元素时（over），鼠标按下时（down）各个状态下的文本标签颜色 labelStroke 文本标签的描边宽度，以像素为单位。默认值为0，表示不描边 labelStrokeColor 文本标签描边的颜色，以字符串表示，默认值为#000000（黑色） labelAlign 文本标签的水平对齐模式：left、center、right，默认为居左对齐 labelPadding 文本标签的边距。格式：上边距、右边距、下边距、左边距 strokecolors 勾选后，可以根据状态设置文本的描边颜色。分三种状态进行设置：鼠标在元素释放时（up）、鼠标移动到元素时（over），鼠标按下时（down），三种状态可以设置不同的描边颜色 可通过设置labels属性增加单选框个数，如动图1-4中所示，默认的单选框组中只有两个单选框。如想增加单选框，只需在labels属性中增加新的标签即可，且修改文本标签的内容也在该属性中设置。 （动图1-4） 还可以改变单选框组RadioGroup的布局方向与间距，RadioGroup默认是水平布局（horizontal），通过更改direction属性，实现垂直布局（vertical）。设置间距可以通过space属性实现，如图1-5所示。 （图1-5） 设置单选框组RadioGroup默认选择的选项，需要通过selectedIndex属性设置。该属性改变单选框组的索引值，默认设置为-1时，不选择任何选项框。设置为0是第1个单选框，1是第2个单选框……以此类推。假设将属性值设置为1时，效果如图1-6所示。 （图1-6） 1.3 脚本控制RadioGroup 在Scene2D的属性设置面板中，增加一个自定义组件脚本。然后，将RadioGroup拖入到其暴露的属性入口中。需要添加如下的示例代码，实现脚本控制RadioGroup： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { @property({ type: Laya.RadioGroup }) public radiogroup: Laya.RadioGroup; //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { this.radiogroup.pos(100, 100); this.radiogroup.labels = \"label0,label1,label2\"; this.radiogroup.space = 20; this.radiogroup.selectedIndex = 0; this.radiogroup.direction = \"vertical\"; } } 二、创建自定义的RadioGroup组件 上一小节，使用了同一种单选框资源，在RadioGroup中通过设置labels生成了三个单选框。然而在实际的游戏中，在同一个RadioGroup组件中对单选框样式有不同的需求，那么通过labels设置的方式是无法完成这个需求的。这个时候就需要使用自定义RadioGroup组件的方式。下面是具体步骤： 2.1 准备美术资源 用三张不同的Raido单选框美术资源，组成自定义的RadioGroup组件，资源如图2-1所示。 （图2-1） Tips： 这里要特别注意一下皮肤图片的命名规则，在自定义的RadioGroup组件中，不能使用RadioGroup或RadioGroup_为前缀命名。因为要使用Radio单选框组件来作为它的子项组件，所以本例中的图片资源命名使用radio_为前缀。 2.2 在IDE中创建Radio组件 将资源拷贝到项目的资源文件夹下，然后在IDE中，将Radio组件逐个拖拽到场景编辑器，从左到右（或从上到下）。再将每个Radio组件的name属性，按先后顺序依次修改成“item0、item1、item2.....”（若不按此规则增加名字属性，生成的RadioGroup组件为无效组件，不能正常运行）。 当设置完各个Radio组件的皮肤、文本、大小、位置等属性后，效果如图2-2所示。 （图2-2） 2.3 转换成RadioGroup容器 当修改好子项属性后，全选子组件，右键单击调出设置面板，点击转换为容器->RadioGroup，最终转换成RadioGroup容器类型，步骤如动图2-3所示。 （动图2-3） 转换成功后，如图2-4所示，需要保证RadioGroup的skin属性值为空。这样，在同一个RadioGroup组件中的三个单选框样式都不同了。 （图2-4） 开发者还可以调节RadioGroup组件的属性，最终效果如下动图所示： （动图2-5） 三、通过代码创建RadioGroup 在进行书写代码的时候，免不了通过代码控制UI，创建UI_RadioGroup类，通过代码设定RadioGroup相关的属性。示例代码如下： const { regClass, property } = Laya; @regClass() export class UI_RadioGroup extends Laya.Script { private SPACING: number = 150; private X_OFFSET: number = 200; private Y_OFFSET: number = 80; private skins: any[]; constructor() { super(); } // 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { this.skins = [\"resources/res/ui/radioButton (1).png\", \"resources/res/ui/radioButton (2).png\", \"resources/res/ui/radioButton (3).png\"]; Laya.loader.load(this.skins).then(() => { this.onLoadComplete(); }); } private onLoadComplete(e: any = null): void { for (let i: number = 0; i 效果如图所示： （图3-1） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-10-12 18:00:17 "},"IDE/uiEditor/uiComponent/CheckBox/readme.html":{"url":"IDE/uiEditor/uiComponent/CheckBox/readme.html","title":"多选框组件","keywords":"","body":"多选框组件（CheckBox）一、通过LayaAir IDE创建CheckBox组件1.1 创建CheckBox1.2 CheckBox属性1.3 脚本控制CheckBox二、代码创建CheckBox多选框组件（CheckBox） CheckBox是多选框组件，继承自Button。它由两部分组成，选择状态框及内容说明标签。其中选择状态框是图片资源，内容说明标签为文本。CheckBox组件的属性接口介绍请参考CheckBox API。 一、通过LayaAir IDE创建CheckBox组件 1.1 创建CheckBox 如图1-1所示，点击选择小部件面板里的CheckBox组件，拖放到页面编辑区，或者在层级窗口中通过右键创建，即可添加CheckBox组件到页面上。 （图1-1） CheckBox组件的选择状态框是图片资源，通常是三态或两态的图片资源。默认皮肤资源如下图所示： （图1-2） 1.2 CheckBox属性 CheckBox的特有属性如下： （图1-3） 属性名 功能说明 toggle 按下时是否切换组件的显示状态。为true时，可以通过点击切换显示状态。为false时，点击后会直接恢复初始状态。该属性一般不要改成false，否则永远都选不中 stateNum 选择框的皮肤状态数，支持两态和三态，多选框默认为三态。如果多选框美术资源改为两态，需设置状态值为2，正常情况下多选框至少应当有2个状态。特殊情况下，也可以使用单态 selected 多选框是否为选中状态，默认为false。设置为true后，多选框的初始状态会变为保持选中的状态 skin 选择框的图像资源，设置后需要根据皮肤资源设置stateNum皮肤状态数 sizeGrid 九宫格在CheckBox组件中无效，多选框的实际大小需在制作美术资源时就设置好 label 多选框的文本标签 labelFont 文本标签的字体 labelSize 文本标签的字体大小 labelBold 文本标签是否为粗体，默认为false labelColors 鼠标在鼠标移出（up）、鼠标悬停（over），鼠标按下（down）时，各个状态下的文本标签颜色 labelAlign 文本标签的水平对齐模式：left、center、right，默认为居左对齐 labelVAlign 文本标签的垂直对齐模式：top、middle、bottom，默认为居顶对齐 labelPadding 文本标签的边距。格式：上边距、右边距、下边距、左边距 labelStroke 文本标签的描边宽度，以像素为单位。默认值为0，表示不描边 labelStrokeColor 文本标签描边的颜色，以字符串表示，默认值为#000000（黑色） strokeColors 勾选后，可以根据状态设置文本的描边颜色。分三种状态进行设置：鼠标移出（up）、鼠标悬停（over），鼠标按下（down），三种状态可以设置不同的描边颜色 相对于单选框组件，多选框组件的特点是，选中之后可以恢复状态，如动图1-4所示。 （动图1-4） 其余属性与Button相同，开发者可以根据按钮组件的文档进行理解。 1.3 脚本控制CheckBox 在Scene2D的属性设置面板中，增加一个自定义组件脚本。然后，将CheckBox组件拖入到其暴露的属性入口中。需要添加如下的示例代码，实现脚本控制CheckBox： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { @property({ type: Laya.CheckBox }) public checkbox: Laya.CheckBox; //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { this.checkbox.pos(300, 300); // this.checkbox.selected = true; this.checkbox.label = \"多选框\"; this.checkbox.labelBold = true; this.checkbox.labelSize = 30; this.checkbox.labelColors = \"#0100ff, #16fa0e, #ff0000\"; //各状态下的文本颜色 this.checkbox.labelStroke = 3; this.checkbox.strokeColors = \"#000000, #c6ff00, #001aff\"; //各状态下的描边颜色 } } 二、代码创建CheckBox 在进行书写代码的时候，免不了通过代码控制UI，创建UI_CheckBox类，并通过代码设定CheckBox相关的属性。下述示例演示了如何通过代码创建一个CheckBox组件并设置其属性。 示例代码如下： const { regClass, property } = Laya; @regClass() export class UI_CheckBox extends Laya.Script { private COL_AMOUNT: number = 2; private ROW_AMOUNT: number = 3; private HORIZONTAL_SPACING: number = 200; private VERTICAL_SPACING: number = 100; private X_OFFSET: number = 100; private Y_OFFSET: number = 50; // 图片资源来自“引擎API使用示例” private skins: any[] = [ \"resources/res/ui/checkbox (1).png\", \"resources/res/ui/checkbox (2).png\", \"resources/res/ui/checkbox (3).png\", \"resources/res/ui/checkbox (4).png\", \"resources/res/ui/checkbox (5).png\", \"resources/res/ui/checkbox (6).png\" ]; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { Laya.loader.load(this.skins).then(() => { this.onCheckBoxSkinLoaded(); }); } private onCheckBoxSkinLoaded(e: any = null): void { let cb: Laya.CheckBox; for (let i: number = 0; i 运行效果如下动图所示： （动图2-1） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-10-19 16:25:36 "},"IDE/uiEditor/uiComponent/navigationMenu/readme.html":{"url":"IDE/uiEditor/uiComponent/navigationMenu/readme.html","title":"导航菜单组件","keywords":"","body":"导航菜单组件导航标签组组件导航容器组件导航菜单组件 导航菜单是由两个容器组件构成，分别是导航标签组组件与导航容器组件。 导航标签组组件 导航容器组件 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:53 "},"IDE/uiEditor/uiComponent/Tab/readme.html":{"url":"IDE/uiEditor/uiComponent/Tab/readme.html","title":"导航标签组组件","keywords":"","body":"导航标签组组件（Tab）一、通过LayaAir IDE创建Tab组件1.1 创建Tab1.2 Tab属性1.3 脚本控制Tab二、通过代码创建Tab组件导航标签组组件（Tab） Tab是导航标签组组件，用于定义选项卡按钮组，例如多页面切换显示，效果如动图1所示。Tab的详细属性可以参考Tab API。 （动图1） 一、通过LayaAir IDE创建Tab组件 1.1 创建Tab 使用LayaAir IDE创建Tab非常简单，通过IDE的可视化操作，就可以实现组件的创建与布局，也是推荐使用的组件创建方式。可以从层级面板右键进行创建，也可以选择小部件面板里的Tab组件，拖拽进行添加，如图1-1所示。 （图1-1） Tab组件的皮肤一般是竖向等分的两态图或三态图，默认的皮肤资源是三态的，如图1-2所示。 （图1-2） 注意：Tab组件的皮肤无法使用九宫格属性，所以要在资源设计的时候就确定好实际应用时的大小。 1.2 Tab属性 Tab组件的特有属性如下： （图1-3） 属性 说明 bgColor 背景颜色，勾选后可以直接输入颜色值，例如：#ffffff，也可以点击输入条右侧的拾色器选取颜色 skin 组件的皮肤纹理资源。设置后需要根据皮肤资源设置stateNum皮肤状态数 stateNum 组件皮肤的状态数，支持单态（1）、两态（2）和三态（3） labels 文本标签集合，以逗号分隔（英文输入法）。可根据文本标签数量，确定导航标签组中标签的数量 space 各标签之间的间隔，以像素为单位 direction 导航标签的排列方向。有vertical（垂直排列）和horizontal（水平排列）两种 selectedIndex 选择索引，默认为0。设置后，导航标签会保持选中状态。索引数量会根据labels数量（标签数量）动态改变 labelFont 文本标签的字体 labelSize 文本标签的字体大小 labelBold 文本标签是否加粗，默认为false labelColors 鼠标在鼠标移出（up）、鼠标悬停（over），鼠标按下（down）时，各个状态下的文本标签颜色 labelStroke 文本标签的描边宽度，以像素为单位。默认值为0，表示不描边 labelStrokeColor 文本标签描边的颜色，以字符串表示，默认值为#ffffff（白色） labelAlign 文本标签的水平对齐模式：left、center、right labelPadding 文本标签的边距。格式：上边距、右边距、下边距、左边距 strokeColors 勾选后，可以根据状态设置文本的描边颜色。分三种状态进行设置：鼠标移出（up）、鼠标悬停（over），鼠标按下（down），三种状态可以设置不同的描边颜色 Tab组件可以通过labels增加标签，如动图1-4中所示，默认的Tab组件中只有两个标签。如果想增加标签，只需在labels属性中增加即可，且修改标签中的文本内容也在该属性中设置。 （动图1-4） 改变Tab组件的布局方向与间距，可通过更改direction属性进行设置。默认是水平布局（horizontal），垂直布局是vertical。设置标签之间的间距可以通过space属性实现。操作如动图1-5所示。 （动图1-5） 设置Tab的默认选项可以通过selectedIndex属性实现。selectedIndex属性是用于改变Tab组件的索引值，默认不设置时，不选择任何选项，0为第1个标签，1为第2个标签……以此类推。效果如动图1-6所示。 （动图1-6） 1.3 脚本控制Tab 在Scene2D的属性设置面板中，增加一个自定义组件脚本。然后，将Tab组件拖入到其暴露的属性入口中。需要添加如下的示例代码，实现脚本控制Tab： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { @property({ type: Laya.Tab }) public tab: Laya.Tab; //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { this.tab.pos(200, 200); this.tab.labelBold = true; this.tab.labelSize = 20; this.tab.labelStrokeColor = \"#000000\"; this.tab.labels = \"Tab 1,Tab 2,Tab 3\"; this.tab.labelColors = \"#32556b,#8FB299,#ff0000\"; this.tab.selectedIndex = -1; } } 二、通过代码创建Tab组件 在进行书写代码的时候，免不了通过代码控制UI，创建UI_Tab类，并通过代码设定Tab相关的属性。下述示例演示了如何通过代码创建一个Tab组件并设置其属性。 示例代码如下： const { regClass, property } = Laya; @regClass() export class UI_Tab extends Laya.Script { // 图片资源来自“引擎API使用示例” private skins: any[] = [\"resources/res/ui/tab1.png\", \"resources/res/ui/tab2.png\"]; constructor() { super(); } // 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { Laya.loader.load(this.skins).then( ()=>{ this.onLoadComplete(); } ); } private onLoadComplete(e: any = null): void { let tabA: Laya.Tab = this.createTab(this.skins[0]); tabA.pos(40, 120); tabA.labelColors = \"#000000,#d3d3d3,#333333\"; let tabB: Laya.Tab = this.createTab(this.skins[1]); tabB.pos(40, 220); tabB.labelColors = \"#FFFFFF,#8FB299,#FFFFFF\"; } private createTab(skin: string): Laya.Tab { let tab: Laya.Tab = new Laya.Tab(); tab.skin = skin; tab.labelBold = true; tab.labelSize = 20; tab.labelStrokeColor = \"#000000\"; tab.labels = \"Tab Control 1,Tab Control 2,Tab Control 3\"; tab.selectedIndex = 1; this.onSelect(tab.selectedIndex); tab.selectHandler = new Laya.Handler(this, this.onSelect); this.owner.addChild(tab); return tab; } private onSelect(index: number): void { console.log(\"当前选择的标签页索引为 \" + index); } } 运行效果如下动图所示： （动图2-1） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-10-20 20:33:41 "},"IDE/uiEditor/uiComponent/ViewStack/readme.html":{"url":"IDE/uiEditor/uiComponent/ViewStack/readme.html","title":"导航容器组件","keywords":"","body":"导航容器组件（ViewStack）1. 创建ViewStack1.1 准备美术资源1.2 创建页面1.3 设置ViewStack组件子页面的name属性1.4 设置ViewStack的页面索引selectedIndex1.5 创建控制用的Tab标签1.6 通过代码控制ViewStack组件切换显示2. ViewStack属性导航容器组件（ViewStack） 本篇中会涉及一些Tab组件知识，请先阅读Tab组件的文档。 ViewStack组件是导航容器组件，主要用于多页面视图切换。它包含多个子页面，但默认只显示一个，可以通过子页面索引进行显示切换。一般情况下，用它与Tab标签组合制作标签切换页面，效果如动图1所示。ViewStack组件的详细用法请查看ViewStack API。 （动图1） 1. 创建ViewStack 1.1 准备美术资源 准备好页面背景图以及需要切换的页面美术资源，如图1-1所示，放到LayaAir IDE的项目目录中。 （图1-1） 图中资源来自“2D入门示例”。 然后设置背景的九宫格属性，如图1-2所示。 （图1-2） 1.2 创建页面 如图1-3所示，将刚刚设置过九宫格的背景图拖拽到场景中，然后创建子节点ViewStack页面，再将页面中涉及的UI基础组件拖拽到ViewStack组件下，作为其子页面，并调整页面的UI布局。 （图1-3） ViewStack组件是容器类组件，没有独立的组件资源规范。本例中直接采用的是Image组件资源，在实际的游戏开发中，可以根据实际开发需求使用各种UI组件。 1.3 设置ViewStack组件子页面的name属性 ViewStack子页面name属性的命名规则为item0、item1、item2.....”如果有更多页面以此类推，如图1-4所示。 （图1-4） 若不按此规则增加name属性，生成的ViewStack组件为无效组件，不能正常运行。 1.4 设置ViewStack的页面索引selectedIndex ViewStack组件默认显示item0，可以通过调整selectedIndex属性值来改变ViewStack组件的默认显示页面，效果如动图1-5所示。 （动图1-5） 1.5 创建控制用的Tab标签 通常，ViewStack组件需要一个相应的控制标签，创建一个Tab标签来控制ViewStack的子页面切换显示。 点击选择资源面板里的Tab资源，拖拽到场景中生成Tab组件。然后，调整位置与背景图适配对齐。设置labels为“页面0,页面1,页面2”，选择的按钮索引selectedIndex设置为0。最后设置字体大小、粗体、字体状态颜色等属性。设置之后的显示效果如图1-6所示： （图1-6） 1.6 通过代码控制ViewStack组件切换显示 创建Tab后，需要通过程序代码把Tab标签和ViewStack的子页面切换显示关联起来。 在Scene2D的属性设置面板中，增加一个自定义组件脚本。然后，将ViewStack和Tab组件拖入到其暴露的属性入口中。需要添加如下的示例代码： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { @property({ type: Laya.ViewStack }) public viewstack: Laya.ViewStack; @property({ type: Laya.Tab }) public tab: Laya.Tab; //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { //点击Tab选择按钮的处理 this.tab.selectHandler = new Laya.Handler(this, this.onSelecte); } // 根据选择tab的索引切换页面 private onSelecte(index: number): void { //切换ViewStack子页面 this.viewstack.selectedIndex = index; } } 最终的效果如动图1-7所示： （动图1-7） 2. ViewStack属性 ViewStack的特有属性如下： （图2-1） 属性 说明 bgColor 背景颜色，勾选后可以直接输入颜色值，例如：#ffffff，也可以点击输入条右侧的拾色器选取颜色 selectedIndex 选择索引，默认为0，表示第一项。-1表示没有选中的子项。索引数量会根据子项数量（item数量）动态改变 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-10-24 20:27:16 "},"IDE/uiEditor/uiComponent/ColorPicker/readme.html":{"url":"IDE/uiEditor/uiComponent/ColorPicker/readme.html","title":"取色器组件","keywords":"","body":"取色器组件（ColorPicker）一、通过LayaAir IDE创建ColorPicker1.1 创建ColorPicker1.2 ColorPicker属性二、通过代码创建ColorPicker取色器组件（ColorPicker） ColorPicker继承自UIComponent，ColorPicker组件将显示包含多个颜色样本的列表，用户可以从中选择颜色。ColorPicker的详细用法可以参考ColorPicker API。 一、通过LayaAir IDE创建ColorPicker 1.1 创建ColorPicker 如图1-1所示，点击选择小部件面板里的ColorPicker组件，拖放到页面编辑区，或者在层级窗口中通过右键创建，即可添加ColorPicker组件到页面上。 （图1-1） 1.2 ColorPicker属性 ColorPicker的特有属性如下： （图1-2） 属性 功能 bgColor 取色器面板背景颜色 borderColor 取色器面板边框颜色 inputBgColor 取色器面板文本框的背景颜色 inputColor 取色器面板文本框中，文本字体的颜色 selectedColor ColorPicker当前所选择的颜色 skin 组件的皮肤纹理资源，运行时会根据选取的颜色而发生变化 ColorPicker组件在拿到颜色值后，就可以在项目里进行赋值，在IDE的可视化操作下非常的简单，点击所需要调整的颜色，在颜色面板中自行选择即可。 二、通过代码创建ColorPicker 在进行书写代码的时候，免不了通过代码控制UI，创建UI_ColorPicker类，通过代码设定ColorPicker相关的属性。示例代码如下： const { regClass, property } = Laya; @regClass() export class UI_ColorPicker extends Laya.Script { private skin: string = \"atlas/comp/colorPicker.png\"; constructor() { super(); } // 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { Laya.loader.load(this.skin).then( ()=>{ this.onColorPickerSkinLoaded(); } ); } private onColorPickerSkinLoaded(e: any = null): void { let colorPicker: Laya.ColorPicker = new Laya.ColorPicker(); colorPicker.selectedColor = \"#ff0033\"; colorPicker.skin = this.skin; colorPicker.pos(100, 100); colorPicker.changeHandler = new Laya.Handler(this, this.onChangeColor, [colorPicker]); this.owner.addChild(colorPicker); this.onChangeColor(colorPicker); } private onChangeColor(colorPicker: Laya.ColorPicker, e: any = null): void { console.log(colorPicker.selectedColor); } } 运行效果如下动图所示： （动图2-1） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-11-29 17:33:41 "},"IDE/uiEditor/uiComponent/OpenDataContextView/readme.html":{"url":"IDE/uiEditor/uiComponent/OpenDataContextView/readme.html","title":"开放数据域组件","keywords":"","body":"开放数据域（OpenDataContextView）1. LayaAir IDE中创建OpenDataContextView2. 代码创建OpenDataContextView3. 作用与效果开放数据域（OpenDataContextView） 1. LayaAir IDE中创建OpenDataContextView 如图1-1所示，可以在层级窗口中右键进行创建，也可以从小部件窗口中拖拽添加。 （图1-1） 将OpenDataContextView组件添加到场景编辑的视图区后，属性面板中OpenDataContextView组件的专属属性如下图所示： （图1-2） 它只有FPS一个属性，表示sharedCanvas（主域和开放数据域都可以访问的一个离屏画布，详见这里）更新到主域的帧率。 除了在IDE中，还可以用脚本代码调节它的属性，在Scene2D的属性设置面板中，增加一个自定义组件脚本。然后，将OpenDataContextView拖入到其暴露的属性入口中。下面给出一个示例代码，实现脚本控制OpenDataContextView： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { //declare owner : Laya.Sprite3D; @property({ type: Laya.OpenDataContextView }) public opendata: Laya.OpenDataContextView; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { this.opendata.pos(100,100); this.opendata.size(500,500); } } 2. 代码创建OpenDataContextView 有时，不想让OpenDataContextView一开始就在舞台上，这就要通过代码来创建了。在Scene2D的属性设置面板中，增加一个自定义组件脚本，示例代码如下： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { //declare owner : Laya.Sprite3D; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { let opendata = new Laya.OpenDataContextView(); Laya.stage.addChild(opendata); opendata.pos(100,100); opendata.size(500,500); } } 3. 作用与效果 开放数据域一般用来显示好友排行榜，需要发布为微信小游戏，然后用微信开发者工具才能看到效果。详细的流程请参考《微信小游戏》。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-06-28 19:14:30 "},"IDE/uiEditor/Dialog/readme.html":{"url":"IDE/uiEditor/Dialog/readme.html","title":"弹窗视图组件","keywords":"","body":"弹窗视图组件（Dialog）一、通过LayaAir IDE创建Dialog1.1 创建Dialog1.2 Dialog属性介绍1.3 脚本控制Dialog二、通过代码创建Dialog弹窗视图组件（Dialog） Dialog是弹窗视图组件，主要用于弹窗面板。 一、通过LayaAir IDE创建Dialog 1.1 创建Dialog 如图1-1所示，点击选择小部件面板里的Dialog组件，拖放到页面编辑区，或者在层级窗口中通过右键创建，即可添加Dialog组件到页面上。 （图1-1） 1.2 Dialog属性介绍 Dialog的特有属性如下： （图1-2） 属性 功能 autoDestoryAtClosed 场景被关闭后，是否自动销毁（销毁节点和使用到的资源），默认为false dragArea 拖动区域（格式：x,y,width,height），默认值为\"0,0,0,0\" isModal 是否是模式窗口，默认为false。为模式窗口时，点击弹窗空白处，可自动关闭该弹窗 isShowEffect 是否显示弹出效果，默认为开启状态。为false时无弹出效果，直接显示弹窗 isPopupCenter 指定对话框是否居中弹出，默认为true。为false时，会以左上角的坐标原点弹出 group 设置资源的分组标识，设置后可以按组来加载或清理资源 在设置dragArea属性后，可以在设置的数值范围内对Dialog进行拖动。将其设置为\"0,0,100,100\"，效果如动图1-3所示，红色区域为可拖拽区域。在设置后只可以在设置的数值内拖动，在超出数值内的区域拖动是无效的。 （动图1-3） 1.3 脚本控制Dialog 1.3.1 创建弹窗 Dialog的弹窗效果需要将它作为根节点使用。可以在项目资源面板创建一个2D预制体Prefab2D，如图1-4所示。 （图1-4） 双击Prefab2D进入编辑界面。右键单击根节点，选择“转换节点类型”，选择UI->Dialog即可，如动图1-5所示。 （动图1-5） 然后，在预制体的编辑界面就可以制作弹窗页面了，制作的效果如图1-6所示。 （图1-6） 图中的UI图片资源来自“2D入门示例”。 1.3.2 设置关闭按钮 在弹窗页面中，有一个关闭按钮（closeBtn），需要添加脚本实现关闭页面的逻辑。如动图1-7所示，勾选closeBtn的定义变量选项，然后双击Prefab2D的“UI运行时”，创建UI组件脚本。 （动图1-7） 保存场景后，在RuntimeScript.ts中添加如下代码： const { regClass } = Laya; import { RuntimeScriptBase } from \"./RuntimeScript.generated\"; @regClass() export class RuntimeScript extends RuntimeScriptBase { onAwake(): void { this.closeBtn.on(Laya.Event.CLICK, this, () => { this.close(); }); } } 1.3.3 关联场景 设置好弹窗之后，需要用代码将Dialog与所需要用到该Dialog的场景管关联起来。回到初始场景Scene，在Scene2D的属性设置面板中，增加一个自定义组件脚本。添加如下代码，实现鼠标点击后，弹出Dialog页面： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { //鼠标点击后执行 onMouseClick(): void { //使用Prefab，需要转换根节点为Dialog Laya.loader.load(\"resources/Prefab2D.lh\").then(res => { let dlg: Laya.Dialog = res.create(); dlg.show(); }); } } 运行效果如下： （动图） 二、通过代码创建Dialog 在进行书写代码的时候，免不了通过代码控制UI，创建UI_Dialog类，通过代码设定Dialog相关的属性。示例代码如下： const { regClass, property } = Laya; @regClass() export class UI_Dialog extends Laya.Script { private DIALOG_WIDTH: number = 220; private DIALOG_HEIGHT: number = 275; private CLOSE_BTN_WIDTH: number = 43; private CLOSE_BTN_PADDING: number = 5; private assets: any[]; private dialog: Laya.Dialog; constructor() { super(); } // 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { // 图片资源来自“引擎API使用示例” this.assets = [\"resources/res/ui/dialog (1).png\", \"resources/res/ui/close.png\"]; Laya.loader.load(this.assets).then( ()=>{ this.onSkinLoadComplete(); } ); } private onSkinLoadComplete(e: any = null): void { this.dialog = new Laya.Dialog(); let bg: Laya.Image = new Laya.Image(this.assets[0]); this.dialog.addChild(bg); let button: Laya.Button = new Laya.Button(this.assets[1]); button.name = Laya.Dialog.CLOSE; button.pos(this.DIALOG_WIDTH - this.CLOSE_BTN_WIDTH - this.CLOSE_BTN_PADDING, this.CLOSE_BTN_PADDING); this.dialog.addChild(button); this.dialog.dragArea = \"0,0,\" + this.DIALOG_WIDTH + \",\" + this.DIALOG_HEIGHT; this.dialog.show(); } onDestroy(): void { if (this.dialog) { this.dialog.close(); } } } 效果如下动图所示： （动图2-1） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-11-29 17:33:41 "},"IDE/uiEditor/uiComponent/skeleton/readme.html":{"url":"IDE/uiEditor/uiComponent/skeleton/readme.html","title":"骨骼动画","keywords":"","body":"骨骼动画骨骼动画 LayaAir引擎的骨骼动画包括两大类， 一种是将第三方的骨骼（龙骨与Spine）转换为引擎内置的骨骼动画文件格式。 另一种是直接封装Spine的骨骼动画动行库。 内置的骨骼动画性能更佳，但受转换工具的版本限制，仅支持3.8以前的spine版本。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:53 "},"IDE/uiEditor/uiComponent/skeleton/spine/readme.html":{"url":"IDE/uiEditor/uiComponent/skeleton/spine/readme.html","title":"Spine骨骼动画","keywords":"","body":"Spine骨骼动画一、概述二、IDE中使用Spine动画2.1 将spine资源复制到项目中2.2 在场景中添加spine动画组件2.3 设置动画资源2.4 IDE中预览动画2.5 动画基础操作三、代码中Spine动画Spine骨骼动画 一、概述 Spine骨骼动画，是游戏中经常使用的骨骼动画之一，使用Spine工具通过将图片绑定到骨骼上，然后再控制骨骼实现动画。 如何制作Spine骨骼动图，在这里就不介绍了，感兴趣的开发者可以到 Spine 官网查看。http://zh.esotericsoftware.com/ LayaAir IDE中支持Spine骨骼动画的添加，预览和运行。使用之前，需要在 IDE 中勾选类库，和选择 Spine 的版本 （图1-1） 1，勾选 laya.ani 类库 2，勾选 laya.spine 类库 3，选择此项目使用的 Spine 版本 目前LayaAir 支持 3.7，3.8和4.0版本，接下来我们会通过使用3.8版本的Spine动画来讲解IDE中的使用 二、IDE中使用Spine动画 2.1 将spine资源复制到项目中 如图2-1所示，我们将做好的Spine动画资源放入 assets 目录下，这里我们用Spine官网下载的示例展示 （图2-1） 2.2 在场景中添加spine动画组件 IDE中通过两种方式，可以在场景中添加Spine动画组件 1，直接拖入Spine动画组件，如动图2-2所示 （动图2-2） 2，通过Scene2D或者任何节点下，创建Spine动画组件，如动图2-3所示 （动图2-3） 此时 Spine 动画组件就准备好了，下一步可以拖入动画资源了 2.3 设置动画资源 我们先来看看Spine动画组件，都有什么属性，如图2-4所示 （图2-4） Source：spine动画的配置文件，也就是 .skel 文件 Skin Name：骨骼动画名称 Animation Name：播放动画名称 Loop：是否循环播放 Preview：在IDE中预览 首先，我们把 .skel 文件拖入 Source 属性中，在IDE中将会看到动画，如动图2-5所示 （动图2-5） 2.4 IDE中预览动画 通过勾选Preview选项，我们就可以在IDE中直接预览Spine动画效果，如动图2-6所示 （动图2-6） 同时，勾选Loop可以设置是否循环动画，也可以选择动画名字来切换动画 2.5 动画基础操作 在IDE中，可以对动画的位置，大小，缩放进行基础操作，如动图2-7所示 （动图2-7） 三、代码中Spine动画 在代码中使用时，我们在使用Spine时需要引用指定的类有Laya.SpineSkeleton、Laya.SpineTemplet 其中，Laya.SpineSkeleton是spine骨骼动画必须要引用的类，这里封装了spine的runtime库。Laya.SpineTemplet是用于资源处理。 代码示例： const { regClass, property } = Laya; @regClass() export class Main extends Laya.Script { private skeleton: Laya.SpineSkeleton; private index: number = -1; onStart() { console.log(\"Game start\"); //加载Spine动画资源 Laya.loader.load(\"spine/spineboy-pma.skel\", Laya.Loader.SPINE).then((templet: Laya.SpineTemplet) => { //创建SpineSkeleton对象 this.skeleton = new Laya.SpineSkeleton(); this.skeleton.templet = templet; this.owner.addChild(this.skeleton); this.skeleton.pos( Laya.stage.width / 2, Laya.stage.height / 2 + 100); this.skeleton.scale(0.4, 0.4); this.skeleton.on(Laya.Event.STOPPED, this, this.play); this.play(); }); } //播放Spine动画 private play(): void { if (++this.index >= this.skeleton.getAnimNum()) { this.index = 0 } this.skeleton.play(this.index, false, true) } } 具体效果大家可以在LayaAir 2D入门示例中查看。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:54 "},"IDE/uiEditor/uiComponent/skeleton/sk/readme.html":{"url":"IDE/uiEditor/uiComponent/skeleton/sk/readme.html","title":"内置骨骼动画","keywords":"","body":"内置骨骼动画一、概述二、IDE中使用内置骨骼动画2.1 将动画资源复制到项目中2.2 在场景中添加内置骨骼动画组件2.3 设置动画资源2.4 IDE中预览动画2.5 动画基础操作三、代码中内置骨骼动画内置骨骼动画 一、概述 Spine骨骼动画，DragonBones（龙骨）骨骼动画，都是游戏中经常使用的骨骼动画，使用LayaAir内置骨骼转换工具，可以将这两种格式转换为LayaAir引擎支持的骨骼动画格式。 LayaAir IDE中支持骨骼动画的添加，预览和运行。使用之前，需要在 IDE 中勾选 laya.ani 类库，如图1-1所示 （图1-1） 二、IDE中使用内置骨骼动画 2.1 将动画资源复制到项目中 如图2-1所示，我们将做好的动画资源放入 assets 目录下 （图2-1） 2.2 在场景中添加内置骨骼动画组件 IDE中通过两种方式，可以在场景中添加内置骨骼动画组件 1，直接拖入骨骼动画组件，如动图2-2所示 （动图2-2） 2，通过Scene2D或者任何节点下，创建骨骼动画组件，如动图2-3所示 （动图2-3） 此时骨骼动画组件就准备好了，下一步可以拖入动画资源了 2.3 设置动画资源 我们先来看看骨骼动画组件，都有什么属性，如图2-4所示 （图2-4） Source：骨骼动画的配置文件，也就是 .sk 文件 Skin Name：骨骼动画名称 Animation Name：播放动画名称 Loop：是否循环播放 Preview：在IDE中预览 首先，我们把 .sk 文件拖入 Source 属性中，在IDE中将会看到动画，如动图2-5所示 （动图2-5） 2.4 IDE中预览动画 通过勾选Preview选项，我们就可以在IDE中直接预览骨骼动画效果，如动图2-6所示 （动图2-6） 同时，勾选Loop可以设置是否循环动画，也可以选择动画名字来切换动画 2.5 动画基础操作 在IDE中，可以对动画的位置，大小，缩放进行基础操作，如动图2-7所示 （动图2-7） 三、代码中内置骨骼动画 在代码中使用时，我们在使用骨骼动画时需要引用指定 Laya.Skeleton 和 Laya.Templet 类 其中，Laya.Skeleton 是骨骼动画必须要引用的类，Laya.Templet 是用于处理资源 代码示例： const { regClass, property } = Laya; @regClass() export class Main extends Laya.Script { private mCurrIndex: number = 0; private mArmature: Laya.Skeleton; onStart() { console.log(\"Game start\"); //加载内置骨骼动画资源 Laya.loader.load(\"skeleton/Dragon/Dragon.sk\").then((templet: Laya.Templet) => { //创建模式为1，可以启用换装 this.mArmature = templet.buildArmature(0); this.mArmature.x = 300; this.mArmature.y = 350; this.mArmature.scale(0.5, 0.5); this.owner.addChild(this.mArmature); //设置动画播放完成后，调用completeHandler继续播放下一个动画 this.mArmature.on(Laya.Event.STOPPED, this, this.completeHandler); this.play(); }); } private completeHandler(): void { this.play(); } //播放骨骼动画 private play(): void { //每次到下一个动画 this.mCurrIndex++; if (this.mCurrIndex >= this.mArmature.getAnimNum()) { this.mCurrIndex = 0; } this.mArmature.play(this.mCurrIndex, false); } } 运行效果如下 （动图3-1） 具体效果大家可以在LayaAir 2D入门示例中查看。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:53 "},"IDE/uiEditor/graphics/readme.html":{"url":"IDE/uiEditor/graphics/readme.html","title":"绘制图形","keywords":"","body":"绘制图形一、IDE中绘制图形二、绘制矩形与圆角矩形2.1 IDE绘制矩形2.2 代码绘制矩形2.3 用drawPath绘制矩形2.4 IDE绘制圆角矩形2.5 代码绘制圆角矩形2.6 用drawPath绘制圆角矩形三、绘制圆形、椭圆与扇形3.1 IDE绘制圆形3.2 代码绘制圆形3.3 IDE绘制椭圆3.4 代码绘制椭圆3.5 代码绘制扇形四、绘制三角形、多边形及根据数据绘制图案4.1 IDE绘制三角形，多边形4.2 代码绘制三角形4.3 代码绘制多边形4.4 根据指定的路径数据绘制出图案五、绘制线段与折线5.1 IDE绘制线段5.2 代码绘制线段5.3 IDE绘制折线5.4 代码绘制折线六、绘制曲线6.1 贝塞尔曲线的基础6.2 代码绘制二次贝塞尔曲线七、绘制文本7.1 IDE绘制文本7.2 代码绘制文本八、绘制填充纹理8.1 IDE绘制填充纹理8.2 代码绘制填充纹理九、绘制九宫格纹理9.1 IDE绘制九宫格纹理9.2 代码绘制九宫格纹理十、消除矢量图绘制绘制图形 一、IDE中绘制图形 LayaAir中可以在Sprite对象中通过使用图形组件来绘制各种图形，如动图1-1所示。 （动图1-1） 在IDE中可以通过这些选项来绘制Graphics，如图1-2所示， （图1-2） LayaAir引擎中 laya.display.Graphics 类可以查看到API的各种矢量绘图方法。 drawRect fillText drawPath drawCircle drawPie drawLine drawLines drawPoly drawCurves ...... 下面将对这些Graphics进行讲解。 二、绘制矩形与圆角矩形 2.1 IDE绘制矩形 在Sprite对象的 Graphics 组件中，可以通过点击 + 来创建一个绘制图形命令。选择第一个选项 创建 矩形（DrawRectCmd），创建后如图2-1所示。 （图2-1） Offset：矩形相对于Sprite对象，X轴，Y轴的偏移量。 Size：矩形的尺寸，默认使用百分比，也可以取消百分比勾选，采用像素值设置。 Percent：当勾选时，矩形的尺寸为Sprite对象尺寸的百分比，当不勾选时，矩形的尺寸为像素大小。 Line Width：绘制矩形的边框宽度值。 Line Color：绘制矩形的边框颜色。 Fill Color：矩形填充的颜色。 动图2-2演示了这些属性的操作过程： （动图2-2） 2.2 代码绘制矩形 LayaAir引擎中的 drawRect() 方法用于绘制矢量矩形。该方法的详细说明如下： /** * 绘制矩形。 * @param x 开始绘制的 X 轴位置。 * @param y 开始绘制的 Y 轴位置。 * @param width 矩形宽度。 * @param height 矩形高度。 * @param fillColor 填充颜色，或者填充绘图的渐变对象。 * @param lineColor （可选）边框颜色，或者填充绘图的渐变对象。 * @param lineWidth （可选）边框宽度。 * @param percent 位置和大小是否是百分比值。 */ drawRect(x: number, y: number, width: number, height: number, fillColor: any, lineColor: any = null, lineWidth: number = 1, percent?: boolean): DrawRectCmd { return this.addCmd(DrawRectCmd.create(x, y, width, height, fillColor, lineColor, lineWidth, percent)); } 代码示例： let sp = new Laya.Sprite(); //画矩形 sp.graphics.drawRect(20, 20, 100, 50, \"#ffff00\", \"#00ff00\", 5, false); this.owner.addChild(sp); 示例中的 20，20 是矩形起始点坐标，100是向右的宽度，如果是负数则是向左的宽度。50是向下的高度，如果是负数则是向上的高度。 运行效果： （图2-3） 2.3 用drawPath绘制矩形 LayaAir引擎 laya.display.Graphics 类的绘制路径的方法 drawPath() 可以根据路径绘制矢量图形： /** * 绘制路径。 * @param x 开始绘制的 X 轴位置。 * @param y 开始绘制的 Y 轴位置。 * @param paths 路径集合，路径支持以下格式：[[\"moveTo\",x,y],[\"lineTo\",x,y],[\"arcTo\",x1,y1,x2,y2,r],[\"closePath\"]]。 * @param brush （可选）刷子定义，支持以下设置{fillStyle:\"#FF0000\"}。 * @param pen （可选）画笔定义，支持以下设置{strokeStyle,lineWidth,lineJoin:\"bevel|round|miter\",lineCap:\"butt|round|square\",miterLimit}。 */ drawPath(x: number, y: number, paths: any[], brush: any = null, pen: any = null): DrawPathCmd { return this.addCmd(DrawPathCmd.create(x, y, paths, brush, pen)); } 代码示例： let sp = new Laya.Sprite(); //自定义路径 let path:Array = [ [\"moveTo\", 0, 0], //画笔移到A点 [\"lineTo\", 100, 0],//画到B点 [\"lineTo\", 100, 50],//再画到C点 [\"lineTo\", 0, 50], //继续画到D点 [\"closePath\"] //闭合路径 ]; //绘制矩形 sp.graphics.drawPath(20, 20, path, {fillStyle: \"#ff0000\"}); this.owner.addChild(sp); drawPath 第一和第二位的坐标点“20,20”是控制整体位置的起始位置，第三位是路径参数。 描述信息 MoveTo 是将画笔移动初始位置，此时并没有开始画。”0,0”是相对于”20,20”这个起始位置的，所以A点还是在起始位置原点。描述信息 lineto 是绘制到路径点坐标，“100，0”这个就是绘制到B点位置的坐标。C点和D点以此类推，最后通过描述信息 closePath 与MoveTo的起点位置闭合，否则是不会被闭合的。 从绘制矩形来看，drawPath 方法肯定没有 drawRect 方法更加方便。但是开发者可以通过这个示例理解相关的参数用法。 运行效果（A、B、C、D四个点在运行时并不显示，这是截图后为了方便描述加上去的）： （图2-4） 2.4 IDE绘制圆角矩形 在Sprite对象的 Graphics 组件中，可以通过点击 + 来创建一个绘制图形命令，如图2-5所示，选择 创建 圆角矩形（DrawRoundRectCmd） 绘制圆角矩形。 （图2-5） Offset：圆角矩形相对于Sprite对象，X轴，Y轴的偏移量。 Size：圆角矩形的尺寸，默认使用百分比，也可以取消百分比勾选，采用像素值设置。 Border Radius：各个圆角的半径。X：左上圆角，Y：右上圆角，Z：左下圆角，W：右下圆角。 Percent：当勾选时，圆角矩形的尺寸为Sprite对象尺寸的百分比，当不勾选时，圆角矩形的尺寸为像素大小。 Line Width：绘制圆角矩形的边框宽度值。 Line Color：绘制圆角矩形的边框颜色。 Fill Color：圆角矩形填充的颜色。 2.5 代码绘制圆角矩形 LayaAir引擎中的 drawRoundRect() 方法用于绘制圆角矩形。该方法的详细说明如下： /** * 绘制圆角矩形 * @param x 开始绘制的 X 轴位置。 * @param y 开始绘制的 Y 轴位置。 * @param width 圆角矩形宽度。 * @param height 圆角矩形高度。 * @param lt 左上圆角 * @param rt 右上圆角 * @param lb 左下圆角 * @param rb 右下圆角 * @param fillColor 填充颜色，或者填充绘图的渐变对象。 * @param lineColor （可选）边框颜色，或者填充绘图的渐变对象。 * @param lineWidth （可选）边框宽度。 * @param percent （可选）位置和大小是否是百分比值。 * @returns */ drawRoundRect(x: number, y: number, width: number, height: number, lt: number, rt: number, lb: number, rb: number, fillColor: any, lineColor: any = null, lineWidth: number = 1, percent?: boolean) { return this.addCmd(DrawRoundRectCmd.create(x, y, width, height, lt, rt, lb, rb, fillColor, lineColor, lineWidth, percent)); } 代码示例： let sp = new Laya.Sprite(); sp.graphics.drawRoundRect(200, 200, 300, 300, 20, 20, 20, 20, \"#ffff00\", \"#00ff00\", 5, false); this.owner.addChild(sp); 示例中的 200，200 是矩形起始点坐标，第一个300是向右的宽度，如果是负数则是向左的宽度。第二个300是向下的高度，如果是负数则是向上的高度。四个20为各圆角的半径。\"#ffff00\"为填充颜色，\"#00ff00\"为边框颜色。5是边框宽度，false表示位置和大小不采用百分比值，而采用像素。 运行效果： （图2-6） 除了用LayaAir自带的方法绘制圆角矩形外，还可以用直线和弧线拼接出一个圆角矩形。 2.6 用drawPath绘制圆角矩形 LayaAir引擎中可以使用 graphics 的 drawPath 方法绘制圆角或弧线，具体的操作需要三步，指定绘制路径的起始点 [\"moveTo\", x, y]、绘制一条水平直线[\"lineTo\", x, y]、绘制弧线 [\"arcTo\", p1.x, p1.y, p2.x, p2.y, r]。 2.6.1 参数示例 [\"moveTo\", 50, 50],[\"lineTo\", 150, 50],[\"arcTo\", 200, 50, 200, 100, 50], 上述参数运行效果如图2-7所示： （图2-7） 通过图2-7我们可以看出，[\"moveTo\", 50, 50] 将画笔的起始点定位于\"50,50\"这个位置。[\"lineTo\", 150, 50] 绘制了一条由于起始点到当前端点（”150, 50“）的直线。[\"arcTo\", 200, 50, 200, 100, 50] 绘制了一段r（半径）为50弧线。 2.6.2 弧线绘制原理 在制作这段弧线时，这个弧其实是利用当前端点\"150, 50\"、端点1\"200, 50\"、端点2\"200, 100\"，这三个端点所形成的夹角，制作一条半径为50px并且与两边相切的圆上的一段弧线。 如果已经理解了弧线的绘制原理，还会发现，构成弧线的核心要素为两条边和与两边形成夹角的顶点（上例中的端点1），图2-7中的端点2与端点1形成的x轴边比较好理解，那当前端点与端点1已经构成了y轴边，那与当前端点在同一个y轴的起始点是不是可以去掉呢，事实并不可以。画笔的起始点必须存在，但是绘制直线的lineTo可以去掉，如果[\"lineTo\", 150, 50],被注释掉，那么arcTo绘制弧线的时候，会视起始点为当前端点，arcTo找不到lineTo绘制的直线时，会自动添加一条由起始点到弧线起点的直线，因此，绘制圆角矩形时，lineTo可以省略。 2.6.3 绘制圆角矩形示例 下面绘制一个圆角弧线半径为30的圆角矩形，示例代码如下： let sp = new Laya.Sprite(); //自定义路径 var path:any[] = [ [\"moveTo\", 0, 0], //画笔的起始点 [\"lineTo\",400,0], [\"arcTo\", 500, 0, 500, 30, 30], //p1（500,0）为夹角B，（500,30）为端点p2 [\"lineTo\",500,200], [\"arcTo\", 500, 300, 470, 300, 30],//p1（500,300）为夹角C，（470,300）为端点p2 [\"lineTo\",30,300], [\"arcTo\", 0, 300, 0, 270, 30], //p1(0,300)为夹角D，（0,270）为端点p2 [\"lineTo\",0,100], [\"arcTo\", 0, 0, 30, 0, 30],//p1(0,0)为夹角A，（30,0）为端点p2 ]; //绘制圆角矩形 sp.graphics.drawPath(100, 100, path, {fillStyle: \"#ff0000\"}); this.owner.addChild(sp); 代码运行效果： （图2-8） 在上面的代码里，看起来没有任何问题，其实moveTo的起始点，需要在圆弧之间的直线上，下面我们只需要在 drawPath 绘制时，增加一个边框线，就可以清楚的看出错误。绘制方法 graphics.drawPath 修改为： //绘制圆角矩形 sp.graphics.drawPath(100, 100, path, {fillStyle: \"#ff0000\"},{\"strokeStyle\":\"#ffffff\",\"lineWidth\":\"10\"}); 修改后运行效果如图2-9所示，由于画线的时候，从画笔的起始点0,0开始的，所以并不是我们想要的结果。 （图2-9） 下面将示例修改为正确的代码： let sp = new Laya.Sprite(); //自定义路径 var path:any[] = [ [\"moveTo\", 30, 0], //画笔的起始点 [\"lineTo\",400,0], [\"arcTo\", 500, 0, 500, 30, 30], //p1（500,0）为夹角B，（500,30）为端点p2 [\"lineTo\",500,200], [\"arcTo\", 500, 300, 470, 300, 30],//p1（500,300）为夹角C，（470,300）为端点p2 [\"lineTo\",30,300], [\"arcTo\", 0, 300, 0, 270, 30], //p1(0,300)为夹角D，（0,270）为端点p2 [\"lineTo\",0,100], [\"arcTo\", 0, 0, 30, 0, 30],//p1(0,0)为夹角A，（30,0）为端点p2 ]; //绘制圆角矩形 sp.graphics.drawPath(100, 100, path, {fillStyle: \"#ff0000\"},{\"strokeStyle\":\"#ffffff\",\"lineWidth\":\"10\"}); this.owner.addChild(sp); 运行效果如图2-10所示： （图2-10） 三、绘制圆形、椭圆与扇形 3.1 IDE绘制圆形 在Sprite对象的 Graphics 组件中，可以通过点击 + 来创建一个绘制图形命令。选择 创建 圆形（DrawCircleCmd） 绘制圆形，创建后如图3-1所示。 （图3-1） Offset：圆形相对于Sprite对象，X轴，Y轴的偏移量。 Radius：圆形相对于Sprite对象的尺寸。 Percent：当勾选时，圆形的Offset和Radius为Sprite对象尺寸的百分比，当不勾选时，圆形的尺寸为像素大小。 Line Width：圆形线的宽度。 Line Color：圆形线的颜色。 Fill Color：圆形填充的颜色。 3.2 代码绘制圆形 LayaAir引擎中的 drawCircle() 方法用于绘制矢量圆形。该方法的详细说明如下： /** * 绘制圆形。 * @param x 圆点X 轴位置。 * @param y 圆点Y 轴位置。 * @param radius 半径。 * @param fillColor 填充颜色，或者填充绘图的渐变对象。 * @param lineColor （可选）边框颜色，或者填充绘图的渐变对象。 * @param lineWidth （可选）边框宽度。 */ drawCircle(x: number, y: number, radius: number, fillColor: any, lineColor: any = null, lineWidth: number = 1): DrawCircleCmd { return this.addCmd(DrawCircleCmd.create(x, y, radius, fillColor, lineColor, lineWidth)); } 代码示例： let sp = new Laya.Sprite(); //画圆 sp.graphics.drawCircle(80,80,50,\"#ff0000\"); this.owner.addChild(sp); 圆形绘制比较简单，“80，80”是圆形中心点坐标。50是半径，”#ff0000”是圆形填充颜色值。 运行效果： （图3-2） 3.3 IDE绘制椭圆 在Sprite对象的 Graphics 组件中，可以通过点击 + 来创建一个绘制图形命令。选择 创建 椭圆形（DrawEllipseCmd） 绘制椭圆，创建后如图3-3所示。 （图3-3） Offset：椭圆相对于Sprite对象，X轴，Y轴的偏移量。 Width：椭圆相对于Sprite的横向半径。 Height：椭圆相对于Sprite的纵向半径。 Percent：当勾选时，椭圆的Offset、Width、Height为Sprite对象尺寸的百分比，当不勾选时，圆形的尺寸为像素大小。 Line Width：椭圆线的宽度。 Line Color：椭圆线的颜色。 Fill Color：椭圆填充的颜色。 3.4 代码绘制椭圆 LayaAir引擎中的 drawEllipse 方法用于绘制矢量椭圆。该方法的详细说明如下： /** * 绘制椭圆形 * @param x 圆点X 轴位置。 * @param y 圆点Y 轴位置。 * @param width 横向半径。 * @param height 纵向半径。 * @param fillColor 填充颜色，或者填充绘图的渐变对象。 * @param lineColor （可选）边框颜色，或者填充绘图的渐变对象。 * @param lineWidth （可选）边框宽度。 * @param percent （可选）位置和大小是否是百分比值。 */ drawEllipse(x: number, y: number, width: number, height: number, fillColor: any, lineColor: any, lineWidth: number, percent?: boolean): DrawEllipseCmd { return this.addCmd(DrawEllipseCmd.create(x, y, width, height, fillColor, lineColor, lineWidth, percent)); } 代码示例： let sp = new Laya.Sprite(); //画椭圆 sp.graphics.drawEllipse(200, 200, 50, 100, \"#ff0000\", \"#ffffff\", 5); this.owner.addChild(sp); 其中，“200，200”是椭圆中心点坐标。50，100是椭圆的横向和纵向半径。”#ff0000”是填充颜色值，\"#ffffff\"是椭圆边框颜色，5是边框宽度。 运行效果： （图3-4） 3.5 代码绘制扇形 下面继续延伸，介绍一下扇形绘制方法 drawPie() ，该方法的详细说明如下： /** * 绘制扇形。 * @param x 开始绘制的 X 轴位置。 * @param y 开始绘制的 Y 轴位置。 * @param radius 扇形半径。 * @param startAngle 开始角度。 * @param endAngle 结束角度。 * @param fillColor 填充颜色，或者填充绘图的渐变对象。 * @param lineColor （可选）边框颜色，或者填充绘图的渐变对象。 * @param lineWidth （可选）边框宽度。 */ drawPie(x: number, y: number, radius: number, startAngle: number, endAngle: number, fillColor: any, lineColor: any = null, lineWidth: number = 1): DrawPieCmd { return this.addCmd(DrawPieCmd.create(x, y, radius, Utils.toRadian(startAngle), Utils.toRadian(endAngle), fillColor, lineColor, lineWidth)); } 代码示例： let sp = new Laya.Sprite(); //画扇形 sp.graphics.drawPie(80, 80, 50, 90, 180, \"#ff0000\"); this.owner.addChild(sp); 代码运行效果如下图所示： （图3-5） 绘制扇形与圆形类似，前三个参数的用法也是一样的，只是增加了绘制开始与结束的角度。为了让大家更好的理解，扇形的绘制代码与参数沿用圆形代码示例，除了方法名的改变，只增加了90与180两个角度参数。大家可在编码过程中通过调整参数，再深入理解。 四、绘制三角形、多边形及根据数据绘制图案 4.1 IDE绘制三角形，多边形 在Sprite对象的 Graphics 组件中，可以通过点击 + 来创建一个绘制图形命令。选择 创建 多边形（DrawPolyCmd） 绘制三角形、多边形，创建后如图4-1所示。 （图4-1） Offset：多边形相对于Sprite对象，X轴，Y轴的偏移量，单位是像素。 Points：多边形的点集合，三角形也是一个多边形，只不过是3个点。 Line Width：多边形线框的宽度。 Line Color：多边形线框的颜色。 Fill Color：多边形填充的颜色。 动图4-2演示了如何创建一个多边形： （动图4-2） 4.2 代码绘制三角形 绘制三角形、多边形以及根据指定的路径数据绘制出图案，均可使用LayaAir引擎中 laya.display.Graphics 类的 drawpoly() 方法实现。该方法的详细说明如下： /** * 绘制多边形。 * @param x 开始绘制的 X 轴位置。 * @param y 开始绘制的 Y 轴位置。 * @param points 多边形的点集合。 * @param fillColor 填充颜色，或者填充绘图的渐变对象。 * @param lineColor （可选）边框颜色，或者填充绘图的渐变对象。 * @param lineWidth （可选）边框宽度。 */ drawPoly(x: number, y: number, points: any[], fillColor: any, lineColor: any = null, lineWidth: number = 1): DrawPolyCmd { return this.addCmd(DrawPolyCmd.create(x, y, points, fillColor, lineColor, lineWidth)); } 代码示例： let sp = new Laya.Sprite(); //画三角形 sp.graphics.drawPoly(30, 28, [0, 100, 50, 0, 100, 100], \"#ffff00\"); this.owner.addChild(sp); 运行效果： （图4-3） 通过代码可以看出，drawPoly 第三位参数的“0，100”是A点坐标。“50，0”是B点坐标。“100, 100”是C点坐标，将三个坐标点连接后填充第四位参数的颜色值，即绘制出上图的黄色三角形。但是这里需要大家理解和注意的是，第三位参数中所有的坐标都是相对坐标，都会受到第一位和第二位坐标参数“30，28”的影响。一旦“30，28”产生改变，整体形状位置都会受到影响。 4.3 代码绘制多边形 继续用上面的代码示例，通过增加 drawPoly 第三位参数的坐标，来实现多边形的绘制，修改的代码如下： let sp = new Laya.Sprite(); //画多边形 sp.graphics.drawPoly(30, 28, [0, 100, 50, 0, 100, 100, 75, 150, 25, 150], \"#ffff00\"); this.owner.addChild(sp); 代码运行效果如下图所示： （图4-4） 在修改的代码中，新增了D点坐标”75，150“与E点坐标”25，150“。通过将各个坐标点连接填充颜色后，即绘制出我们想要的多边形。要绘制更多边的多边形，按上述方式增加坐标点即可。 4.4 根据指定的路径数据绘制出图案 下面通过示例深入介绍一下，如何指定路径绘制一个五角星。示例代码如下： let sp = new Laya.Sprite(); //画五角星 var path: Array = []; path.push(0, -130);//五角星A点坐标 path.push(33, -33);//五角星B点坐标 path.push(137, -30);//五角星C点坐标 path.push(55, 32);//五角星D点坐标 path.push(85, 130);//五角星E点坐标 path.push(0, 73);//五角星F点坐标 path.push(-85, 130);//五角星G点坐标 path.push(-55, 32);//五角星H点坐标 path.push(-137, -30);//五角星I点坐标 path.push(-33, -33);//五角星J点坐标 sp.graphics.drawPoly(Laya.stage.width / 2, Laya.stage.height / 2, path, \"#FF7F50\"); this.owner.addChild(sp); 代码运行效果如下图所示： （图4-5） 通过上面的示例代码的写法，是不是感觉代码的可读性得到了增强，大家也可以将之前的三角形或多边形改成这种方式去体验一下，掌握了这些基础，可以衍生出很多灵活的用法。 五、绘制线段与折线 5.1 IDE绘制线段 在Sprite对象的 Graphics 组件中，可以通过点击 + 来创建一个绘制图形命令。选择 创建 线段（DrawLineCmd） 绘制线段，创建后如图5-1所示。 （图5-1） From：线的起始点，相对于Sprite对象，X轴，Y轴的偏移量。 To：线的终点，相对于Sprite对象，X轴，Y轴的偏移量。 Percent：当勾选时，线的起始点和终点为Sprite对象尺寸的百分比，当不勾选时，线的起始点和终点为像素点。 Line Width：线的宽度。 Line Color：线的颜色。 5.2 代码绘制线段 Laya引擎中 laya.display.Graphics 类中 drawLine() 方法用于绘制线段。该方法的详细说明如下： /** * 绘制一条线。 * @param fromX X轴开始位置。 * @param fromY Y轴开始位置。 * @param toX X轴结束位置。 * @param toY Y轴结束位置。 * @param lineColor 颜色。 * @param lineWidth （可选）线条宽度。 */ drawLine(fromX: number, fromY: number, toX: number, toY: number, lineColor: string, lineWidth: number = 1): DrawLineCmd { return this.addCmd(DrawLineCmd.create(fromX, fromY, toX, toY, lineColor, lineWidth)); } 代码示例： let sp = new Laya.Sprite(); //画直线 sp.graphics.drawLine(10, 58, 146, 58, \"#ff0000\", 3); this.owner.addChild(sp); 运行效果： （图5-2） 5.3 IDE绘制折线 在Sprite对象的 Graphics 组件中，可以通过点击 + 来创建一个绘制图形命令。选择 创建 折线（DrawLinesCmd） 绘制折线，创建后如图5-3所示。 （图5-3） Offset：线段相对于Sprite对象，X轴，Y轴的偏移量，单位是像素。 Points：线段的点集合。 Line Width：线的宽度。 Line Color：线的颜色。 5.4 代码绘制折线 Laya引擎中 laya.display.Graphics 类中 drawLines() 方法用于绘制折线。该方法与 drawLine 比较像，编码时千万不要漏掉了末尾的“s”。drawLines 的参数详细说明如下： /** * 绘制一系列线段。 * @param x 开始绘制的X轴位置。 * @param y 开始绘制的Y轴位置。 * @param points 线段的点集合。格式:[x1,y1,x2,y2,x3,y3...]。 * @param lineColor 线段颜色，或者填充绘图的渐变对象。 * @param lineWidth （可选）线段宽度。 */ drawLines(x: number, y: number, points: any[], lineColor: any, lineWidth: number = 1): DrawLinesCmd | null { if (!points || points.length 代码示例： let sp = new Laya.Sprite(); //画折线 sp.graphics.drawLines(20, 88, [0, 0, 39, -50, 78, 0, 120, -50], \"#ff0000\", 3); this.owner.addChild(sp); 运行效果： （图5-4） 通过代码，我们可以看出，画折线与画直线的参数区别是从第三位开始，第三位参数是Array类型的折线点集合，其中的“0，0”是折点A的起始坐标。“39，-50”是折点B的起始坐标。“78, 0”是折点C的起始坐标，“120, -50”是终点D的坐标。但是这里需要大家理解和注意的是，第三位参数中所有的坐标都是相对坐标，都会受到第一位和第二位参数的“20，88”而影响。一旦“20，88”产生改变，整体折线都会受到影响。 六、绘制曲线 相对于直线而言，曲线的绘制与坐标关系更难理解一些。由于LayaAir引擎绘制的是贝塞尔曲线，所以本文中先针对贝塞尔曲线的基础进行说明，然后再结合引擎的API进行讲解。 6.1 贝塞尔曲线的基础 贝塞尔曲线在港澳台等地称为貝茲曲線，新加坡马来西亚等地称为贝济埃曲线。一般的矢量图形软件通过它来精确画出曲线，贝塞尔曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋，我们在绘图工具上看到的钢笔工具就是来做这种矢量曲线的。 贝塞尔曲线是应用于二维图形应用程序的数学曲线。曲线的定义有四个点：起始点、终止点（也称锚点）以及两个相互分离的中间点。滑动两个中间点，贝塞尔曲线的形状会发生变化。 基于线性、二次方、三次方等公式的不同，贝塞尔曲线也被称为一次、二次……五次贝塞尔曲线，有些文章也称为一阶、二阶……说的是一回事。下面通过动图让大家直观的理解一下： 6.1.1 一次贝塞尔曲线 （动图6-1） 说明：上图是由 P0 至 P1 的连续点， 描述的是一条线性的贝赛尔曲线。线性贝塞尔曲线函数中的 t 会经过由 P0 至 P1 的 B(t) 所描述的曲线。例如当 t=0.25 时，B(t) 即一条由点 P0 至 P1 路径的四分之一处。就像由 0 至 1 的连续 t，B(t) 描述一条由 P0 至 P1 的直线。 6.1.2 二次贝塞尔曲线 （动图6-2） （动图6-3） 说明：为建构二次贝塞尔曲线，上图由 P0 至 P1 的连续点 Q0，描述一条线性贝塞尔曲线。由 P1 至 P2 的连续点 Q1，描述一条线性贝塞尔曲线。由 Q0 至 Q1 的连续点 B(t)，描述一条二次贝塞尔曲线。 6.1.3 三次贝塞尔曲线 （动图6-4） （动图6-5） 说明：对于三次曲线，可由线性贝塞尔曲线描述的中介点 Q0、Q1、Q2，和由二次曲线描述的点 R0、R1 所建构。 6.1.4 高阶贝塞尔曲线 由于高阶贝塞尔曲线并不常见，本文将不再详细说明，想对贝塞尔曲线原理了解更多的可以查看其它相关文章。 （动图6-6） 四次贝塞尔曲线 （动图6-7） 五次贝塞尔曲线 6.2 代码绘制二次贝塞尔曲线 LayaAir引擎的曲线绘制采用的是二次贝塞尔曲线，开发者可以用 laya.display.Graphics 类的 drawCurves() 方法来绘制曲线。该方法的详细说明如下： /** * 绘制一系列曲线。 * @param x 开始绘制的 X 轴位置。 * @param y 开始绘制的 Y 轴位置。 * @param points 线段的点集合，格式[controlX, controlY, anchorX, anchorY...]。 * @param lineColor 线段颜色，或者填充绘图的渐变对象。 * @param lineWidth （可选）线段宽度。 */ drawCurves(x: number, y: number, points: any[], lineColor: any, lineWidth: number = 1): DrawCurvesCmd { return this.addCmd(DrawCurvesCmd.create(x, y, points, lineColor, lineWidth)); } 下面我们用LayaAir引擎绘制矢量曲线，示例代码如下： let sp = new Laya.Sprite(); //画折线 sp.graphics.drawCurves(10, 58, [0, 0, 19, -100, 39, 0], \"#ff0000\", 3); this.owner.addChild(sp); 运行效果如下： （图6-8） 通过增加 drawCurves 的第三位points点集合的参数，我们可以让曲线更复杂一些，修改的示例代码如下： //增加58, 100与78, 0坐标让曲线更复杂一些 sp.graphics.drawCurves(10, 58, [0, 0, 19, -100, 39, 0, 58, 100, 78, 0], \"#ff0000\", 3) ; 运行效果如下： （图6-9） 如果想绘制更复杂的曲线，可自行调整 drawCurves 中的参数，再结合二次贝赛尔曲线原理进行理解。 最后提醒一下，与绘制折线一样，第三位参数中所有的坐标都是相对坐标，都会受到第一位和第二位参数的“10，58”而影响。一旦“10，58”产生改变，整体曲线都会受到影响。 七、绘制文本 7.1 IDE绘制文本 在Sprite对象的 Graphics 组件中，可以通过点击 + 来创建一个绘制图形命令。选择 创建 文本（FillTextCmd） 绘制文本，创建后如图7-1所示。 （图7-1） Text：显示的文本内容。 Offset：文本距离Sprite原点（0，0）坐标位置的偏移值。 font：文本的字体设置。 Font Size：文本的字体大小。 Bold：文本是否为粗体。 Italic：文本是否为斜体。 fillColor：文本颜色。 Stork：文本的描边宽度，0表示不描边。 Stork Color：文本的描边颜色。 7.2 代码绘制文本 Laya引擎中 laya.display.Graphics 类中 fillText() 方法用于绘制文本。该方法的详细说明如下： /** * 在画布上绘制文本。 * @param text 在画布上输出的文本。 * @param x 开始绘制文本的 x 坐标位置（相对于画布）。 * @param y 开始绘制文本的 y 坐标位置（相对于画布）。 * @param font 定义字号和字体，比如\"20px Arial\"。 * @param color 定义文本颜色，比如\"#ff0000\"。 * @param textAlign 文本对齐方式，可选值：\"left\"，\"center\"，\"right\"。 */ fillText(text: string | WordText, x: number, y: number, font: string, color: string, textAlign: string): FillTextCmd { return this.addCmd(FillTextCmd.create(text, x, y, font, color, textAlign, 0, \"\")); } 代码示例： let sp = new Laya.Sprite(); // 绘制文本 sp.graphics.fillText(\"LayaAir\", 100, 100, \"20px Arial\", \"#ff0000\", \"center\"); this.owner.addChild(sp); 运行效果： （图7-2） 八、绘制填充纹理 8.1 IDE绘制填充纹理 在Sprite对象的 Graphics 组件中，可以通过点击 + 来创建一个绘制图形命令。选择 创建 填充纹理（FillTextureCmd） 绘制填充纹理，创建后如图8-1所示。 （图8-1） Texture：设置纹理图像。 Position：纹理相对于Sprite对象的位置。 Size：纹理的尺寸，默认使用百分比，也可以取消百分比勾选，采用像素值设置。 Percent：当勾选时，纹理的尺寸为Sprite对象尺寸的百分比，当不勾选时，纹理的尺寸为像素大小。 Type：纹理填充的类型：重复、仅x轴重复、仅y轴重复、不重复。 Offset：纹理相对于Sprite对象，X轴，Y轴的偏移量，单位是像素。 Color：纹理的颜色。 8.2 代码绘制填充纹理 Laya引擎中 laya.display.Graphics 类中 fillTexture() 方法用于绘制填充纹理。该方法的详细说明如下： /** * 用 texture 填充。 * @param texture 纹理。 * @param x X轴偏移量。 * @param y Y轴偏移量。 * @param width （可选）宽度。 * @param height （可选）高度。 * @param type （可选）填充类型 repeat|repeat-x|repeat-y|no-repeat * @param offset （可选）贴图纹理偏移 * @param color （可选）颜色 * */ fillTexture(texture: Texture, x: number, y: number, width: number = 0, height: number = 0, type: string = \"repeat\", offset: Point | null = null, color: string = null): FillTextureCmd | null { if (texture && texture.bitmap) return this.addCmd(FillTextureCmd.create(texture, x, y, width, height, type, offset || Point.EMPTY, color)); else return null; } 代码示例： Laya.loader.load(\"resources/layaAir.png\").then((res: Laya.Texture) => { let sp = new Laya.Sprite(); // 绘制填充纹理 sp.graphics.fillTexture(res, 0, 0, 500, 500, \"repeat\"); this.owner.addChild(sp); }); 运行效果： （图8-2） 九、绘制九宫格纹理 9.1 IDE绘制九宫格纹理 在Sprite对象的 Graphics 组件中，可以通过点击 + 来创建一个绘制图形命令。选择 创建 九宫格纹理（Draw9GridTextureCmd） 绘制九宫格纹理，创建后如图9-1所示。 （图9-1） Texture：设置纹理图像。 Position：纹理相对于Sprite对象的位置。 Size：纹理的尺寸，默认使用百分比，也可以取消百分比勾选，采用像素值设置。 Percent：当勾选时，纹理的尺寸为Sprite对象尺寸的百分比，当不勾选时，纹理的尺寸为像素大小。 Size Grid：位图的有效缩放网格数据（九宫格信息）：上边距、右边距、下边距、左边距、是否重复填充。 Color：纹理的颜色。 9.2 代码绘制九宫格纹理 Laya引擎中 laya.display.Graphics 类中 draw9Grid() 方法用于绘制九宫格纹理。该方法的详细说明如下： /** * @private * 绘制带九宫格的图片 * @param texture * @param x * @param y * @param width * @param height * @param sizeGrid * @param color */ draw9Grid(texture: Texture, x: number = 0, y: number = 0, width: number = 0, height: number = 0, sizeGrid: any[], color?: string): void { this.addCmd(Draw9GridTextureCmd.create(texture, x, y, width, height, sizeGrid, false, color)); } 代码示例： Laya.loader.load(\"atlas/comp/image.png\").then((res: Laya.Texture) => { let sp = new Laya.Sprite(); // 绘制九宫格纹理 sp.graphics.draw9Grid(res, 0, 0, 1024, 626, [0, 0, 0, 0, 1]); this.owner.addChild(sp); }); 运行效果： （图9-2） 十、消除矢量图绘制 在PC电脑的浏览器上，我们经常发现LayaAir引擎绘制的矢量图会有一些锯齿，这是由于LayaAir引擎基于性能的考虑，做的优化处理，由于移动手机端的像素密度比较大，所以在PC上看起来明显的锯齿问题，其实在移动设备上基本上看不出来。 如果有追求完美的开发者，可以通过开启 Laya.Config.isAntialias=true 开设置，也可以在项目设置中开启，如图10-1所示。 （图10-1） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-11-29 17:33:41 "},"IDE/uiEditor/Filter/readme.html":{"url":"IDE/uiEditor/Filter/readme.html","title":"UI滤镜效果","keywords":"","body":"UI滤镜效果一、概述1.1 IDE中创建滤镜1.2 同时生效二、颜色滤镜2.1 基础属性2.2 代码实现三、模糊滤镜3.1 基础属性3.2 代码实现四、发光滤镜4.1 基础属性4.2 代码实现UI滤镜效果 一、概述 滤镜，主要是用来实现图像的各种特殊效果，使图像取得最佳艺术效果。滤镜的类型有很多，但是营造不同的效果需要不同的滤镜功能。 LayaAir提供了颜色滤镜、模糊滤镜、发光(或阴影)滤镜三种效果，其中模糊滤镜与发光滤镜对性能的消耗较大。 1.1 IDE中创建滤镜 在LayaAir 3.0中，除了Sprite对象以外，可以将滤镜应用于任何显示对象，开发者通常对Image组件使用最多。选择Image组件，在属性设置面板的杂项中，添加滤镜的属性Filters，如动图1-1所示，演示了如何在Image组件上使用滤镜。 （动图1-1） 如图1-2所示，可以创建颜色滤镜（ColorFilter）、模糊滤镜（BlurFilter）、发光滤镜（GlowFilter）。 （图1-2） 1.2 同时生效 如图1-3所示，不同滤镜效果可以叠加使用并同时生效，开发者可以根据需要进行设置。 （图1-3） 二、颜色滤镜 ColorFilter是颜色滤镜，颜色滤镜是图像后期处理中非常重要的一部分，它可以改变原有图像中的各种参数，从而在不改变图像大体的前提下，使其呈现出不同的风格。在实际操作时，颜色滤镜主要改变的参数为亮度、对比度、饱和度、色调等，整体来讲只改变颜色，并不对图像进行任何变形处理。正确地使用颜色滤镜，可以修正图像非正常曝光、缓解图片失真现象，从而突出主要细节，弱化掉一些不太好的部分。在艺术领域，颜色滤镜还被用来呈现不同的美学风格。 2.1 基础属性 如图2-1所示，颜色滤镜有5个属性： （图2-1） Color：设置滤镜颜色。 Brightness：调整亮度。 Contrast：调整对比度。 Saturation：调整饱和度。 Hue：调整色调。 2.2 代码实现 代码控制滤镜有以下两种： 1、使用ColorFilter类直接创建滤镜，示例代码如下： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { // 获得Image组件 @property({ type: Laya.Image }) public img: Laya.Image; //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { //创建一个颜色滤镜对象 let colorFilter: Laya.ColorFilter = new Laya.ColorFilter(); //给Image组件添加颜色滤镜 this.img.filters = [colorFilter]; //设置滤镜颜色 colorFilter.color(0.5, 0.5, 0.5, 1); //设置滤镜亮度 colorFilter.adjustBrightness(-50); //设置滤镜对比度 colorFilter.adjustContrast(8); //设置滤镜饱和度 colorFilter.adjustSaturation(30); //设置滤镜对比度 colorFilter.adjustHue(-15); } } 2、使用代码调整已经添加滤镜效果的Image组件，示例代码如下： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { // 获得Image组件 @property({ type: Laya.Image }) public img: Laya.Image; //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { //获得Image的颜色滤镜对象（在IDE中已经给Image组件添加了颜色滤镜） let colorFilter: Laya.ColorFilter = this.img.filters[0]; //设置滤镜颜色 colorFilter.color( 0.5, 0.5, 0.5, 1 ); //设置滤镜亮度 colorFilter.adjustBrightness(-50); //设置滤镜对比度 colorFilter.adjustContrast(8); //设置滤镜饱和度 colorFilter.adjustSaturation(30); //设置滤镜对比度 colorFilter.adjustHue(-15); } } 其它滤镜的使用方法与此类似，后续只给出第一种方法，即直接创建滤镜的示例。 三、模糊滤镜 BlurFilter是模糊滤镜，能够产生模糊的效果。 3.1 基础属性 如图3-1所示，模糊滤镜只有1个属性： （图3-1） Strength：模糊滤镜的模糊强度值，数值越大越模糊。 3.2 代码实现 使用BlurFilter类直接创建滤镜，示例代码如下： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { // 获得Image组件 @property({ type: Laya.Image }) public img: Laya.Image; //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { let blurFilter: Laya.BlurFilter = new Laya.BlurFilter(); // 设置模糊强度 blurFilter.strength = 5; // 给Image组件添加模糊滤镜 this.img.filters = [blurFilter]; } } 四、发光滤镜 GlowFilter是发光滤镜，就是创建放光效果或者阴影的效果，比如外发光。 4.1 基础属性 如图4-1所示，发光滤镜有3个属性： （图4-1） Offset：发光滤镜相对于组件的偏移，X轴方向和Y轴方向。 Blur：发光滤镜的边缘模糊大小，数值越大，边缘越模糊。 Color：发光滤镜的颜色。 4.2 代码实现 使用GlowFilter类直接创建滤镜，示例代码如下： const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { // 获得Image组件 @property({ type: Laya.Image }) public img: Laya.Image; //组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { // 创建发光滤镜，创建时初始化滤镜 let glowFilter: Laya.GlowFilter = new Laya.GlowFilter(\"#ffff00\", 10, 0, 0); // 给Image组件添加发光滤镜 this.img.filters = [glowFilter]; } } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-11-29 17:33:41 "},"IDE/uiEditor/runtime/readme.html":{"url":"IDE/uiEditor/runtime/readme.html","title":"UI运行时","keywords":"","body":"UI运行时一、概述1.1 功能划分方式1.2 UI管理方式二、UI运行时2.1 IDE自动生成代码2.2 勾选UI组件声明2.3 代码中使用UI组件三、与自定义组件脚本区别3.1 继承类不同3.2 不同的生命周期3.3 不同的使用UI组件方式四、UI运行时和自定义组件脚本的混合使用4.1 简单用法4.2 高级用法UI运行时 一、概述 在项目开发过程中，开发者往往对UI的开发思路不够清晰，开发方式也多种多样，对项目的结构和使用方式会造成一定的混乱。这篇文章可以帮助开发者理清一些思路，我们会从这几个方面来展开： UI组件脚本（UI运行时、Runtime类） UI组件脚本和自定义组件脚本的区别 UI组件脚本和自定义组件脚本混合使用的高级用法 本篇之前已经介绍了所有的UI小部件，并且在《ECS组件系统》中讲解了自定义的组件脚本管理UI小部件的方式。其实还有一种UI管理方式，就是之前在《项目入口说明》中和自定义组件脚本一起介绍的UI组件脚本，虽然已经告诉大家它在IDE中创建的方式，但是并没有介绍在哪种情况下使用这种方式，所以我们先来聊一聊2D开发UI过程中会遇到的情况，再引入UI组件脚本的深入讲解。 1.1 功能划分方式 首先，我们的项目不止一套UI，就比如游戏开发来说，有登陆界面，加载界面，英雄属性界面，背包界面，战斗界面等等，那么对于这些界面的合理规划，我们建议是通过划分场景或者预制体来解决。如图1-1所示，这里有很多UI场景，因为这些UI的功能是不一样的，所以将它们划分到场景里。 （图1-1） 如图1-2所示，这里有很多Prefab（预制体），因为这些UI的功能是一样的，可以重复利用，所以划分到预制体中。 （图1-2） 所以，通常我们把每一套不同功能的UI，用场景（Scene）来规划；把能复用的功能性UI，用预制体（Prefab）来规划 。 1.2 UI管理方式 在UI开发过程中，我们会使用Image，Box，Tab等等这些LayaAir 提供的UI组件。对于一套相对复杂的UI界面来说，大量的UI组件，用自定义组件脚本的方式管理并不方便，需要每个组件都拖拽到自定义属性中，繁琐而费力。因此我们建议开发者，使用UI组件脚本来管理UI组件，后面我们再说UI组件脚本和自定义组件脚本的区别。UI组件脚本设计的目的就是在场景或者是预制体的根节点创建，能对其内部所有的组件进行更加方便的管理。 如图1-3所示，这是一套复杂的UI的预制体，是通过UI组件脚本（Runtime即UI运行时）进行管理的。 （图1-3） 从图1-3中可以看到，这套UI并没有使用自定义的组件脚本，而是使用UI组件脚本（Runtime），是在预制体的根节点 View上的 Runtime 属性里添加“ BagListRT.ts”代码来管理的。 二、UI运行时 UI组件脚本只能添加在Scene2D节点或2D预制体根节点的属性设置面板上的Runtime入口。如果添加在Scene2D上，它的父类就继承于Laya.Scene；如果添加在2D预制体的根节点，它的父类就继承于UI小部件的类（根据2D预制体根节点的节点类型而定）。因此，UI组件脚本就是UI运行时，也叫做 Runtime 类，可以对场景或预制体内部所有UI组件进行方便的管理。 在《项目入口说明》中已经介绍了IDE中创建UI组件脚本，下面介绍它的使用。 2.1 IDE自动生成代码 如图2-1所示，创建UI组件脚本以后，除了生成RuntimeScript.ts之外，在项目工程中看到还多了一个 RuntimeScript.generated.ts。 （图2-1） 图2-2展示了RuntimeScript.ts默认生成的代码，其类名RuntimeScript就是创建时的文件名，它在生成时自动继承于RuntimeScriptBase 类。 （图2-2） 图2-3展示了RuntimeScript.generated.ts默认生成的代码，这个类的名字为RuntimeScriptBase ，它继承了“Laya.Scene”，说明它是有场景管理能力的。 （图2-3） 注意：请不要修改这个代码，随着我们开发过程中不断添加新的UI组件、删除UI组件，这个代码会自动更新。 这个类是以runtime类名字xxx为基础进行命名，命名后的文件名就是xxx.generated.ts，类名为xxxBase。 2.2 勾选UI组件声明 在UI组件脚本中管理UI组件，需要先关联UI组件。 新建一个场景，创建一个UI组件脚本，并在场景中先添加几个UI组件（如图2-4）。 （图2-4） 要想管理这几个UI组件，需要对这些组件勾选 定义变量 选项，如动图2-5所示。 （动图2-5） 勾选 定义变量 选项后，保存场景，此时IDE会自动识别出组件的声明有变化，再看 RuntimeScript.generated.ts 代码（如图2-6），多了几个属性，正是对应于刚刚勾选的组件。 （图2-6） 通过这样操作，UI组件和代码就自动关联了。 2.3 代码中使用UI组件 此时，我们可以在UI组件脚本中，使用此场景中已经勾选过的UI组件，直接使用this.即可使用。例如下面的代码： onAwake(): void { // Button添加鼠标事件，让Image不显示 this.Button.on( Laya.Event.MOUSE_DOWN, this, ()=>{ this.Image.visible = false; }); } 运行此场景来看看效果，如动图2-7所示。 （动图2-7） UI组件脚本就已经介绍完了，再复杂的UI都可以通过勾选组件声明，让IDE自动创建关联关系，提供给 Runtime 类来使用。不需要像自定义组件脚本的方式建立关联关系，因此UI组件脚本在管理场景方面会更加方便。 三、与自定义组件脚本区别 3.1 继承类不同 UI组件脚本如果添加在Scene2D上，它的父类就继承于Laya.Scene（如图3-1）；如果添加在2D预制体的根节点，它的父类就继承于UI小部件的类，例如Laya.Box（如图3-2）。而自定义的组件脚本继承于Laya.Scirpt（如图3-3）。 （图3-1） （图3-2） （图3-3） 3.2 不同的生命周期 自定义的组件脚本的生命周期，如图3-4所示。 （图3-4） 而UI组件脚本的生命周期只有如下方法： /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 * 此方法为虚方法，使用时重写覆盖即可 */ onAwake(): void { } /** * 组件被启用后执行，比如节点被添加到舞台后 * 此方法为虚方法，使用时重写覆盖即可 */ onEnable(): void { } /** * 组件被禁用时执行，比如从节点从舞台移除后 * 此方法为虚方法，使用时重写覆盖即可 */ onDisable(): void { } /** * 销毁时执行 * 此方法为虚方法，使用时重写覆盖即可 */ onDestroy(): void { } /** * 关闭完成后，调用此方法（如果有关闭动画，则在动画完成后执行） * @param type 如果是点击默认关闭按钮触发，则传入关闭按钮的名字(name)，否则为null。 */ onClosed(type: string = null): void { } /**场景打开完成后，调用此方法（如果有弹出动画，则在动画完成后执行）*/ onOpened(param: any): void{ } 注意1：不论是Scene2D节点还是2D预制体的根节点，它们的Runtime是没有onStart、onUpdate、onLateUpdate方法的。 注意2：onOpened、onClosed方法是只有Scene2D节点的Runtime有，其它情况是没有的。 3.3 不同的使用UI组件方式 相比自定义的组件脚本，UI组件脚本可以直接使用UI定义的属性（通过IDE内勾选定义变量，因此它也不需要@property装饰器暴露属性），然后直接通过“this.”的方法使用，比如 this.Button，this.Image，具有代码提示效果。而自定义的组件脚本获取只能通过代码定义属性，再在IDE中拖入节点获取节点或组件。 因此建议开发者：一般情况下使用自定义脚本的方式。只有当页面内需要管理较多的组件时，使用UI组件脚本能够更加方便的进行管理。 四、UI运行时和自定义组件脚本的混合使用 4.1 简单用法 在上述示例中（图2-4），已经在Scene场景中创建好了UI组件脚本，而后添加的代码如下所示： const { regClass } = Laya; import { RuntimeScriptBase } from \"./RuntimeScript.generated\"; @regClass() export class RuntimeScript extends RuntimeScriptBase { onAwake(): void { // Button添加鼠标事件，让Image不显示 this.Button.on( Laya.Event.MOUSE_DOWN, this, ()=>{ this.Image.visible = false; }); } } 其次，可以在Scene2D节点下添加自定义的组件脚本，如图4-1所示。 （图4-1） 此时Scene场景中既有UI组件脚本（Runtime），又有自定义的组件脚本。通过在自定义的组件脚本“NewScript.ts”中添加如下代码，来看看如何在自定义的组件脚本中使用Runtime的功能。 import { RuntimeScript } from \"./RuntimeScript\"; const { regClass, property } = Laya; @regClass() export class NewScript extends Laya.Script { private ui : RuntimeScript; onStart() { // 获得场景的Runtime对象 this.ui = this.owner.scene as RuntimeScript; // Button添加鼠标事件，让Image不显示 this.ui.Button.on( Laya.Event.MOUSE_DOWN, null, ()=>{ this.ui.Image.visible = false; }); } } ui 属性直接从脚本中通过 this.owner.scene as RuntimeScript 这句代码拿到了Runtime对象，那么Runtime下的UI组件也就可以直接获取了（this.ui.）。 将本节（4.1节）开头添加的“Button添加鼠标事件”代码注释后，运行项目，效果依然是动图2-7所展示的效果。说明以上这段代码的运行效果与开头所示代码的运行效果是一致的。通过UI组件脚本和自定义组件脚本的混合使用，开发者可以在自定义组件脚本中方便的使用UI组件了。 4.2 高级用法 上述方案中，自定义的组件脚本已经可以拿到场景的Runtime对象，那么在复杂的项目中，如果有很多的UI界面，我们是否可以对所有的UI界面做统一的管理呢？比如，统一找到和处理所有UI相关的Button，让所有Button点击时自动缩放。再比如更高级的用处，统一做所有UI的自适应功能。我们通过下面的方式来看看。 4.2.1 创建多个场景 那么以“统一找到和处理所有UI的Button，让所有Button点击时自动缩放” 为例，我们需要再创建一个有多个Button的UI场景，命名为“Button_Scene”，如图4-2所示。 （图4-2） 因为不同的UI，所持有的UI组件是不一样的，比如A场景有a1，a2组件，B场景有b1，b2，b3组件，那么不同的场景就需要有不同的 Runtime来关联每个UI的组件。那么下一步，针对这个Button_Scene的场景，再在Runtime入口创建一个UI组件脚本，并重命名为“ButtonRuntime.ts” ，如动图4-3所示。 （动图4-3） 接下来，我们需要把Button_Scene中的Button1，Button2，Button3都勾选定义变量属性，然后保存场景。这个操作和动图2-5类似，就不再详细介绍了。 最后，我们还需要给Button_Scene再添加一个自定义的组件脚本，命名为“ButtonScript.ts”，如图4-4所示。 （图4-4） 4.2.2 创建脚本父类 在上述操作后，两个场景都有UI组件脚本和自定义组件脚本了，那么如何做统一处理呢？我们发现Runtime类是用来关联UI组件的，因为它们都是继承于各自生成的脚本（RuntimeScript继承于RuntimeScriptBase、ButtonRuntime继承于ButtonRuntimeBase），就不能再统一继承某个类了。 而自定义的组件脚本类（NewScript、ButtonScript）都继承自Laya.Script，那么我们再多继承一层，可以让NewScript和ButtonScript都继承自一个新的类“Main”（这个类就是创建项目时默认生成的Main.ts），Main类再继承自Laya.Script（图4-5），从而实现统一处理的目的。 （图4-5） 另外在Main类加一个方法baseUI()： const { regClass, property } = Laya; @regClass() export class Main extends Laya.Script { //用来统一处理ui的事情，比如自适应，缩放所有Button public baseUI(ui: Laya.Scene){ } } 接下来，修改NewScript和ButtonScript都继承自Main，获得Runtime对象，并调用Main的baseUI()方法，传入runtime对象，如下： import { Main } from \"./Main\"; import { RuntimeScript } from \"./RuntimeScript\"; const { regClass, property } = Laya; @regClass() export class NewScript extends Main { private ui: RuntimeScript; onStart() { console.log(\"Game start\"); this.ui = this.owner.scene as RuntimeScript; super.baseUI(this.ui); } } import { Main } from \"./Main\"; import { ButtonRuntime } from \"./ButtonRuntime\"; const { regClass, property } = Laya; @regClass() export class ButtonScript extends Main { private ui: ButtonRuntime; onStart() { console.log(\"Game start\"); this.ui = this.owner.scene as ButtonRuntime; super.baseUI(this.ui); } } 最后，在 Main中加入点击缩放Button的代码，如下： const { regClass, property } = Laya; @regClass() export class Main extends Laya.Script { //用来统一处理ui的事情，比如自适应，缩放所有Button public baseUI(ui: Laya.Scene) { this.searchButton(ui); } //找出所有ui下的Button包括子节点下 searchButton(ui: Laya.Node) { for (let i = 0; i 分别运行两个场景看看效果： （动图4-6）Scene的Button可以点击缩放 （动图4-7）Button_Scene的三个Button都可以点击缩放 到此，我们了解了什么是UI运行时，UI运行时和自定义组件脚本类的区别，以及混合使用的方式，统一管理UI的高级用法，开发者可以更深一步研究，有更多的混合用法欢迎和我们交流~ Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-06-28 21:30:07 "},"IDE/uiEditor/use3D/readme.html":{"url":"IDE/uiEditor/use3D/readme.html","title":"混合使用3D","keywords":"","body":"混合使用3D一、概述二、IDE中混合使用3D2.1 IDE中创建RenderTexture文件2.2 3D场景添加渲染物2.3 设置摄像机的目标纹理2.4 设置Sprite的Texture2.5 修改渲染纹理属性三、代码中混合使用3D混合使用3D 一、概述 在2D项目开发过程中，开发者往往需要在UI界面显示3D场景或者3D物体，比如游戏开发中，3D人物在2D背景地图上跑动，英雄属性界面里会展示3D的英雄模型等等，如动图1-1所示， （动图1-1） 动图1-1是LayaAir创建的2D入门示例中的“混合3D”示例。 首先，利用LayaAir引擎中的RenderTexture可以很方便的实现这个功能。渲染纹理（RenderTexture）是在运行时不断更新渲染的一种特殊类型纹理 。渲染纹理的一个典型用法是将其设置为摄像机的“目标纹理”属性，这将使摄像机渲染到纹理，而不是渲染到屏幕。随后可以如同普通纹理（Texture）一样在2D UI下的Sprite对象中使用。 现在我们分别讲解在IDE和代码中是如何利用渲染纹理混合使用3D的。 二、IDE中混合使用3D 2.1 IDE中创建RenderTexture文件 如图2-1所示，先在IDE的 assets 资源中创建一个渲染纹理（RenderTexture）文件。 （图2-1） 点击新创建的RenderTexture文件，在属性面板中，会显示属性信息，如图2-2所示。 （图2-2） Width：渲染纹理的像素宽度。 Height：渲染纹理的像素高度。 Color Format：渲染纹理的颜色格式。 Depth Format：渲染纹理的深度格式。 Generate Mipmap：如果勾选了，则自动生成多级渐进纹理级别。 Multi Samples：多重采样。 sRGB：此渲染纹理是否使用sRGB读/写转换（只读）。 AnisoLevel：各向异性值。 FilterMode：采样过滤模式。 WrapModeU：U方向采样模式。 WrapModeV：V方向采样模式。 对本篇来说，渲染纹理的宽度，高度，颜色格式和深度格式，对效果有一定影响，暂时使用默认设置。 2.2 3D场景添加渲染物 在IDE中的3D场景中，添加希望显示的3D物体，此例中把LayaMonkey添加到3D场景中，如图2-3所示。 （图2-3） 摄像机正对LayaMonkey，同时把摄像机的 Render 组件中的Clear Flag定义为“SolidColor”，并且Clear Color定义为“#000000”。 然后如图2-4所示，改摄像机为正交投影，并调整好摄像机的显示比例。 （图2-4） 2.3 设置摄像机的目标纹理 把之前创建好的渲染纹理文件（RenderTexture），拖入摄像机的目标纹理（Render Target）属性中。此时摄像机就会渲染到纹理， 而不是渲染到屏幕了。如图2-5所示， （图2-5） 2.4 设置Sprite的Texture 在Scene2D中创建一个Sprite，作为显示3D物体的载体，把之前创建的渲染纹理拖入Sprite的Texture属性中，如动图2-6所示， （动图2-6） 可以看到，LayaMonkey已经显示在2D Sprite中了，不过背景是黑色的，需要再次对渲染纹理的颜色格式修改，支持透明色。 2.5 修改渲染纹理属性 如动图2-7所示，修改渲染纹理的颜色格式（Color Format）为“R16G16B16A16”，背景就由黑色变成透明了。 （注意，在2.2节中，摄像机Render组件中的Clear Color的A值要设为0）。 （动图2-7） 仔细观察LayaMonkey，图像比较粗糙，主要原因是渲染纹理的分辨率（Width×Height）是256x256太低导致，下面修改分辨率为1024x1024，如动图2-8所示。 （动图2-8） 这样，LayaMonkey一下变清晰了，到此我们就把3D对象通过渲染纹理的方式，混合到UI界面了。运行效果如动图2-9所示： （动图2-9） 三、代码中混合使用3D LayaAir引擎提供的“2D入门示例”中有完整的3D混合使用代码示例，其中核心代码是通过使用 Laya.RenderTexture 来创建渲染纹理，并把渲染纹理分别应用到摄像机对象和Sprite对象中： // 把3D摄像机视图画到256宽高的纹理上 _camera.renderTarget = new Laya.RenderTexture(256, 256, Laya.RenderTargetFormat.R8G8B8A8, Laya.RenderTargetFormat.DEPTHSTENCIL_24_8); // 再将离屏3D画到2D节点上，至此，就完成把3D画到2D的基础渲染流程 sp.texture = new Laya.Texture(_camera.renderTarget); 运行效果如本篇开始的动图1-1所示。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-11-29 17:33:41 "},"IDE/uiEditor/textureCompress/readme.html":{"url":"IDE/uiEditor/textureCompress/readme.html","title":"纹理压缩","keywords":"","body":"纹理压缩一、概述1.1 纹理压缩的目的1.2 纹理格式种类1.3 总结二、IDE中使用纹理压缩2.1 图片纹理压缩2.2 图集纹理压缩三、代码加载纹理压缩3.1 图片纹理压缩的加载3.2 图集纹理压缩的加载四、优化效果到底怎么样纹理压缩 一、概述 纹理是指物体表面的纹路样式和细腻程度等外观效果。在计算机图形学中，常用于描述三维模型表面图案的二维图形。 我们日常见到和使用的图片格式，主要为PNG和JPG，虽然在三维和二维的某些情况下，也会把这些图片称为纹理，但他们并不是纹理格式，不能被GPU直接读取并显示。因此，这些图片文件要先经过CPU解码成纹理格式，再传送到GPU进行使用。 而纹理格式，自然就是可以被GPU直接读取并显示的格式。所以，一方面，避免CPU解码可以减少运算带来的性能压力。另一方面，就是直接读取并渲染，也可以避免图像解压到内存的占用开销。 1.1 纹理压缩的目的 1，降低内存，特别是移动端应用，内存占用不应过大，否则低端机很容易崩溃。 2，降低带宽，手游类应用，在渲染时会有大量贴图传输到GPU，不限制的话不仅会严重影响渲染性能，同时会带来很严重的发热。 1.2 纹理格式种类 1.2.1 ASTC ASTC（Adaptive Scalable Texture Compression）是一种世界领先的新型纹理压缩格式。ASTC由ARM和AMD联合开发，2012年发布。是一种基于块的有损压缩算法。它的压缩分块从4x4到12x12最终可以压缩每个像素占用1bit以下，并且ASTC格式支持RGBA。以ASTC 4x4 Block Size为例，可以看到每个像素占用8bits即1个字节。因此一张1024x1024的RGBA图片按照该格式压缩后占用的内存大小为1MB。如果你的纹理是选择了生成mipmap的话，那么最终的资源大小还需要乘以1.333也就是大约1.333MB。而相对应的如果采用了ASTC 8x8的格式进行压缩的话，最终纹理资源的大小就应该是 1024 × 1024 × 2 × 1.333333 ÷ 8 ≈ 341K。所以如果想要使用10x10或12x12这种更小的压缩格式的话，选用这两种格式基本也就意味着放弃对画质的基本要求了。因此我们推荐使用6x6的压缩格式。 适配机型： iOS：苹果从A8处理器开始支持ASTC，即iPhone6和iPad mini 4及以上的设备都支持，ASTC格式在iOS设备上的显示效果比PVRTC的效果要好很多(PVRTC格式存在两个大问题：首先是透明贴图在iOS上显示比较模糊，失真；另一点是对于颜色比较丰富的图，特别是UI，颜色过渡大的区域会出现色阶问题，目前的方案一般是拆分Alpha通道。因此在当前情况下iOS上可以全部使用ASTC作为纹理格式。 安卓：安卓中所有支持OpenGL ES 3.1及以上的设备，和大部分支持OpenGL ES 3.0的设备都支持ASTC。因此在安卓上需要根据具体情况来设置纹理压缩格式，一般而言若项目依旧要考虑低端机型，就要退而求其次使用ETC2格式进行压缩。 1.2.2 ETC ETC（Ericsson Texture Compression）最初为移动设备开发，如今它是安卓的标准压缩方案，ETC1在OpenGL和OpenGL ES中都有支持。 RGB ETC1 4 bit：4 bits/pixel，对RGB压缩比6:1，不支持Alpha，绝大部分安卓设备都支持。 RGB ETC2 4 bit：4 bits/pixel，对RGB压缩比6:1。不支持Alpha，ETC2兼容ETC1，压缩质量可能更高，但对于色度变化大的块误差也更大，需要在OpenGL ES 3.0和OpenGL 4.3以上版本。 RGBA ETC2 8bit：8 bits/pixel，对RGBA压缩比4:1。支持完全的透明通道，版本要求同上。 1.2.3 PVR PVRTC（PowerVR Texture Compression）由Imagination公司专为PowerVR显卡核心设计，由于专利原因一般它只被用于苹果的设备，仅iPhone、iPad和部分PowerVR的安卓机支持。 1.2.4 BC1 DXTC（或BC）是微软为DX而推出的基于block的贴图压缩格式，其主要采用调色板的原理来进行压缩。BC1（Block Compression）是最小的一种变体，也是转换比最高的一种，在不需要高精度也不需要a值时可以使用。它将4x4个像素作为一个块（block）存储64位数据，不含有alpha通道，每个block内记录两个16bits的颜色做为基准颜色，然后解压时再使用两个基准色调制出另外两个颜色做为块内4个压缩颜色。 1.2.5 BC3 BC3在BC1的基础上支持alpha通道。首先，颜色的存储方式与BC1相同，需要64bits；对于alpha部分，使用与颜色部分相同的策略来处理。在block存储两个基准的alpha值，然后在其基础上插值得到其它6个共计8个alpha值，来做为alpha的调色板；然后对于每个texel存储一个3bits的索引，用来指向到这8个alpha中的一个。 1.3 总结 ASTC在压缩率、图像质量、种类上都挺不错的，也正在逐步代替ETC和PVR，最大的缺点可能就是兼容性还不够完善和解码时间较长，但以现在移动端的发展趋势来看，GPU计算能力越来越难成为瓶颈，因此非常有希望在以后能成为统一的压缩格式。 整理网络上的一些资料： 桌面端：不需要透明通道使用BC1，需要透明通道使用BC3。 安卓：用ETC2没有什么问题；ASTC在Android 5.0/OpenGL ES 3.1后支持，市场大部分机型都支持，可以考虑选择。 iOS：在iPhone6以上（包含）都支持ASTC，6以下可以选择PVRTC2。 LayaAir 3.0引擎及工具也更新了这一情况，全面支持ASTC标准，也仍然支持ETC1和ETC2_RGB，ETC2_RGBA，同时不再支持PVR。 所以我们建议使用ASTC 6x6作为安卓和iOS统一的压缩纹理格式，而且两个平台只需要一个压缩纹理文件，也节省了项目的使用空间。 二、IDE中使用纹理压缩 2.1 图片纹理压缩 如图2-1所示，LayaAir 3.0可以在IDE中直接操作图片，做纹理压缩的转换。 （图2-1） 点击“layabox.png”图片，可以在右边的属性面板中，看到默认是使用Default选项，纹理格式选择的是“带透明通道的位图(32位)”。在没有纹理压缩前，图片在所有平台都使用此格式。 纹理压缩在PC端和手机端有所不同，如动图2-2所示，若在Default选项中选择“纹理压缩(BC1与ASTC_6×6)”，那么PC就默认使用BC1，Android和IOS默认都使用ASTC_6×6。 （动图2-2） 这里的Default选项只是给了一个通用的设置，开发者如果有需求，还可以分别进行设置，下面就来分别介绍PC端和手机端。 设置纹理压缩格式后，在assets目录下实际上是不会生成对应的压缩文件的。也就是说在预览模式下，也无法使用。只有在发布后，才可以使用压缩纹理，发布方法请参考文档《Web发布》。 2.1.1 桌面端 在PC端以BC1为例（BC3也可以，但PC端不支持ASTC格式），按照如图2-3所示进行设置，勾选PC平台设置后，就可以单独设置纹理格式了。其它平台如果要单独设置也是同样的道理，只需勾选对应的选项即可，后面会再介绍。 （图2-3） 如动图2-4所示，设置好后，可以将图像作为Image组件的皮肤，然后构建发布。 （动图2-4） 如图2-5所示，发布后的目录里，有一个layabox@0.dds文件，这个就是BC1纹理压缩格式的图片。同时生成的还有一个.png图片，因为在设置纹理压缩格式时，虽然PC平台设置的是BC1，但是Android和iOS设置的还是“带透明通道的位图(32位)”，所以生成的”layabox.png“是在Android和iOS运行的纹理格式。 （图2-5） 在发布目录下可以找到一个”fileconfig.json“文件，这个文件中记录了一些对图片属性设置信息，其中包括使用纹理压缩信息，打开.json文件如下： { \"files\": { \"resources\": [ \"layabox.png\" ] }, \"config\": [ { \"sRGB\": true, \"filterMode\": 1, \"mipmap\": true, \"pma\": false, \"files\": [ { \"file\": \"0\", \"ext\": \"dds\", \"format\": 3 }, { \"file\": \"\", \"ext\": \"png\", \"format\": 1 } ], \"platforms\": { \"0\": 0, \"1\": 1, \"2\": 1 }, \"t\": 0, \"i\": 0 } ] } platforms表示图片使用的平台，0表示PC平台，1和2分别指向Android和iOS平台。 运行发布后的Web项目（可以使用anywhere启动本地服务器，参考文档《Web发布》），启动后在Chrome浏览器中打开DevTools工具。如图2-6所示，点击“Network“选项，可以看到使用的是BC1纹理格式，@0表示在PC平台运行。 （图2-6） 2.1.2 手机端 如果我们想针对Android和iOS平台使用ASTC_6x6，设置方法如动图2-7所示： （动图2-7） ASTC格式可以设置纹理质量，有时，质量低的比质量高的会更模糊。 分别对Andorid和iOS选择ASTC_6x6纹理压缩格式，并点击应用后，再将设置好的图像作为Image组件的皮肤，然后构建发布。通过发布web平台，如图2-8所示，来看发布后的文件： （图2-8） 发布出“layabox.png”和“layabox@1.ktx”两个文件。其中“layabox@1.ktx”就是上述操作生成的纹理压缩文件，因为都使用了ASTC_6x6，所以只生成一个压缩纹理文件。如果Android和iOS平台分别配置为不同的格式，那么就会生成两个不同的文件。同时生成的还有一个.png图片，因为在设置纹理压缩格式时，PC平台默认设置的是“带透明通道的位图(32位)”，并没有改变。 发布目录下的”fileconfig.json“文件记录了一些对图片属性设置信息，其中包括使用纹理压缩信息，打开.json文件如下： { \"files\": { \"resources\": [ \"layabox.png\" ] }, \"config\": [ { \"sRGB\": true, \"filterMode\": 1, \"mipmap\": true, \"pma\": false, \"files\": [ { \"file\": \"\", \"ext\": \"png\", \"format\": 1 }, { \"file\": \"1\", \"ext\": \"ktx\", \"format\": 19 } ], \"platforms\": { \"0\": 0, \"1\": 1, \"2\": 1 }, \"t\": 0, \"i\": 0 } ] } platforms表示图片使用的平台，1和2分别指向Android和iOS平台，两个平台都使用files信息中的ktx为后缀的纹理压缩文件。 运行发布后的Web项目，启动后，以Android手机为例来看实际运行效果。在手机的Chrome浏览器中输入启动的Web项目网址，然后连接USB数据线，开启手机的开发者模式，再在PC的Chrome浏览器中输入chrome://inspect/#devices，然后点击inspect。 输入chrome://inspect/#devices后的操作类似小米快游戏的调试方法。 点击后，如下图所示： （图2-9） 可以看到正在使用“layabox@1.ktx”，其中@1表示在Android平台运行。 注意：手机端调试必须使用真机。如果不使用真机，只是在PC平台的Chrome下，使用手机模式（如图2-10），是无法使用到纹理压缩格式的。因为虽然使用了手机模式，但是LayaAir引擎会判断当前运行的平台依然是win32。 （图2-10） 2.2 图集纹理压缩 不仅图片可以纹理压缩，通常我们在2D开发中使用的图集也可以使用纹理压缩格式，如图2-11所示： （图2-11） 自动生成图集的使用方法请参考《Web发布》。 以Android平台为例，在LayaAir IDE中，对自动图集设置进行纹理压缩配置，然后在场景中将图像作为Image组件的皮肤。发布后可以看到图集也可以使用纹理压缩格式了，如图2-12所示，@1.ktx是Android平台的纹理压缩格式，.atlas是图集文件，.png是其它平台默认的纹理格式。 （图2-12） 再用Android手机来看看运行时的情况，图集纹理压缩文件“@1.ktx”成功使用了，如图2-13所示： （图2-13） 到此，在IDE中配置图片纹理压缩和图集的纹理压缩就介绍完了，开发者可以自己来试一试！ 三、代码加载纹理压缩 通过IDE配置纹理压缩后，本身LayaAir引擎是可以自动识别运行平台来使用对应的压缩纹理的，这个改进对开发者来说是非常方便的。如果开发者希望用代码来动态加载也是一样的。 3.1 图片纹理压缩的加载 与正常图片加载一样，在代码中直接使用图片的路径即可。以给Image组件添加皮肤为例，示例代码如下： const { regClass, property } = Laya; @regClass() export class Main extends Laya.Script { onAwake(): void { let img = new Laya.Image; Laya.stage.addChild(img); img.pos(500,100); img.skin = \"resources/layabox.png\"; //纹理压缩的图片的路径 } onStart() { Laya.Stat.show(0, 0); //性能面板 } } 发布后，使用的图片就是压缩后的图片了。 3.2 图集纹理压缩的加载 对于2D图集，预加载图集atlas文件即可，引擎在加载图集的时候，会检测是否包含了纹理压缩转换的信息，如果包含，会自动识别平台并加载对应的纹理压缩格式文件，不需要开发者在代码里判断平台。 示例代码如下所示： const { regClass, property } = Laya; @regClass() export class Main extends Laya.Script { onAwake(): void { Laya.loader.load([\"resource/AtlasConfig.atlas\"], Laya.Handler.create(this, () => { let img = new Laya.Image; Laya.stage.addChild(img); img.pos(500, 100); img.skin = \"resources/img_bg.png\"; //图集中的图片 })); } onStart() { Laya.Stat.show(0, 0); } } 通过示例代码，我们可以看到，图集的纹理压缩的代码使用是无感的，和普通的图集使用方式完全相同。 四、优化效果到底怎么样 由于纹理压缩格式不需要CPU解码，那因解码而产生的瞬间性能压力就没有了，不过如果不是特别多的处理，这个过程并不是持续的，所以并不明显。 比较显著的优化还是在显存上。我们仍然举个例子来说明。 使用IDE里Image组件自带的那张图，我们将宽高改成512*512后， 当舞台上什么显示也没有的时候，初始显存占用是2.31M，使用纹理压缩格式，只增加170K，加上初始大小最终为2.48M。而原图则增加1024K，达到3.31M。如图4-1所示。所以显存优化效果还是非常明显的，减少约83%。 （图4-1） 性能显示面板介绍参考文档《性能统计与优化》。 有一些开发者，还不太理解显存的占用与文件的关系。我这里告诉大家一个简单的计算依据。如果是非纹理压缩的图片，比如PNG和JPG，直接用图片像素的宽*高*4就是显存的占用。 所以有一些游戏，为了减少显存的占用，把图片的宽高像素做小，然后用缩放的方式，再显示放大。不过这种方式，虽然显存占用小了，但是质量的损失也大了。纹理压缩虽然也是有损压缩，但同样质量的情况下，显存占用更小，甚至和原图质量差不多的情况下，也比拉伸的方式内存占用小。所以纹理压缩是开发者比较常用的一种节省显存的方案。 那纹理压缩的显存占用，怎么计算呢，除了统计面板上的信息外，也有一种比较简单的统计方案。直接查看纹理压缩文件的大小就好了，比如纹理压缩文件是170k，那显存占用也是170k。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-12-19 12:23:21 "},"IDE/uiEditor/3DUI/readme.html":{"url":"IDE/uiEditor/3DUI/readme.html","title":"使用3DUI","keywords":"","body":"使用3DUI一、概述1.1 3D UI的本质1.2 3D UI的分类二、IDE中使用UI3D组件2.1 创建一个2D的Prefab2.2 创建Sprite3D，添加UI3D组件2.3 添加2D Prefab资源2.4 更改UI3D属性2.5 调整UI3D位置2.6 脚本控制UI3D使用3DUI 一、概述 2D UI都是纯粹的2D图片按层次显示，不会出现三维立体效果，所以都是直接紧贴着视窗上。而3D UI的原理是，创建的UI控件都在一个三维立体空间中，摄像机是一个透视的摄像机，这和2D UI有着截然不同的区别，因为2D UI是一个正交摄像机。因此如果要出现UI有三维变换的效果，就必须用3D UI。 1.1 3D UI的本质 3D UI也是UI，就需要承担UI的交互职能。例如，当我们点击UI上的按钮时，按钮会带来交互反馈，并触发设定的事件，以达到逻辑运行的目的。 （动图1-1） 1.2 3D UI的分类 场景化UI 3D UI是位于3D场景中，不跟随窗口运动而运动的UI。它更像是一个位于3D场景中的物件，并带有UI的交互特征。 （动图1-2） 透视UI 3D UI是始终位于窗口上，和常规的UI一样。但3D UI可以进行XYZ三个轴上的运动，带来明显的透视变化。 （动图1-3） 二、IDE中使用UI3D组件 2.1 创建一个2D的Prefab 在IDE中使用3D UI，首先需要我们创建一个用于在3D场景中展示的2D UI，这里必须使用Prefab2D来实现。首先，我们先创建一个Prefab2D，在Prefab2D中搭建一个希望实现的2D UI，例如，我们要做一个游戏中人物战斗中头顶的血条，如图2-1所示。 （图2-1） 在Prefab2D中，创建一个Progress组件，因为血条有当前血量和总体血量构成，因此Progress正好符合我们的要求。并且血条上面使用Label显示人物的名字。另外注意Prefab的根节点Box的size最好改为2的N次幂，这符合纹理的2的N次幂原则。 2.2 创建Sprite3D，添加UI3D组件 在IDE的Scene3D节点下，创建一个Sprite3D对象，添加UI3D组件，如动图2-2所示。 （动图2-2） 在Sprite3D节点属性面板中，点击添加组件，选择渲染，选择UI3D组件。可以看到，当添加UI3D组件后，场景中在Sprite3D节点的位置，多了一个显示的纹理（黑色），这个纹理就是用来显示UI的。 2.3 添加2D Prefab资源 准备好UI3D组件后，下一步就是要把之前做好的2D Prefab UI拖入到UI3D组件的Prefab属性中，如动图2-3所示。 （动图2-3） 拖入Prefab后，纹理会立即显示2D UI。但是默认是OPAQUE渲染模式，纹理有黑色的背景色。下面介绍UI3D的属性，来调整纹理效果。 2.4 更改UI3D属性 对于UI3D组件，如图2-4所示，有如下一些属性： （图2-4） Prefab：需要显示的2D Prefab资源文件。 Resolution Rate：纹理的分辨率，当拖入Prefab时，会自动识别Prefab下节点的size，来动态调整纹理的分辨率。 Scale：纹理宽高缩放。基于纹理分辨率的缩放比率，通过控制缩放，让2的幂纹理与UI资源宽高相符。 Billboard：是否使用广告牌模式。若勾选，UI会始终朝向摄像机；若不勾选，则UI永远朝向Z轴方向，即UI在场景中的透视效果。 Enable Hit：是否响应鼠标事件，默认不勾选。勾选后，可以实现按钮的响应、滑动条的拖动、List组件的滑动等。 Render Mode：渲染模式。OPAQUE（不透明）、CUTOUT（裁剪）、TRANSPARENT（透明）、ADDTIVE（效果叠加）、ALPHABLENDED（透明度混合）。 Cull：剔除模式。Off（不剔除）、Front（剔除正面，只显示背面）、Back（剔除背面，只显示正面）。 通常使用的渲染模式为TRANSPARENT，也就是支持透明色，如图2-5所示，背景变成透明的了。 （图2-5） 2.5 调整UI3D位置 我们的需求是做人物的血条，那首先把我们做好的但丁人物拖入到场景中，并设置为（0,0,0）点，如图2-6所示。 （图2-6） 但是可以看到，由于之前创建的Sprite3D也在（0,0,0）点，那么位置就会在人物脚下，这时需要调整Sprite3D的位置，来符合血条的效果，如动图2-7所示。 （动图2-7） 这时来看看运行的效果： （动图2-8） 可以看到随着人物在摄像机前拉进和拉远，血条也在变大变小，很符合实际的效果 。如果用2D UI来实现的话，就需要动态去计算人物相对摄像机的位置来缩放UI的大小，效果肯定不好。 当然，我们也可以不勾选UI3D的 Billboard 属性，调整XYZ轴的旋转，让血条随着人物的旋转而改变朝向。 （动图2-9） 2.6 脚本控制UI3D 通常我们需要对UI中的内容进行操作，此例中血条中血量比例的变化，有向上飘动的伤害数等等，这些都是通过对2D Prefab中UI组件控制来实现的。而UI3D组件通常是用来控制显示效果，比如透视效果，位置信息等。 在2.1节中的Prefab2D中，添加一个Text节点，命名为“value”，并将ProgressBar重命名为“bar”，接着勾选value、bar的定义变量选项。保存场景后，就像处理2D UI的操作一样，在根节点上添加Runtime类，添加逻辑代码如下： const { regClass } = Laya; import { BloodBarBase } from \"./BloodBar.generated\"; import { Main } from \"./Main\"; @regClass() export class BloodBar extends BloodBarBase { onAwake(): void { this.bar.value = 1; this.value.visible = false; Laya.stage.on( Laya.Event.CLICK, this, this.onHurt ); } onHurt(): void { this.bar.value = this.bar.value - 0.1; this.value.y = 35; this.value.visible = true; Main.instance.animator.play(\"Stun\"); Laya.Tween.to( this.value, { y : -20 }, 500, null, Laya.Handler.create(this, this.end)) } private end(): void { this.value.visible = false; } } 上述代码中的Main.instance.animator.play(\"Stun\");表示改变动画状态，目的是在减少血量时播放受到攻击的动画。需要在场景的Scene2D中添加如下脚本： const { regClass, property } = Laya; @regClass() export class Main extends Laya.Script { /** 设置单例 */ static instance: Main; constructor() { super(); Main.instance = this; } @property({ type: Laya.Sprite3D }) private target: Laya.Sprite3D; public animator: Laya.Animator; onAwake(): void { //获得状态机 this.animator = this.target.getComponent(Laya.Animator); } } 最后来看看运行效果： （动图2-10） 到此为止，UI3D组件已经介绍完了，开发者可以在项目中通过使用UI3D组件来实现更多的3D UI效果。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-11-29 17:33:41 "},"IDE/sceneEditor/readme.html":{"url":"IDE/sceneEditor/readme.html","title":"3D场景编辑模块","keywords":"","body":"3D场景编辑器3D场景编辑基础交互使用3D精灵3D基础显示对象使用3D摄像机3D灯光与阴影3D场景环境设置3D模型与动画的导入使用3D场景编辑器 Author: Charley 3D场景编辑器，是3D可视化编辑的核心模块，主要包括3D场景的环境设置、模型的导入与使用、3D节点对象的变换、摄像机、灯光等等3D基础组成部分的可视化使用。 3D场景编辑基础交互 使用3D精灵 3D基础显示对象 使用3D摄像机 3D灯光与阴影 3D场景环境设置 3D模型与动画的导入使用 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:49 "},"IDE/sceneEditor/basic/readme.html":{"url":"IDE/sceneEditor/basic/readme.html","title":"3D场景编辑基础交互","keywords":"","body":"3D场景编辑的基础交互1. 操作视窗摄像机1.1 旋转视窗摄像机：鼠标右键1.2 空间位移视窗摄像机1.3 屏幕内位移视窗摄像机：Q \\ 鼠标中键1.4 视窗摄像机缩放：鼠标滚轮1.5 视窗摄像机绕焦点中心旋转：Alt + 左键拖拽1.6 保存视窗摄像机位置1.7 透视投影与正交投影1.8 局部坐标与全局坐标1.9 显示设置1.10 场景视图刷新频率2. 操作模型2.1 模型位移工具：W2.2 模型旋转工具：E2.3 模型缩放工具：R2.4 模型工具集合：T2.5 模型的多选2.6 模型的吸附3. 对齐3.1 3D对象一键对齐到视窗摄像机：Ctrl+Shift+F3.2 视窗摄像机一键对齐到3D对象：Shift+F3D场景编辑的基础交互 Author: Charley、孟星煜 3D场景中的基础交互，主要是两大类基础操作， 一是，改变场景视窗的摄像机位置与角度，让开发者如同自己的眼睛一样观察3D场景世界。 二是，改变模型的位置与角度，将模型摆放到场景中适当位置。 我们可以使用如图1所示的基础工具， （图1） 也可以使用快捷键切换到对应的工具。 本篇我们逐个分解示意，让大家了解全部的3D场景编辑的交互基础操作。 1. 操作视窗摄像机 1.1 旋转视窗摄像机：鼠标右键 在3D场景中，只要持续按住鼠标右键即进入视窗摄像机的旋转模式，松开鼠标右键即退出视窗摄像机旋转模式。 在该模式下，在屏幕方向上移动鼠标，可以改变视窗摄像机的角度，对整个场景的任意角度进行观察，效果如动图1-1所示。 (动图1-1) 1.2 空间位移视窗摄像机 当按住鼠标右键 + 键盘功能键，可以让摄像机按上下左右前后，具体功能键如下： 功能说明 操作 摄像机向上位移 鼠标右键 + E 摄像机向下位移 鼠标右键 + Q 摄像机向左位移 鼠标右键 + A 摄像机向右位移 鼠标右键 + D 摄像机向前位移 鼠标右键 + W 摄像机向后位移 鼠标右键 + S 位移视窗摄像机的效果如动图1-2所示。 (动图1-2) 上下前后左右，是一个相对的方向，无论旋转到任何角度，都会按这个相对的方向进行位移。 位移视窗摄像机加速： 在位移视窗摄像机的基础上，按住Shift叠加，可以在原功能基础上进行加速移动。 操作按键为：鼠标右键 + shift + (E、Q、A、D、W、S) 1.3 屏幕内位移视窗摄像机：Q \\ 鼠标中键 除了采用鼠标右键 + 键盘功能键（E、Q、A、D）实现视窗摄像机上下左右的位移外，还可以通过快捷键Q或鼠标中键来启动屏幕任意方向位移。 使用快捷键Q时，鼠标左键按下并拖拽，即可实现视窗摄像机在屏幕任意方向位移，效果如动图1-3所示。 (动图1-3) 要想退出该模式，则需要通过其它模式的快捷键，除非是需要持续不断的采用该模式位移视窗摄像机。否则更建议采用鼠标中键来启动屏幕任意方向位移。 鼠标中键的方式，只有在按下并拖拽时才会进入该模式，松开鼠标中键会自动回到其它模式。 1.4 视窗摄像机缩放：鼠标滚轮 视窗摄像机缩放本质上就是视窗摄像机的前后位移，只因在位移过程中，观察目标时基于近大远小的透视原理，有种缩放的错觉，所以称为缩放视窗摄像机。效果如动图1-4所示， (动图1-4） 1.5 视窗摄像机绕焦点中心旋转：Alt + 左键拖拽 在观察或操作具体某个模型时，我们可能需要找一个非正面的合适角度。此时，之前介绍的方式都不太方便。所以围绕目标进行任意旋转是最适合的操作。 要旋转视窗摄像机之前，我们首先要做的事，就是聚焦（选中3D对象，快捷键F），将模型处于视窗摄像机的中心位置。 聚焦后，通过Alt + 左键的组合，左键向任意角度拖拽，即可实现绕焦点中心旋转，效果如动图1-5所示， (动图1-5) 1.6 保存视窗摄像机位置 快捷键 功能 Ctrl + Shift +1/2/3/4/5/6/7/8/9 每一个数字可以存储一个摄像机位置，可以保存9个位置 1/2/3/4/5/6/7/8/9 已经存储的摄像机位置，按对应的数字键可以进行快速切换 如动图1-6所示，在场景面板中，将相机移动到合适位置后，按下快捷键Ctrl + Shift +1，这时，这个摄像机位置就保存在了数字1下，移动相机后，想回到1的位置，按下数字键1即可。 （动图1-6） 剩余位置2~9的操作和1相同，开发者可以根据需求进行保存。 1.7 透视投影与正交投影 如动图1-7所示，基础工具中的透视投影/正交投影表示：当前场景预览摄像机的投影模式为正交投影还是透视投影。 （动图1-7） 1.8 局部坐标与全局坐标 如动图1-8所示，将Cube绕x轴旋转45度，此时可以观察到移动模型相对于局部坐标和全局坐标的区别。 （动图1-8） 1.9 显示设置 点击图1-9所示的显示设置，可以设置Camera和Gizmos属性。 （图1-9） 1.9.1 Camera 参数 作用 Field Of View 透视模式下的视野范围 Near Plane 离摄像机视野方向最近的剪裁面 Far Plane 离摄像机视野方向最远的剪裁面 Zoom Speed 摄像机的缩放速度 Transform Speed 摄像机的位移速度 Post Process 勾选后，开启后处理 Depth Texture 勾选后，开启深度纹理 1.9.2 Gizmos 参数 作用 3D Icons 设置场景中摄像机图标的大小 Show Grid 勾选后，场景中将显示水平面的网格线 Selection Outline 勾选后，选中的模型将显示外边框 1.10 场景视图刷新频率 点击图1-10所示的场景视图刷新频率，可以选择响应式和实时。响应式，是当前的模式，有改动才会刷新；实时，是场景视图以30fps帧率刷新。 （图1-10） 2. 操作模型 操作模型的工具有四种，分别是位移、旋转、缩放、混合使用。可以通过快捷键 W、E、R、T进行启动不同的工具模式。 快捷键名称 按键 模型位移工具 W 模型旋转工具 E 模型缩放工具 R 混合编辑模型 T 2.1 模型位移工具：W 通过快捷键W进入模型位移工具模式后，模型上会出现红绿蓝三色的轴和片。 红绿蓝三个轴分别代表X、Y、Z三个方向，轴的颜色与右上角的坐标轴对应。 箭头所指的方向为正方向，拖动其中一个轴，可使该模型按该轴的正负方向进行位移，效果如动图2-1所示。 (动图2-1) 留意属性面板，如果该模型没有任何旋转（rotation都为0），拖动其中一个轴，只有该轴的属性值会发生变化 。如果有旋转，则会影响其它轴属性值。 三个相邻的面，蓝色为XY面、绿色XZ面、红色为YZ面。 拖动其中一个面，可使该模型在该面范围内任意位移，效果如动图2-2所示。 (动图2-2) 2.2 模型旋转工具：E 通过快捷键E进入模型旋转工具模式后，模型上出现红绿蓝三色的交叉弧线和外层白圈，当鼠标划到模型上时，还会出现一个半透明圆。 红绿蓝三色的弧线分别代表X、Y、Z三个轴的方向，颜色与右上角的坐标轴对应。 选中其中一个弧线后，会变成完整的圆圈，代表按该该轴方向进行旋转，效果如动图2-3所示。 (动图2-3) 外层白圈，是基于屏幕的垂直旋转，效果如动图2-4所示。 (动图2-4) 如果鼠标在半透明圆拖拽，则可以任意角度旋转，效果如动图2-5所示。 (动图2-5) 2.3 模型缩放工具：R 通过快捷键R进入模型缩放工具模式后，模型上不仅有红绿蓝三色轴，还有中心白块和外层白色圆圈。 红绿蓝三色轴分别代表X、Y、Z三个轴的方向，拉动其中一个轴，可在该轴对模式进行缩放，效果如动图2-6所示。 (动图2-6） 中心的白块与外层白色圆圈均是三轴同时缩放，两者的区别仅是缩放速率差异，效果如动图2-7所示。 (动图2-7） 2.4 模型工具集合：T 通过快捷键T进入模型工具集合后，前文介绍的模型操作工具，都会集合到一起。 唯一需要注意的是，混合模式下，中心块缩放不再保留，只能通过外层白色圆圈整体缩放，以及通过拉动各轴的方块从单轴方向缩放，效果如动图2-8所示。 (动图2-8) 2.5 模型的多选 多选的方式分别是框选、Shift、Ctrl这几种方式。 模型的框选，就是通过鼠标拉起屏幕矩形区，只要在矩形区内，无论远近都会被选中。 除了框选，也可以通过Shift或Ctrl结合鼠标点击，进行连续多选。 无论是单选，还是多选，选中的模型都会出现红色边框。 2.6 模型的吸附 2.6.1 下吸附：End 假设有两个立方体，Cube1在上，Cube2在下，选中Cube1，按下End键（Mac: fn+右方向键），如动图2-9所示，Cube1会直接下落到下面的Cube2上。 （动图2-9） 2.6.2 点吸附：V 点吸附是指，基于模型的顶点与目标模型的顶点进行吸附对齐。选中模型后，持续按住快捷键V，即可进入点吸附模式。此时，鼠标可移到当前模型的任何一个顶点上，然后持续按住顶点拖拽到目标模型上，与目标模型的顶点进行吸附对齐。如动图2-10所示，场景中有两个Cube，选中其中一个，按下V键不松开，移动到另一个Cube的顶点上，移动过程中也不要松开V键，可以将两个Cube的顶点对齐。 （动图2-10） 2.6.3 面吸附：Ctrl+Shift 面吸附是指，基于模型与目标模型的网格表面进行对齐。选中模型后，持续按住快捷键Ctrl+Shift（Mac: control+shift），即可进入面吸附模式。鼠标持续按住模型拖拽到目标模型上，模型的中心点会与目标模型的网格表面对齐，此时，可以在目标模型的各个面上移动，但中心点不得离开网格表面，除非退出面吸附模式。如动图2-11所示，将一个Cube的中心点移动到另一个Cube的侧面上，鼠标移动过程中Cube不会发生移动，只有将中心点拖到另一个Cube的面上时，才会移动。 （动图2-11） 如果持续按住快捷键Ctrl+Shift（Mac: control+shift）的同时，持续按下V，可开启面吸附的组合模式。组合模式下Ctrl+Shift+V（Mac: control+shift+V），不再局限于中心点，鼠标可划到当前模型的任意顶点上，然后持续按住该顶点，可以与目标模型的网格表面进行对齐。如动图2-12所示，在面吸附的组合模式下，将一个Cube的顶点移动到另一个Cube的侧面上，鼠标移动过程中Cube不会发生移动，只有将顶点拖到另一个Cube的面上时，才会移动。 （动图2-12） 3. 对齐 3.1 3D对象一键对齐到视窗摄像机：Ctrl+Shift+F 此方法直接改动了目标对象的位置。 比较常用的情况是，选中摄像机后，可以通过Ctrl+Shift+F快捷键，直接将摄像机（Main Camera）一键对齐到视窗摄像机的位置，如动图3-1所示（注意看右下角Main Camera视口的变化）。这样，视窗摄像机看到什么，那摄像机（Main Camera）也可以直接看到什么。方便用户调整，让摄像机的镜头调整更方便、更精确。 （动图3-1） 如动图3-2所示，Ctrl+Shift+F可以应用于其它3D对象。 （动图3-2） 3.2 视窗摄像机一键对齐到3D对象：Shift+F 此方法不改变目标对象位置。 比较常用的情况是，选中摄像机，可以通过Shift+F快捷键，直接将视窗摄像机一键对齐到摄像机（Main Camera）的位置，如动图3-3所示。这样，就能快速转移到摄像机（Main Camera）的视口下了。 （动图3-3） 如动图3-4所示，还可以将视窗摄像机一键（Shift＋Ｆ）对齐到其它3D对象，使其快速具有编辑器的第一人称视口。 （动图3-4） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-07-21 20:43:07 "},"3D/Sprite3D/readme.html":{"url":"3D/Sprite3D/readme.html","title":"使用3D精灵","keywords":"","body":"使用3D精灵（Sprite3D）一、概述二、属性和功能2.1 节点的名字2.2 是否激活2.3 是否为静态2.4 蒙版层2.5 变换三、子父级关系四、克隆五、添加组件六、添加脚本七、各种渲染精灵简介7.1 MeshSprite3D精灵7.2 SkinnedMeshSprite3D精灵7.3 Particle3D 精灵7.4 PixelLine 精灵7.5 Trail 精灵使用3D精灵（Sprite3D） 一、概述 Sprite3D 是3D的基本节点对象，就像Sprite是2D的基本节点对象一样，是LayaAir3D中所有3D节点的父类，包含很多3D精灵基本的功能属性，除此之外还是所有3D组件和脚本的容器。 在LayaAir 3.0编辑器中，我们可以通过鼠标右键来创建一个Sprite3D，如动图1-1所示 （动图1-1） 创建好的Sprite3D，在编辑器场景中，Scene3D下会是一个空节点，如图1-2所示 （图1-2） 基本上我们创建一个Sprite3D空节点的最重要的目的是作为一个根节点，一个项目中会有很多不同功能的根节点，来方面我们管理。另外也可以用Sprite3D来添加组件，下面我们会详细介绍Sprite3D的用途。 二、属性和功能 （图2-1） 图2-1中，可以看到Sprite3D作为一个最基础的3D节点，都具备哪些属性，其它更丰富的3D节点都具备这些属性 2.1 节点的名字 （图2-2） 图2-2中，任何一个节点都有名字，通过名字可以方便的来查找一个节点下是否存在某个名字的子节点，通常会调用如下方法来获取子节点 getChildByName(\"xxx\") /** * 根据子节点的名字，获取子节点对象。 * @param name 子节点的名字。 * @return 节点对象。 */ getChildByName(name: string): Node { for (let child of this._children) { if (child && child.name === name) return child; } return null; } 当我们找到子节点时，也可以对节点做一些基础操作，比如删除掉自己方法 removeSelf() /** * 从父容器删除自己，如已经被删除不会抛出异常。 * @return 当前节点（ Node ）对象。 */ removeSelf(): Node { this._parent && this._parent.removeChild(this); return this; } 具体一个Sprite3D都有哪些基础方法，可以去参考Node节点的基础属性。 2.2 是否激活 （图2-3） 图2-3中，任何节点，都可以通过勾选是否激活来作用于场景中，当不激活某个节点时，下面的所有子节点也会随着根节点处于不激活状态。当然我们也可以通过代码来控制 /** * 获取自身是否激活。 * @return 自身是否激活。 */ get active(): boolean /** * 设置是否激活。 * @param value 是否激活。 */ set active(value: boolean) 2.3 是否为静态 （图2-4） 图2-4所示，是否为静态。在游戏场景中，每一个Sprite3D都有静态或者动态的两种状态，当一个物体标记为static后，就确保这个物体在游戏场景中为静态的、不会移动的物体，进而在游戏的运行过程中让游戏有更加流畅的运行体验。一般而言，在场景中完全静止的物体标记成static是比较好的。这个静止指在游戏运行过程中没有发生移动或者缩放或者旋转等，一般将用于烘焙的节点标记为static。 标记成 static 往往是为了提高效率，比如静态物体的碰撞检测要更快，同时多个使用同一材质的静态物体在绘制的时候只使用一个drawcall，进而节省了CPU。在光照计算上，static的物体也更快一些。 另外，当勾选Static时，编辑器会询问是否同时改变所有子对象的静态标志，如图2-5所示 （图2-5） 当然也可以用代码来控制 /** * 是否为静态。 */ get isStatic(): boolean /** * 是否设为静态。 */ set isStatic(value: boolean) 2.4 蒙版层 （图2-6） 图2-6中，是精灵所在的图层 Layer。渲染相机可进行可视遮罩层的控制，对精灵的渲染与否进行控制，可以参考摄像机文档，其中有对设置不同物体蒙版层后，摄像机选择不同蒙版层的示例。如动图2-7所示 （动图2-7） 如图2-8所示，通过点击Layer，可以选择编辑器已经自定义好的Default，Layer1等等，也可以再次编辑Layer层 （图2-8） 也可以通过代码来设置 /** * 蒙版层。 */ get layer(): number set layer(value: number) //添加显示图层(为相机添加一个蒙版) this.camera.addLayer(5); 2.5 变换 变换组件确定场景中每个精灵的位置，旋转和缩放。同时和Node节点一样具备子父节点的关联关系，使变换操作更灵活，每个精灵都有一个Transform3D。 （图2-9） 我们也可以在编辑器里手动调整精灵的变换 （图2-10） （图2-11） 图2-10用来调整精灵的旋转，图2-11用来调整精灵的缩放 （图2-12） 图2-12可同时用来调整精灵的位置，旋转和缩放。 通过代码，来做变换 //平移 this.position1.setValue(-1.5, 0, 0.0); this.sprite3d.translate(this.position1); //旋转 this.rotate1.setValue(0, 60, 0); this.sprite3d.rotate(this.rotate1, false, false); //缩放 var scale = this.sprite3d.localScale; scale.setValue(0.1, 0.1, 0.1); this.sprite3d.localScale = scale; 三、子父级关系 Sprite3D继承自Node节点，是LayaAir3D中所有3D对象的父类。通过一些示例，我们可以了解子父级关系。 （动图3-1） 通过点击按钮，让父节点移动，同时可以看到子节点也跟随移动 this.layaMonkeyParent.transform.translate(new Laya.Vector3(-0.2, 0, 0); （动图3-2） 通过点击按钮，让子节点移动，可以看到父节点并没有移动 this.layaMonkeySon.transform.translate(new Laya.Vector3(-0.2, 0, 0); 四、克隆 关于克隆，LayaAir3D中提供了几种接口。比较常用的是clone方法 /** * 克隆。 * @return 克隆副本。 */ clone(): Node { var dstSprite3D: Node = Sprite3D._createSprite3DInstance(this); Sprite3D._parseSprite3DInstance(this, dstSprite3D, this, dstSprite3D); return dstSprite3D; } （动图4-1） 通过代码来克隆一个猴子 //克隆一个猴子 let sp = this.layaMonkeyParent.clone() as Laya.Sprite3D; //设置克隆猴子的坐标 sp.transform.position = new Laya.Vector3(1,0,0); //添加到场景中 this.scene.addChild(sp); 其次，这里详细讲解下Sprite3D中特有的克隆接口instantiate /** * 创建精灵的克隆实例。 * @param original 原始精灵。 * @param parent 父节点。 * @param worldPositionStays 是否保持自身世界变换。 * @param position 世界位置,worldPositionStays为false时生效。 * @param rotation 世界旋转,worldPositionStays为false时生效。 * @return 克隆实例。 */ static instantiate(original: Sprite3D, parent: Node = null, worldPositionStays: boolean = true, position: Vector3 = null, rotation: Quaternion = null): Sprite3D { var destSprite3D: Sprite3D = (original.clone()); (parent) && (parent.addChild(destSprite3D)); var transform: Transform3D = destSprite3D.transform; if (worldPositionStays) { var worldMatrix: Matrix4x4 = transform.worldMatrix; original.transform.worldMatrix.cloneTo(worldMatrix); transform.worldMatrix = worldMatrix; } else { (position) && (transform.position = position); (rotation) && (transform.rotation = rotation); } return destSprite3D; } original ：原始精灵。 parent：父节点。 worldPositionStays：是否保持自身世界变换。 position：世界位置，worldPositionStays为false时生效。 rotation：世界旋转，worldPositionStays为false时生效。 该方法可以在克隆时携带父节点信息，世界位置信息和世界旋转信息。 （动图4-2） 通过代码来instantiate克隆一个猴子 //sprite3d的instantiate克隆方法 let layaMonkey_clone1 = Laya.Sprite3D.instantiate(this.layaMonkeyParent, this.scene, false, new Laya.Vector3(-2, 0, 0), new Laya.Quaternion(0, -90, 0)); this.scene.addChild(layaMonkey_clone1); 五、添加组件 LayaAir中，可以对任何3D对象添加Component 组件，如动图5-1所示 （动图5-1） Component 组件，是附加到所有3D对象的内容的基类。 通过代码也可以添加组件，需要物体使用addComponent方法 //添加Rigidbody3D组件 let rigidBody = this.layaMonkeyParent.addComponent(Laya.Rigidbody3D) as Laya.Rigidbody3D; //创建盒子形状碰撞器 var boxShape = new Laya.BoxColliderShape(1, 1, 1); //设置盒子的碰撞形状 rigidBody.colliderShape = boxShape; //使用重力 rigidBody.overrideGravity = true; //重力为向下-10 rigidBody.gravity = new Laya.Vector3(0,-10,0); （动图5-2） 如动图5-2，添加 Rigidbody3D 组件，并且设置重力的效果（需要在“项目设置”中勾选物理相关的“引擎模块”）。 六、添加脚本 在3D世界的开发中，脚本类会在很多地方被使用，给Sprite3D添加一个脚本。如动图6-1所示。 （动图6-1） 我们可以给Main Camera添加一个通过鼠标和键盘来控制摄像机的脚本，这个脚本在实际开发过程中非常的实用，图6-2中，显示摄像机添加了这个脚本。 （图6-2） 脚本的代码为： const { regClass, property } = Laya; @regClass() export class CameraMoveScript extends Laya.Script3D { /** @private */ protected _tempVector3: Laya.Vector3 = new Laya.Vector3(); protected lastMouseX: number = 0; protected lastMouseY: number = 0; protected yawPitchRoll: Laya.Vector3 = new Laya.Vector3(); protected resultRotation: Laya.Quaternion = new Laya.Quaternion(); protected tempRotationZ: Laya.Quaternion = new Laya.Quaternion(); protected tempRotationX: Laya.Quaternion = new Laya.Quaternion(); protected tempRotationY: Laya.Quaternion = new Laya.Quaternion(); protected isMouseDown: boolean = false; protected rotaionSpeed: number = 0.00006; protected camera: Laya.BaseCamera = new Laya.Camera; protected scene: Laya.Scene3D = new Laya.Scene3D; speed: number = 0.01; constructor() { super(); } /** * @private */ protected _updateRotation(): void { if (Math.abs(this.yawPitchRoll.y) this.owner); } /** * 监听键盘事件 */ onUpdate(): void { var elapsedTime: number = Laya.timer.delta; if (!isNaN(this.lastMouseX) && !isNaN(this.lastMouseY) && this.isMouseDown) { Laya.InputManager.hasKeyDown(87) && this.moveForward(-this.speed * elapsedTime);//W Laya.InputManager.hasKeyDown(83) && this.moveForward(this.speed * elapsedTime);//S Laya.InputManager.hasKeyDown(65) && this.moveRight(-this.speed * elapsedTime);//A Laya.InputManager.hasKeyDown(68) && this.moveRight(this.speed * elapsedTime);//D Laya.InputManager.hasKeyDown(81) && this.moveVertical(this.speed * elapsedTime);//Q Laya.InputManager.hasKeyDown(69) && this.moveVertical(-this.speed * elapsedTime);//E var offsetX: number = Laya.stage.mouseX - this.lastMouseX; var offsetY: number = Laya.stage.mouseY - this.lastMouseY; var yprElem: Laya.Vector3 = this.yawPitchRoll; yprElem.x -= offsetX * this.rotaionSpeed * elapsedTime; yprElem.y -= offsetY * this.rotaionSpeed * elapsedTime; this._updateRotation(); } this.lastMouseX = Laya.stage.mouseX; this.lastMouseY = Laya.stage.mouseY; } /** * 释放监听 */ onDestroy(): void { Laya.stage.off(Laya.Event.MOUSE_DOWN, this, this.mouseDown); Laya.stage.off(Laya.Event.MOUSE_UP, this, this.mouseUp); } protected mouseDown(e: Laya.Event): void { this.camera.transform.localRotation.getYawPitchRoll(this.yawPitchRoll); this.lastMouseX = Laya.stage.mouseX; this.lastMouseY = Laya.stage.mouseY; this.isMouseDown = true; } protected mouseUp(e: Laya.Event): void { this.isMouseDown = false; } protected mouseOut(e: Laya.Event): void { this.isMouseDown = false; } /** * 向前移动。 * @param distance 移动距离。 */ moveForward(distance: number): void { this._tempVector3.x = this._tempVector3.y = 0; this._tempVector3.z = distance; this.camera.transform.translate(this._tempVector3); } /** * 向右移动。 * @param distance 移动距离。 */ moveRight(distance: number): void { this._tempVector3.y = this._tempVector3.z = 0; this._tempVector3.x = distance; this.camera.transform.translate(this._tempVector3); } /** * 向上移动。 * @param distance 移动距离。 */ moveVertical(distance: number): void { this._tempVector3.x = this._tempVector3.z = 0; this._tempVector3.y = distance; this.camera.transform.translate(this._tempVector3, false); } } 运行时效果如动图6-3所示 （动图6-3） 七、各种渲染精灵简介 7.1 MeshSprite3D精灵 MeshSprite3D 是引擎中最常用的 静态网格精灵，可根据于美术软件预制作或自定义的网格数据渲染模型。例如图7-1场景中的各种建筑模型、山体岩石一般均为MeshSprite3D （图7-1） 通常我们在实践中会创建简单的Mesh网格3D对象，如图7-2所示 （图7-2） 也可以通过代码添加这些Mesh网格 //正方体 var box = new Laya.MeshSprite3D(Laya.PrimitiveMesh.createBox(0.5, 0.5, 0.5)); this.scene.addChild(box); box.transform.position = new Laya.Vector3(2.0, 0.25, 0.6); box.transform.rotate(new Laya.Vector3(0, 45, 0), false, false); //球体 var sphere = new Laya.MeshSprite3D(Laya.PrimitiveMesh.createSphere(0.25, 20, 20)); this.scene.addChild(sphere); sphere.transform.position = new Laya.Vector3(1.0, 0.25, 0.6); //圆柱体 var cylinder = new Laya.MeshSprite3D(Laya.PrimitiveMesh.createCylinder(0.25, 1, 20)); this.scene.addChild(cylinder); cylinder.transform.position = new Laya.Vector3(0, 0.5, 0.6); //胶囊体 var capsule = new Laya.MeshSprite3D(Laya.PrimitiveMesh.createCapsule(0.25, 1, 10, 20)); this.scene.addChild(capsule); capsule.transform.position = new Laya.Vector3(-1.0, 0.5, 0.6); //圆锥体 var cone = new Laya.MeshSprite3D(Laya.PrimitiveMesh.createCone(0.25, 0.75)); this.scene.addChild(cone); cone.transform.position = new Laya.Vector3(-2.0, 0.375, 0.6); //平面 var plane = new Laya.MeshSprite3D(Laya.PrimitiveMesh.createPlane(6, 6, 10, 10)); this.scene.addChild(plane); 7.2 SkinnedMeshSprite3D精灵 SkinnedMeshSprite3D 是引擎中的 蒙皮动画网格精灵，可根据美术软件预制作的网格数据和Animator组件的动画数据产生动作形变。常用于带蒙皮动画的角色、怪物等。和MeshSprite3D相比具产生网格形变的能力。 （图7-3） 7.3 Particle3D 精灵 Particle3D 是引擎中的 3D粒子精灵,可根据美术人员编辑的粒子参数产生奇妙炫酷的粒子特效。一般用于各种角色技能特效或火焰、烟雾等场景特效。 （动图7-4） 7.4 PixelLine 精灵 PixelLine 是引擎中的 像素线精灵,可根据脚本的绘制数据产生任意颜色的像素线。一般用于场景中的引导效果或项目调试数据用途。 （图7-5） 7.5 Trail 精灵 Trail 是引擎中的 拖尾精灵,可根据精灵运动轨迹产生动态的拖尾特效。一般用于各种轨迹拖尾效果的展示。 （动图7-6） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-11-29 17:33:41 "},"3D/displayObject/readme.html":{"url":"3D/displayObject/readme.html","title":"3D基础显示对象","keywords":"","body":"3D基础显示对象一、概述二、IDE中创建与使用2.1 创建对象2.2 基础变换使用2.3 属性设置2.4 添加组件2.5 添加材质和纹理三、代码创建与使用3.1 代码创建3.2 基础变换使用3.3 属性设置3.4 添加组件3.5 添加材质和纹理3D基础显示对象 一、概述 3D基础显示对象，在3D开发环境中是非常重要的辅助工具，是能够帮助开发者在3D场景中学习和使用的基础，往往对于初学者来说，通过创建和操作3D基础显示对象，可以快速了解3D基础知识，熟悉3D开发环境，同时在没有其它模型资源的情况下，可以快速建立概念，搭建场景，添加不同的组件，也可以快速熟悉代码开发。对于熟练的开发者来说，通过3D基础显示对象，可以方便的模拟和实现一些开发需求，或者用来展示一些开发逻辑，可以大大提高工作效率。 目前LayaAir IDE中可以创建的3D基础显示对象种类有： Cube（立方体） Sphere（球体） Cylinder（圆柱体） Capsule（胶囊体） Cone（锥体） Plane（平面） （图1-1） 如图1-1所示，下面我们来看看在IDE和代码中是如何创建和使用这些3D基础对象的 二、IDE中创建与使用 对于初级开发者来说，在IDE中学会简单的创建和使用3D基础对象是非常重要的一步！ 2.1 创建对象 在一个3D场景的层级面板中，任何节点下，或者是空白位置，都可以通过鼠标右键来创建3D显示对象，如动图2-1所示 （动图2-1） 创建这六种基础对象就不一一演示了，我们可以通过如图2-2的菜单选择创建， （图2-2） 2.2 基础变换使用 移动，旋转，缩放是对3D对象来说最基础的变换操作，如动图2-3所示， （动图2-3） 2.3 属性设置 每个3D基础对象，都具有 MeshRenderer 组件，通过给接收阴影的平面设置Receive Shadow和给产生阴影的立方体设置Cast Shadow来创建阴影效果，如动图2-4所示， （动图2-4） 阴影除了设置3D基础对象的MeshRenderer，还需要保证Direction Light的Shadow Mode不为None。 2.4 添加组件 每个3D基础对象，都可以添加组件来实现高级的功能，通过对立方体添加3D物理组件 Rigidbody3D ，勾选重力属性，最后添加碰撞盒，可以实现模拟自由落体的效果，如动图2-5所示， （动图2-5） 运行时可以看到立方体下落的效果， （动图2-6） 运行物理组件需要在项目设置面板中勾选相应的引擎模块。 2.5 添加材质和纹理 每个3D基础对象，都可以通过创建 Material，并在 MeshRenderer 组件中指定新创建的材质，来设置 albedo Texture 纹理 ，如动图2-7所示， （动图2-7） 三、代码创建与使用 通过代码来创建和使用3D基础对象，也是我们了解和熟悉LayaAir引擎的过程 3.1 代码创建 3.1.1 PrimitiveMesh 类用于创建简单网格 注意：这里还不是最终场景中看到的 Sprite3D。 用 createBox 来举例，看下API是如何创建网格的： /** * 创建Box网格。 * @param long 半径 * @param height 垂直层数 * @param width 水平层数 * @return */ static createBox(long: number = 1, height: number = 1, width: number = 1): Mesh 可以看到，通过 createBox 方法，可以创建Box网格，而且还可以创建不同的垂直和水平高度 因此，可以通过代码创建不同类型的Mesh网格： //正方体 let box = Laya.PrimitiveMesh.createBox(0.5, 0.5, 0.5); //球体 let sphere = Laya.PrimitiveMesh.createSphere(0.25, 20, 20); //圆柱体 let cylinder = Laya.PrimitiveMesh.createCylinder(0.25, 1, 20); //胶囊体 let capsule = Laya.PrimitiveMesh.createCapsule(0.25, 1, 10, 20); //圆锥体 let cone = Laya.PrimitiveMesh.createCone(0.25, 0.75); //平面 let plane = Laya.PrimitiveMesh.createPlane(6, 6, 10, 1)); 创建好的对象是Mesh网格，如果想要创建出场景中能看到的Sprite3D对象，我们还需要使用 Laya.MeshSprite3D 类 3.1.2 MeshSprite3D 使用 MeshSprite3D 类，可以通过构造方法，传入 Mesh 对象，创建出场景能看到的 Sprite3D 对象，同时是带有 Mesh 形状的 Sprite3D 构造方法如下： /** * 创建一个 MeshSprite3D 实例。 * @param mesh 网格,同时会加载网格所用默认材质。 * @param name 名字。 */ constructor(mesh: Mesh = null, name: string = null) { super(name); this._meshFilter = this.addComponent(MeshFilter); this._render = this.addComponent(MeshRenderer); (mesh) && (this._meshFilter.sharedMesh = mesh); } MeshSprite3D 对象是会创建 MeshFilter （网格过滤器）和 MeshRenderer （网格渲染器）组件的。 最后，我们通过 MeshSprite3D 来创建并添加到场景中，代码如下： //正方体 //创建Box网络 let box: Laya.Mesh = Laya.PrimitiveMesh.createBox(0.5, 0.5, 0.5); //创建MeshSprite3D网络 let boxMeshSprite3D: Laya.MeshSprite3D = new Laya.MeshSprite3D(box); //添加到场景中 this.scene.addChild(boxMeshSprite3D); // 三维变换 boxMeshSprite3D.transform.position = new Laya.Vector3(2.0, 0.25, 0.6); boxMeshSprite3D.transform.rotate(new Laya.Vector3(0, 45, 0), false, false); //球体 let sphere: Laya.Mesh = Laya.PrimitiveMesh.createSphere(0.25, 20, 20); let sphereMeshSprite3D: Laya.MeshSprite3D = new Laya.MeshSprite3D(sphere); this.scene.addChild(sphereMeshSprite3D); sphereMeshSprite3D.transform.position = new Laya.Vector3(1.0, 0.25, 0.6); //圆柱体 let cylinder:Laya.Mesh = Laya.PrimitiveMesh.createCylinder(0.25, 1, 20); let cylinderMeshSprite3D: Laya.MeshSprite3D = new Laya.MeshSprite3D(cylinder); this.scene.addChild(cylinderMeshSprite3D); cylinderMeshSprite3D.transform.position = new Laya.Vector3(0, 0.5, 0.6); //胶囊体 let capsule:Laya.Mesh = Laya.PrimitiveMesh.createCapsule(0.25, 1, 10, 20); let capsuleMeshSprite3D: Laya.MeshSprite3D = new Laya.MeshSprite3D(capsule); this.scene.addChild(capsuleMeshSprite3D); capsuleMeshSprite3D.transform.position = new Laya.Vector3(-1.0, 0.5, 0.6); //圆锥体 let cone:Laya.Mesh = Laya.PrimitiveMesh.createCone(0.25, 0.75); let coneMeshSprite3D: Laya.MeshSprite3D = new Laya.MeshSprite3D(cone); this.scene.addChild(coneMeshSprite3D); coneMeshSprite3D.transform.position = new Laya.Vector3(-2.0, 0.375, 0.6); //平面 let plane:Laya.Mesh = Laya.PrimitiveMesh.createPlane(6, 6, 10, 10); let planeMeshSprite3D: Laya.MeshSprite3D = new Laya.MeshSprite3D(plane); this.scene.addChild(planeMeshSprite3D); 运行时效果如下： （图3-1） 3.2 基础变换使用 使用 Transform3D 类，可以对3D基础对象做基础变换，代码示例如下： 代码中的cube就是3.1.2节中的boxMeshSprite3D。 //改变立方体的世界坐标 cube.transform.position = new Laya.Vector3(0, 0, 0); //立方体的平移 cube.transform.translate( new Laya.Vector3(1, 1, 1)); //立方体的旋转 cube.transform.rotate(new Laya.Vector3(0, 45, 0), false, false); //立方体的缩放 cube.transform.setWorldLossyScale( new Laya.Vector3(2, 2, 2)); 3.3 属性设置 通过对 MeshRenderer 组件的属性设置，可以给接收阴影的平面设置Receive Shadow和给产生阴影的立方体设置Cast Shadow来创建阴影效果，代码示例如下： //立方体产生阴影 cube.meshRenderer.castShadow = true; //创建平面 let plane = this.scene.addChild(new Laya.MeshSprite3D(Laya.PrimitiveMesh.createPlane(6, 6, 10, 10))); //平面接收阴影 plane.meshRenderer.receiveShadow = true; 需要保证Direction Light的Shadow Mode不为None。 3.4 添加组件 每个3D基础对象，都可以通过代码添加组件来实现高级的功能，通过对立方体添加3D物理组件 Rigidbody3D ，设置重力属性，最后添加碰撞盒，可以实现模拟自由落体的效果，代码示例如下： //添加Rigidbody3D组件 let rigidbody3D : Laya.Rigidbody3D = cube.addComponent(Laya.Rigidbody3D); //设置重力 rigidbody3D.overrideGravity = true; //创建盒子形状碰撞器 let boxShape: Laya.BoxColliderShape = new Laya.BoxColliderShape(1, 1, 1); //设置盒子的碰撞形状 rigidbody3D.colliderShape = boxShape; 运行物理组件需要在项目设置面板中勾选相应的引擎模块。 3.5 添加材质和纹理 每个3D基础对象，都可以通过代码添加材质和纹理，代码示例如下： //预加载纹理资源 let resource: string = \"layabox.png\"; Laya.loader.load(resource).then( ()=>{ //创建BlinnPhong材质 let materialBill: Laya.BlinnPhongMaterial = new Laya.BlinnPhongMaterial; cube.meshRenderer.material = materialBill; //为材质加载纹理 let tex = Laya.Loader.getTexture2D(\"layabox.png\"); //设置贴图 materialBill.albedoTexture = tex; } ); 运行时效果如下： （图3-2） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-12-04 17:07:19 "},"3D/Camera/readme.html":{"url":"3D/Camera/readme.html","title":"使用3D摄像机","keywords":"","body":"一篇学会使用3D摄像机一、概述二、IDE中的摄像机三、变换3.1 移动和旋转3.2 跟随移动四、Projection4.1 Perspective 透视模式4.2 Orthographic 正交模式五、Render5.1 清除标志5.2 高动态光照渲染5.3 抗锯齿5.4 剔除遮罩六、Output6.1 视图矩形6.2 深度贴图6.3 目标纹理6.4 其它七、通过代码使用摄像机7.1 如何从摄像机创建一条射线7.2 可视遮罩层Layer7.3 捕捉目标7.4 横纵比7.5 目标纹理一篇学会使用3D摄像机 一、概述 我们都知道，电影是通过摄像机将故事与画面呈现给观众。 虚拟的3D世界，也需要通过虚拟的摄像机，将三维画面及情节呈现给用户或者玩家。在3D游戏中，Camera相当于眼睛，通过他来看世界，一切景象都通过Camera来渲染。也就是说如果场景内没有摄像机，那么游戏画面内就不会显示任何物体。场景中的摄像机还可以放置在场景中的子节点中，比如添加到主角角色模型中，同样可以呈现3D画面。 在LayaAir引擎中，我们可以有一个摄像机，也可以有多个摄像机同时工作，这取决于我们开发者的实际需求。 本篇，我们来学习如何控制LayaAir引擎3D摄像机，以及日常使用摄像机的功能介绍。 二、IDE中的摄像机 下面我们先来了解一个3D场景中的摄像机的参数都有哪些，通过创建3D-RPG项目来参考，如图2-1所示 （图2-1） 当我们创建一个新的3D场景时，引擎会自动添加一个主摄像机 Main Camera 在Scene3D节点下。当然也还可以添加更多的摄像机。当我们如图2-1所示，选中主摄像机时，Scene窗口中会出现一个Camera Preview窗口，用来显示主摄像机所看到的视野，这样方便我们来预览，当我们移动或者旋转摄像机时，预览中的视野会随着改变，当然其他的参数设置也会有所变化，后面我们会详细讲解。 通过图2-2所示，LayaAir中摄像机具备如下一些参数设置，这些参数能够很好的满足项目的需要，红色的参数会是我们常用的设置 （图2-2） 三、变换 如图2-2所示，最上面的红色区域内的参数，就是摄像机的位置和旋转，区别于其他场景内的物体，摄像机的位置和旋转，不只是自己的参数，而是能够对我们的视野做出改变。 3.1 移动和旋转 通常我们可以通过Scene窗口下的移动和旋转，来调整摄像机的位置，如动图3-1所示。 （动图3-1） 也可以用另外一种方式定位摄像机，如动图3-2所示， 先在Scene窗口中移动场景， 找到合适你的位置和角度，点Main Camera节点，同时按下 Ctrl+Shift+F ，此时摄像机的位置和角度就会变更到你所定位的点。 （动图3-2） 以上这只是在编辑器中调整摄像机的位置，可能是初始化场景时摄像机的初始位置。 3.2 跟随移动 在3D游戏中，往往我们需要通过代码来调整摄像机的位置，比如摄像机一直跟随主角的移动和旋转来做调整，如动图3-3所示。 （动图3-3） 可以通过代码来处理，在Main Camera节点下添加CameraControll 脚本，随着主角的移动，摄像机的位置也同步移动，代码如下： const { regClass, property } = Laya; @regClass() export default class CameraControll extends Laya.Script { @property( { type: Laya.Sprite3D } ) public target: Laya.Sprite3D; private camera: Laya.Camera; public distanceUp: number = 0.5;//相机与目标的竖直高度参数 public distanceAway: number = 10;//相机与目标的水平距离参数 public smooth: number = 2;//位置平滑移动插值参数值 public camDepthSmooth: number = 20 public curpos: Laya.Vector3; private delatpos: Laya.Vector3; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 * 此方法为虚方法，使用时重写覆盖即可 */ onAwake(): void { this.curpos = new Laya.Vector3(); } /** * 第一次执行update之前执行，只会执行一次 * 此方法为虚方法，使用时重写覆盖即可 */ onStart(): void { this.camera = this.owner as Laya.Camera; if (this.target) { this.target.transform.position.cloneTo(this.curpos); this.delatpos = new Laya.Vector3(); } } /** * 每帧更新时执行，尽量不要在这里写大循环逻辑或者使用getComponent方法 * 此方法为虚方法，使用时重写覆盖即可 */ onUpdate(): void { if (!this.target || !this.camera) return; this.target.transform.position.vsub(this.curpos, this.delatpos); this.camera.transform.position.vadd(this.delatpos, this.delatpos); this.camera.transform.position = this.delatpos; this.target.transform.position.cloneTo(this.curpos); } } 四、Projection （图4-1） 摄像机成相效果的投影方式有两个选项，分别是默认值透视模式Perspective和正交模式Orthographic。在LayaAir IDE中，通过是否勾选Orthographic来选择使用哪种方式。 4.1 Perspective 透视模式 当我们没有勾选Orthographic，就是采用Perspective方式，也是最常用的方式。透视投影的观察体是视锥体，它使用一组由投影中心产生的放射投影线，将三维对象投影到投影平面上去。这种透视模式，是一种模拟了人眼近大远小视觉效果的摄像机成相模式，如动图4-2所示。 （动图4-2） Field of view是视野范围，从动图4-2可以看到，通过修改Field Of View，可以调整透视模式下的视野范围，从4到120度，只有使用透视投影时，Field Of View才有效。 剪裁平面是与摄像机视野方向垂直的平面。通过近裁剪面与远裁剪面两个子参数来设置摄像机渲染的范围，超出范围的部分不会被渲染显示，犹如被剪裁掉的效果。 Near Plane是近裁面，是指离摄像机视野方向最近的剪裁面，小于此距离值的不渲染。 Far Plane是远裁面，是指离摄像机视野方向最远的剪裁面，大于此距离值的不渲染。 这两个参数也是只有使用透视投影时才有效。如动图4-3所示，我们来看看修改这两个参数的效果， （动图4-3） 4.2 Orthographic 正交模式 正交投影模式的观察体是规则的长方体，它使用一组平行投影，将三维对象投影到投影平面上去，如图4-4所示。 （图4-4） Orthographic Vertical Size是视野大小，用于设置正交模式下的视野大小，如动图4-5所示。只有在正交模式下，Orthographic Vertical Size才有效。 （动图4-5） 五、Render （图5-1） 5.1 清除标志 每个摄相机在渲染时，都会先将颜色和深度信息存储起来，也就是ColorBuffer与DepthBuffer，然后下一帧直接读取缓冲区中颜色和深度信息，而不是实时计算的。当使用多个摄像机时，由于每一个摄像机都将自己的颜色和深度信息存储在缓冲区中，那将积累大量的渲染数据。 所以，Clear Flags（清除标记）可以决定是否清除当前渲染之前存储起来的缓冲区信息，该属性功能有四个选项（Sky、SolidColor、DepthOnly、Nothing），下面分别介绍它们具体清除什么缓冲信息。 Sky 天空盒 天空盒是默认选项，表示着清除当前渲染之前的全部摄相机缓冲区的颜色与深度信息，使用天空盒代替。如果没有指定天空盒，则会显示默认清除色（Clear Color属性的颜色）。 SolidColor 纯色 表示着清除当前渲染之前的全部摄相机缓冲区的颜色与深度信息，使用清除色（Clear Color属性的颜色）代替，屏幕上的任何空的部分都将显示当前摄像机的颜色。 Nothing 不清除 表示该选项不清除摄相机缓冲区的信息，颜色与深度信息全都保留着。这样做会导致每帧渲染的结果都会叠加在下一帧之上。 看起来这选项没有存在的必要，事实上的确不常用，但在一些特定场合还是用的上，例如结合自定义shader来使用。 DepthOnly 仅深度 表示着只清除当前渲染之前的全部摄相机缓冲区的深度信息，保留全部摄相机缓冲区的颜色信息。 这个功能非常实用，要想将多个摄像机的画面，渲染到同一个画面，就可以通过DepthOnly选项来实现。 例如，在场景中添加一个新的摄像机Camera2，Clear Flag使用DepthOnly，把摄像机Camera2的视野朝向主角，点击运行。可以看到，场景的渲染不变，还是用的天空盒，但是主摄像机是主角所看到的视野，但是屏幕中还有显示了主角，那就是Camera2所看到的，也就是保留了深度信息。 当Clear Flags的DepthOnly开启后，LayaAir引擎会通过摄像机的渲染顺序来控制。默认的渲染顺序就是节点的渲染顺序，开发者也可以通过LayaAir引擎摄像机的renderingOrder来改变渲染顺序。 如果第一摄像机的Clear Flags设置的是Skybox，那第二摄像机的Clear Flags设置DepthOnly，这时需要第一摄像机的渲染顺序在第二摄像机的渲染顺序之前，如图5-2所示，Main Camera节点在Camera2节点之上，所以两个摄像机的渲染画面才会合并到一起。 （图5-2） 如果顺序反了，Camera2先渲染的话，虽然只清理了深度信息保留了颜色信息。但后渲染的Main Camera会把前面所有缓冲区深度和颜色的都清理掉，所以就没办法看到合并到一起的画面了。 在同一个场景中，可以使用多个摄像机，当加载到场景中后，它们会产生各自的游戏视图画面。在我们以前遇到的游戏中，如双人3D游戏就使用了两个3D摄像机，左半屏幕显示一个玩家，右半屏幕显示另一个，极大的丰富了游戏性。不过多摄像机的缺点是非常耗性能，模型三角面数与DrawCall数量会成倍上升，多几个摄像机就会多出几倍性能损耗，因此开发者们需酌情考虑。 5.2 高动态光照渲染 高动态范围图像（High-Dynamic Range）简称HDR。HDR相比普通的图像，可以提供更多的动态范围和图像细节，它能够更好的反映出真实环境中的视觉效果。 Enable HDR用于开启摄像机的高动态范围渲染功能，默认是不勾选状态，代表默认不开启HDR。 由于HDR需要基于webGL 2.0，所以，当我们在某些不支持webGL 2.0的平台中发布产品时，需要将此选项去掉，或者在引擎里将摄像机的HDR关闭。 开启HDR，还会导致LayaAir引擎抗锯齿功能无效，需要开启抗锯齿功能的，也不能开启HDR。 5.3 抗锯齿 MSAA：多重采样抗锯齿。MSAA首先来自于OpenGL，具体是MSAA只对Z缓存( Z-Buffer)和模板缓存（Stencil Buffer）中的数据进行超级采样抗锯齿的处理。可以简单理解为只对多边形的边缘进行抗锯齿处理。 FXAA：快速近似抗锯齿。FXAA的基本原理与MSAA相同，都是通过提取像素界面周围的颜色信息并完成混合来消除高对比度界面所产生的锯齿。但是FXAA将像素的提取和混合过程交由GPU内的ALU来执行，因此其所占用的显存带宽要大大低于传统的MSAA。 5.4 剔除遮罩 在LayaAir中，可以为每个节点设置所属的Layer(层)，不设置就是默认的Default层。如图5-3所示，是主角这个节点，默认使用Default层， （图5-3） Culling Mask（剔除遮罩），就是针对层的渲染剔除进行设置，通常会与DepthOnly搭配使用。 例如，将Cube节点设置到一个独立的cube层上，Culling Mask选择cube层，那渲染的时候，将会剔除该摄像机其它的节点物体，像遮罩效果一样，只保留cube层上的节点物体，这样，摄像机合并显示的时候，就只合并保留层上的节点物体。如图5-4所示， （图5-4） 代码中设置Culling Mask可以指定单层，也可以多层混合，例如： xx.cullingMask=Math.pow(2,0)|Math.pow(2,1); //该代码表示为第0层和第1层渲染显示。 六、Output （图6-1） 6.1 视图矩形 视图矩形是通过X\\Y\\W\\H四个数值来控制摄像机的视图在屏幕中的位置和大小的功能。这四个数值均使用屏幕坐标系，数值范围是0～1，可以设置小数。 具体的参数说明为： X：水平位置起点 Y：垂直位置起点 W：宽度 H：高度 需要注意的是，在LayaAir中表示屏幕左上角(0,0)位置。如图6-2所示， （图6-2） 假如我们将屏幕水平位置起点X设置为0.25，屏幕垂直位置起点Y设置为0.25，宽度W设为0.5，高度H设为0.5，在LayaAir中效果如图6-3所示。 （图6-3） 6.2 深度贴图 Depth Texture Mode：深度贴图模式。 None：不生成深度贴图。 Depth：生成深度贴图。 这个模式让摄像机生成的深度纹理只携带深度信息。深度纹理中包含了每一个像素点相对于摄像机的距离（深度值）。 DepthNormals：生成深度+法线贴图。在这个模式下，摄像机生成的深度纹理不仅携带了深度信息，同时还包含了物体表面的法线信息。 DepthAndDepthNormals：这个模式是Depth和DepthNormals的结合体。在此模式下，摄像机将同时生成包含深度信息和深度法线信息的纹理。这种类型的深度纹理不仅存储了每个像素的深度值（距离摄像机的距离），还存储了法线信息。 Depth Texture Format：摄像机深度格式与深度纹理的默认值是DEPTH_16，随着深度广泛的使用，有的开发者会发现16位的深度已然不够用，现在增加了24位和32位深度模式的值。用于设置depthTextureFormat属性。 （图6-4） 6.3 目标纹理 目标纹理就是指摄像机的 RenderTarget 属性。它将摄像机的视图放置在一个纹理上，该纹理可以被应用到另一个对象。这样就可以方便地创建镜子，监控摄像机等效果了。注意的是使用了该属性的摄像机将禁用渲染到屏幕的功能。 相关功能还有渲染纹理。 6.4 其它 Opaque Pass：开启opaquePass后，会生成非透明物体贴图。在Shader中可以引入u_cameraOpaqueTexture来得到相机渲染管线的非透明图片。使用非透明物体贴图功能，可以实现玻璃折射，水面折射，热浪等效果。 Enable Blit Depth：设置是否使用内置的深度贴图 (如果开启，只可在后期使用深度贴图，不可在渲染流程中使用)。 七、通过代码使用摄像机 7.1 如何从摄像机创建一条射线 从摄像机创建一条射线，使用的是camera的 viewportPointToRay 方法。生成的这条射线是从摄像机的近裁剪面的一点出发，向远裁剪面的一点。这个射线的反向延长线经过摄像机的原点。 /** * 计算从屏幕空间生成的射线。 * @param point 屏幕空间的位置位置。 * @param out 输出射线。 */ viewportPointToRay(point: Vector2, out: Ray): void { this._rayViewport.x = this.viewport.x; this._rayViewport.y = this.viewport.y; this._rayViewport.width = ILaya.stage._width; this._rayViewport.height = ILaya.stage._height; Picker.calculateCursorRay(point, this._rayViewport, this._projectionMatrix, this.viewMatrix, null, out); } 参照3D-RPG项目，我们加上一段代码，当鼠标点击屏幕时，会发射一条射线，这条射线碰到的点，会创建一个立方体。代码和效果如下所示： //在CameraControll.ts类下的onStart()方法中，加入鼠标按下监听 //Laya.stage.on(Laya.Event.MOUSE_DOWN,this, this.onMouseDown); //鼠标点下事件，处理发射射线，检测碰撞物体 onMouseDown(e: Laya.Event) { let point = new Laya.Vector2(); point.x = Laya.stage.mouseX; point.y = Laya.stage.mouseY; //产生射线 let ray = new Laya.Ray(new Laya.Vector3(0, 0, 0), new Laya.Vector3(0, 0, 0)); this.camera.viewportPointToRay(point,ray); //拿到射线碰撞的物体 let outs : any[] = []; this.scene.physicsSimulation.rayCastAll(ray,outs); //如果碰撞到物体 if (outs.length !== 0) { for (let i = 0; i （动图7-1） 7.2 可视遮罩层Layer 前面5.4节中也提到过Culling Mask的用处，在我们制作游戏时，我们也可用通过代码来达到‘ 隐身 ’的效果。 还是用3D-RPG项目为例，我们先设置两个Layer。 （图7-2） 再把这两个屋子的Layer改为Building1和Building2，如图7-3，7-4所示， （图7-3） （图7-4） 我们在CameraControll.ts类添加如下代码： private layerIndex: number = 0; onMouseDown(e: Laya.Event) { //清除所有图层 this.camera.removeAllLayers(); this.layerIndex++; //设置可视图层 this.camera.addLayer(this.layerIndex%2+ 1); } 效果如动图7-5所示， （动图7-5） 7.3 捕捉目标 在创建摄像机时，我们经常需要调整摄像机的位置，用于对准显示某个三维物体，或显示某个区域。对于初学者来说，空间思维还未形成习惯，调整位置所花的时间会很多。LayaAir的3D变换提供了一个lookAt()方法，用于捕捉目标，自动调整3D对象对准目标点。摄像机也可以使用它达到我们的调整视角的目的。 /** * 观察目标位置。 * @param target 观察目标。 * @param up 向上向量。 * @param isLocal 是否局部空间。 */ lookAt(target: Vector3, up: Vector3, isLocal: boolean = false, isCamera: boolean = true): void 同样，我们在3D-RPG项目中，通过鼠标点击来切换所见区域，代码如下： //CameraControll.ts类脚本中，添加3个节点对象，把3个不同的房子建筑拖入到属性中 @property( { type: Laya.Sprite3D } ) public target1: Laya.Sprite3D; @property({ type: Laya.Sprite3D }) public target2: Laya.Sprite3D; @property({ type: Laya.Sprite3D }) public target3: Laya.Sprite3D; private _up = new Laya.Vector3(0, 1, 0); private index: number = 0; //同样，添加鼠标事件，来修改摄像机对3个建筑的朝向 onMouseDown(e: Laya.Event) { this.index++; if (this.index % 3 === 1 ){ //摄像机捕捉模型目标 this.camera.transform.lookAt(this.target1.transform.position, this._up); } else if (this.index % 3 === 2){ //摄像机捕捉模型目标 this.camera.transform.lookAt(this.target2.transform.position, this._up); } else{ //摄像机捕捉模型目标 this.camera.transform.lookAt(this.target3.transform.position,this._up); } } 效果如下： （动图7-6） 7.4 横纵比 我们一般不会手动设置屏幕的横纵比，在运行过程中会通过计算自动设置横纵比。但是在一些特殊的情况下需要对横纵比手动设置时，可以自己手动设置。如果需要重置横纵比，变回自动改变横纵比，只需要将这个值设置为0。 //手动设置横纵比 camera.aspectRatio = 2; //重置 camera.aspectRatio = 0; 7.5 目标纹理 我们依然用3D-RPG项目为例，Main Camera为场景主渲染摄像机，添加一个新的 renderTargetCamera 为开启 RenderTarget 属性的摄像机。同时在场景中添加一个Plane，面向主摄像机，如图7-7所示。 （图7-7） 接下来，我们把Plane和renderTargetCamera添加到CameraControll.ts脚本中， @property({ type: Laya.Camera }) public renderTargetCamera: Laya.Camera; @property({ type: Laya.Sprite3D }) public plane: Laya.Sprite3D; 并在onStart()中添加代码： //选择渲染目标为纹理 this.renderTargetCamera.renderTarget = Laya.RenderTexture.createFromPool(512, 512, Laya.RenderTargetFormat.R8G8B8A8, Laya.RenderTargetFormat.DEPTH_16, false, 1); //渲染顺序 this.renderTargetCamera.renderingOrder = -1; //清除标记 this.renderTargetCamera.clearFlag = Laya.CameraClearFlags.Sky; //创建一个UnlitMaterial材质 var mat1: Laya.UnlitMaterial = new Laya.UnlitMaterial(); mat1.albedoColor = new Laya.Color(1.0, 1.0, 1.0, 1.0); mat1.cull = Laya.RenderState.CULL_NONE; //指定plane的材质为创建的材质 this.plane.getComponent(Laya.MeshRenderer).sharedMaterial = mat1; //指定纹理为摄像机的渲染目标 mat1.albedoTexture = this.renderTargetCamera.renderTarget; 在LayaAir引擎中，渲染顺序renderingOrder越小，渲染优先度越高。 运行效果如动图7-8所示，场景中多了一个摄像机的视图放在Plane上作为纹理， （动图7-8） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-12-14 20:05:20 "},"3D/Light/readme.html":{"url":"3D/Light/readme.html","title":"3D灯光与阴影","keywords":"","body":"使用3D灯光和阴影一、概述二、PointLight2.1 创建点光源2.2 组件属性2.3 使用代码设置三、DirectionLight3.1 创建平行光3.2 组件属性3.3 使用代码设置四、SpotLight4.1 创建聚光4.2 组件属性4.3 使用代码设置五、AreaLight5.1 创建区域光5.2 组件属性六、如何为灯光添加阴影七、多光源渲染使用3D灯光和阴影 一、概述 光源是每一个场景的重要组成部分。网格和纹理决定了一个物体的形状和外观，但是光源决定了你的环境的颜色和氛围。灯光的种类有多种，不同的光源呈现的效果不同，可以设置不同的参数。 目前光源的种类有： DirectionLight（平行光） PointLight（点光源） SpotLight（聚光灯） AreaLight（区域光） 本篇会一一讲解这四种光源。 二、PointLight PointLight（点光源）是向四面八方发射光线的光源，又称全向光或者球状光，现实中的点光源比如灯泡、蜡烛，可以感觉到点光源是有强度、颜色和衰减半径属性。 如图2-1所示，在一个建筑中，周围都是墙壁，其中创建的点光源，可以通过设置强度，颜色，半径来设置光源效果 （图2-1） 2.1 创建点光源 （动图2-2） 如动图2-2所示，在Scene3D或者任意节点下，鼠标右键选择Light，点击PointLight，即可在场景中创建一个点光源。 2.2 组件属性 2.2.1 基础属性 如图2-3所示，当创建一个PointLight后，在Inspector属性面板中会有如下几个属性 （图2-3） Color：点光源的颜色 （图2-4） Intensity：点光源的强度 （图2-5） Range：设置点光源的范围，相当于点光源的照射范围，数值越大，光照范围越大。 （图2-6） Lightmap Bake Type：光源模式 ​ Mixed：混合光源 ​ 混合光源结合了实时光源和光照烘焙。可以使用混合光源将动态阴影与来自同一光源的烘焙照明相结合，或者在希望灯光提供直接实时照明和烘焙间接照明时使用混合灯光。可在运行时更改混合光源的属性。这样做将更新光源的实时光照，但不会更新烘焙光照。由于混合灯光总是至少结合一些实时和一些烘焙灯光，因此混合灯光总是比完全烘焙灯光涉及更多的运行时计算，并且比完全实时灯光使用更高的内存。 ​ Realtime：实时光源 ​ LayaAir会在运行时为实时光源执行光照计算，每帧进行一次。你可以在运行时更改实时光源的属性，从而创建诸如闪烁的灯泡或穿过暗室的火炬之类的效果。 实时光源可用于在角色或可移动的几何体上提供光照和投射阴影。为实时光源执行运行时计算可能成本很高。 ​ Baked：烘焙光源 ​ LayaAir为烘焙光源执行计算，并将结果作为光照数据保存到磁盘中。这一过程称为烘焙。在运行时，LayaAir将加载烘焙的光照数据，并使用这一数据来照亮场景。由于复杂的计算是预先执行的，因此烘焙光源可以减少运行时的着色成本，并减少阴影的渲染成本。烘焙光源可用于照亮在运行时不会发生变化的对象，例如景物。 2.2.2 烘焙属性 如图2-7所示，当选择Lightmap Bake Type为Baked时，下面会出现三个参数。此功能是为了对烘焙效果提前做出设置。 由于只有在烘焙执行后，才能看到烘焙效果，有可能会对如下参数反复进行调整，不断烘焙出最佳效果。 （图2-7） ​ Box：立方体天空盒 ​ Dome：球形天空盒 Material：指定天空盒的材质 Power：烘焙的光照强度 Radius：烘焙的光照半径 Max Bounces：烘焙的光照最大反弹数 （图2-8） 图2-8所示，为对一个建筑场景添加多个点光源，烘焙后的效果 2.3 使用代码设置 //创建点光源 var pointLight: PointLight = (this.scene.addChild(new PointLight())); //点光源的颜色 pointLight.color = new Color(1.0, 0.5, 0.0, 1); pointLight.transform.position = new Vector3(0.4, 0.4, 0.0); //设置点光源的范围 pointLight.range = 3.0; //设置点光源的强度 pointLight.intensity = 2; 三、DirectionLight Direction Light（平行光）与点光区别较大，它有固定的一个方向，可通过弧度值设定，并且也没有衰减和光照范围，会对全场景所有模型进行照亮。3D世界中经常用来模拟固定方向的太阳光。 当新建一个3D场景时，DirectionLight是默认自带的 如图3-1所示，在一个场景中，通过调整平行光的角度，可以调整场景的光照效果 （动图3-1） 3.1 创建平行光 （动图3-2） 如动图3-2所示，在Scene3D或者任意节点下，鼠标右键选择Light，点击DirectionLight，即可在场景中创建一个平行光。 3.2 组件属性 3.2.1 基础属性 如图3-3所示，当创建一个DirectionLight后，在Inspector属性面板中会有如下几个属性 （图3-3） Color：平行光的颜色 （图3-4） Intensity：平行光的强度 （图3-5） Lightmap Bake Type：光源模式，同点光源一样 Shadow Mode：阴影模式 Shadow Cascades Mode：阴影的级联模式 （动图3-6） 如动图3-6所示，可以开启阴影模式的效果，同时调整平行光的角度，可以看到阴影随着改变。我们将会在第六章介绍阴影 3.2.2 烘焙属性 如图3-7所示，当选择Lightmap Bake Type为Baked时，下面会出现三个参数。此功能是为了对烘焙效果提前做出设置。 （图3-7） Power：烘焙的光照强度 Radius：烘焙的光照角度 Max Bounces：烘焙的光照最大反弹数 3.3 使用代码设置 //方向光的颜色 this.directionLight.getComponent(Laya.DirectionLightCom).color.setValue(1, 1, 1, 1); //设置平行光的方向 var mat: Matrix4x4 = this.directionLight.transform.worldMatrix; mat.setForward(new Vector3(-1.0, -1.0, -1.0)); this.directionLight.transform.worldMatrix = mat; setForward 平行光的方向，分别代表x、y、z轴上的方向，负数为负轴，正数为正轴，值的范围为-1—0—1，超过范围后为-1或1，初学者们可以在这个范围内设值观察方向的变化。 （动图3-8） 如动图3-8，设置平行光旋转看到的效果 四、SpotLight SpotLight 聚光指的是从特定光源方向射出的光，比如手电筒，舞台筒灯等。光照区域根据距离因素逐渐放大，同时光照区域边缘也有衰减现象。 如图4-1所示，在一个场景中，通过调整聚光的锥形角度，可以调整场景的光照效果 （动图4-1） 4.1 创建聚光 （动图4-2） 如动图4-2所示，在Scene3D或者任意节点下，鼠标右键选择Light，点击SpotLight，即可在场景中创建一个聚光。 4.2 组件属性 4.2.1 基础属性 如图4-3所示，当创建一个SpotLight后，在Inspector属性面板中会有如下几个属性 （图4-3） Color：聚光的颜色 （图4-4） Range：聚光的照射范围，与点光类似，区别只是聚光有方向，而点光无方向 （图4-5） Spot Angle：聚光灯的锥形角度，设置的值越小，聚光光圈的越小，反之光圈越大。 （图4-6） 4.2.2 烘焙属性 如图4-7所示，当选择Lightmap Bake Type为Baked时，下面会出现五个参数。此功能是为了对烘焙效果提前做出设置。 （图4-7） Power：烘焙的光照强度 Radius：烘焙的光照半径 Max Bounces：烘焙的光照最大反弹数 Spot Size：聚光的尺寸 Blend：混合比例，0-1之间 4.3 使用代码设置 //聚光灯 var spotLight = scene.addChild(new Laya.SpotLight()) as Laya.SpotLight; //设置聚光灯颜色 spotLight.color = new Laya.Vector3(1, 1, 0); //设置聚光灯位置 spotLight.transform.position = new Laya.Vector3(0.0, 1.2, 0.0); //设置聚光灯方向 var mat = spotLight.transform.worldMatrix; mat.setForward(new Laya.Vector3(0.15, -1.0, 0.0)); spotLight.transform.worldMatrix = mat; //设置聚光灯范围 spotLight.range = 6.0; //设置聚光灯锥形角度 spotLight.spotAngle = 32; setForward 平行光的方向，分别代表x、y、z轴上的方向，负数为负轴，正数为正轴，值的范围为-1—0—1，超过范围后为-1或1，初学者们可以在这个范围内设值观察方向的变化。 （动图4-8） 如动图4-8，设置聚光灯旋转看到的效果 五、AreaLight AreaLight（区域光）可以通过空间中的两个形状之一定义区域光：矩形或圆盘。区域光从该形状的一侧发射光。发射的光在该形状的表面区域的所有方向上均匀传播。区域光提供的照明强度以与光源距离的平方反比确定的速率减小（见平方反比定律）。由于此照明计算非常占用处理器，因此区域灯光在运行时不可用，只能烘焙到光照贴图中。 由于区域光同时从几个不同方向照亮对象，因此阴影趋向于比其他光源类型更柔和、细腻。您可以使用这种光源来创建逼真的路灯或靠近玩家的一排灯光。小的区域光可以模拟较小的光源（例如室内光照），但效果比点光源更逼真。 如图5-1所示，在一个场景中，通过调整区域光的尺寸和扩散，可以调整场景的光照效果 （动图5-1） 5.1 创建区域光 （动图5-2） 如动图5-2所示，在Scene3D或者任意节点下，鼠标右键选择Light，点击AreaLight，即可在场景中创建一个区域光。 5.2 组件属性 5.2.1 基础属性 如图5-3所示，当创建一个AreaLight后，在Inspector属性面板中会有如下几个属性 （图5-3） Color：区域光的颜色 Intensity：区域光的强度 Shape：区域光的形状 ​ Rect：矩形 ​ Elliptic：圆形 Spread：扩散度 5.2.2 烘焙属性 Max Bounces：烘焙的最大反弹数 六、如何为灯光添加阴影 投影是灯光照射模型时产生的即时阴影，可随着灯光角度、灯光强度、模型位置等变化而变化。投影是3D世界最重要的因素之一，能产生更加强烈的立体感。 即时阴影非常损耗性能，不能用得太多，特别是游戏场景，模型量较大，一般我们不使用实时投影，而使用静态的光照贴图。 6.1 灯光的阴影属性 要让场景中产生投影，我们需了解灯光的以下属性，每种光源都具备这些属性 6.1.1 阴影模式 （图6-1） ShadowMode：阴影模式，共分为四种模式： ​ None：不产生阴影 ​ Hard：硬阴影，对性能要求较低 （图6-1-1） ​ SoftLow：低强度软阴影，对性能要求一般 （图6-1-2） ​ SoftHigh：高强度软阴影，对性能要求较高 （图6-1-3）效果最好 硬阴影和软阴影的区别：硬阴影（hard shadow）是指由理想电光源（即聚光性能好的单一光源）产生的阴暗均一、边界分明的阴影,它只包含物体的本影（umbra）。软阴影（soft shadow）则是由线、面或体光源等产生的边界柔和、有一定明暗过度的阴影，它包括物体的本影和半影（penumbra）。当物体完全处于阴影中时，即在本影域内，而当物体受到部分光照时则处于半影域内。 6.1.2 阴影属性 当我们选择一种阴影模式后，可以看到设置阴影的属性 （图6-2） shadowStrength：阴影强度，该值越大，阴影越明显。 （动图6-2-1） shadowDistance：灯光产生阴影的范围，范围是指摄像机到模型的距离，超出这个范围的模型将不会产生阴影与接受阴影，开发者可以根据场景大小进行设置。 （图6-2-2） 图6-2-2中，shadowDistance距离为8时的效果 shadowDepthBias：阴影贴图基于深度的偏移，将深度做一个偏移可以有效解决阴影痤疮（”shadow acne”）。但需要提醒的是：在 shadowDepthBias 过大时会导致阴影脱离物体，即”Peter Panning”现象的出现。 shadowNormalBias：阴影贴图基于法线的偏移，将阴影Caster的表面沿着法线方向的反方向偏移，以防止自身阴影（“shadow acne”）伪影的出现。 较大的值可以更好地防止阴影痤疮（”shadow acne”），但要以阴影形状小于实际对象为代价。 shadowNearPlane：阴影视锥的近裁面，可以对阴影视锥的近裁面进行设置。 6.1.3 阴影的级联模式 （图6-3） shadowCascadesMode：阴影的级联模式，数量越大，产生阴影贴图时，将视锥体划分的子视锥体越多，对应的阴影贴图也越多，阴影的质量会越好。 TwoCascades：二级级联阴影分割比例。 （图6-3-1） 图6-3-1中，TwoCascades的效果 FourCascades：四级级联阴影分割比例，X、Y、Z依次为其分割比例，Z必须大于Y，Y必须大于X。 （图6-3-2） 图6-3-2中，FourCascades的效果 6.2 模型的投影属性 除了光源的阴影设置，需要在模型上设置投影属性：如图6-4所示 （图6-4） receiveShadow：是否接受阴影，当模型此属性为true时，计算出的阴影会在此模型上显示出来。在游戏中，我们可以把场景的地面，及场景中可走动区域中的模型 castShadow 属性设置为true。 castShadow：是否产生阴影，当模型此属性为true时，灯光根据产生阴影的模型位置、模型网格形状大小、与灯光的角度等进行阴影计算，然后在接受阴影的模型上产生阴影。比如场景中的角色、NPC等活动游戏元素可以开启此属性。 如动图6-5所示，展现了平行光实时阴影的效果 （动图6-5） 如动图6-6所示，展现了聚光灯实时阴影的效果 （动图6-6） 6.3 使用代码设置 灯光方面的设置: // Use soft shadow. directionLight.shadowMode = ShadowMode.SoftLow; // Set shadow max distance from camera. directionLight.shadowDistance = 3; // Set shadow resolution. directionLight.shadowResolution = 1024; // Set shadow cascade mode. directionLight.shadowCascadesMode = ShadowCascadesMode.NoCascades; // Set shadow normal bias. directionLight.shadowNormalBias = 4; 开启地面接收阴影和模型产生阴影： // A plane receive shadow. var grid: Sprite3D = scene.addChild(Loader.getRes(\"res/threeDimen/staticModel/grid/plane.lh\")); (grid.getChildAt(0)).meshRenderer.receiveShadow = true; // A sphere cast/receive shadow. var sphereSprite: MeshSprite3D = this.addPBRSphere(PrimitiveMesh.createSphere(0.1), new Vector3(0, 0.2, 0.5), scene); sphereSprite.meshRenderer.castShadow = true; 七、多光源渲染 如图7-1所示，在IDE的项目设置中，可以对支持多光源做设置 （图7-1） Enable Multi Light：是否支持多光源 Max Light Count：最大支持的光源数量，目前最大是50 Light Cluster Count： X、Y、Z轴的光照集群数量 X、Y、Z轴的光照集群数量，Z值会影响Cluster接受区域光(点光、聚光)影响的数量，Math.floor(2048 / lightClusterCount.z - 1) * 4 为每个Cluster的最大平均接受区域光数量，如果每个Cluster所接受光源影响的平均数量大于该值，则较远的Cluster会忽略其中多余的光照影响。 （动图7-2） 动图7-2，为多光源的示例，下面为创建多光源的代码 export class MultiLight extends BaseScript { constructor() { super(); } onAwake(): void { var moveScript: LightMoveScript = this.camera.addComponent(LightMoveScript); var moverLights: LightSprite[] = moveScript.lights; var offsets: Vector3[] = moveScript.offsets; var moveRanges: Vector3[] = moveScript.moveRanges; moverLights.length = 15; //添加15个点光源 for (var i: number = 0; i this.scene.addChild(new PointLight())); pointLight.range = 2.0 + Math.random() * 8.0; pointLight.color.setValue(Math.random(), Math.random(), Math.random(), 1); pointLight.intensity = 6.0 + Math.random() * 8; moverLights[i] = pointLight; offsets[i] = new Vector3((Math.random() - 0.5) * 10, pointLight.range * 0.75, (Math.random() - 0.5) * 10); moveRanges[i] = new Vector3((Math.random() - 0.5) * 40, 0, (Math.random() - 0.5) * 40); } //添加一个聚光灯 var spotLight: SpotLight = (this.scene.addChild(new SpotLight())); spotLight.transform.localPosition = new Vector3(0.0, 9.0, -35.0); spotLight.transform.localRotationEuler = new Vector3(-15.0, 180.0, 0.0); spotLight.color.setValue(Math.random(), Math.random(), Math.random(), 1); spotLight.range = 50; spotLight.intensity = 15; spotLight.spotAngle = 60; } } //光源移动脚本 class LightMoveScript extends Laya.Script { forward: Vector3 = new Vector3(); lights: LightSprite[] = []; offsets: Vector3[] = []; moveRanges: Vector3[] = []; onUpdate(): void { var seed: number = Laya.timer.currTimer * 0.002; for (var i: number = 0, n: number = this.lights.length; i Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-11-29 17:33:41 "},"IDE/sceneEditor/environment/readme.html":{"url":"IDE/sceneEditor/environment/readme.html","title":"3D场景环境设置","keywords":"","body":"3D场景环境设置一、概述二、场景天空2.1 组件属性2.2 使用代码设置场景天空材质2.3 IDE中创建天空盒三、环境光3.1 组件属性3.2 固定颜色3.3 球谐光照四、环境反射4.1 组件属性4.2 天空盒作为反射源4.3 自定义反射源作为反射源4.3 IBL介绍五、场景雾5.1 组件属性5.2 代码使用六、光照贴图6.1 组件属性6.2 创建光照设置文件6.3 属性详解6.4 烘焙七、场景管理7.1 创建新场景7.2 场景重命名7.3 设置为启动场景八、场景切换和加载资源8.1 代码切换场景8.2 场景资源加载3D场景环境设置 本篇，我们将全面了解LayaAir3.0 3D场景编辑的强大功能 （图1-1） 一、概述 场景即为LayaAir引擎的3D世界容器，用于呈现游戏的3D画面和加载各种3D元素，游戏中的摄像机，灯光，人物，物品等都需要放到场景中才能展示出画面，相当于一个游戏3D播放器或者3D视图。 在LayaAir3.0引擎中，3D和2D可以混合使用，创建的Scene 3D场景和Scene 2D容器或元素可以同时加载到舞台上。 下面我们先来了解一个3D场景的参数都有哪些，为了让一个3D场景达到一个好的效果，都需要考虑的因素。我们通过创建3D-RPG项目来参考，如图1-2所示 （图1-2） 创建后的3D-RPG项目，如图1-3所示，这个项目本身就是一个场景 从Hierarchy窗口中，可以看到Scene3D和Scene2D根节点，这里我们只讲解Scene3D场景，其中包括了3D场景中重要的组成部分，3D摄像机，3D精灵等等，我们会在其它文档中讲解 （图1-3） 当我们点击Scene3D节点，在Inspector下看看都有什么参数信息，如图1-4所示 （图1-4） 从图1-4看到几个组件，也就是我们需要关心的几个内容，接下来讲解场景涉及到的内容： 环境天空 环境光 环境反射 环境雾 光照贴图（烘焙） 二、场景天空 场景天空的实现方式是天空盒，天空盒是一种让场景看上去更广阔无垠的一种视觉技术，用无缝对接的封闭纹理将摄像机的视口360度无死角的包裹起来，天空盒也就是3D世界中的天空。 图2-1中我们可以看到天空盒。天空盒的思想就是绘制一个大的立方体，然后将观察者放在立方体的中心，当相机移动时，这个立方体也跟着相机一起移动，这样相机就永远不会运动到场景的边缘。这与我们真实世界中的情况一样的，我们可以看见远处的天空接触到了地平线，但是不论我们怎么朝着那个方向移动，都不可能到达那个地方。 （图2-1） 天空渲染器组件 Sky Renderer 是Scene3D场景默认的组件，用来指定天空盒的网络形状。 （图2-2） 2.1 组件属性 Mesh Type：网格形状。目前引擎提供常见的两种天空盒网格：立方体 和 球形 。其中立方体网格更为常用。 ​ Box：立方体天空盒 ​ Dome：球形天空盒 Material：指定天空盒的材质 （图2-3） 展开DefaultSkyMaterial，如图2-3，就是正在使用的天空盒材质，目前我们使用LayaAir内置的SkyPanoramic着色器，SkyPanoramic的颜色和纹理是两个最重要的设置，我们会在材质一章中详细介绍LayaAir3.0提供的3种天空盒材质 SkyPanoramic、Skybox、SkyProcedural 注意：如果需要使用SkyProcedural程序化天空，那么只能使用球形天空。因为这种材质使用的顶点着色，需要跟精细的顶点信息。 关于天空盒使用的材质SkyProcedural 程序化天空材质 与SkyBox天空盒材质在后面的 Material材质 篇有讲解 关于 SkyPanoramic 材质，下面看看如何设置 Tint Color：颜色，如图2-4，改变颜色，可以看到改变后的颜色叠加到纹理上了 （图2-4） Rotation：旋转，从0到360度，旋转可以帮助我们调整天空盒的位置 天空盒随着视角的旋转改变，我们可以观察到四面八方都有远景效果。目前提供的这两种网格中，盒型天空的顶点数据要更少，所以这种天空的性能要更好一些。 Panoramic Texture：天空盒的纹理贴图（一张球形模型对应的贴图） 2.1.1 立方体天空 立方体天空盒用到的6张可以无缝相接的贴图参考，图2-5所示 （图2-5） 2.1.2 球形天空 是一个球形模型及一张对应的贴图构成。示例中用到的是一张球形模型对应的贴图，如图2-6 （图2-6） 基本上用到纹理和颜色后，配置好天空盒材质，就可以为我们的场景添加好天空效果 （动图2-7） 运行3D-RPG项目，旋转摄像机，可以看到天空盒的效果，如动图2-7所示 2.2 使用代码设置场景天空材质 当然我们也可以通过代码来加载和指定天空盒 var skyRenderer = this.scene.skyRenderer; //加载相机天空盒材质 Laya.Material.load(\"sky2.lmat\", Laya.Handler.create(null, function(mat: any) { //修改天空盒渲染器的天空盒材质 skyRenderer.material = mat; })); 2.3 IDE中创建天空盒 2.3.1 更改IDE默认的球形天空盒 当我们用IDE场景一个3D场景时，默认是采用SkyPanoramic材质的球形天空盒，如图2-8所示 （图2-8） 由于系统的材质是在IDE内部，无法直接修改，如果需要修改的话，可以通过克隆的方式复制一个同样的天空盒材质到assets目录下，如动图2-9所示 （动图2-9） 然后准备好一张新的球形天空盒贴图，如图2-10所示 （图2-10） 拖入新的贴图到克隆后的材质中，如动图2-11所示 （动图2-11） 此时，不管是在IDE的场景中还是预览的效果，天空盒都换成了新的了 2.3.2 更改立方体天空盒 如果开发者像使用立方体天空盒，首先我们更改上述天空盒材质为Skybox，如动图2-12所示 （动图2-12） Laya.SkyBox材质是支持6张可以无缝相接的贴图，但是需要先创建一个Cube Texture，如动图2-13所示，在assets目录下创建Cube Texture （动图2-13） 在Cube Texture中，添加好预先准备好的6张贴图，并点击应用，如图2-14所示 （图2-14） 最后，拖入配置好贴图的Cube Texture到skyBox材质的天空盒Texture中，立方体天空盒就配置好了，运行场景可以看到效果 （图2-15） 三、环境光 环境光，也称为漫反射环境光，是场景周围存在的光。并且不来自任何特定的光源。它可以对场景的整体外观和亮度做出重要贡献。 环境光在许多情况下都很有用，这取决于您选择的艺术风格。如果需要在不调整单个灯光的情况下增加场景的整体亮度，也可以使用。 图3-1所示，在3D-RPG项目中EnvironmentLight组件来指定环境光 （图3-1） 3.1 组件属性 Ambient Mode：环境光的模式，分为两种 ​ Ambient Color：固定颜色。使用环境光颜色 Ambient Color 作为环境光源 ​ Ambient Intensity：颜色强度。 ​ Spherical Harmonics：球谐光照，通过天空盒生成的球谐数据，直接作用到物体上，后面会介绍当选用球谐光照时，采用IBL来调整效果 3.2 固定颜色 图（3-2） 我们用一个简单的场景来做参考，当我们关掉Direction Light后（图3-2） 动图（3-2） 可以看到使用Ambient Color时，调整颜色对环境光的变化，如动图3-2所示 3.1.1 代码使用 环境光颜色AmbientColor，是对材质进行颜色融合染色，使材质趋于某种颜色色调，同时还能对材质进行提亮，模拟灯箱发光效果。如果设置了天空盒且不设置Scene3D场景的AmbientColor，那么LayaAir3.0会默认使环境光来源于天空盒，也就是球谐光照。 我们也可以通过代码来修改当前场景的环境光 //设置场景环境光 scene.ambientColor = new Laya.Color(0,0,0,0); 3.3 球谐光照 可以看到采用球谐光照的效果，物体的表面受天空盒的影响，如动图3-3所示，下一节我们会介绍采用球谐光照作用到环境反射IBL方式的具体用法 动图（3-3） 四、环境反射 环境反射功能为场景中的每个地方提供了有效的光滑反射效果。 一些重要的材质，比如金属，都依靠各个方向反射效果，这正是环境反射提供的功能。 场景环境反射分两种，天空盒反射与自定义反射。想要有反射效果就必须在物体Shader中有反射材质，如果没有反射材质也是没有效果的，默认的BlinnPhong不支持，PBR材质是支持环境反射的 ReflectionProbe是Scene3D场景的环境反射组件，如图4-1 （图4-1） 4.1 组件属性 Source：反射来源 ​ Skybox：选择此选项可使用天空盒作为反射源 ​ Custom：选择此选项可使用自定义反射源 Resolution：如果选择天空盒反射，可以是设置分辨率 4.2 天空盒作为反射源 上一章的球谐光照的效果，动图（3-3），展示了用场景设置的天空盒作为环境反射 4.3 自定义反射源作为反射源 Cubemap：如果选择自定义反射，会使用cubemap，是一个由六个独立的正方形纹理组成的集合，它将多个纹理组合起来映射到一个单一纹理，如图4-2所示 （图4-2） 注意：纹理贴图要设置成Cube的纹理形状 （图4-3） 把cubemap图拖入到cubemap中，配置Cubemap 如图4-4所示，然后点击 Generate Light 生成反射效果 （图4-4） 如图4-5所示，球体的反射采用指定的天空盒纹理，而不采用场景的天空盒 （图4-5） 不管是哪种天空盒，我们都可以使用IBL来更好的处理反射效果，但是第一步我们先要生成光照 Generate Light 通过点击 Generate Light 按钮，开始生成环境反射，如图4-6所示 （图4-6） 生成过程介绍后，从ReflectionProbe 组件中，可以看到IBL Tex多了天空盒的贴图，如图4-7所示 （图4-7） 4.3 IBL介绍 IBL 是基于物理渲染的真实感的重要来源，是对环境光照的一种处理方案。对于大部分情况来说，环境光来自于天空盒，也就是 cubemap 贴图。因此，IBL 的重点就在于如何从图像中获取光照信息。 iblSamples：基于图像的光照的采用率，采样的越多，就越接近真实 ibl Tex：环境立方体贴图 (Cubemap) ibl Tex RGBD：默认采用RGB深度图 采用IBL时，环境光必须采用 Spherical Harmonics 方式，当点击 Generate Light 后，可以看到IBL Tex纹理会自动生成，并可以在3D物体的材质种调节反射效果。 五、场景雾 雾化效果在项目中起着重要的作用，雾化效果就相当于开启大气的效果，看起来有种朦朦胧胧的感觉，让场景更真实。LayaAir 3.0引擎可以设置场景的雾效可见距离（相当于浓度）及雾效的颜色。雾化使用的恰当不但可以提升游戏性能，还可以增加游戏的体验。 雾化组件 Fog 是Scene3D场景默认的组件，如图5-1所示 （图5-1） 5.1 组件属性 Fog Start：雾化的起始位置 Fog Range：雾化最浓处的距离 Fog Color：雾化的颜色 首先勾选雾化属性，然后调整雾化的范围，雾化的颜色 5.2 代码使用 //雾化代码 this.scene.enableFog = true; //设置雾化的颜色 this.scene.fogColor = new Laya.Color(0,0,0.6); //设置雾化的起始位置，相对于相机的距离 this.scene.fogStart = 10; //设置雾化最浓处的距离。 this.scene.fogRange = 40; 六、光照贴图 在3D游戏场景中，依赖灯光与模型即时渲染产生投影及颜色影响，是非常耗性能。特别是在移动平台上，手机的显卡功能并不强大，如果全部使用即时光影，性能开销是非常大的，游戏也会变得卡顿。 场景光照贴图就是为了解决这个问题，其优点就是可以通过较少的性能消耗使静态场景看上去更加真实，丰富，更具有立体感。缺点就在于不能实时的处理动态光照。 我们来对比下未使用光照贴图和使用光照贴图的效果 （图6-1）未使用光照贴图 （图6-2）使用了光照贴图 我们看到区别是很明显的，现在来讲解怎么生成光照贴图。 6.1 组件属性 当我们创建一个新的场景的时候，默认 Lighting 组件是没有任何设置的，如图6-3 （图6-3） Lightmaps：光照贴图，可以是一组贴图，在没有烘焙的情况下，不需要点击加号+ Lighting Setting：光照贴图设置文件，下面我们将创建这个文件 Bake：Bake按钮用来生成烘焙 6.2 创建光照设置文件 接下来创建一个LightingSetting文件，如果6-4 （图6-4） 将生成的文件，拖入到 Lighting Settings 里 （图6-5） 6.3 属性详解 下面我们可以看到 LightingSettings 的所有属性 （图6-6） Max lightmap size：光照贴图的最大尺寸，尺寸越大越清晰 Mode： ​ Bake：模式将生成烘焙图（根据场景分配几张） ​ View：模式将生成渲染图（只有一张） Max sample：采样值，越大效果越好，时间越长 Denoise：消除光照贴图中的噪点，去噪设置 ​ Enable：是否开启 ​ prefillter：去噪方式，可以选择 ​ accurate 精细 ​ fast 快速 ​ none 无 ​ Denoise Type：去噪方法，可以选择 ​ optix 去噪optix方法 ​ openimagedenoise 去噪openimagedenoise方法，业内最好的方法 ​ none 无 AO：控制烘焙环境遮挡中表面的相对亮度。用于烘焙光照的光照贴图计算的间接光照。 ​ Bounces：AO弹射次数，值越大，越慢。默认：8 ​ Factor：AO影响参数。默认：1 ​ Distance：影响AO的最大距离，值越大，效果会好，但是烘焙速度越慢。默认：6 Bounce：光线反弹次数 ​ Diffuse bounce：漫反射光线反弹次数。默认：4 ​ Transmission bounce：透射光线反弹次数。默认：12 ​ Glossy bounce：玻璃反弹次数。默认：4 ​ Total bounce：反弹次数。默认：3 Sample_clamp_direct：默认：0，用来减少直接光噪点 Sample_clamp_indirect：默认：10，用来减少间接光噪点，但是灯光会变暗 Margin：渲染扩展边，用来解决边界黑缝的问题，一般选择16 Margin higher filter：边界是否高精度采样 Scene Module Scale：整个场景lightmap大小的缩放 6.4 烘焙 设置好参数后，点击Bake，等几分钟之后，会自动生成烘焙后的光照图，并添加到 Lightmaps 中，如图6-7所示 （图6-7） 光照贴图就是在物体本身的贴图基础上生成了一张新的贴图，如图6-8所示 （图6-8） 烘焙后的场景，树上带有光照效果和阴影效果，如图6-9所示 （图6-9） 通过对比，我们能看到光照贴图所带来的效果，并且渲染效率很高，不需要用实时光照。图6-10是没有用光照贴图的对比图 （图6-10） 七、场景管理 3D-RPG项目仅仅是只有一个场景的3D项目，大型的项目是由多个场景组成的，合理的管理3D场景会提高我们开发效率。 7.1 创建新场景 打开3D-RPG项目的Project资源目录，可以看到这里有个scene文件夹，如图7-1所示，这里来存放其它场景文件是比较好的习惯，看起来也比较清晰。 （图7-1） 例如在3D-RPG项目中，有了Game场景，可能还需要有游戏登录场景，那么我们来创建一个 Login 场景，如动图7-2所示 （动图7-2） 也可以从编辑器的File菜单里的New Scene来创建场景，保存到scene目录下，如动图7-3所示 （动图7-3） 7.2 场景重命名 想对场景进行重新命名，可以直接在Project里对场景文件进行改名操作，如动图7-4所示 （动图7-4） 7.3 设置为启动场景 通常 Login 场景是启动场景，因此我们在Project Settings中可以设置启动场景，如动图7-5所示 （动图7-5） 八、场景切换和加载资源 在3D游戏开发过程中，往往我们需要制作多个场景，游戏的主程序需要加载场景做切换，同时释放老的场景资源和内存 8.1 代码切换场景 示例代码如下： //打开指定的场景，同时显示Scene2D和Scene3D Laya.Scene.open(\"scene/Game.ls\",true, null, Laya.Handler.create(this, this.onLoaded), Laya.Handler.create(this, this.onLoading)); //关闭指定的场景 Laya.Scene.close(\"scene/Login.ls\") //销毁指定的场景 Laya.Scene.destroy(\"scene/Login.ls\") 8.2 场景资源加载 示例代码如下： //用Laya.Scene3D的方式加载 Laya.Scene3D.load('scene/Game.ls', Laya.Handler.create(null, function (res:any){ Laya.stage.addChild(res); })); //用Laya.loader的方式加载，加载后根节点是Scene2D Laya.loader.load('scene/Game.ls', Laya.Handler.create(this, this.onLoaded), Laya.Handler.create(this, this.onLoading)).then( (res)=>{ let scene = res.create(); //scene.scene3D 可以获得Scene3D资源 Laya.stage.addChild(scene.scene3D); }); Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-11-29 17:33:41 "},"3D/useModel/readme.html":{"url":"3D/useModel/readme.html","title":"模型与动画的导入使用","keywords":"","body":"3D模型与动画的导入使用一、骨骼蒙皮动画1，模型文件导入2，贴图设置关联3，骨骼蒙皮动画导入及使用4，多个单独骨骼蒙皮动画文件使用5，代码运行示例二、刚体动画1，glTF或fbx文件导入2，动画导入及使用3D模型与动画的导入使用 LayaAir支持的模型后缀为fbx与gltf，支持导入的3D动画为骨骼蒙皮动画与刚体动画 一、骨骼蒙皮动画 在LayaAir中只能制作比较简单的动画，要想要复杂的动画，比如人物跑步的动画，那就要在外部的软件中制作并且导入到LayaAir中使用。通常我们需要使用3dMax软件制作模型和动画，并导出为Fbx格式文件，下面将介绍如何导入3D模型及动画 1，模型文件导入 将Fbx放入Assets目录下 （图1） 打开LayaAir IDE，IDE会识别Fbx文件并可以展开Fbx文件，看到图2中的文件信息，其中Take_001是Fbx自带的骨骼蒙皮动画文件，也是自身待机动画 将Fbx拖入Scene3D场景下，可以看到模型，但是没有贴图和动画，下面先介绍如何为LayaMonkey添加材质和贴图 （图2） 2，贴图设置关联 将贴图文件放入Assets下 （图3） 需要创建一个材质文件，来为模型配置贴图等信息 （图4） 点击新建的Material文件，右面可以看到很多配置信息，这里我们只需要将贴图文件拖入到材质文件中， （图5） 将材质文件拖入LayaMonkey的SkinnedMeshRenderer组件的Materials中 （图6） 可以看到模型已经有贴图效果了 （图7） 3，骨骼蒙皮动画导入及使用 下面介绍如何为LayaMonkey添加动画 当Fbx文件拖入到Scene3D场景中时，会自动添加Animator组件，如果没有可以自行添加Animator组件，并且保证AlwaysAnimate模式 （图8） 此时，我们需要创建一个AnimationController文件，也就是3D动画状态机 （图9） 将新创建的Animation Controller文件，拖入到Animator组件中 （图10） 双击AnimatorController后，将Take_001动画文件拖入Animator窗口中 （图11） 再次点击Scene窗口，点击下面的动画文件预览可以看到动画效果 （图12） 此时运行IDE，可以播放LayaMonkey动画，也可以将LayaMonkey拖入Assets目录下，作为预制体，方便重用或者代码实现 （图13） 4，多个单独骨骼蒙皮动画文件使用 大多数情况下，含动画的模型导出的Fbx文件会同时包含网格信息和动画信息，但是也有一些情况fbx文件只需要导出动画信息。例如同一个模型有很多动画，网格信息只需要一个就够了，其他动画信息可以通过单独的模型文件（不包含网格信息）导出。在制作动画时应该考虑动画的重用，用于场景中同类的模型。例如，不同的人形角色可能都使用相同的走动和跑步动画。只要保持骨骼结构一致，动画就可以重用。 图14中，以girl为例，我们将不带动画信息的Fbx文件和多个只带动画的Fbx文件放入Assets中 （图14） 创建好AnimatorController后，并将待机和跑步动画拖入Animator窗口中，可修改动画名字 （图15） 注意：此时idle待机动画是默认动画 如图16所示，我们可以分别预览待机和跑的动画，并设置是否循环播放 （图16） 多个单独的骨骼蒙皮文件就设置成功了，单独的动画也可以设置到其它的模型去重用 5，代码运行示例 如下代码，我们可以在任何场景下，加载girl预制体，添加到场景中，并用鼠标点击屏幕来切换动画 import { MainBase } from \"./Main.generated\"; import KeyBoardManager = Laya.InputManager; import Keyboard = Laya.Keyboard; const { regClass, property } = Laya; @regClass() export class Main extends MainBase { private _animator: Laya.Animator; private _isRun: boolean; onAwake() { console.log(\"Game start\"); //加载指定的模型预制体，并添加到Scene3D场景内 Laya.loader.load(\"girl/girl.lh\").then(res => { let girl : Laya.Sprite3D = res.create(); this.scene3D.addChild(girl); //获得Animator this._animator = girl.getComponent(Laya.Animator); }); this.on( Laya.Event.MOUSE_DOWN, this, this.switchAni ); } switchAni(): void { if (this._isRun) { //播放对应的动画 this._animator.play(\"idle\"); } else { this._animator.play(\"run\"); } this._isRun = !this._isRun; } } 二、刚体动画 1，glTF或fbx文件导入 将glTF放入Assets目录下，打开LayaAir IDE，IDE会识别glTF文件并可以展开glTF文件，看到图17中的文件信息，其中Animation_0是glTF自带的刚体动画文件 （图17） 将glTF拖入Scene3D场景下，可以看到模型，但是没有动画，下面先介绍如何使用动画 （图18） 2，动画导入及使用 当glTF文件拖入到Scene3D场景中时，会自动添加Animator组件，如果没有可以自行添加Animator组件，并且保证AlwaysAnimate模式 （图19） 此时，我们需要创建一个AnimationController文件，也就是3D动画状态机 （图20） 将新创建的Animation Controller文件，拖入到Animator组件中 （图21） 双击AnimatorController后，将Take_001动画文件拖入Animator窗口中 （图22） 此时运行IDE，可以播放刚体动画，也可以将BoxAnimated拖入Assets目录下，作为预制体，方便重用或者代码实现 （图23） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:44 "},"IDE/animationEditor/readme.html":{"url":"IDE/animationEditor/readme.html","title":"动画编辑模块","keywords":"","body":"动画编辑器动画编辑器 动画编辑器，包括2D时间轴动画编辑、3D时间轴动画编辑、动画控制器（状态机） 时间轴动画编辑详解(2D+3D) 动画状态机详解(2D+3D) Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:47 "},"IDE/animationEditor/timelineGUI/readme.html":{"url":"IDE/animationEditor/timelineGUI/readme.html","title":"时间轴动画编辑详解","keywords":"","body":"时间轴动画编辑详解一、打开时间轴动画编辑器1.1 创建动画1.2 直接启动动画面板1.3 不支持动画组件的节点1.4 添加动画组件二、时间轴动画编辑器的基础概念2.1 关键帧、空帧2.2 当前帧2.3 播放帧率2.4 动画节点属性2.5 曲线、切线、权重2.6 刻度三、时间轴动画编辑面板的基础交互3.1 多选3.2 鼠标左键3.3 鼠标右键3.4 滚轮操作四、属性设置4.1 属性增加4.2 关键帧属性设置五、帧面板通用操作5.1 关键帧管理5.2 关键帧批量管理5.3 空白帧插入5.4 动画事件5.5 关键帧跳转5.6 帧面板缩放六、曲线模式操作6.1 动画曲线调节6.2 曲线定位6.3 曲线显示筛选七、播放动画7.1 动画面板播放7.2 查看运行效果7.3 运行时的循环播放八、其它8.1 保存动画8.2 退出动画编辑器8.3 快捷键总结九、使用动画事件9.1 属性设置9.2 脚本中监听时间轴动画编辑详解 Author：charley LayaAir IDE的时间轴动画编辑器，适用于2D与3D动画的编辑。 本篇中的功能介绍，如果是2D与3D通用的操作，默认以3D为例进行说明，如果存在2D与3D差异的部分，会针对差异进行额外的说明。 隨着版本的升级，文档中截图的部分细节可能会稍有差异，以IDE实际版本为准，如果改动较大的我们会及时调整，未及时调整的欢迎联系官方客服进行反馈。 一、打开时间轴动画编辑器 1.1 创建动画 1.1.1 场景中的节点创建动画 场景中添加的任一节点都可以创建动画，下述介绍以cube（立方体）为例。首先在场景创建一个cube节点，选中cube节点后，就可以在编辑器下方的时间轴动画面板（Timeline） 中看到“创建”按钮。如图1-1所示： （图1-1） 点击图1-1的创建按钮，会弹出如图1-2所示界面，提醒用户设置动画名称（这里重命名为“ani3d.lani”）。 （图1-2） [!Tip] 3D动画文件的后缀是.lani，2D动画文件的后缀是.mc 保存名称后，可以看到时间轴动画编辑面板、动画组件、状态机、动画文件，即代表动画创建成功。如图1-3所示： （图1-3） 1.1.2 预制体中创建动画 我们不仅可以在场景中的节点创建动画，还可以在预制体中创建动画。 不理解预制体的，请先查阅>文档。 从操作看，从场景上创建动画与预制体里创建动画并没有本质上的区别。 主要的区别是： 场景中的节点创建的动画，适用于只用一次动画的情况。 预制体中创建的动画，适用于需要多次复用动画的情况。 1.1.3 动画文件后缀 3D创建的动画文件后缀名称为.lani，3D动画控制器（也叫动画状态机）文件后缀为.controller 2D创建的动画文件后缀为.mc，2D动画状态机文件后缀为.mcc。 在发布微信小游戏等对后缀有限制的平台时，IDE发布功能会自动修改后缀，开发者知道即可，仍按上述标准使用相对路径，引擎会根据不同平台自动适配文件后缀。 1.1.4 动画状态机文件命名规则 首次为节点创建动画的时候，不仅会创建一个由开发者自己命名的动画文件，还会自动创建一个动画状态机文件， 状态机文件命名是由动画节点名_动画名组成。效果如图1-4所示。 （图1-4） 1.2 直接启动动画面板 如果节点上已经绑定了动画组件，那么无需再创建动画，直接点击下方的启动动画面板按钮即可。如图1-5所示： （图1-5） 1.3 不支持动画组件的节点 场景根节点Scene2D、Scene3D不支持创建动画。 1.4 添加动画组件 当已经创建了动画，只是想在某个节点上复用已创建的动画时，可以通过添加动画组件的方式，直接打开已有动画。 以球体（Sphere）节点为例，进行介绍。 首先，选中球体节点，在右侧的属性面板中点击添加组件，选择Animator组件，在3D节点里只能看到Animator，如果是2D节点只能选Animator2D。 [!Tip|label:Tips] Animator2D是2D动画组件，Animator是3D动画组件。 操作顺序如动图1-6所示： （图1-6） 然后，在属性面板中可看到Animator组件。点击Animator组件中的Controller，选择已有的动画状态机。如图1-7所示： （图1-7） 1.4.1 有动画状态机且有动画文件的情况： 以选择“Sphere_ani3d1”动画状态机为例，选择后，即将此动画绑定在Sphere节点上，在有动画状态机且有动画文件的情况下，刷新后点击动画编辑面板中的启动动画即可。如图1-8所示： （图1-8） 1.4.2 有动画状态机但无动画文件的情况： 假如动画状态机中没有动画，添加动画组件并设置状态机后，再点击启动，会提醒没有动画文件，此时会自动弹出创建新动画文件的窗口。 如图1-9所示： （图1-9） 如果想使用已有的动画，直接从资源窗口中拖拽动画文件到状态机视图窗口即可，效果如图1-10所示。 （图1-10） 二、时间轴动画编辑器的基础概念 2.1 关键帧、空帧 2.1.1 关键帧 关键帧指物体运动变化中关键动作所处的那一帧，即存储了属性值的帧。 （图2-1） 2.1.2 空帧 空帧指这个帧里没有设置任何内容，通常指相邻两个关键帧之间的帧。 （图2-2） 2.1.3 关键帧与空帧的区别 关键帧：根据关键帧上存储的属性值决定动画的效果变化。 空帧：引擎会根据插值算法计算出播放时的属性值，用于动画俩个关键帧之间的过渡。 2.2 当前帧 当前帧指针所在的帧，也是当前鼠标点击选择的帧。 并且，编辑器窗口下方也会显示出当前帧指针所在的位置。以图2-3所示为例，当前帧位于第6帧的位置。 （图2-3） 2.3 播放帧率 指每秒播放的动画帧数。如图2-4所示，默认值为60。 （图2-4） 2.4 动画节点属性 动画节点的属性如图2-5左侧所示，当指向某一个关键帧，再通过调节属性值，即可将调整后的属性值存储在该帧中，用于关键帧效果改变的依据。 （图2-5） 2.5 曲线、切线、权重 2.5.1 曲线 定义： 曲线是指两个关键帧之间用于帧过渡的插值算法连线。 作用： 用于两个关键帧之间的属性插值算法，调节动画关键帧之间的过渡效果。 外观： 曲线线条是关键帧之间的属性数值的过渡算法效果，IDE采用三次贝塞尔曲线（也称三阶贝塞尔曲线）算法绘制，绘制原理如动图2-6所示。 (动图2-6) 在动图2-6中，红色的线条就是最终的插值算法曲线效果外观，p0是起始帧，p3是结束帧，纵向红色指针是当前帧基于曲线的运动速度。 曲线的调节，由p1与p2决定，而p1与p2又是由切线与权重决定。 曲线外观的表现有曲线形态，也有直线形态，如图2-7所示，均是采用三次贝塞尔曲线算法绘制。 （图2-7） [!Tip|label:Tips] 以上所指贝塞尔曲线算法绘制的曲线均是可调节的曲线。2D动画内置的缓动曲线模板，并非是贝塞尔曲线算法。 2.5.2 曲线切线 在上文的动图2-6中，p0到p1点的线段是p0点的切线，p2到p3的线段是p3的切线，切线的位置会影响曲线的形态。 对应到动画编辑器的效果如动图2-8所示， （动图2-8） 2.5.3 曲线权重 曲线权重是指曲线切线的长度。最短不能低于0，最长不能超过1。也就是上文动图2-6中，p0到p3这两个关键帧之间的长度。 注意观察动图2-9，当改变权重长度时，tips的第三行也会显示出当前权重的数值。 （动图2-9） 这里仅仅演示权重调节的概念，下文6.1.2小节，会有详细介绍曲线权重如何调节。 2.6 刻度 刻度分为横向刻度和纵向刻度，横向刻度是指动画帧的刻度，纵向刻度是指动画属性值刻度。如图2-10所示。 （图2-10） 三、时间轴动画编辑面板的基础交互 3.1 多选 3.1.1 框选 持续按住鼠标左键进行框选，鼠标选区内全选。 3.1.2 连续区域多选 Shift + 鼠标点击，指定首尾帧与属性区间内全选。 3.1.3 间隔多选 ctrl + 鼠标点击，点中哪个选中哪个。 3.1.4 排除 ctrl + 鼠标点击，在已选中的情况下，按住ctrl + 鼠标点击即可排除该项。 3.1.5 多选松开 通用：所选的首帧与尾帧 曲线：显示所选的最高属性值与最低属性值，以及首帧与尾帧。如图3-1所示： （图3-1） 3.2 鼠标左键 3.2.1 单击 （改变当前帧） 改变当前帧位置，鼠标点击处为当前帧。 3.2.2 双击 添加动画事件： 双击如图3-2所示区域添加动画事件。一帧可派发多个动画事件。 （图3-2） 添加关键帧： 双击如图3-3所示区域添加关键帧。 （图3-3） 3.2.3 拖拽 拖拽单帧： 选中某一关键帧进行拖拽，可改变当前关键帧的位置。 批量拖拽多帧： 也可批量选中多个关键帧进行拖拽，整体进行位置改变。 3.3 鼠标右键 3.3.1 关键帧模式 1、添加关键帧：右键点击关键帧面板区域，可调出关键帧添加菜单。例如，图3-4所示的红1区域，括号内的数字代表是在第几帧上添加。 （图3-4） 2、添加动画事件：右键点击帧刻度与关键帧面板中间的区域，如图3-5所示，可调出添加动画事件菜单，括号内的数字代表是在第几帧上添加。 （图3-5） 3、点击选中某一关键帧，单击右键调出当前关键帧功能菜单。如图3-6所示： （图3-6） 4、右键点击（3）区域，调出属性添加菜单。如图3-7所示： （图3-7） 3.3.2 曲线模式 1、在曲线模式下，右键单击空白区域，调出曲线自动定位菜单。如图3-8所示： （图3-8） 2、在曲线模式下，右键单击关键帧，调出曲线功能菜单。如图3-9所示： （图3-9） 3、在曲线模式下，右键单击曲线，调出曲线定位菜单。如图3-10所示： （图3-10） 3.4 滚轮操作 3.4.1 帧显示缩放 关键帧模式下，直接滚轮，将以鼠标指针为中心，对帧刻度面板进行缩放。如动图3-11所示： （动图3-11） 3.4.2 属性显示缩放 曲线模式下，使用 Ctrl+滚轮 ， 将以鼠标指针为中心，对属性刻度面板进行缩放。如动图3-12所示： （动图3-12） 3.4.3 帧与属性同时缩放 曲线模式下，直接滚轮，将以鼠标指针为中心，对帧与属性刻度面板同时缩放。如动图3-13所示： （动图3-13） 3.4.3 动画属性面板纵向滚动 当有多个属性超出属性面板的显示区域时，为方便操作可直接通过鼠标滚轮对属性面板进行纵向滚动调节。如动图3-14所示： （动图3-14） 3.4.4 动画帧面板纵向滚动 当鼠标在动画帧面板时，直接滚动鼠标滚轮只会对帧面板进行缩放。 那我们也需要纵向滚动时，可以在动画帧面板按住Ctrl+滚动鼠标滚轮进行纵向滚动操作，如动图3-15所示： （动图3-15） 四、属性设置 4.1 属性增加 4.1.1 通过按钮增加 如图4-1所示： （图4-1） 4.1.2 通过右键增加 如图4-2所示： （图4-2） 4.1.3 通过录制增加 首先，点击红色的录制按钮，在刻度条变为红色时，代表此时进入到录制状态，此时通过调节右侧的Transform参数，即可在时间轴动画编辑器中添加对应的属性。操作如图4-3所示： （图4-3） 2D动画属性与3D动画属性的差异： [!Note] 2D动画中的每一个属性值均允许单个设置。3D动画中的Vector属性不可缺少，删除也会自动补上。 2D动画默认是录制模式，3D动画需要点击录制按钮开启录制模式。 4.2 关键帧属性设置 4.2.1 属性输入框直接输入 直接在输入框输入数值。如图4-4所示： （图4-4） 4.2.2 属性输入框划动输入 将鼠标放置输入框上，待光标变为双向箭头时，按住左键后左右拖动鼠标，即可改变数值。 4.2.3 录制模式的同步输入 方式1：在录制模式下，在视图窗口拖拽输入。如图4-5所示： （图4-5） 方式2：在录制模式下，在属性窗口的输入。如图4-6所示： （图4-6） 五、帧面板通用操作 5.1 关键帧管理 5.1.1 添加 在动画帧面板添加： 在动画帧面板中已有属性的情况下，通过双击或鼠标右键单击如图5-1所示的区域来添加关键帧。 （图5-1） 在动画属性面板添加： 在动画属性面板中点击属性右侧的 “+” 号添加，如图5-2所示： （图5-2） 5.1.2 删除 鼠标选中关键帧，通过 “delete” 快捷键或右键菜单中的“删除选中快捷键”按钮进行删除。 5.1.3 复制 鼠标选中关键帧，通过 “ctrl+C” 进行复制。 5.1.4 粘贴 鼠标选中某一空白帧，通过 “ctrl+V” 进行复制。 5.1.5 移动 鼠标选中关键帧，按住左键不放进行拖拽。 5.2 关键帧批量管理 5.2.1 批量平移 批量平移，是指对选中的关键帧整体进行水平位置移动，关键帧之间的间距保持不变。 操作方式是对关键帧进行批量选中，然后桉住鼠标左键不放，即可进行批量平移。如动图5-3所示： （动图5-3） 5.2.2 插入移动 插入移动是指，在选中的全部关键帧之中，每两个关键帧之间插入空白帧。所以首帧位置不变，但其后的所有关键帧间距变大或缩小。 间距增大： 选中多个关键帧，执行插入空白帧操作。如动图5-4所示： （动图5-4） 为方便理解动图5-4，采用了右键操作，但建议用快捷键F5插入空白帧。 间距缩小： 选中多个关键帧，执行删除空白帧操作。当两个关键帧之间的空白帧全部删除后，会停止删除。但不影响其它关键帧的继续删除操作。如动图5-5所示： （动图5-5） 为方便理解动图5-5，采用了右键操作，但建议用快捷键Shift + F5插入空白帧。 5.2.3 批量删除 对关键帧进行批量选中，然后通过快捷键 “delete” 或右键菜单中的删除选中关键帧选项即可进行批量删除。如动图5-6所示： （动图5-6） 5.3 空白帧插入 5.3.1 空白帧单个插入 增加：选中某个关键帧，通过快捷键 “F5” 或右键菜单中的 “插入空白帧” 按钮。 删除：选中某个关键帧，通过快捷键 “shift + F5” 或右键菜单中的 “删除空白帧” 按钮。 5.3.2 空白帧批量插入 增加：选中多个关键帧，通过快捷键 “F5” 或右键菜单中的 “插入空白帧” 按钮。 删除：选中多个关键帧，通过快捷键 “shift + F5” 或右键菜单中的 “删除空白帧” 按钮。 5.4 动画事件 5.4.1 添加 在帧面板中如图5-7所示的区域中，可以通过双击或右键菜单中的 “添加动画事件” 按钮来添加动画事件。 （图5-7） 5.4.2 删除 鼠标选中动画事件，可以通过快捷键 “delete” 或者右键菜单中的 “移除动画事件” 来删除动画事件。 动画事件的具体使用请看第九部分。 5.5 关键帧跳转 （图5-8） 跳转到首帧 点击如图5-8中的（1）所示的按钮，即可快速跳转到首帧。 跳转到上个关键帧 点击如图5-8中的（2）所示的按钮，即可快速跳转到上一帧。 跳转到下个关键帧 点击如图5-8中的（3）所示的按钮，即可快速跳转到下一帧。 跳转到尾帧 点击如图5-8中的（4）所示的按钮，即可快速跳转到尾帧。 5.6 帧面板缩放 5.6.1 滚动条缩放 左缩放：拉动左边滚动条对当前关键帧左边的帧刻度进行缩放。 右缩放：拉动右边滚动条对当前关键帧右边的帧刻度进行缩放。 滚动条如动图5-9所示： （动图5-9） 5.6.2 滚轮缩放 1、鼠标放在帧刻度上滑动滚轮，此时帧刻度以当前鼠标所在刻度处为中心进行缩放。如动图5-10所示： （动图5-10） 2、鼠标放在属性刻度上滑动滚轮，此时属性刻度以当前鼠标所在刻度处为中心进行缩放。如动图5-11所示： （动图5-11） 关于滚轮缩放的锁定某个刻度面板，请上翻查看3.5快捷键小节。 六、曲线模式操作 6.1 动画曲线调节 6.1.1 使用动画曲线模板 动画曲线模板可分为两种，分别是内置的曲线算法与自定义的曲线算法。 使用内置的曲线算法后，曲线不可随意调整。 使用自定义的曲线算法，曲线可以随意调整。 曲线模板打开方法：在曲线模式下右键单击关键帧，在右键菜单中单击 “使用动画曲线模板” 即可打开曲线模板界面。 [!Tip|label:Tips] 内置的曲线算法仅支持2D动画。 内置的曲线算法： Linear：线性动画，也就是匀速。以相同的速度开始以相同的速度结束。动画曲线如图6-1所示： （图6-1） EaseIn：入口缓动曲线，动画以低速开始，进行过程中一直加速。动画曲线如图6-2所示： （图6-2） EaseOut：出口缓动曲线，动画进行过程中一直减速，以低速结束。动画曲线如图6-3所示： （图6-3） EaseInOut：两边缓动曲线，动画以低速开始，加速后再减速，以低速退出。动画曲线如图6-4所示： （图6-4） 自定义的曲线算法： Custom： 如果内置的曲线模板无法满足需求，开发者可以直接在选择Custom曲线模式，然后在面板区域中修改曲线轨迹。如图6-5所示： 修改后可以将其保存下来，以便复用。 （图6-5） 6.1.2 切线调节 （图6-6） 权重： 默认权重：曲线权重默认值是权重总长度的三分之一处，该处为引擎优化位置，采用的是埃尔米特(Hermite)插值算法，性能较好。推荐使用。 （图6-7） 自定义权重：当不勾选锁定权重时，就是自定义权重。自定义权重更加灵活，但是性能不如默认权重的性能好。 （动图6-8） 锁定权重：当使用了自定义权重后，如果想保持这个权重，可以锁定该权重，只调节切线位置。 （动图6-9） 功能： 左切线：调节当前关键帧左侧的切线设置参数。 右切线：调节当前关键帧右侧的切线设置参数。 两条切线：调节当前关键帧俩侧的切线设置参数。 插值过渡： linear：调整曲线角度，让曲线表现为直线形态。 （图6-10） constant：调整曲线角度，让曲线表现为直角折线形态。 （图6-11） 6.1.3 平滑 不勾选状态：关键帧俩侧可分别设置曲线左、右切线来调节，互不影响。但是可能会出现过渡不够平滑，形成尖锐角度情况。如图6-12所示： （图6-12） 勾选状态：关键帧两侧同步设置曲线切线，勾选后会使过渡更平滑。 6.1.4 水平 不勾选状态：自定义曲线切线。 勾选状态：勾选后，使曲线切线快速恢复到水平位置。 （动图6-13） 6.2 曲线定位 6.2.1 在曲线上定位输入 右键单击曲线，在右键菜单中点击 “定位到输入” 选项，即可快速定位到该曲线代表的参数。以绿色曲线为例，点击 “定位到输入” 后，即可发现绿色曲线代表的是X参数的变化。如图6-14所示： （动图6-14） 6.2.2 自动定位 当由于鼠标的一系列操作在曲线面板的显示区域中看不到曲线时，单击右键选择 “自动定位” 就可以使曲线快速显示出来。如动图6-15所示： （动图6-15） 6.3 曲线显示筛选 6.3.1 在动画属性面板筛选指定曲线 在动画属面板中双击参数，可快速找到指定曲线。如动图6-16所示： （动图6-16） 6.3.2 在曲线面板筛选指定曲线 在曲线面板中，选中某一曲线右键单击，在右键菜单中选择 “只显示当前曲线” 即可筛选到指定曲线。如动图6-17所示： （动图6-17） 七、播放动画 7.1 动画面板播放 7.1.1 单次播放 点击播放按钮，会播放动画，默认为单次播放。 单击如图7-1所示按钮，即可播放动画。 （图7-1） 7.1.2 循环播放 动画预览默认是单次播放模式，当我们看到循环图标中间有个数字1的时候，就表示处于单次播放的模式。如图7-2所示。 （图7-2） 点击单次播放状态按钮后，按钮处于循环图标状态，如图7-3所示，此时可无限循环播放动画。 (图7-3) 7.1.3 取消循环播放 点击循环播放状态按钮后，会停止当前循环播放状态，此时循环图标中间又可以看到数字1，说明已取消循环播放，恢复到单次播放模式。 （图7-3） 需要提醒的是，单次播放模式改变为循环播放模式时，由于当前未处于播放状态，所以不会自动转变为循环播放状态。 7.2 查看运行效果 IDE内的播放预览只是动画基础效果，多数情况下，动画还配合了代码交互逻辑，此时还需要在浏览器运行，查看最终运行效果。 点击如图7-4所示按钮，查看在不同平台的预览效果。 （图7-4） 由于动画组件，不能独立播放，必须挂在场景中，所以直接运行动画所在的场景即可播放动画。 如果想独立查看动画效果，则需要建立一个动图效果的测试场景，挂在测试场景中。 7.3 运行时的循环播放 IDE里的循环播放预览，与运行时是否循环播放无关。 如果需要在运行时循环播放，需要勾选图7-5中的loop状态。 （图7-5） 不勾选loop，在运行时会单次播放。 八、其它 8.1 保存动画 如图8-1所示，点击时间轴动画编辑器下方的保存图标即可。这里要注意，如果不保存，那么运行时会按照没有保存的效果播放动画。 （图8-1） 8.2 退出动画编辑器 点击时间轴动画编辑器下方的退出图标即可退出动画编辑器。如图8-2所示： （图8-2） 8.3 快捷键总结 快捷键 作用 F5 插入空白帧 Shift + F5 删除空白帧 Delete 删除关键帧 Ctrl + c 复制关键帧 Ctrl + v 粘贴关键帧 Ctrl+滚轮 关键帧模式下，动画属性面板与动画帧面板，同时纵向滚动曲线模式下，锁定帧刻度面板（不缩放），以鼠标指针为中心，无限制缩放属性刻度面板的精度。 Alt+滚轮 曲线模式下，锁定属性刻度面板（不缩放），以鼠标指针为中心，无限制缩放帧刻度面板的精度。（无限制缩放会导致当缩放拉伸到0帧可见时，不再以缩放前的鼠标指标为中心进行缩放） Alt+Shift+滚轮 曲线模式下，锁定锁定属性刻度面板（不缩放），以鼠标指针为中心，有限制缩放帧刻度面板的精度。（始终保持以鼠标指针为中心进行缩放，当缩放拉伸至0帧可见时，禁止刻度精度缩小，只允许刻度精度放大） Shift 曲线模式下，持续按住Shift键，可以使得移动关键帧，始终保持水平方向位移，单个与批量移动均有效。 Ctrl 曲线模式下，持续按住Ctrl键，可以使得移动关键帧，始终保持垂直方向位移，单个与批量移动均有效。 九、使用动画事件 在5.4小节中介绍了动画事件添加和删除的操作，我们看看如何使用动画事件 9.1 属性设置 当添加动画事件后，点击白色事件图标，可以在IDE后侧属性面板中设置动画事件属性，如图9-1所示 （图9-1） Event Name：在脚本中调用的事件方法名 Params：在脚本中调用事件方式时的传参（字符串），可以设置多个 如图9-2所示，例如对此事件添加一个 “event1” 方法名，添加两个参数，\"a\", \"1\"，点击下面的保存 （图9-2） 9.2 脚本中监听 通过设置动画事件属性后，要想监听到事件和参数，需要在动画节点上添加脚本。 我们通过动图9-3，来看看如何为一个动画节点添加脚本 （动图9-3） 添加脚本后，就可以在脚本中监听到事件和参数了，脚本代码如下： const { regClass, property } = Laya; @regClass() export class Script extends Laya.Script { //declare owner : Laya.Sprite3D; constructor() { super(); } event1(p1:any, p2:any): void { console.log(\"event1\",p1,p2); } } 在脚本中创建event1的方法和接收两个参数，最后我们来运行动画，看看运行结果： （图9-4） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-05-19 17:38:15 "},"IDE/animationEditor/aniController/readme.html":{"url":"IDE/animationEditor/aniController/readme.html","title":"动画状态机详解","keywords":"","body":"动画状态机详解一，概述二、动画状态机组件三、动画状态机文件四、动画状态五、动画切换六、动画播放及脚本七、子状态机动画状态机详解 LayaAir IDE的动画状态机，适用于2D与3D。 本篇中的功能介绍，如果是2D与3D通用的操作，默认以3D为例进行说明，如果存在2D与3D差异的部分，会针对差异进行额外的说明。 隨着版本的升级，文档中截图的部分细节可能会稍有差异，以IDE实际版本为准，如果改动较大的我们会及时调整，未及时调整的欢迎联系官方客服进行反馈。 一，概述 我们先来了解一下什么是动画状态机和它的构成，后面再进一步了解每个部分。 首先，动画状态机 Animator 可以允许我们定义动画状态，以及动画状态之间的切换条件，来驱动3D对象播放不同的动画，表现出不同的行为。那么动画状态机有下面几部分构成： 动画状态机组件 Animator Component ：是Sprite3D上的一个组件，用来控制动画状态机的接口。 动画状态机文件 Animator Controller ：是一个文件，用来执行整个状态机逻辑，驱动动画状态运行，执行状态切换。同时定义了驱动参数，可以由代码逻辑驱动这些参数，再由这些参数驱动动画。 动画状态 Animator State：是状态机的一个动画状态，用来执行动画的逻辑，定义动画播放的属性，可以改变单一动画的播放位置、时间、层级等等。 动画切换 Animator Transition：由参数和比较条件构成，当条件满足时，会切换到相应的动画状态。每个状态，可以创建多个到其它状态的切换。 通过下图，可以清晰了解这四个部分的关系，如图1-1所示： （图1-1） 二、动画状态机组件 我们需要播放动画以及使用动画状态机的对象都需要添加 Animator 组件，该组件是控制动画状态机的接口，下面我们来看看 Animator 组件。 2.1 场景中的节点添加 场景中添加的任一节点都可以添加动画状态机组件，下述介绍以cube为例。首先在场景创建一个cube节点，选中cube节点后，就可以在编辑器的增加组件面板中添加 Animator 组件。如动图2-1所示： （动图2-1） 2.2 预制体中添加 我们不仅可以在场景中的节点添加动画状态机组件，还可以在预制体中创建。 不理解预制体的，请先查阅预制体的文档>。 从操作看，从场景上创建与预制体里创建并没有本质上的区别。 主要的区别是： 场景中的节点创建，适用于只用一次动画的情况。 预制体中创建，适用于需要多次复用动画的情况。 2.3 默认添加 某些情况下，Animator 组件会自动添加到节点下，如图2-2所示，当我们导入一个FBX模型文件到场景中时，已经默认添加好了 Animator 组件。 （图2-2） 2.4 组件属性 Animator 组件的属性如图2-3所示： （图2-3） Controller ：使用的 Animator Controller文件，当有了 Animator 组件，依然不能打开动画状态机，我们需要创建动画状态机文件，下一章将具体介绍。 Culling Mode：剔除模式，Always Animate表示即使摄像机看不见也要进行动画播放的更新，Cull Completely 表示摄像机看不见时停止动画的所有更新。 Sleep：动画完成是否停止更新。因为在LayaAir中，动画播放完成以后还依然会不停的循环最后一帧，所以勾选Sleep可以停止更新。例如，给场景中一个立方体添加平移的动画，如动图2-4所示，最后看到这个立方体已经不再移动了。 （动图2-4） 此时不勾选Sleep选项，给CubeAnimation动画节点添加动画脚本，添加的代码如下： ... import Vector3 = Laya.Vector3; ... export class AnimationScript extends Laya.AnimatorStateScript { ... private model: Laya.Sprite3D; /**@internal */ setPlayScriptInfo(animator: Laya.Animator | Laya.Animator2D, layerindex: number, playstate: Laya.AnimatorState | Laya.AnimatorState2D) { ... this.model = animator.owner as Laya.Sprite3D;//得到Cube节点 } ... /** * 动画状态退出时执行。 */ onStateExit(): void { console.log(\"动画退出了\"); //平移操作 let position = new Vector3(1, 1, 1); this.model.transform.translate(position); } } 在脚本中，当动画结束时，对模型进行了平移。但是由于没有勾选Sleep选项，动画播放完成以后还依然会不停地循环最后一帧，即动图2-4最后的静止状态。所以无法控制Cube的位置，实现平移的效果。当勾选了Sleep，动画播放完成以后，就可以显示出平移效果了。 三、动画状态机文件 Animator Controller 是一个文件，用来执行整个状态机逻辑，驱动动画状态运行，执行状态切换。 3.1 创建动画状态机文件 Project面板中，任何目录下都可以创建一个动画状态机文件。如动图3-1所示： （动图3-1） 3.2 自动创建动画状态机文件 对于一个带网格和动画信息的Fbx模型文件来说，如图3-2所示，Fbx文件导入过程中，LayaAir 3.0编辑器已经识别出这个Fbx文件具有Animator属性，并可以设置是否可开启压缩。 （图3-2） 当我们拖Fbx模型到场景中时，会自动添加动画状态机组件。打开时间轴动画面板，会自动创建动画状态机文件，如图3-3所示： （图3-3） 这种情况下，LayaAir 3.0已经自动为我们创建好了Animator Controller文件，下一步就可以编辑动画状态机了。 3.3 打开动画状态机 当我们点击动画状态机文件后，可以点击 动画状态机 面板来打开动画状态机，如图3-4所示。 （图3-4） LayaAir 3D引擎的Sprite3D类提供了 getComponent() 方法来获取模型上的组件。带动画的模型在加载创建时引擎默认赋予了Animator（动画状态机）动画组件，因此我们可以这样获取： //获得状态机 this.animator = this.target.getComponent(Laya.Animator); 注：这段代码来自“3D入门示例”的“Animator”场景。 3.4 编辑动画状态机 动画状态机 面板中，可以做一些常规的操作，如动图3-5所示，下面一章，我们将引入动画状态的介绍和操作。 （动图3-5） 3.5 动画状态机分层 默认情况下，一个动画状态机文件只有一个默认的层 BaseLayer，如图3-6所示，比如一个角色模型的常规动作（待机，跑，攻击），我们只需要一个默认层就可以了。 （图3-6） 但是我们也可以创建更多的分层，多个分层可以用来解决什么样的问题呢？试想一下如果你要开发一款第三人称的射击游戏，那么肯定是希望身体的动画分为上下两部分，上方根据瞄准的位置和是否射击进行动画播放，下方根据移动播放动画。所以更多复杂的需求可以用分层来解决，如图3-7所示，我们又添加了一个分层，并命名为Layer1。 （图3-7） 3.5.1 图层的属性 每个图层是有一些参数属性的，如图3-8所示： （图3-8） 1.Name：图层的名字。 2.Play On Wake：是否默认播放这个层的动画。 3.Blending Mode：动画混合方式： Override：覆盖，表示当前层的动画会覆盖掉其它层的动画，比如射击播放时右手就不能播放其它的动画了； Additive：添加，表示当前层的动画的量添加到其它层的动画，比如射击播放时，手部奔跑或站立的甩动也会保留。 4.Default Weight：动画层的权重，默认的Base Layer必须为1。如果设置为0则当前层的动画不会播放，1则会播放，0-1之间会采用类似融合的情况来播放动画，比如之前说的边移动边射击的情况，如果设置为0.5则射击动画播放时手部只会抬到脖子附近。 通过代码，我们可以获得想要的图层，需要使用Animator的 animator.getControllerLayer(layerIndex)方法，该方法的定义如下： /** * 获取控制器层。 */ getControllerLayer(layerInex: number = 0): AnimatorControllerLayer { return this._controllerLayers[layerInex]; } 举一个使用此方法的例子： //获得BaseLayer层AnimatorControllerLayer let animatorControllerLayer : Laya.AnimatorControllerLayer = this.animator.getControllerLayer(0); //获得当前BaseLayer层的默认动画状态 let defaultState = animatorControllerLayer.defaultState; 5.Avatar Mask：动作遮罩，进行遮罩后，选定的上层动作会遮挡下层的动作。以一个具体的例子来说明： 假设有两个图层，如图3-9所示，fight和congratulate， （图3-9） 将Blending Mode属性设置为覆盖后，congratulate层的动作会覆盖fight层的动作，congratulate效果如动图3-10所示。 （动图3-10） 此时的覆盖，是将fight动作全都覆盖掉了，如果想上半身是fight动作，下半身是congratulate动作，这就需要动作遮罩了，先来看一下动图3-11的fight动作，方便进行对比。 （动图3-11） 在项目资源面板中，添加AvatarMask后，如图3-12所示，可以添加预制体或模型资源，这里选择预制体，然后点击导入骨架按钮。 （图3-12） 导入后的骨架，勾选的部位，就是要进行遮罩的地方。如图3-13所示，这里勾选了下半身的骨架，那么就是要对下半身的动作进行遮挡。 （图3-13） 原本，congratulate层的动作会遮挡fight层的动作，并且会全部遮挡。现在，在congratulate层添加AvatarMask，按照刚刚的设置，congratulate层只遮挡fight层的下半身动作，也就是上半身仍然是fight层的动作不被覆盖，下半身的动作被遮挡变为congratulate层的动作。效果如动图3-14所示。 （动图3-14） 可以看到，上半身是fight动作，下半身是congratulate动作，这就是动作遮罩的用法。 这只是最基本的一种用法，如果只有一个动画层，比如给fight动画层的下半身添加动画遮罩，那么此时就只显示下半身动画了。 3.5.2 图层的参数 每个图层是可以添加一些参数的，如图3-15所示，具体这些参数是在动画切换中会用到，我们将在第五章动画切换中介绍。 （动图3-15） 目前LayaAir中，我们可以添加这三种参数： Float：浮点数 Bool：布尔 Trigger：触发器 四、动画状态 动画状态 Animator State，是动画状态机里的一个动画状态，每个状态对应一个动画，所以叫动画状态。用来执行动画的逻辑，定义动画播放的属性，可以改变单一动画的播放位置、时间等等。而我们的游戏逻辑状态，可能由一系列的动画状态构成。 4.1 系统状态 动画状态机创建时，会默认创建2个系统状态，如图4-1所示： （图4-1） 任何状态 AnyState：当我们需要在条件满足时，无论当前是哪个状态，都执行切换时，可以定义切换为从该状态开始。 进入 Entry：进入状态，当进入一个动画状态机时，会首先执行从该状态到默认状态的切换。 当创建子状态机时，会默认多创建一个退出状态，如图4-2所示： （图4-2） 子状态机的内容请参看第七章。 退出 Exit：当需要退出该子状态机时，可以执行一个到该状态的切换。 4.2 创建动画状态 4.2.1 新建动画状态 在动画状态机面板中，鼠标右键点击空白处，点击创建空节点即可。如动图4-3所示： （动图4-3） 4.2.2 拖入一个动画状态 在Project面板中，可以拖动一个Fbx下的动作文件到Animator面板中，如动图4-4所示 ： （动图4-4） 此时，我们已经可以自动播放一个动画了，这是最基本最简单的用法，不需要做额外的工作，可以让LayaMonkey动起来！ （动图4-5） 4.3 动画状态属性 作为动画状态机里的每一个动画状态，我们都可以对此状态做单独的设置，如图4-6： （图4-6） 4.3.1 基础属性 Name：动画状态的名字，可以在代码里用来播放动画。 Is Looping：是否循环播放。 Speed：动画的播放速度。 Cycle Offset：循环偏移，基于播放起始时间的偏移值，仅作用于动画首次播放（0-1之间）。 Clip Start：动画文件的起始播放位置（0-1之间）。 Clip End：动画文件的停止播放位置（0-1之间）。 Clip：动画文件（.lani）。 注意：参数“Cycle Offset”不影响动画播放完整性，例如“Clip Start”设置为0，“Clip End\"设为1，”Cycle Offset“设为0.8，那么动画就是从0.8这个位置开始播放，再播放到0.8这个位置算一次循环。 通常Fbx文件中包含的动画文件，通过拖入Animator中，会自动把动画文件关联进来，如图4-7所示： （图4-7） 4.3.2 切换列表 AnimatorTransition：列出了所有此动画状态连接其它动画状态的动画切换，如图4-8所示： （图4-8） 单机New State -> New State 0可以打开AnimatorTransition详细面板，双击New State -> New State 0，可以改名，如动图4-9所示： （动图4-9） 4.3.3 solo与mute solo与mute：两个选框，Solo表示只生效这一条切换，Mute相当于把这条动画切换禁用掉，如图4-10所示： （图4-10） 注意： solo和mute都可以多选，但是优先级是按照添加顺序的，将会在5.5切换优先级中讲解。 条件满足优先于Solo/Mute，当条件没有满足时依然不会过渡，将会在5.5切换优先级中讲解。 五、动画切换 从一个状态过渡到另一个状态的过程就是动画切换，由参数和比较条件构成，当条件满足时，会切换到相应的动画状态。每个状态，可以创建多个到其它状态的切换。 5.1 创建动画切换 当我们创建好动画状态后，通过在前一个状态上点击鼠标右键，选择连线，此时会创建一点连线，拖动鼠标到后面的动画状态上抬起鼠标，即可创建动画切换，点击此连线时，点击键盘的delete键可以删除此连线。如动图5-1所示： （动图5-1） 当我们从New State连了New State 0，New State 1，New State 2后，在不添加任何条件的情况下，New State会继续切换到New State 0状态，因为New State 0是最先连的。 5.2 设置为默认 当我们创建好多个动画状态时，如果想设置某个动画状态为进入状态，可以鼠标右键点击此动画状态，选择设置为默认即可，如动图5-2所示： （动图5-2） 注意：当我们创建第一个动画状态时，会默认把这个状态设为默认状态，当然我们随时可以改为其它动画状态为默认状态。 5.3 动画切换属性 点击一条连线时，可以看到动画切换的属性，如图5-3所示，用来处理动画切换的动画调整效果。 （图5-3） Exit Time：该时间是一个0-1的归一化时间，用来定义在动画播放的时间百分比。比如0.85，表示动画播放到85%时，开始切换动画。Exit Time的逻辑功能类似于float参数，但是不能进行设置。 Transstartoffset：该时间是一个0-1的归一化时间，目标状态的时间偏移，即从哪个时间点开始播放目标状态动画。比如0.5，表示目标状态从50%开始播放动画。 Transduration：该时间是一个0-1的归一化时间，用来定义状态切换到目标状态时，持续播放后一个动画状态的时间百分比。比如0.15，表示动画播放到目标动画的15%时，停止切换动画。 注意： 处于过渡时间时，动画1和动画2同时播放。当过渡时间结束，动画1才彻底停止播放，而动画2进入下一段切换的判断。 当过渡时间为0时，动画1会直接切换到动画2。 Exit By Time：是否让Exit Time 生效，如果不勾选，该动画是直接切换到下一个动画。 动图5-3-1和动图5-3-2分别是勾选Exit Time和不勾选的对比效果，明显来看，不勾选会出现动画不衔接的情况。 （动图5-3-1） （动图5-3-2） 5.4 动画切换条件 状态切换可以有一个条件，多个，或者没有条件。如果切换没有条件，那么动画系统也会将Exit Time 作为唯一的条件，当到达时间时触发切换。如果有多个条件，必须所有条件都满足，才触发切换。 目前LayaAir中，我们可以添加这三种参数： 5.4.1 Float：浮点数 如动图5-4所示，我们来看看Float条件怎么设置，首先要定义一个Float的参数，其次在条件中，可以选择这个Float参数，右边会选择 Less 或者 Greater，最后可以填上数值。那么动图5-4的意思是，当Float大于0.5时，切换New State到New State0。 注意：当定义这个Float参数时，可以设置默认值，比如1，那么如果条件是Float参数 Greater 0.5，则条件直接打成，运行时会直接切换状态 （动图5-4） 可以通过代码来满足条件，代码如下： //通过设置“Float”参数的值，来满足切换状态的条件 this.animator.setParamsNumber( \"Float\" , 2 ); 运行效果如动图5-5： （动图5-5） 5.4.2 Bool：布尔 如动图5-6所示，我们来看看Bool条件怎么设置，首先要定义一个Bool的参数（有true或false），其次在条件中，可以选择这个Bool参数，最后可以勾选true或者false。那么动图5-6的意思是，当Bool为true时，切换New State到New State0。 注意：当定义这个Bool参数时，可以设置默认值，比如true，那么如果条件是Bool参数 true，则条件直接打成，运行时会直接切换状态 （动图5-6） 可以通过代码来满足条件，如下： //通过设置“Bool”参数的值，来满足切换状态的条件 this.animator.setParamsBool( \"Bool\" , true ); 运行效果如动图5-7： （动图5-7） 5.4.3 Trigger：触发器 如动图5-8所示，我们来看看Trigger条件怎么设置，首先要定义一个Trigger的参数（有true或false），其次在条件中，可以选择这个Trigger参数。那么后面我们可以通过代码来使用触发器，切换New State到New State0 。 （图5-8） 通过代码来满足条件，如下： //通过触发“Trigger”，来满足切换状态的条件 this.animator.setParamsTrigger( \"Trigger\" ); 运行效果如动图5-9： （动图5-9） 5.4.4 多个参数使用 当然我们可以定义多个参数，但是这种情况下需要对参数进行命名会更有效。如动图5-10所示来修改名字 ： （动图5-10） 修改好名字后，可以比较清晰的来编辑切换条件，如图5-11所示： （图5-11） 注意：这些条件中只要满足一个就可以触发动画切换，而不是并且的关系 5.5 切换优先级 一个动画状态下如果连有多个动画状态时，我们来看看优先级时怎样的。 当没有任何条件时或者条件都满足时，没有选择solo和mute的情况下，如图5-12： （图5-12） 此时，Attack动画播完会播放Stand动画，因为Stand动画是第一个。 当没有任何条件时或者条件都满足时，如果某个选了solo时，如图5-13： （图5-13） 此时，Attack动画播完会播放Run动画，因为Run动画选了solo。 当没有任何条件时或者条件都满足时，如果都选了solo时，如图5-14： （图5-14） 此时，Attack动画播完会播放Stand动画，因为即使都选了solo，但是动画切换只能选一个，按顺序Stand是第一个。 如果Attack-> Stand的条件不满足，Attack-> Run的条件满足，但是依然也如上图5-14一样，都选了solo。 此时，Attack动画播完会播放Run动画，因为Attack-> Stand的条件不满足 当没有任何条件时或者条件都满足时，如果都选了solo时，并Attack-> Stand选了mute，如图5-15： （图5-15） 此时，Attack动画播完会播放Run动画，因为Attack-> Stand选了mute。 当没有任何条件时或者条件都满足时，如果都选了solo和mute时，如图5-16 ： （图5-16） 此时，Attack动画播完不会切换任何状态。 六、动画播放及脚本 上面的章节中，只需要用简单的代码，就可以控制状态机来满足条件，播放指定的动画状态，除此之外，我们也可以通过代码来更多的控制动画播放。 6.1 播放控制 在获得动画状态机组件，添加了多个动画状态的情况下，那怎么播放其中一个动画呢？有几种方法实现对动作的控制与切换： 6.1.1 Play() 查看Animator动画组件中play()方法，具体方法参数如下： /** * 播放动画。 * @param name 如果为null则播放默认动画，否则按名字播放动画片段。 * @param layerIndex 层索引。 * @param normalizedTime 归一化的播放起始时间。 */ play(name: string | null = null, layerIndex: number = 0, normalizedTime: number = Number.NEGATIVE_INFINITY) 这是动画状态机里最基本的播放动画方式，通过下面的代码： //动画状态机，直接播放Run动画状态 this.animator.play(\"Run\"); 看看运行效果，如动图6-1所示： （动图6-1） 通过Play()的参数也可以指定播放动画的起始位置： //动画状态机，直接播放Stand动画状态，从50%的位置开始 this.animator.play(\"Stand\", 0 , 0.5); 看看运行效果，如动图6-2，每次鼠标点击按钮，可以从50%的位置开始播放Stand动画。 （动图6-2） 当然我们也可以通过代码修改动画状态的属性，播放不同的效果： //获得动画状态机的BaseLayer层，也可以获得其它层 let acl: Laya.AnimatorControllerLayer = this.animator.getControllerLayer(0); //获得一个动画状态 let state = acl.getAnimatorState(\"Stand\"); //设置动作状态的名称 state.name = \"Stand_new\"; //设置动作状态播放的起始时间（起始时间与结束时间的设置为0-1的百分比数值） 要截取的时间点 / 动画的总时长 state.clipStart = 10/40; //设置动作状态播放的结束时间 state.clipEnd = 20/40; //动画播放是否循环 state.clip.islooping = true; //动画状态机，直接播放Stand_new动画状态 this.animator.play(\"Stand_new\"); 看看运行效果，如动图6-3所示： （动图6-3） 6.1.2 crossFade() 动画过度融合是用于在给定的时间内从一个动画状态平滑过渡到另一个动画状态。如果一个动画跳转到另一个完全不同的动画耗时很短，那么过渡通常的表现令人满意。 先来看看Animator动画组件中crossFade()方法，具体方法参数如下： /** * 在当前动画状态和目标动画状态之间进行融合过渡播放。 * @param name 目标动画状态。 * @param transitionDuration 过渡时间,该值为当前动画状态的归一化时间，值在0.0~1.0之间。 * @param layerIndex 层索引。 * @param normalizedTime 归一化的播放起始时间。 */ crossFade(name: string, transitionDuration: number, layerIndex: number = 0, normalizedTime: number = Number.NEGATIVE_INFINITY) 通过代码调用如下： //动画状态机，过渡融合到Run动画状态 this.animator.crossFade(\"Run\", 0.3); 看看运行效果，如动图6-4，将待机动画和跑步动画混合起来。 （动图6-4） 6.1.3 暂停动画 播放动画说完了，我们再来说一下暂停动画。可以直接使用动画的播放速度控制动画的暂停与播放，直接设置需要暂停动画的播放速度为0即可，继续播放只需要重新设置速度为1。 //暂停动画 this.animator.speed = 0.0; //播放动画 this.animator.speed = 1.0; //一半速度播放动画 this.animator.speed = 0.5; 看看运行效果，如动图6-5所示： （动图6-5） 6.2 获取播放状态 获取动画播放状态，需要先使用Animator的 animator.getControllerLayer(layerIndex)方法： /** * 获取控制器层。 */ getControllerLayer(layerInex: number = 0): AnimatorControllerLayer { return this._controllerLayers[layerInex]; } 获得 AnimatorControllerLayer 后，再使用 getCurrentPlayState() 方法： /** * 获取当前的播放状态。 * @return 动画播放状态。 */ getCurrentPlayState(): AnimatorPlayState { return this._playStateInfo!; } 获得 AnimatorPlayState 后，有三个常用的方法获取播放状态如下： /** * 播放状态的归一化时间,整数为循环次数，小数为单次播放时间。 */ get normalizedTime(): number { return this._normalizedTime; } /** * 当前动画的持续时间，以秒为单位。 */ get duration(): number { return this._duration; } /** * 动画状态机。 */ get animatorState(): AnimatorState { return this._currentState!; } 通常我们可以利用 normalizedTime 来判断是否某个动画状态是否播完，例如下面的代码： const { regClass, property } = Laya; @regClass() export class Main extends Laya.Script { @property( { type: Laya.Label } ) private label: Laya.Label; @property( { type: Laya.Sprite3D } ) private target: Laya.Sprite3D; private animator : Laya.Animator; onStart() { this.label.on( Laya.Event.CLICK, this, this.test ); //获得状态机 this.animator = this.target.getComponent(Laya.Animator); } //运行状态机的跑动画，可使用动作融合方式 test(e: Laya.Event) { //动画状态机，过渡融合到Run动画状态 this.animator.crossFade(\"Run\", 0.1); //等待动画播放完成 Laya.timer.frameLoop(1,this,()=>{ //如果当前播放state已经播放完了一次 if(this.animator.getControllerLayer(0).getCurrentPlayState().normalizedTime >= 1){ //回到站立状态 this.animator.crossFade(\"Stand\", 0.1); Laya.timer.clearAll(this); } }); } } 看看运行效果，如动图6-6所示： （动图6-6） 6.3 使用状态脚本 对我们的开发需求来说，能够播放和切换动画状态还不够，可能还需要在每一个状态内实现更多的需求，例如当进入或者离开下一个状态时，播放不同的音效，那么通过添加动画状态脚本可以很容易实现，如图6-7所示，每个状态都可以添加一个或者多个状态脚本 。 （图6-7） 6.3.1 创建脚本 我们通过动图6-8，来看看如何为一个站立状态创建一个动画脚本。首先在项目资源->src目录中，创建一个动画脚本，然后选中Stand状态，在Scripts下点击+按钮，即可挂上刚刚创建的动画脚本。 （动图6-8） 6.3.2 脚本使用 我们来看看刚刚创建的动画脚本，初始的代码如下： const { regClass } = Laya; interface AnimatorPlayScriptInfo { animator: Laya.Animator | Laya.Animator2D; layerindex: number; playState: Laya.AnimatorState | Laya.AnimatorState2D; } /** * 继承自AnimatorStateScript(动画状态脚本) * @author ... */ @regClass() export class AnimationScript extends Laya.AnimatorStateScript { /**动画的状态信息 */ playStateInfo: AnimatorPlayScriptInfo = { animator: null, layerindex: -1, playState: null }; /**@internal */ setPlayScriptInfo(animator: Laya.Animator | Laya.Animator2D, layerindex: number, playstate: Laya.AnimatorState | Laya.AnimatorState2D) { this.playStateInfo.animator = animator; this.playStateInfo.layerindex = layerindex; this.playStateInfo.playState = playstate; } constructor() { super(); } /** * 动画状态开始时执行。 */ onStateEnter(): void { console.log(\"动画开始播放了\"); } /** * 动画状态运行中 * @param normalizeTime 0-1动画播放状态 */ onStateUpdate(normalizeTime: number): void { console.log(\"动画状态更新了\"); } /** * 动画状态退出时执行。 */ onStateExit(): void { console.log(\"动画退出了\"); } } AnimationScript脚本继承自Laya.AnimatorStateScript，setPlayScriptInfo是一个生命周期函数，可通过该函数获取当前脚本的动画组件、动画状态机层级、动画状态机。 /**说明 * setPlayScriptInfo为生命周期函数，如果想获得动画状态机的信息，必须要调用。 * @param animator 当前脚本的动画组件 * @param layerindex 当前脚本所处的动画状态机层级 * @param playState 当前脚本的动画状态机 */ setPlayScriptInfo(animator: Laya.Animator | Laya.Animator2D, layerindex: number, playstate: Laya.AnimatorState | Laya.AnimatorState2D) { this.playStateInfo.animator = animator; this.playStateInfo.layerindex = layerindex; this.playStateInfo.playState = playstate; } 此脚本还具备三个方法： onStateEnter：动画状态开始时执行； onStateUpdate：动画状态运行中，方法中可以获得当前状态执行的时间长度 normalizeTime； onStateExit：动画状态退出时执行； 我们可以通过重写这几个方法，来实现动画状态改变时执行自己的逻辑。简单加入一些代码来看效果： const { regClass } = Laya; interface AnimatorPlayScriptInfo { animator: Laya.Animator | Laya.Animator2D; layerindex: number; playState: Laya.AnimatorState | Laya.AnimatorState2D; } /** * 继承自AnimatorStateScript(动画状态脚本) * @author ... */ @regClass() export class AnimationScript extends Laya.AnimatorStateScript { /**动画的状态信息 */ playStateInfo: AnimatorPlayScriptInfo = { animator: null, layerindex: -1, playState: null }; private isShow: boolean = false; private _label: Laya.Label; /**@internal */ setPlayScriptInfo(animator: Laya.Animator | Laya.Animator2D, layerindex: number, playstate: Laya.AnimatorState | Laya.AnimatorState2D) { this.playStateInfo.animator = animator; this.playStateInfo.layerindex = layerindex; this.playStateInfo.playState = playstate; this._label = animator.owner.scene.scene2D.getChildByName(\"Label\"); } constructor() { super(); } /** * 动画状态开始时执行。 */ onStateEnter(): void { console.log(\"动画开始播放了\"); this._label.text = \"开始跑动画\"; } /** * 动画状态运行中 * @param normalizeTime 0-1动画播放状态 */ onStateUpdate(normalizeTime: number): void { console.log(\"动画状态更新了：\" + normalizeTime); if (normalizeTime > 0.5 && !this.isShow) { this.isShow = true; this._label.text = \"跑动画一半\"; } } /** * 动画状态退出时执行。 */ onStateExit(): void { console.log(\"动画退出了\"); this._label.text = \"退出跑动画\"; } } 实际运行效果，如动图6-9所示 （动图6-9） 七、子状态机 子状态机，就是在状态机里面，再创建一个新的状态机，这个新的状态机就叫子状态机。 这个状态机的作用是可以创建另外一套状态，方便来管理复杂的动画状态。举例来说，游戏中角色站着的时候有待机/跑/攻击/防御，下蹲的时候则是另外一套待机/跑/攻击/防御。那么下蹲就是子状态，因为下蹲跑，下蹲攻击这些动作都是基于下蹲这个状态，所以他们可以独立成为一个子状态机。 7.1 创建子状态机 如动图7-1所示，在状态机的空白位置，点击鼠标右键，选择创建节点目录，将会生成一个名为“New StateMachine”的节点，这就是子状态机。双击子状态机可进入子状态机面板，在这个面板中可以看到三个状态， 进入、任何状态和退出 ，这三种状态是属于子状态机的，而非父状态机。父状态机只有进入和任何状态。 （动图7-1） 同样，我们可以对子状态机进行新的命名，如动图7-2所示 ： （动图7-2） 7.2 编辑子状态机 比如我们想把角色的所有攻击和技能动画，都放到子状态机中，归为一类作为角色的攻击状态，而父状态机只用来处理待机，跑，眩晕，死亡，胜利等状态。那么我们进入子状态机中，拖入攻击和技能等动画并连线，同之前的父状态机的操作一样。如动图7-3所示： （动图7-3） 7.3 进入子状态机 拖入一个 Attack（Take 001） 动画进去，此时 进入 状态会连接到此动画，表示该子状态机的默认状态是Attack。如图7-4所示： （图7-4） 接着回到父状态机，将Idle连接子状态机，实际上相当于连接子状态机中的 进入 状态。如动图7-5操作： （动图7-5） 7.4 退出子状态机 如果我们希望Attack动画结束之后，就完成了子状态机的功能，并且退出子状态机，回到父状态机，并回到Idle状态，这个过程属于退出子状态机。 在父状态机里，回到子状态机的状态后，需要继续连线到其它状态，才能让动画连续，如动图7-6所示： （动图7-6） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-08-04 16:47:56 "},"IDE/animationEditor/aniBake/readme.html":{"url":"IDE/animationEditor/aniBake/readme.html","title":"动画烘焙详解","keywords":"","body":"动画烘焙详解一、从资源商店中导入插件二、使用动作烘焙三、烘焙多个动画动画烘焙详解 上面两篇文档介绍了在LayaAir中如何使用时间轴动画及动画状态机，本篇将介绍一种特殊的动画优化方案，动画烘焙。什么是动画烘焙呢？动画烘焙是将所有动画提前计算一次；将所有的骨骼节点预计算，存入内存中；GPU直接通过内存读取对应节点的矩阵值；进行渲染的方式。通过使用动画烘焙，可以降低CPU的消耗，因为GPU动画效率高于CPU动画，对于大量使用骨骼动画的场景，可以大大提高性能。 一、从资源商店中导入插件 从LayaAir3.1开始，开发者进行动画烘焙可通过资源商店导入“3D骨骼动作烘焙插件”到LayaAir IDE中。 （图1-1） 详情参考《3D骨骼动作烘焙插件》文档。 二、使用动作烘焙 由于在LayaAir项目中播放动画的对象都需要添加Animator组件，因此我们先准备好一个带Animator的动画对象，如图2-1所示 （图2-1） 在动画状态机中配置好动画状态和动画片段，如图2-2所示 （图2-2） 此时运行场景，可以看到人物在做待机的动画，如动图2-3所示 （动图2-3） 此时的动画是通过CPU计算骨骼的信息来播放动画的，接下来我们来使用动画烘焙，用GPU来计算动画数据 在菜单栏中，点击“面板”，选择“动作烘焙”，如图2-4所示 （图2-4） 可以打开“动作烘焙”插件，如图2-5所示 （图2-5） 参数说明： 目标节点：场景中的带骨骼动画节点； 忽略骨架：生成蒙皮动画时，忽略掉骨骼节点； 帧数：每秒多少帧（数量越大动作越细腻平滑，同时需要的贴图数量成线性比例增加）； 从插件中可以了解到，要想对上面的带Animator的动画做动画烘焙，需要把包含Animator组件的节点，拖入到插件中，如动图2-6所示， （动图2-6） 通过点击烘焙动作后，开始执行动画烘焙。 动画烘焙的动画不支持动画融合。 在节点名字“DanDing”的目录下会生成动画烘焙后的数据文件。 注意：生成数据文件的目录名是节点的名字 我们来看看都生成了什么数据文件，如图2-7所示 （图2-7） 其中，在danding目录下 anim目录：存入动画.lani文件（可以多个动画文件） mesh目录：存入模型文件 DanDing.ktx：烘焙后的数据文件，使用ktx纹理图片的格式，用来存放计算好的动画数据 DanDing.controller：重新以节点名字命名的3D动画状态机文件 DanDing.lh：保存烘焙后的预制体，可以直接使用。点击预制体，可以从图2-7中后边看到，模型节点上配置了SimpleSkinnedMeshRenderer组件，同时配置好烘焙的数据文件 这时我们可以直接使用代码或者直接将预制体拖入场景中，在LayaAir示例中，可以看到加载大量烘焙后的动画，效率有大幅提高，如图2-8所示， 预烘焙骨骼动画示例：https://layaair.com/3.x/demo/?category=3D&group=8&name=6 有时，开发者烘焙后，会遇到模型手上的武器丢失的情况。这是由于模型的手与武器节点没有绑定，需要将武器节点作为手节点的子节点，烘焙时就可以绑定。 “层级结构”并不是检验绑定与否的唯一方法。将武器节点作为手节点的子节点，可以确保两者绑定，防止重新烘焙。 例如，图2-9中，两个武器节点并没有作为两个手节点的子节点，此时并不确定手与武器节点是否绑定（需要结合具体情况判断）， （图2-9） 此时将两个武器节点作为两个手节点的子节点，如图2-10，则可以保证它们是绑定的。 （图2-10） 三、烘焙多个动画 通常情况下Animator中会配置好多个动画，那么就可以一次性的烘焙所有的动画，如图3-1所示 （图3-1） 重新对DanDing节点做动画烘焙后，多个动画就烘焙好了，如图3-2所示 （图3-2） 在anim目录中生成了多个动画lani文件。 打开controller文件后，可以看到所有的动画状态已经创建，后面直接使用预制体就好了。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2024-02-26 16:28:33 "},"IDE/physicsEditor/readme.html":{"url":"IDE/physicsEditor/readme.html","title":"物理编辑模块","keywords":"","body":"物理编辑模块2D物理编辑3D物理编辑物理编辑模块 LayaAir引擎IDE内集成了2D物理与3D物理的可视化编辑，可直观的实现物理。 使用物理模块前，一定要先在项目设置（1.3.2节）里勾选对应的引擎模块。 2D物理编辑 3D物理编辑 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-07-05 16:34:32 "},"IDE/physicsEditor/physics2D/readme.html":{"url":"IDE/physicsEditor/physics2D/readme.html","title":"2D物理编辑","keywords":"","body":"LayaAir3-IDE可视化2D物理编辑详解一、新手必读1.1 前言1.2 物理引擎长度转换需知（必读）二、刚体 RigidBody2.1 添加刚体组件2.2 刚体类型 type2.3 重力2.4 角速度 angularVelocity2.5 角阻尼 angularDampin2.6 线性速度 linearVelocity2.7 线性阻尼 linearDamping2.8 子弹 bullet2.9 刚体休眠2.10 允许旋转 allowRotation2.11 碰撞相关的属性三、碰撞体 collider3.1 碰撞体与刚体的关系3.2 碰撞体基类属性3.3 矩形碰撞体 BoxCollider3.5 圆形碰撞体 CircleCollider3.6 多边形碰撞体 PolygonCollider3.7 链形碰撞体 ChainCollider3.8 边缘碰撞体 Edgecollider四、 关节 Joint4.1 关节的通用功能4.2 距离关节DistanceJoint4.3 鼠标关节 MouseJoint4.4 焊接关节WeldJoint4.5 滑轮关节 PulleyJoint4.6 马达关节 motorJoint4.7 旋转关节 RevoluteJiont4.8 平移关节 PrismaticJoint4.9 齿轮关节 GearJoint4.10 轮子关节WheelJoint五、总结与关联文档LayaAir3-IDE可视化2D物理编辑详解 Author : Charley Version >= LayaAir 3.1 一、新手必读 1.1 前言 本篇涉及2D物理IDE可视化编辑的全部内容，也就是说，不需要写一行代码，就可以通过可视化操作完成了物理的配置与效果实现。 如果您是刚接触物理引擎的新手，本篇不可避免的会涉及一些物理学相关的基础概念，文档中会尽可能简要说明，让大家理解作用与效果。 但本篇重点在于介绍引擎物理组件属性的作用与如何使用，为了文档的连贯性，对于过于基础的概念，可能不会太详细的进行描述。 此时，如果涉及到某块基础概念不理解，或者想进一步深入理解，需根据关键字自行搜索补习相关的基础知识。 1.2 物理引擎长度转换需知（必读） LayaAir3引擎内置支持Box2D物理引擎2.4.1版本。本篇文档全部内容均是基于该版本的物理引擎。 在Box2D物理引擎中，长度的单位是一个抽象的概念，物理引擎只关心相对长度和比例关系，而不关心具体的实际物理单位。 但是，常规情况下，会基于现实中的米、千克、秒（MKS）的单位制。 例如，默认的重力加速度值为 9.8，对应于现实世界中的 9.8米/秒²（m/s²） 。 物理密度的单位是质量除以面积，如果使用 MKS 单位制，那么密度的单位就是 kg/m²。 由于游戏中均是以像素作为长度单位，用米作为长度单位对游戏开发者而言并不直观。 所以，LayaAir3引擎IDE为了直观的表达，除了重力加速度之外，默认将物理引擎中的1长度单位转换为50个渲染像素。 并且，在项目设置中开放了长度转换比率的设置，开发者可根据项目实际需求，自主进行调整，调整位置如图1所示： (图1) 该设置与原生的Box2D物理引擎以及LayaAir3.1之前的版本有所不同，使用过旧版引擎的老用户请重点留意。 二、刚体 RigidBody 2.1 添加刚体组件 2.1.1 什么是刚体 大家都知道，自然界一切有形体的物质，都可以叫物体。 刚体是力学中为了体现物体特性的一种科学抽象概念，也是一种理想状态的力学表达模型，是指在运动中和受到力的作用后，形状和大小不变，而且内部各点的相对位置不变的物体。 现实中不可能存在这种理想模型，物体在受力之后，会根据力、材料、弹性、 塑性等综合因素，决定是否改变或改变多少。 如果物体本身的变化不影响整个运动过程，为使被研究的问题简化，仍将该物体当作刚体来处理而忽略物体的体积和形状，这样所得结果仍与实际情况相当符合。 LayaAir引擎中的2D刚体组件类是 Laya.RigidBody ，继承自创建组件的基类 Component。 2.1.2 如何添加刚体组件 在LayaAirIDE中，我们可以直接为2D节点添加刚体组件。如动图2-1所示。 (动图2-1) 在实际使用的时候，单独添加刚体的时候比较少，因为在添加碰撞体和关节的时候，会自动添加刚体 2.2 刚体类型 type Box2D物理引擎的刚体类型type分为： 静态刚体static、动态刚体dynamic、运动学刚体kinematic，默认为动态刚体dynamic。 如图2-2所示。 (图2-2) 2.2.1 静态刚体static 静态刚体通常用于表示不可移动的物体，如地面、墙壁等。静态刚体的质量和惯性是无限大的，因此它们不受外部力的作用，也不会对其他刚体施加力。 静态刚体的特点是：始终静止不动，无论施加怎样的力都不会移动， 不受重力影响，速度为零且不可设置 。 2.2.2 动态刚体dynamic 动态刚体是最常见的刚体类型，用于表示可以移动并受到外部力影响的物体，如角色、球体等。动态刚体具有质量和惯性，会根据外部力和扭矩的作用而移动和旋转。 动态刚体的特点是：会根据受到的力进行运动， 会受到重力的影响，可设置速度。 2.2.3 运动学刚体kinematic 运动学刚体是介于静态和动态之间的类型。它们不受外部力的影响，但可以通过设置线性速度和角速度来移动，而不是受到外力的直接作用。运动学刚体通常用于控制关节、平台等。 运动学刚体的特点是：不会根据受到的力进行移动，不受重力影响，可设置速度。与静态刚体主要区别就是，通常会通过设置速度（线速度和角速度）使其移动。 2.2.4 三种刚体类型特点对比表格 静态刚体 动态刚体 运动学刚体 是否受外部力影响 静止不动，且不受外部力影响 受外部力影响 不受外部力影响 是否受重力影响 不受重力影响 受重力影响 不受重力影响 是否可设置速度 速度为零，且不可设置 可设置速度 可设置速度 2.3 重力 2.3.1 什么是重力 重力是一种基本的自然力，是物体之间由于质量而产生的相互吸引力。根据万有引力定律，两个物体之间的引力与它们的质量成正比，与它们之间的距离的平方成反比。在地球表面附近，地球的质量导致物体朝向地心方向受到重力的作用，使其具有向下的加速度，通常被定义为9.8米/秒²。 在物理引擎中，重力是模拟现实世界中物体受到的引力效应的关键因素之一。物理引擎通过模拟重力可以使物体在仿真环境中按照自然规律受到牵引，落地，或者在斜面上滚动。引擎通常使用物体的质量和一个预定义的重力加速度值来计算物体所受的重力。这些计算可以基于经典力学的牛顿定律，通过使用离散的时间步长来模拟物体的运动。 物理引擎中的重力概念涉及到力的计算、运动的数学模型和仿真的时间步进。通过逼真地模拟重力，物理引擎能够提供更真实的虚拟环境，使开发者能够更容易地创建具有自然物理特性的游戏或其他应用。 2.3.2 全局的重力参数设置gravity $$ 重力的表达式为 ：F = m ⋅ g　　（其中 F 是物体所受的重力，m 是物体的质量，g 是重力加速度。） $$ 在LayaAir3-IDE项目设置里，2D物理分组下的重力加速度是用于整个2D物理重力的全局参数设置，该设置支持X、Y两个方向的重力设置，默认是Y轴正方向（垂直向下）的重力加速度值为9.8米/秒²（m/s²）。如图3-1所示： （图3-1） 在同等情况下，重力加速度的值越大，受重力影响的物体下落速度越快。 除了在项目设置面板中设置重力加速度，开发者也可以在代码中设置，示例代码如下： Physics2D.I.gravity= new Vector2(0,9.8) 2.3.3 重力缩放系数 gravity Scale 除了全局的重力加速度参数设置外，刚体的重力缩放系数属性，是用于独立影响单个动态刚体重力效果的参数。 该值乘以重力值，得到当前刚体最终受重力影响的值。该数值可以为正数或负数，也包括了正负小数。默认值为1，即正常的全局重力，如图3-2所示。 （图3-2） 如果数值为0则表示没有重力。大于1的数值表示正常重力的倍数，数值越大则重力越大。数值为负数，则表示反方向重力，数值越小则反方向的重力越大。如动图3-3所示。 (动图3-3) 2.4 角速度 angularVelocity 角速度即物体围绕其质心的自旋转速度，是表示单位时间内的角位移物理量，标准国际单位是弧度每秒。 LayaAir3.1开始，为了用户更容易直观的理解和设置，该处直接设置为角度值即可。例如设置为90，如图4-1所示，表示每秒的速度为90度角对应的弧度值。 （图4-1） 当我们设置角速度属性为正值的时候，则按顺时针旋转。角速度属性为负值的时候，则按逆时针旋转。属性值的绝对值越大，旋转速度越快。角速度属性的默认值为0，此时不会旋转。效果如动图4-2所示。 (动图4-2) 2.5 角阻尼 angularDampin 在现实中，旋转的物体通常会由于外部阻力而逐渐减速。 角阻尼正是用来模拟刚体在旋转运动中逐渐减速的参数，它用于表示外界作用或自身原因引起逐渐下降的衰减特性。 具体而言，刚体的角阻尼则是相对于角速度的旋转阻尼系数，这意味着角阻尼会导致刚体的旋转速度逐渐减小。通过调整该值，可以控制刚体在旋转过程中的减速程度。默认值为0，表示没有阻尼。 有无角阻尼的对比效果，如动图5所示。 （动图5） 2.6 线性速度 linearVelocity 线性速度也可简称为线速度，是指刚体在运动中沿着直线路径的速度，而不考虑其旋转。 该属性用二维向量来表示，分别描述了刚体沿着X（水平方向）和Y轴（垂直方向）的线性速度分量。 并且，该向量值同时也是矢量值，包含大小和方向。 从3.1开始，这两个分量的单位为像素/秒。 线速度的实际大小通过勾股定理（X平方加Y平方的根）计算得到，其大小表示物体运动的快慢。例如，X为3，Y为4，则线速度的实际大小为5，即5像素/秒。计算公式如图6-1所示。 (图6-1) 线速度的方向代表物体沿直线运动的方向，运动方向在坐标系统中理解起来就非常直观了，还是以3和4为例，表示了从坐标原点0,0到坐标3,4的直线运动方向。 默认值为0,0，在不受力的作用时，表示不进行线性运动。线速度效果如动图6-2所示。 （动图6-2） 2.7 线性阻尼 linearDamping 线性阻尼通常与刚体（RigidBody）的运动有关。刚体在运动过程中，除了受到外部的力之外，还可能受到一种与其速度成正比的阻尼力，该阻尼力被称为线性阻尼力。线性阻尼的引入可以模拟物体在流体或空气中运动时由于介质的阻碍而逐渐减缓速度并最终停止的现象。 开发者可以通过设置刚体的线性阻尼属性来调整刚体在运动过程中受到的线性阻尼力的强度。范围从0到无穷大。默认值为0，表示没有阻尼。有无阻尼的效果如动图7所示。 （动图7） 通常情况下，阻尼的值设置在0到1之间 2.8 子弹 bullet 当物体运动速度非常高时，传统的碰撞检测可能无法准确捕捉到碰撞的发生，导致隧穿等问题的出现。这是由于在碰撞检测的两个时间步之间，物体可能已经移动了一个较大的距离，离开了检测范围。这种情况下子弹属性的启用变得十分重要。 如动图8所示，启用子弹属性后，物理引擎采用更为精确的碰撞检测算法（连续碰撞检测CCD），即使在高速运动的情况下，也能够准确地检测到碰撞。而未开启弹属性的刚体在高速运动时出现了隧穿现象。 （动图8） 除了避免隧穿现象，子弹属性还可以用于避免高速移动的物体碰撞时可能产生的误差（如反弹或转动发生错误），以及避免高速刚体可能会对物理世界中的其他动态刚体造成剧烈冲击，从而影响整个物理世界的稳定性等问题的发生。 然而，需要注意的是，勾选启用子弹属性会增加物理引擎的计算负担。因为更为精确的碰撞检测需要更多的计算资源。因此，建议仅对确实需要进行高速运动的刚体启用该属性，以避免不必要的性能开销。 2.9 刚体休眠 物理引擎进行运动模拟时，是存在性能消耗的。当刚体停止运动时，其实我们可以不去模拟它。刚体设置为休眠状态就会跳过该刚体的模拟，直到被其它刚体解除才会醒来（关节被破坏或者手动唤醒也可以），从而节省性能的消耗。 2.9.1 允许休眠 allowSleep 如图9-1所示，勾选允许休眠，当刚体长时间没有发生运动或受到外力时，物理引擎会将其置于休眠状态。允许刚体休眠可以减少不必要的计算，提高性能。 （图9-1） 但是从休眠恢复到计算，也可能会导致无法即时响应。是否启用休眠取决于具体需求和对性能的权衡。在大多数情况下，启用休眠通常是合理的选择。 2.9.2 全局的刚体休眠功能开关 除了在刚体组件的休眠属性外，全局（项目设置面板）也有一个刚体功能的开关，如图9-2所示。 （图9-2） 需要注意的是，只有全局的刚体休眠功能开关是勾选启用的，单个的刚体才可以设置是否允许休眠。 否则，全局去掉勾选，则表示所有的刚体都不得休眠。这里建议保持全局的默认开启。 2.10 允许旋转 allowRotation 刚体的允许旋转是指当力或者冲击作用于该刚体时，它会按照物理规则进行自然旋转。这种旋转能够提供更加逼真的物理交互效果，比如当车辆碰撞或者物体掉落时的自然翻滚。如动图10-1所示。 (动图10-1) 如果把允许旋转的默认勾选去掉，则强制该刚体在整个物理模拟过程中保持不旋转，无论何种力学作用其上。这样的设置在某些游戏设计中也是有用的。例如，在一些需要刚体仅沿着特定轴移动或保持特别姿态的场景，禁用旋转能够简化物理响应，让游戏体验更加直接和可控。如动图10-2所示。不过，需要注意的是，这种非自然的物理限制可能会使碰撞的结果看起来不那么真实。 (动图10-2) 此外，在性能需求较高的情形下，关闭不必要的物体旋转也可能有助于提升物理模拟的效率，特别是在处理大量物体时。 2.11 碰撞相关的属性 2.11.1 碰撞组 group 每一个刚体，我们都可以分配一个整数的碰撞组索引值。通过碰撞组的索引比对规则来决定两个刚体是否应该进行碰撞。 碰撞组规则如下： 1、如果两个刚体的碰撞组索引相等，且都大于零，它们将始终会发生碰撞。 2、如果两个刚体的碰撞组索引相等，但都小于零，它们将永远不会发生碰撞。 3、如果两个刚体的碰撞组索引都等于0，或者碰撞组的索引不相等，则碰撞行为的检测不再依靠碰撞组的索引值，而是使用刚体的碰撞类别和碰撞掩码来判断是否进行碰撞。 2.11.2 碰撞类别category 碰撞类别是用来指定一个刚体属于哪个碰撞分类的，这个类别的值通常使用2的N次幂作为属性值，范围为[1, 2^31]，最多有32种不同的碰撞类别可用。 指数 2的N次幂 指数 2的N次幂 指数 2的N次幂 指数 2的N次幂 0 1 8 256 16 65536 24 16777216 1 2 9 512 17 131072 25 33554432 2 4 10 1024 18 262144 26 67108864 3 8 11 2048 19 524288 27 134217728 4 16 12 4096 20 1048576 28 268435456 5 32 13 8192 21 2097152 29 536870912 6 64 14 16384 22 4194304 30 1073741824 7 128 15 32768 23 8388608 31 2147483648 2.11.3 碰撞掩码 mask 碰撞掩码是用来声明当前刚体可能会与哪些碰撞类别的其他刚体发生碰撞的。 碰撞规则： 当两个刚体的碰撞组索引都等于0，或者碰撞组的索引不相等时，刚体的碰撞类别和碰撞掩码按位与的计算结果非0，可以碰撞；为0，则不可以碰撞。 例如，碰撞类别为2（2进制是10）， 碰撞掩码为3（2进制是11），二进制的按位与运算，如示意图11-1所示： (图11-1) 通过图11-1，我们可以看到，10是二进制按位与位运算的结果，而10的十进制对应值是2，非0，所以上面的示例可以发生碰撞。 开发者在设置不常用的数值时，可以在Devtools的控制台等工具中，通过&运算符直接用十进制数字来计算，从而确认碰撞关系，如图11-2所示： (图11-2) 掩码默认值-1的意义： 碰撞掩码默认值的默认值为-1，如图11-3所示： (图11-3) -1（所有二进制位都为1）与任何2的N次幂值进行按位与运算，都是幂值本身，非0，是可以碰撞的。 所以，相当于默认值就是一切都可以碰撞。 指定碰撞目标的掩码： 如果想指定具体某个刚体作为碰撞目标，那么想碰哪个类别的刚体，就为碰撞掩码直接设置那个碰撞类别值即可。 有的时候，我们需要为多个碰撞类别（不同的刚体），指定一个共同的碰撞掩码。 从原理上，我们可以通过按位或，直接计算多个碰撞类别，得到的结果就是可以碰撞的掩码，如图11-4所示： (图11-4) 通过上图的观察，细心的开发者可能发现，按位或得到的结果，就是要碰撞类别之和。 虽然本质是二进制位运算，但为了快速的设置碰撞掩码，直接将2的幂的碰撞类别总和作为可碰撞的掩码来理解也可以。 如果碰撞类别不是2的幂，是不能当作求和来理解的。这也是碰撞类别的值要设置为2的幂的原因之一。 排除碰撞目标的掩码： 前文都是介绍如何指定想与谁发生碰撞，如果我们不想碰撞某些碰撞类别的刚体，如何设置掩码呢？ 答案为，用-1去异或运算任何2的N次幂值，得到的结果再与该幂值进行按位与运算，一定是为0，也就是不可以碰撞的。 验证该理论的计算过程，如图11-5所示： (图11-5) 通过异或的二进制方式，我们就可以快速指定要排除的碰撞刚体。例如，图11-5中的-25就可以排除碰撞类别为8和16的刚体，其它刚体均可以发生碰撞。 为了简化理解和快速设计，异或运算也有简单的掩码取值方法。那就是把要排除碰撞类别之和+1，然后再取负，即可。 三、碰撞体 collider LayaAir引擎与IDE基于Box2D物理引擎的形状（shape）封装了更容易理解和使用的碰撞体（collider）。下面针对LayaAir3碰撞体进行介绍。 3.1 碰撞体与刚体的关系 碰撞体顾名思义，是用来检测碰撞的形状体组件。 刚体是作为碰撞体的载体，它定义了一个物体的物理性质（如刚体类型、重力、速度等），而碰撞体则定义了刚体的碰撞形状和与其他物体交互时的物理特性（如密度、摩擦力等）。 在物理世界中，进行碰撞检测和响应的实际是碰撞体，没有碰撞体的形状区域，只有刚体，则无法产生碰撞效果。 一个渲染节点对象，可以拥有多个不同形状的碰撞体，但只能有一个刚体。 3.2 碰撞体基类属性 碰撞体都继承于碰撞体基类ColliderBase，有着共有的基类属性。 所以，我们先介绍一下通用的属性和基类的属性。稍后再分别介绍各碰撞体的特有属性。 3.2.1 偏移量 碰撞体的偏移量是指该碰撞体形状相对于所属节点坐标的偏移值，XY的默认值均为0，与节点坐标保持一致，如图12-1所示。 （图12-1） 3.2.2 摩擦系数 friction 摩擦系数是一个描述两个接触表面之间相对滑动阻力大小的无量纲比值，定义为摩擦力与这两个表面上的垂直力之比。 在游戏开发和物理模拟中，摩擦系数用于确保物体运动的真实性和准确性。常用值在0到1之间， 0表示没有摩擦，1表示强摩擦。 对于非常光滑的表面（如冰面），摩擦系数可能接近0.01；对于日常生活中的接触表面，如橡胶与干燥路面，摩擦系数可能在0.1到1之间；动图12-2演示了不同摩擦系数的效果。 （动图12-2） 3.2.3 恢复系数 restitution 恢复系数是描述碰撞过程中物体弹性的属性。我们可以想象一下打乒乓球、篮球等，以恢复的特性使其弹出或弹起。 具体而言，恢复系数表示物体在碰撞时弹射回的速度相对于碰撞前的速度的比例。当两个物体发生碰撞时，它们之间的相对速度会影响碰撞的结果。如果恢复系数为1，表示碰撞是完全弹性的，物体之间会以相同的速度反弹；而如果恢复系数为0，表示碰撞是非弹性的，物体在碰撞后会停止。效果如动图12-3所示： （动图12-3） 3.2.4 密度 density 密度属性定义了一个物体单位面积所拥有的质量。密度的作用体现在它可以影响游戏中的多个物理特性，例如质量、惯性、浮力等。 在现实中，密度是物体质量与其体积的比值。但在二维世界里，由于缺失了一个维度，所以使用面积代替体积来简化计算。 密度值可以为零或者是正数，如果为零，无论形状的面积是多少，质量都将为零。这将使得物理反应类似于静态刚体，不会受到外部的力或重力等影响。 密度值在通常情况下都是正数，密度值越大，那么同等面积下，它的质量就越大。过小的密度可能会导致物体的行为不稳定，而过大的密度可能会导致物体质量极大，计算的消耗也更大。合理设置密度对于实现逼真的物理模拟至关重要，IDE内的默认值为10。不同密度的对比效果如动图12-4所示： （动图12-4） 当产生多物体堆叠在一起时，建议使用相似的密度，这样做可以使得堆叠更加稳定。 3.2.5 是否为传感器 isSensor 当交互逻辑需要判断两个碰撞体是否碰撞发生，但又不需要有碰撞反应。这时候，可以通过传感器来完成。 勾选该属性，设置为传感器后，可以检测到与其他物体的碰撞事件，但不会对这些物体产生物理的碰撞影响。 例如，可用于监测角色是否到达某个特定区域导致游戏行为发生改变，又或者用于触发特定效果，比如声音和动画。 是否设置为传感器的不同效果区别，如动图12-5所示： （动图12-5） 3.2.6 标签 label 碰撞体的标签，用于脚本物理碰撞事件中的碰撞体识别，当自定义了标签名后，如图12-6所示。 (图12-6) 应对的示例代码： onTriggerEnter(other: any): void { //other是碰撞到的碰撞体对象，根据碰撞到的标签处理对应的逻辑 if (other.label === \"buttle\") { //碰撞到子弹后，增加积分，播放声音特效 //省略若干代码…… } else if (other.label === \"ground\") { //只要有一个盒子碰到地板，则停止游戏 //省略若干代码…… } } 3.2.7 编辑碰撞体形状 点击编辑碰撞体形状，可以使得该碰撞体在场景面板中进入可视化的编辑状态，对其整体位置偏移或改变宽高的操作，鼠标离开碰撞体和节点的范围，编辑模式自动退出，再次编辑需要再次点击该按钮。演示效果如动图12-7所示： (动图12-7) 3.3 矩形碰撞体 BoxCollider 公共的属性说明在上文的碰撞体基类属性，本节不再重复介绍 3.3.1 宽高 Size 矩形碰撞体，是封闭的直角平行四边形碰撞框。 宽高是该碰撞体特有的属性，如图13-1所示，通过设置宽高改变碰撞体的大小。 (图13-1) 3.3.2 自动适配大小 autoFit 碰撞体的所属节点宽高改变后，碰撞体大小不会自动跟随改变。 自动适配大小是指，通过该按钮一键将节点的宽高设置为碰撞体的宽高。如图13-2所示。 (图13-2) 3.5 圆形碰撞体 CircleCollider 公共的属性说明在上文的碰撞体基类属性，本节不再重复介绍 3.5.1 半径 radius 圆形碰撞体是一种用于模拟圆形物体的碰撞形状。它通常由一个中心点和一个半径组成的封闭圆形框。 而半径正是圆形碰撞体特有的属性，其大小通过半径来控制，半径越大，该碰撞体的圆形框越大。效果如动图14-1所示： (动图14-1) 3.5.2 自动适配大小 autoFit 圆形碰撞体的自动适配大小与矩形碰撞体不同， 点击自动适配大小后，不仅会根据节点宽高中最短边的一半作为半径，还会修改节点的锚点值为0.5， 这样的好处是，不再以节点的左上角作为中心点，使得更符合圆形碰撞体的常用需求。效果如动图14-2所示。 （动图14-2） 3.6 多边形碰撞体 PolygonCollider 公共的属性说明在上文的碰撞体基类属性，本节不再重复介绍 3.6.1 多边形点数据集的设置datas 多边形碰撞体用于表示由多个顶点组成的凸多边形物体。顶点数量不能低于3个且不能超过8个。多边形碰撞体可以用来模拟各种平面物体，比如箱子、三角形或其他多边形形状的物体。点击点数据集右侧的点数据列表按钮，可以通过弹窗面板设置每个顶点的坐标（XY），如图15-1所示， (图15-1) 多边形碰撞体必须构成一个凸形状，如果必须要用凹多边形，可以由多个碰撞体组合拼接，强行设置凹多边形可能会导致不精确或者不正确的碰撞结果。 3.6.2 可视化设置点数据集 除了在弹窗中准确的设置数据，我们也可以可视化的编辑顶点，或先初步可视化编辑大致的基础形状，再到数据集弹窗中精准矫正。 进入可视化编辑碰撞状态，首先要点击碰撞体属性顶部的编辑碰撞体形状，进入碰撞体形状的编辑模式。此时就可以用鼠标左键，持续按住顶点拖拽，来改变顶点的位置。 如果想增加顶点，可以按住 ctrl 鼠标左键单击碰撞体形状的边线。 如果想删除顶点，可以按住 Alt 鼠标左键单击碰撞体的顶点。 效果如动图15-2所示： (动图15-2) 3.7 链形碰撞体 ChainCollider 公共的属性说明在上文的碰撞体基类属性，本节不再重复介绍 3.7.1 链形碰撞体与多边形碰撞体的主要差异 如果将链形碰撞体闭合起来，构建出同样外观的多边形，表面上看与多边形碰撞体并无不同，也是由多个顶点构成。 但是，无论链形碰撞体是否闭合，该碰撞体都不具有面积，不具有质量，无法受重力或碰撞力的影响，这与多边形碰撞体的特性完全不同。 因此，链形碰撞体通常用于静态的刚体。用于创建不规则或复杂的地面，例如山脉轮廓或多折线路径。 另外，在Box2D引擎中，双方发生碰撞，至少要有一方是具有面积形状的，而链形碰撞体显然没有，也就是说，当链形碰撞体与其它有实体形状（矩形、圆形、多边形）的碰撞体均可以发生碰撞，但与无实体的碰撞体（链形碰撞体与边缘碰撞体）之间不会发生碰撞。 3.7.2 链形点数据集的设置datas 链形碰撞体通常由一系列顶点连接的线段构成，形成一个开放的或者封闭的链。这种结构不会填充中间的区域，它仅仅定义了物体的边界。 链形碰撞体的数据集设置与多边形的方式一样，点击点数据集右侧的点数据列表按钮，可以通过弹窗面板设置每个顶点的坐标，这里就不配图了。 重点提醒一下，链形碰撞体最少由2个点的线段组成，通常是3个或更多。链形碰撞体的线段不能进行穿插自相交。如图16-1所示。 （图16-1） 自相交会导致物理引擎很难确定碰撞的确切行为，无法明确区分哪一部分应该在另一部分上方或下方。 3.7.3 可视化设置点数据集 与多边形碰撞体一样，除了在弹窗中准确的设置数据，我们也可以可视化的编辑顶点，或先初步可视化编辑大致的基础形状，再到数据集弹窗中精准矫正。 进入可视化编辑碰撞状态，首先要点击碰撞体属性顶部的编辑碰撞体形状，进入碰撞体形状的编辑模式。此时就可以用鼠标左键，持续按住顶点拖拽，来改变顶点的位置。 如果想增加顶点，可以按住 ctrl 鼠标左键单击碰撞体形状的边线。 如果想删除顶点，可以按住 Alt 鼠标左键单击碰撞体的顶点。 需要注意的是，由于链形碰撞体的实体只是线段本身，哪怕是封闭的链形碰撞体也没有对内部进行填充，所以在编辑模式下，只能对线段进行拖拽位移和增删顶点。离开节点显示对象的宽高范围后，只要不是点击线段，就会导致离开编辑模式。所以尽可能在节点范围内进行编辑操作。 效果如动图16-2所示： (动图16-2) 3.7.4 闭合loop 尽管链形碰撞体通常是用来创建开放的、不闭合的形状，如道路或者河流的边缘。 但也会存在闭合的需求，例如需要所有的碰撞反馈只在一个矩形区内发生，或环形湖泊等需求时，使用引擎的闭合功能来处理一个完整的链形碰撞体，就无需开发者手动连接起始和终点顶点，这样做不仅提高了工作效率，而且减小了出错的可能性，并且能保持物理模拟的连贯性和准确性。 勾选闭合的不同效果如动图16-3所示： (动图16-3) 3.7.5 反转数据ReversalData 由于链形碰撞体采用的是单侧碰撞，即法线朝向的一侧可以产生碰撞。因此，顶点的排列顺序非常重要，它会决定碰撞的方向（法线的方向）。 当链形碰撞体的顶点逆时针排序时，法线朝向内侧。当顶点顺时针排序时，法线朝向外侧。 如图16-4所示，左侧小球顺着法线的方向，会直接穿透，无法出去。右侧小球与法线方向相对产生运动，则会发生碰撞，无法进入。 （图16-4） 我们再以动图16-5直观的感受，当闭合链形碰撞体顶点逆时针排序形成一个封闭的区域时，小球产生的碰撞效果。 (动图16-5) 当顶点顺时针排序时，碰撞方向相反，效果如动图16-6所示， (动图16-6) 有的开发者可能想了解，如果链形碰撞体不是闭合的，怎么判断？ 其实，还是上面的理论，根据顶点逆时针还是顺时针排序来判断，与是否闭合没有关系。上面的示例只是由于闭合时，更形象的解释和理解了逆时针和顺时针的排序特点。例如动图16-7演示了未闭合的碰撞效果。 (动图16-7) 以上示例，无论是闭合还是不闭合，均较为明显的可以识别出顺逆时针的方向，那当链形碰撞体接近水平直线的时候，又是怎么判断呢？ 其实，还是一样的，关键点是，顺时针是从左向右开始环绕，逆时针是从右向左开始环绕的。 当起始的顶点到最终的顶点，方向是从左向右，哪怕是没有形成环绕，是水平的，那也属于顺时针方向，法线向下，从上向下才会发生碰撞。 反之，方向从右向左，是逆时针方向，法线向上，从下向上才会碰撞。效果如动图16-8所示， （动图16-8） 通过以上的示例，我们其实已经可以完全理解链形碰撞体的单侧碰撞，是与顶点的排序有着直接的关系。 而反转数据的功能，正是将顶点的数据进行逆向重排，也就是在链的形状不变的前提下，只是顶点的顺序相反。带来的效果，就是直接改变法向方向，改变了可碰撞的方向。 3.8 边缘碰撞体 Edgecollider 公共的属性说明在上文的碰撞体基类属性，本节不再重复介绍 边缘碰撞体是两个端点间一条线段形状的碰撞体。它主要用于表示地形的边界或其他不需要填充的平面。由于它没有体积，所以不会发生质量相关的计算。 该碰撞体与链形碰撞体一样，不具有面积，不具有质量，无法受重力或碰撞力的影响，而产生力的物理反馈，所以通常用于静态刚体。 但与链形碰撞体可以多条线段组合完全不同的是，边缘碰撞体只能由两个端点构成线段形状，如图17-1所示， (图17-1) 另外，在碰撞关系方面， 与链形碰撞体相同的是，都只能与有面积的碰撞体发生碰撞。 与链形碰撞体不同的是，哪怕是同为两个点组成的线段形状，边缘碰撞体两侧均可以发生碰撞，而链形碰撞体是单侧的。效果如动图17-2所示， (动图17-2) 四、 关节 Joint 关节用于连接两个或多个刚体，将刚体约束到物理世界或彼此约束。关节定义了物体之间如何运动，用于模拟真实世界中各种机械结构的运动方式，如铰链、弹簧、绳索、钟摆等。通过使用不同类型的关节，开发者能够创建复杂的物理模型，为游戏或仿真提供更富有现实感的动态行为。 4.1 关节的通用功能 关节的属性并不像碰撞体有大量的基类属性，只要属于碰撞体基类的属性，那所有的碰撞体都会拥有该属性。 但是关节里也有一些属性在好几个关节属性中都会出现，为避免重复介绍，把一些经常出现的通用属性和功能，这里统一进行说明。 4.1.1 编辑关节连线 关节的物理辅助编辑功能，主要是编辑连接两个关节连线的锚点位置。点击 编辑关节连线，关节连线的两端会出现两个点，红点表示自身刚体的锚点，绿点表示另一刚体的锚点。如图18-1所示： （图18-1） 在关节连线的编辑模式时，通过长按拖拽不同颜色锚点，就可以改变对应的刚体锚点位置。 当鼠标双击刚体和节点之外的位置后，关节连续锚点的编辑会自动取消。如需再次编辑，再次点击编辑关节连线按钮即可。 4.1.2 绑定另一刚体otherBody 在关节组件中，绝大多数都需要绑定另一个刚体，形成组合的关节关系与效果。 关节属性中的另一刚体就是指定当前刚体要与哪个刚体绑定，从而形成一对关节组合。 我们可以通过刚体选择弹窗来选择某个带刚体的节点进行绑定，也可以直接从层级面板上拖拽带有刚体组件的节点拖入到另一刚体的属性输入栏，操作如动图18-2所示。 (动图18-2) 4.1.3 设置锚点(自身锚点、另一锚点) 锚点指定了关节连接刚体的确切位置，它告诉物理引擎关节应该作用于刚体的什么位置。 锚点默认值是位于节点的原点位置，例如节点默认是左上角(0,0点)为原点，那锚点的值就是基于这个位置的偏移。如果想将锚点设置为中心点，建议直接修改节点锚点的XY均为0.5，这样关节锚点默认就不用再设置偏移值了，否则需要更改锚点的值到中心位置。 关于锚点的名称上， 有的关节只需要设置自身刚体的锚点，有的关节不仅需要设置自身刚体的锚点，还需要设置与当前关节绑定的另一个刚体的锚点。 当出现自身锚点与另一个刚体的锚点都需要设置时，为了明确区分，分别称为自身锚点selfAnchor和另一锚点otherAnchor，不需要设置另一个刚体锚点时，自身刚体的锚点直接称为锚点anchor。效果如下图所示： (图18-3) 4.1.4 振动频率frequency 振动频率也是很多关节中都会出现的属性，该属性值越大表示振动频率越高，意味着在更短的时间内完成一个振动周期，所以，振动幅度相对较小，振动速度更快。反之，振动幅度相对较大，振动速度更慢。效果如动图18-4所示： （动图18-4） 因此，我们可以理解，振动频率定义了关节刚体振动的速率。较高的振动频率通常对应于更快的振动，而较低的频率对应于更慢的振动。在某些应用中，可以通过调整振动频率来模拟不同类型的运动。 需要注意的是，振动频率不能过低，尤其是不能设置为0，设置为0相当于禁用了关节的弹簧效果，这会导致关节失去约束能力。 4.1.5 阻尼 damping 阻尼一般用来描述能量在系统中逐渐丧失的过程，例如由于摩擦力、空气阻力等造成的速度减少等。与上文刚体中涉及的线性阻尼和角阻尼的基本物理性质一样，都用于降低系统中的动能，帮助物体在无外力作用时返回稳定状态。 其区别是，刚体阻尼作用于单一物体，影响其线性或角运动。 而关节阻尼特别针对连接在一起的两个刚体，控制它们之间的相对运动和震动。它帮助控制通过关节运动传递的震动和冲击，防止过度振荡。 例如，在游戏中模拟车辆的悬挂系统，适当的关节阻尼可以让车辆在颠簸的道路上运行得更平稳。 有无阻尼的对比效果如动图18-5所示： （动图18-5） 4.1.6 碰撞连接刚体collideConnected 通常情况下，关节之间彼此连接的关节之间是不需要产生碰撞的，这也是关节的默认设置。然而也有一些情况，两个相互连接的关节刚体之间也存在碰撞的需求，此时，勾选碰撞连接刚体就可以使得关节彼此连接的刚体之间也可以发生碰撞。效果如动图18-6所示： （动图18-6） 提示：即便是勾选了碰撞连接刚体，碰撞的前提是关节连接的两个刚体本身，是可以发生碰撞的刚体。 4.2 距离关节DistanceJoint 本小节只介绍距离关节的特色属性，其它通用属性请查看> 距离关节描述了两个刚体锚点之间的距离，并且最终会保持着这个约束的距离。 根据距离关节的特点，这个关节的特色属性就是长度相关了，分别是长度、最小长度、最大长度，如图19-1所示： (图19-1) 4.2.1 长度length 长度的默认值为0，这并不是表示没有长度，而是自动取得关节的两个关节锚点之间的长度。 如果我们手动设置一个长度的话，那这里的长度就是两个关节在振荡停止后的最终长度。 但是，当我们设置了最小长度与最大长度，则长度的设置会受这两个属性所影响，我们继续向下阅读。 4.2.2 最小长度minLength与最大长度maxLength 最小长度是指关节连接的两个刚体之间可以达到的最小距离，当两个刚体受到关节约束时，它们之间的距离不会小于此最小长度。这可以防止关节连接的两个刚体过分靠近，确保物体在运动过程中不会穿透或发生异常行为。 最大长度是指关节连接的两个刚体之间可以达到的最大距离。当两个刚体受到关节约束时，它们之间的距离不会大于此最大长度。这有助于限制关节连接的两个物体之间的距离，确保它们不会在过大的范围内分离。 因此，这两个关节是影响距离关节的距离范围的参数。哪怕振荡幅度较大（频率低）也会受到这个范围的影响。 例如，钟摆示例中，如果不设置最小和最大长度，那震荡过程中，最短的弹性距离会小于长度的的设置，最大的弹性距离会大于长度的设置。而设置了最小和最大的长度后，最小和最大的振荡幅度范围会固定在这两个设定的范围区间。甚至是，当最小与最大长度保持一致时，直接不再振动，如同铁棍一样，关节约束的两个刚体固定在该长度的距离。效果如动图19-2所示。 (动图19-2) 4.3 鼠标关节 MouseJoint 本小节只介绍鼠标关节的特色属性，其它通用属性请查看> 鼠标关节是一种用来模拟用户用鼠标拖拽物体的物理约束。它通常会使得一个刚体可以跟随鼠标移动，但同时也能受到其他物理效果如碰撞、重力等的影响。 4.3.1 锚点 鼠标关节的锚点有些特别，所以除了通用属性的介绍外，这里再次进行说明。 其它关节需要手动指定另一个刚体，而鼠标关节的另一个刚体锚点会自动指向鼠标所在的位置，也就是说，鼠标关节是一种鼠标点与刚体锚点形成运动约束的关节。 另外，其它的关节锚点都是基于节点00点的位置偏移，而鼠标锚点则是基于鼠标点中的刚体位置进行偏移。 当振动频率较低时，更容易观察鼠标锚点与关节自身刚体锚点的连接关系，效果如动图20-1所示。 (动图20-1) 4.3.2 最大力 MaxForce 在鼠标关节中，核心的属性是设置最大的施加力maxForce，这个力用于限制鼠标关节试图将物体移向鼠标位置时所能施加的最大力量，避免力过大导致的异常行为或不自然的效果。 例如10牛顿可以勉强提起的物体，用100牛顿的力可以快速使得该鼠标关节的刚体跟随鼠标移动。效果如动图20-2所示。 （动图20-2） 该属性的值越大，将该关节刚体拉向鼠标的位置的牵引力越强，移动的响应速度越快。过小的值甚至不能克服其它作用在物体上的力（比如重力）的影响。 4.4 焊接关节WeldJoint 本小节只介绍焊接关节的特色属性，其它通用属性请查看> 焊接关节是一种常见的关节类型，用于将两个刚体固定在一起，使它们在物理仿真中相对位置和旋转保持不变，如同焊接起来一样，从而实现一体化的运动。 在游戏中，焊接关节可以用于实现机关、车辆等复杂物体的连接和运动。在工程仿真中，焊接关节可以用于模拟机器人、工业设备等的运动和控制。 焊接关节是个非常简单的关节组件，简单到它的属性在通用功能里都已经讲过，之所以放到鼠标关节之后来介绍，也仅仅是因为示例里需要用鼠标关节来撞击焊接关节，以显示焊接关节的约束关系。 动图21演示了焊接关节的约束效果， （动图21） 通过动图效果，我们可以看出，无论如何撞击，关节之间的刚体都如同被关节连线焊住一样，总能恢复如初，保持着相对的位置和角度。这正是焊接关节的特性。 4.5 滑轮关节 PulleyJoint 本小节只介绍滑轮关节的特色属性，其它通用属性请查看> 滑轮关节通过连接两个刚体，模拟现实中绳索或链条相互连接的滑轮系统运动和行为，实现力的传递和方向的改变，以及限制连接刚体之间的相对运动。当一个刚体上升时，另一个刚体就会下降。效果如动图22-1所示： (动图22-1) 动图22-1中，对三角形进行拖拽不是滑轮关节自身的功能，而是叠加了鼠标关节组件 4.5.1 自身地面点selfGroundPoint、另一地面点otherGroundPoint 地面点是沿用于Box2D引擎中的说法直译，并非是\"地面\"的中文字面意思，用于表示一个静止不变的固定点。相当于滑轮系统中的滑轮支架。 在滑轮关节中，存在两个滑轮支架，一个是连接自身刚体锚点的自身地面点，另一个是连接另一刚体锚点的另一地面点。 当一侧的刚体进行位移时，另一侧的刚体基于连接的“绳索”进行关联移动，移动的约束限制就是地面点。效果如动图22-2所示。 （动图22-2） 初始的地面点与锚点是对齐的，在默认值的状态下，相同质量的物体是静止的。如果我们调整地面点的位置，使得与锚点不再对齐，刚体受重力影响产生运动。如动图22-3所示。 （动图22-3） 4.5.2 传动比率ratio 传动比率模拟了现实中滑轮组的运动原理，它定义了两个连接刚体之间绳索长度的变化比率。也就是说，自身刚体的移动距离与另一刚体的移动距离之间存在着固定的倍率关系。 例如，如果传动比率被设为2，这意味着当自身刚体在其滑轮上升1米时，另一刚体的滑轮将下降2米。同样，当另一刚体上升2米时，自身刚体将下降1米。 所以说，在同一时间，另一刚体移动的距离 = 自身刚体移动的距离 * 传动比率；或者是，自身刚体移动的距离 = 另一刚体移动的距离 / 传动比率 效果如动图22-4所示： （动图22-4） 4.6 马达关节 motorJoint 本小节只介绍马达关节的特色属性，其它通用属性请查看> 马达关节允许指定两个刚体间的相对位置和角度，然后尝试通过施加力和扭矩来达到这些目标，并会尽力维持这样的配置。 4.6.1 线性偏移 linearOffset 线性偏移的作用在于试图将连接的另一刚体与自身刚体保持在某一个相对的位置上，而这个相对的位置正是基于自身刚体锚点的偏移位置。默认的偏移是0，表示与另一刚体的位置会与自身刚体重合，通过调整线性偏移值，我们可以使得其中一个刚体到达预期的目标位置，例如实现自动门的效果，如动图23-1所示： (动图23-1) 如果需要设置线性偏移，并且关节中的一方是静态刚体的时候，建议将马达关节添加给静态刚体，这样最终另一刚体的锚点会直接与静态刚体的线性偏移点重合，看上去更加直观。否则动态刚体的线性偏移点会与静态刚体锚点主动重合，导致线性偏移点在运行的时候与编辑时候位置不一致（不影响结果，都可以实现出同样的运行效果）。 4.6.2 角度偏移 angularOffset 角度偏移定义了两个刚体之间期望保持的角度差，马达关节会尝试通过施加力和扭矩来使刚体旋转到目标角度，并尽可能地维持这个角度差。 角度偏移值以X轴正方向为起始，顺时针计算角度。该功能可以适用于关卡中的旋转门或板桥开合等效果的实现，效果如动图23-2所示： （动图23-2） 这里有一个细节需要注意，当力作用于自身刚体时，正角度是顺时针方向。如果自身刚体是静态刚体，基于力的相互性，力作用于另一刚体时，另一刚体则会与自身刚体处于逆时针的角度。效果如动图23-3所示： （动图23-3） [!tip] 由于角度偏移涉及力与质量的计算。设置角度偏移的目标刚体，必须要添加碰撞体，否则角度偏移无效果。 4.6.3 最大力 maxForce 最大力是指在马达关节中施加在刚体上的最大力的大小。设置最大力的目的是限制马达关节施加在刚体上的力的大小，以防止力过大导致刚体的运动不稳定或产生不受控制的行为。当马达关节施加的力超过最大力时，引擎会自动截断力的大小，使其不超过设定的最大值。 但是如果最大力设置的过小，也可能会导致受其它力的影响而无法实现预期的刚体运动效果。合理的最大力设置有助于保持马达关节约束能力的稳定性和可控性。 效果如动图23-4所示： （动图23-4） 4.6.4 最大扭矩 maxTorque 马达关节的力指的是线性力（推或拉力），而扭矩是绕轴旋转的角力，用来旋转刚体。 与最大力类似，最大扭矩用于当马达关节施加的扭矩超过最大扭矩值时，引擎会自动截断扭矩的大小，以确保不超过设定的最大值。 扭矩的大小会影响旋转速度，过小的最大扭矩值，甚至会导致无法实现马达关节的角度偏移。因此，在实现角度偏移时，既需要足够的力保持刚体运动的稳定性，也需要足够的扭矩使得刚体能够旋转起来。 效果如动图23-5所示： （动图23-5） 4.6.5 修正系数 correctionFactor 当马达关节连接的刚体发生了位置偏差时（不在指定的偏移位置上），修正系数影响用多快的速度来纠正这一偏差，使得物体回到预期的位置。 修正系数取值范围是0-1之间，该值影响着马达关节的偏移纠正速度，可以理解为是一个控制马达关节响应速度的参数。较大的修正系数会导致更快的达到偏移位置，但会引起振荡。较小的修正系数会导致更慢的达到偏移位置，但更稳定。 它允许开发者为关节设定一个响应灵敏度的平衡点，使得刚体能以期望的方式运动，同时又不会因过于剧烈的校正而造成的不稳定。 效果如动图23-6所示： （动图23-6） 4.7 旋转关节 RevoluteJiont 本小节只介绍旋转关节的特色属性，其它通用属性请查看> 旋转关节允许刚体围绕自身锚点旋转。该关节可以配置马达，施加扭矩以实现持续旋转，如模拟车轮转动效果；也可以设定角度限制，实现铰链动作效果，仅允许刚体在特定范围内旋转。 4.7.1 启用马达 enableMotor 在勾选启用马达后，有两个关联的属性，马达速度motorSpeed与最大扭矩maxMotorTorque，如图24-1所示： （图24-1） 最大扭矩通常不用设置，采用默认值即可，该属性的作用与前文中的马达关节一致。 关键属性是马达速度，这将直接影响旋转的速度与方向。该值与扭矩的共同作用下，使得旋转关节可以产生持续旋转的动力。 另外，马达速度的正负值会影响旋转方向，如果马达速度为正值，旋转方向为顺时针旋转，为负值的时候旋转方向为逆时针旋转。 动图24-2中对比了不同转速与方向的效果： （动图24-2） 4.7.2 角度限制enableLimit 在勾选角度限制后，也有两个关联的属性，角度下限lowerAngle与角度上限upperAngle，如图24-3所示： (图24-3) 角度限制由角度的下限与上限组成，下限表示最小的角度范围，上限表示最大的角度范围。 当启用马达或施加外力的时候，关节的刚体会在该角度的范围内具有旋转的自由度。效果如动图24-4所示； （动图24-4） 4.8 平移关节 PrismaticJoint 本小节只介绍平移关节的特色属性，其它通用属性请查看> 平移关节也被称为棱柱关节，其中“棱柱关节”是从Box2D中的英文名称“Prismatic Joint”直译而来，源自于棱柱两侧面平行的几何特性。而“平移关节”这个名称则更加直观地描述了关节允许的物理运动——那就是沿特定轴线的直线移动。 此外，在理解它的工作原理时，平移关节可以类比于马达中的线性推力，相对于旋转关节（RevoluteJoint）代表马达中的角扭矩。这样的对比有助于我们了解不同类型的关节及其功能：旋转关节允许刚体围绕某个点进行旋转，就像马达产生的角动作；平移关节则限制刚体沿着一个方向进行线性平移，类似于马达施加的直线动作。 因此，尽管平移关节具备两个刚体间只能平行运动及沿着特定直线方向进行平移这两个特性，我们更倾向于使用“平移关节”这个名称，因为它更加形象地体现了该关节的主要作用。 4.8.1 平移方向angle 平移方向是指该关节只能沿着哪个方向进行平移，单位是角度。例如0度表示水平向右方向，90度表示垂直向下的方向，180度表示水平向左的方向，采用顺时针的角度作为方向，以此类推。效果如动图25-1所示： (动图25-1) 4.8.2 启用马达enableMotor 在勾选启用马达后，有两个关联的属性，马达速度motorSpeed、最大力maxMotorForce，如图25-2所示： (图25-2) 最大力通常不用设置，采用默认值即可，该属性的作用与前文中的马达关节一致。 关键属性是马达速度，这将直接影响移动的速度与方向。马达速度属性的绝对值越大，移动的速度也就越快，通常设置为正值，如果设置负值，则会向相反方向移动。 动图25-3中对比了不同速度与方向的效果： （动图25-3） 4.8.3 平移限制enableLimit 在勾选平移限制后，有两个关联的属性，平移下限lowerTranslation、平移上限upperTranslation，如图25-4所示： (图25-4) 与旋转关节类似，平移范围也有下限和上限，限制的值以像素为单位。 平移下限lowerTranslation是指移动的最短距离是离锚点anchor有多远。移动的时候会以下限为起点。 平移上限upperTranslation是指移动的最长距离可以离锚点anchor有多远，达到限制后，无论设置多大的马达力，移动时，也不会超出上限范围。 下限与上限，即便没有启用马达，也会受这个限制影响。 下限与上限的对比效果如动图21-4所示。 (动图25-5) 4.9 齿轮关节 GearJoint 本小节只介绍齿轮关节的特色属性，其它通用属性请查看> 齿轮关节是一种模拟两个齿轮连接效果的关节类型，它可以用来将两个关节的运动通过一定的比例关系连接起来。 4.9.1 绑定关节joint 齿轮关节与其它关节不同的是，齿轮关节并非是连接绑定刚体，而是连接两个关节，如图26-1所示。并且关节类型只能是旋转关节（RevoluteJoint）或平移关节（PrismaticJoint）。 (图26-1) 齿轮关节应该添加在哪个节点上？ 对于齿轮关节而言，它本身并不直接与任何刚体相连，而是通过连接另外两个关节(关节1和关节2)来传递运动和约束。所以，齿轮关节添加到哪个节点均无所谓，关键点是关节1和关节2是谁，这会影响哪两个关节会发生作用。通常情况下，建议添加到关节1或关节2的节点对象上，或者是它们的父节点上。 被连接的关节有什么要注意的？ 关节1与关节2选择哪个关节，并没有先后顺序的影响，只要是旋转关节或平移关节二者之一即可，其它关节类型不得应用于齿轮关节。 由于旋转关节或平移关节均可以不设置连接其它刚体，所以关节1与关节2的被连接关节，是否连接另一个显示对象的刚体取决于实际的需求。 如果需要设置马达力给关节，虽然可以给两个关节都设置马达力，但通常情况下，只给其中一个关节设置马达力 是更佳选择。这是因为两个马达力可能会产生冲突，导致齿轮关节的运动不稳定。 动图26-2中，演示了齿轮关节设置的基础流程： (动图26-2) 4.9.2 齿轮比率 ratio 齿轮比率是决定两个通过齿轮关节连接的关节之间运动转换方式的系数。当你设置了一个齿轮比率，相当于是在定义转动或平移的一种“汇率”。例如，一个旋转关节与一个平移关节通过齿轮关节连接，并设定了一个特定的齿轮比率。这个比率决定了旋转关节的每一度旋转会导致平移关节移动多少距离，反之亦然。 正比率：如果齿轮比率为正值，这意味着两个关节将会以相同的方向进行转动或移动（即一个关节的顺时针旋转会导致另一个关节相应地以正比率移动或旋转）。 负比率：如果齿轮比率为负值，这表示两个关节会以相反的方向进行转动或移动（即一个关节的顺时针旋转会导致另一个关节相应地以负比率反向移动或旋转）。 效果如动图26-3所示： (动图26-3) 4.10 轮子关节WheelJoint 本小节只介绍轮子关节的特色属性，其它通用属性请查看> 轮子关节是一种可以模拟车辆轮子挂载以及悬挂系统的关节。这种关节允许一个物体在另一个物体上以固定的轴向转动，同时还能沿着轴向弹簧回弹。轮子关节广泛用于模拟车辆动力学，如摩托车、汽车等在游戏中的行为。利用轮子关节，可以轻松实现车辆的平滑行驶、跳跃和过弯等复杂动作。 4.10.1 启用马达 enableMotor 启用马达在前文中介绍过，基础的使用完全一样，这里只说一下需要注意的要点。 由于轮子关节通常是应用于模拟车辆，所以我们通常会将多个轮子连接到同一个车身刚体。例如摩托车的两个轮子关节的另一刚体都连接到同一个车身节点的刚体。 需要注意的是，我们保持至少有一个轮子启用马达，用于模拟车辆的驱动力，但无需所有轮子都要启用马达，这相当于摩托车是后轮驱动还是前轮驱动的效果。当然，如果您需要全轮驱动（全部轮子都启用马达）的效果，也是允许的。 效果如动图27-1所示： (动图27-1） 4.10.2 弹性方向 angle 弹性方向是一个角度值，用于定义模拟悬挂的弹性运动方向，即轮子在哪个方向可以如弹簧一样压缩和伸展，比如0度是沿X轴向右, 90度是沿Y轴向下的方向。 更多弹性方向的介绍与移动限制结合起来介绍 4.10.3 移动限制 enableLimit 弹性方向的设置，只是定义了悬挂模拟的弹簧方向，移动限制勾选后，定义了在这个方向上的移动范围。如图27-2所示： (图27-2) 这个范围是的基于弹性方向和锚点位置的线性范围区间。 当运行后，如果我们勾选了绘制关节，那我们可以直观的看到移动的范围区间，如图27-3所示： （图27-3） 有了这个范围区间，我们就可以爬坡、落地的时候，直观的感受到悬挂模拟效果受这个范围的限制后，会更加的稳定。否则可能会出现不真实的弹性效果。对比效果如动图27-4所示： (动图27-4) 实现悬挂的效果还要配合振动频率，太低和太高均会影响最终效果。 如果移动上限与移动下限均为0，那即便是设置了弹性的方向，也无法得到悬挂的效果。对比效果如动图27-5所示： （动图27-5） 五、总结与关联文档 本篇文档至此，已完成了2D物理组件的介绍，通过2D物理组件，开发者可以在IDE中可视化编辑和预览物理的效果（如碰撞、关节）。 然而实现一个完整的物理游戏或交互产品。仅凭本文所述知识还是不够的，关键还在于交互的逻辑，所以我们还需要掌握脚本编写、以及脚本中的物理碰撞事件，通过对碰撞事件的妥善处理，我们可以在物理碰撞发生的适当时机进行精确的物理反馈或实现特定的逻辑效果。 另外，项目设置中与2D物理相关的设置说明，开发者也需要熟悉，这有助于对物理的深入理解与控制，下面提供的文档链接，希望可以为大家进一步掌握物理带来帮助。 关联文档链接： 脚本 - 物理碰撞事件 项目设置 - 2D物理 自定义物理引擎 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2024-04-26 15:54:00 "},"IDE/physicsEditor/physics3D/readme.html":{"url":"IDE/physicsEditor/physics3D/readme.html","title":"3D物理编辑","keywords":"","body":"LayaAir3-IDE可视化3D物理编辑详解一、刚体二、物理碰撞三、物理约束四、物理射线五、其它物理引擎的使用LayaAir3-IDE可视化3D物理编辑详解 Author : Charley Version >= LayaAir 3.1 LayaAir3.1引擎版本中，我们对于物理引擎的接口架构进行了重构，使得3D物理不仅仅完善了物理组件的功能，还彻底满足了自由接入第三方的物理库的需求。 也就是说，除了本身就集成好的Bullet物理引擎与PhysX物理引擎，开发者也可以轻松的自行接入其它的物理引擎。 例如，我们在资源商店中提供了Cannon.js这样的轻量物理引擎库，由开发者通过自定义的方式引入到LayaAir中使用。 本篇文档，将会围绕可视化的3D物理组件的详细使用说明、物理组件脚本的使用、如何引入第三方物理库等内容，指导开发者快速上手物理引擎的基础使用。 一、刚体 1.1 什么是刚体 无论是2D，还是3D，物理的开篇，都需要先了解刚体（RigidBody），这是物理引擎的基础之一。 大家都知道，自然界一切有形体的物质，都可以叫物体。 刚体是力学中为了体现物体特性的一种科学抽象概念，也是一种理想状态的力学表达模型，是指在运动中和受到力的作用后，形状和大小不变，而且内部各点的相对位置不变的物体。 然而，现实中不可能存在这种理想模型，物体在受力之后，会根据力、材料、弹性、 塑性等综合因素，决定是否改变或改变多少。 如果物体本身的变化不影响整个运动过程，为使被研究的问题简化，仍将该物体当作刚体来处理而忽略物体的体积和形状，这样所得结果仍与实际情况相当符合。 1.2 常用的刚体属性 isKinematic是否为运动刚体 3D的刚体，默认是动力学刚体。受力的影响，可以位移。 一旦我们把刚体设置为运动刚体类型后，即将isKinematic的值设置为true。 那么运动刚体可以触发第三方的物理反馈，自己却不受物理影响。例如，运动刚体与动力学刚体发生撞击，动力学刚体会受力反弹，但运动刚体却不会受力的影响，不会产生受力位移，运动刚体的位移只能通过transform改变节点坐标。 与2D的运动学类型刚体不同，LayaAir 3D的运动刚体脱离了物理引擎运动，即使设置速度也不可以使其位移。这样做的好处是减少了物理运算，节省了性能。 mass质量 质量是物质的量的量度，Bullet引擎中的质量单位为kg。 刚体的质量越大，运动状态改变越难，比如，不同质量的两个物体相撞，质量大的一方改变更小一些，如动图1的左侧所示： （动图1） 静态刚体和运动刚体就相当于无限大质量，不受力的影响。 gravity 重力 自然界中物体受地心吸引的作用而受到的力叫重力，物理引擎中也同样模拟了重力， 动力学刚体在同等的质量下，重力越大，下落的加速度越大。对比效果如动图1-1。 （动图1-1） angularVelocity 角速度 刚体的angularVelocity属性是角速度， 角速度简单理解就是单位时间的角位移，以弧度每秒进行旋转 。当我们设置动力学刚体angularVelocity属性为正值的时候，则按顺时针旋转位移。angularVelocity属性为负值的时候，则按逆时针旋转位移。属性值的绝对值越大，旋转位移速度越快。 （动图1-2） angulaVelocity属性的值是3维向量Vector3类型值，Bullet使用欧拉角来描述物体的旋转，3D向量的每个分量代表绕x、y、z轴旋转的速度，单位是弧度/秒。动图1-2，就是在x轴分别设置了3.14与31.4的对比效果。 angularDamping 角阻尼 刚体的角阻尼相当于是为角速度旋转方向施加了相反的力，使得旋转速度衰减。 动图1-3，是在同样的31.4角速度下，左侧为1的的角阻尼值，右侧为0.9的角阻尼值，对比效果。 （动图1-3） angularFactor 角度因子 刚体的角度因子是在每个轴方向（速度和力）上缩放物理值的角度因子 动图1-4，是在同样的31.4角速度下，左侧为1的的角度因子，右侧为2的角度因子，对比效果。 （动图1-4） linearVelocity 线性速度 刚体的linearVelocity属性称为线速度或者线性速度，是指物体的直线运动速度。 动力学刚体的线速度是3维向量Vector3类型值，向量的方向即速度的方向，向量的长度即速度的大小。 动图1-5，是动力学刚体在同样重力值为0的情况下，没有设置线速度和y轴设置了线速度值的对比效果。 （动图1-5） linearDamping 线性阻尼 刚体的linearDamping属性，是指线性速度的阻尼系数，使得线性速度衰减。 动图1-6，是动力学刚体在重力为0并且y轴设置了同样为-1的线速度值情况下，左侧为0.9线性阻尼值和右侧为1线性阻尼值的对比效果。 （动图1-6） linearFactor 线性因子 刚体的linearFactor属性，是指个轴方向上缩放物理值（速度和力）的线性因子 刚体的linearDamping属性，是指线性速度的阻尼系数，使得线性速度衰减。 动图1-7，是动力学刚体在重力为0并且y轴设置了同样为-1的线速度值情况下，左侧为1线性因子和右侧为2线性因子的对比效果。 （动图1-7） 二、物理碰撞 碰撞是物理引擎中最基础、最常用的功能。在这个小节里，我们对3D物理碰撞进行全面的认知。 2.1 碰撞器与触发器 对于检测3D物理碰撞的方式，有碰撞器与触发器两种。我们先从概念认知开始。 2.1.1 碰撞器 在LayaAir引擎2D物理的时候，通过封装的不同形状的碰撞体，就可以直接实现带范围的物理碰撞。 而LayaAir引擎的3D物理，形状不再是最主要的特征，只是碰撞器用于检测碰撞范围的三维形状区域。 完整的3D碰撞器，由碰撞器和碰撞器形状两部分组成。 3D碰撞器根据特点的不同，分为静态碰撞器、刚体碰撞器、角色碰撞器。 这些碰撞器必须要添加三维碰撞器形状（例如：盒形、球形、圆锥形、圆柱形、胶囊形、平面、混合、模型网格），才可以实现有范围的物理碰撞。 （图2-1） 图2是胶囊形状角色碰撞器的编辑预览效果。 2.1.2 触发器 LayaAir 3D物理的触发器相当于2D物理里的传感器。 触发器是碰撞器的一个属性，任何碰撞器的触发器属性设置生效后，当前的碰撞器即转变为触发器（比如，刚体碰撞器设置触发器后可称为刚体触发器）。即使发生物体接触，也不会产生碰撞的物理反馈。例如，动图3-1右侧所示。下落的盒子无视物理引擎，直接穿透而过。 （动图2-1） 设置触发器后，虽然失去了物理引擎反馈，但是可以激活触发器的碰撞生命周期方法，用于检测物体间碰撞接触的发生。 激活触发器生命周期也有特定的情况除外，具体规则会在下面的物理生命周期章节介绍 当触发器isTrigger设置为true时，如图2-2所示。触发器即可设置生效。 （图2-2） 通过代码设置触发器的方式： /* ……省略若干代码 */ //获取物理刚体组件 this.rigidbody1 = this.cube1.getComponent(Laya.Rigidbody3D) as Laya.Rigidbody3D; this.rigidbody2 = this.cube2.getComponent(Laya.Rigidbody3D) as Laya.Rigidbody3D; //设置rigidbody1为触发器,取消物理反馈 this.rigidbody1.isTrigger = true; this.rigidbody2.isTrigger = false; /* ……省略若干代码 */ 2.2 理解各种碰撞器 2.2.1 静态碰撞器 PhysicsCollider LayaAir的3D物理碰撞器类是PhysicsCollider，为了便于记忆和理解，我们叫他静态碰撞器类。因为它的特性是不受力，不会产生物理移动。 当其与动力学刚体碰撞器或角色碰撞器发生物理碰撞后，可以触发物理碰撞生命周期方法，但不会产生物理的受力位移。 这种碰撞器可以用于不需要物理受力位移的物体，只需要触发碰撞逻辑的应用场景。例如墙体，撞墙后判定游戏结束。 （图2-3） 图2-3是添加LayaAir的3D物理碰撞器组件PhysicsCollider 2.2.2 刚体碰撞器 Rigidbody3D LayaAir的2D物理刚体与碰撞体是分开的，而3D物理的刚体与碰撞器是整合的，Rigidbody3D类即是刚体也是碰撞器，我们可称为刚体碰撞器。 默认情况下，Rigidbody3D是动力学类型的刚体碰撞器，这是可以受力影响的刚体类型碰撞器，所以我们通常用动力学刚体碰撞器进行受力的交互反馈。例如，撞击后的反弹、飞出或者倒下，放在空中会受重力影响而掉落，等等。 当我们将刚体Rigidbody3D的isKinematic设置为true后，那么默认的动力学刚体碰撞器就转变为运动刚体碰撞器。 运动刚体碰撞器从表象上看，与静态碰撞器基本上没有什么区别。都是不受重力、不受速度、不受其它力的影响，在物理世界中永远处于静止，只能通过transform去改变节点坐标来移动。 但实质上，运动刚体有物理特性，它可以是施力物体，可以对非运动刚体产生力，例如通过控制节点去移动运动刚体，会推着挡在前面的动力学刚体移动。而静态碰撞器的应用场景则是要永远不动，也无法施加力。并且，通过节点去移动静态碰撞器，也比较消耗性能。如果有移动的碰撞器需求，例如来回移动的跳板或障碍，使用运动刚体碰撞器就可以了。 通过代码设置运动刚体的方式： /* ……省略若干代码 */ //获得刚体碰撞器 this.rigidbody = this.cube1.getComponent(Laya.Rigidbody3D) as Laya.Rigidbody3D; //开启运动类型刚体 this.rigidbody.isKinematic = true; /* ……省略若干代码 */ 在LayaAir中设置运动类型刚体的方式，如图2-4所示： （图2-4） 由于LayaAir的3D物理中有了静态碰撞器PhysicsCollider，所以并没有在Rigidbody3D中去实现静力学类型的刚体碰撞器。有静止的碰撞反馈需求，直接使用静态碰撞器即可。 2.2.3 角色碰撞器 CharacterController 角色控制器类CharacterController常用于对第一人称和第三人称游戏角色的控制，可以方便的控制角色的跳跃、跳跃速度、降落速度、行走、等。 由于角色控制器继承于PhysicsComponent，也具有碰撞器的特性，可以添加三维碰撞形状，产生碰撞的反馈，因此也称为角色碰撞器，属于碰撞器之一。 与静态碰撞器和刚体碰撞器都继承自物理触发器组件PhysicsTriggerComponent不同，角色控制器直接继承于物理组件的父类PhysicsComponent。所以，角色控制器是无法设置为触发器的。但是，角色碰撞器与触发器进行接触，仍然可以激活触发器的生命周期方法。 （图2-4） 图2-4是添加角色控制器类CharacterController 2.3 碰撞形状 碰撞形状是用于检测碰撞接触的范围，只有添加了形状，碰撞器和触发器才能触发物理反馈和生命周期。 LayaAir引擎支持8种3D碰撞形状，分别为： 盒形BoxColliderShape、球形SphereColliderShape、圆柱形CylinderColliderShape、胶囊形CapsuleColliderShape、圆锥形ConeColliderShape、平面形状StaticPlaneColliderShape、复合形状CompoundColliderShape、网格形状MeshColliderShape。 2.3.1 LayaAir中可创建的碰撞形状 盒形碰撞体Box collider、球形碰撞体Sphere Collider、胶囊形碰撞体Capsule Collider、圆柱形CylinderColliderShape、圆锥形ConeColliderShape、网格碰撞体 Mesh Collider，这6种组件是可以在LayaAir中使用的。 下面我们简单介绍一下这些碰撞体形状的基础属性设置 盒形碰撞形状 盒形碰撞形状是通过设置XYZ调整长宽高的长方体（含立方体）形状。常用于盒子外形的长方体物体，如图2-6所示。 （图2-6） 在LayaAir中，设置盒形碰撞XYZ各轴的大小，如图2-7所示。 （图2-7） 球形碰撞形状 球形碰撞形状是通过设置半径调整球体大小的碰撞形状。常用于球形外观的物体，如图2-8所示。 （图2-8） 在LayaAir中，设置球形碰撞半径，如图2-9所示。 （图2-9） 胶囊形碰撞形状 胶囊形碰撞形状是由两个半球和一个圆柱体组成，需要通过设置球体半径和圆柱体的高来组成胶囊形状。常用于角色碰撞器。如图2-10所示。 （图2-10） 在LayaAir中，设置胶囊形碰撞半径和高，轴方向，如图2-11所示，导出后即可使用。 （图2-11） 圆柱形碰撞形状 圆柱形碰撞形状是通过设置半径和高调整球体大小的碰撞形状。如图2-12所示。 （图2-12） 在LayaAir中，设置圆柱形碰撞半径和高，如图2-13所示。 （图2-13） 圆锥形形碰撞形状 圆锥形形碰撞形状是通过设置半径和高调整球体大小的碰撞形状。如图2-14所示。 （图2-14） 在LayaAir中，设置圆锥形碰撞半径和高，如图2-15所示。 （图2-15） 网格形碰撞形状 网格形碰撞形状是利用模型网格资源构建的形状，如图2-16-1的猴子所示。相对于其它固定规则的碰撞形状（LayaAir内置的3D碰撞基础形状），网格形碰撞形状属于自定义任意外观的碰撞形状，可以适用于任何模型网格。 （图2-16-1） 在LayaAir中，设置模型网格，如图2-16-2所示。 （图2-16-2） 2.3.2 其它LayaAir碰撞形状 除了碰撞体组件支持的一些形状外，LayaAir引擎中还内置了一些基础的3D碰撞形状。这些只能通过代码的方式进行添加。 平面碰撞形状 平面碰撞形状，是一种无限大的2D平面碰撞形状。通常用于整个场景地面的碰撞形状。通过法线来确定在3维世界的平面朝向，可以通过偏移值来调整距离原点的偏移多少。API说明如图2-17所示。 （图2-17） 通过API，我们可以看到normal是一个3维向量值，表示着平面的法线。例如这个值为Vector3(0, 1, 0)，则表示法线位于Y轴正方向，平面碰撞形状就是处于其垂直的X轴无限大水平面。 图2-18和2-19是法线同样位于Y轴正方向，偏移值offset分别为0（左侧）和为1（右侧）的效果对比。 （图2-18） （图2-19） 2.3.3 碰撞器的形状代码添加示例 LayaAir内置的基础碰撞形状使用示例 内置的碰撞器使用思路为，创建节点对象，创建碰撞器，创建碰撞器形状，为碰撞器添加碰撞形状。 我们以创建圆锥形刚体碰撞器为例，编写代码如下所示： /* ……省略若干代码 */ /**增加圆锥形刚体碰撞器 */ private addCone(): void { //生成随机值半径和高 let raidius = Math.random() * 0.2 + 0.2; let height = Math.random() * 0.5 + 0.8; //创建圆锥形3D模型节点对象 let cone = new Laya.MeshSprite3D(Laya.PrimitiveMesh.createCone(raidius, height)); //把圆锥形3D节点对象添加到3D场景节点下 this.newScene.addChild(cone); //设置随机位置 this.tmpVector.setValue(Math.random() * 6 - 2, 6, Math.random() * 6 - 2); cone.transform.position = this.tmpVector; //为圆锥形3D节点对象创建刚体碰撞器 let _rigidBody = (cone.addComponent(Laya.Rigidbody3D)); //创建圆锥形碰撞器形状（使用节点对象的值，保持一致性） let coneShape = new Laya.ConeColliderShape(raidius, height); //为刚体碰撞器添加碰撞器形状 _rigidBody.colliderShape = coneShape; } /* ……省略若干代码 */ 其它基础形状的创建可参考官网的引擎示例 复合碰撞形状的使用示例 复合碰撞形状是由多个基础形状组合而成的碰撞器形状。例如桌子或者凳子等，可以由多个盒形碰撞形状组成，如图2-20所示。 （图2-20） 复合碰撞形状主要就是可以添加多个不同的子形状，理解后其实也是非常简单。 创建复合碰撞形状的方式并不复杂，先实例化复合碰撞形状CompoundColliderShape()，再通过复合碰撞形状对象的addChildShape方法添加基础碰撞形状子对象即可。 我们继续通过代码和注释来理解。编写代码如下所示： /* ……省略若干代码 */ Laya.Mesh.load(\"res/threeDimen/Physics/table.lm\", Laya.Handler.create(this, function(mesh:Laya.Mesh) { //读取桌子模型节点对象，添加到3D场景节点下， var table = scene.addChild(new Laya.MeshSprite3D(mesh)) as Laya.MeshSprite3D; //给桌子节点对象添加刚体碰撞器 var rigidBody = table.addComponent(Laya.Rigidbody3D) as Laya.Rigidbody3D; //实例化一个复合碰撞形状对象 var compoundShape:Laya.CompoundColliderShape = new Laya.CompoundColliderShape(); //创建盒形碰撞形状 var boxShape:Laya.BoxColliderShape = new Laya.BoxColliderShape(0.5, 0.4, 0.045); //获取本地偏移 var localOffset:Laya.Vector3 = boxShape.localOffset; //修改偏移 localOffset.setValue(0, 0, 0.125); boxShape.localOffset = localOffset; //为复合碰撞形状对象添加子形状（刚刚创建的盒形碰撞形状） compoundShape.addChildShape(boxShape); //后面的代码都是类似，把一个个的子形状都添加到复合碰撞形状对象上。子形状也可以是别的形状，例如球形、圆柱形等，根据模型节点的实际情况来。 /* ……省略若干boxShapeXX类似的代码，只保持到boxShape4 */ var boxShape4:Laya.BoxColliderShape = new Laya.BoxColliderShape(0.1, 0.1, 0.3); var localOffset4:Laya.Vector3 = boxShape4.localOffset; localOffset4.setValue(0.2, 0.153, -0.048); boxShape4.localOffset = localOffset3; compoundShape.addChildShape(boxShape4); //把组合好的复合碰撞形状添加给刚体碰撞器的碰撞器形状属性 rigidBody.colliderShape = compoundShape; })); /* ……省略若干代码 */ 2.4 碰撞生命周期方法 生命周期是从开始到结束的完整周期过程，有主动触发的主干生命周期方法，例如onAwake()、onEnable()、等。也有被动触发的事件类生命周期虚方法，这种只有在某个条件达到时才会自动激活，例如，本小节要讲的物理事件相关的方法。 2.4.1 物理事件的生命周期方法说明 前文介绍过，检测物理碰撞的方式有两种，那物理事件的方法，也对应着两种。分别是碰撞事件生命周期方法和触发事件生命周期方法。 碰撞事件生命周期方法说明： 碰撞器之间发生碰撞后，自动激活的事件虚方法。 碰撞事件生命周期方法名称 碰撞事件生命周期方法说明 onCollisionEnter 刚发生物理碰撞时，也就是碰撞事件生命周期内的第一次进入碰撞，自动执行的生命周期虚方法，该方法只会执行一次。 onCollisionStay 持续的物理碰撞时，也就是碰撞事件生命周期内的第二次碰撞到碰撞离开前，自动执行的生命周期虚方法。该方法在持续碰撞期间，每帧都会执行。 onCollisionExit 物理碰撞结束时，自动执行的生命周期虚方法，该方法只会执行一次。 触发事件生命周期方法说明： 设置为触发器之后，因物体接触而自动激活的事件虚方法。 触发事件生命周期方法名称 触发事件生命周期方法说明 onTriggerEnter 刚发生物体接触时，也就是触发事件生命周期内的第一次进行接触，自动执行的生命周期虚方法，该方法只会执行一次。 onTriggerStay 持续的物体接触时，也就是触发事件生命周期内的第二次接触到接触离开前，自动执行的生命周期虚方法。该方法在持续接触期间，每帧都会执行。 onTriggerExit 物体接触结束时，自动执行的生命周期虚方法，该方法只会执行一次。 特别说明： 碰撞事件的生命周期方法永远不会与触发事件的生命周期方法同时激活，只能是碰撞事件或者是触发事件。并且，如果有一方是触发器，那两方一定无法进入碰撞事件，只有进入触发事件的可能。 无论是碰撞事件还是触发事件的生命周期方法，从进入到离开的顺序皆为“Enter,Stay,Stay,……,Exit”。 2.4.2 碰撞事件生命周期方法的触发条件 根据碰撞器的类型不同，并不是所有碰撞器之间，都会触发碰撞的反馈，以及激活相应的生命周期方法。 下面通过表格的方式，对应了各碰撞器之间是否可触发碰撞事件的生命周期虚方法。 静态碰撞器 动力学刚体碰撞器 运动刚体碰撞器 角色碰撞器 静态碰撞器 ✘ ✔ ✘ ✔ 动力学刚体碰撞器 ✔ ✔ ✔ ✔ 运动刚体碰撞器 ✘ ✔ ✘ ✔ 角色碰撞器 ✔ ✔ ✔ ✔ 总结： 通过上面的表格，我们发现，静态碰撞器和运动刚体碰撞器，只能与动力学刚体碰撞器或者是角色碰撞器碰撞才可以触发碰撞器生命周期方法，静态碰撞器和运动刚体碰撞器彼此之间，是无法触发碰撞器生命周期的。 而动力学刚体碰撞器和角色碰撞器，和任意的碰撞器发生碰撞都可以触发碰撞器生命周期方法。 2.4.3 触发事件生命周期方法的触发条件 碰撞器是只能与碰撞器之间碰撞，才有可能进入碰撞器的生命周期， 而触发器则不然，触发器不仅与触发器之间有可能进入触发器的生命周期，当触发器与碰撞器之间接触，也有可能进入触发器的生命周期，所以，我们分成两个表来理解。 触发器与触发器之间： 静态触发器 动力学刚体触发器 运动刚体触发器 静态触发器 ✘ ✔ ✔ 动力学刚体触发器 ✔ ✔ ✔ 运动刚体触发器 ✔ ✔ ✔ 触发器与碰撞器之间： 静态触发器 动力学刚体触发器 运动刚体触发器 静态碰撞器 ✘ ✔ ✔ 动力学刚体碰撞器 ✔ ✔ ✔ 运动刚体碰撞器 ✔ ✔ ✔ 角色碰撞器 ✔ ✔ ✔ 总结： 通过上面的两个表格，我们发现，无论是触发器与触发器之间，还是触发器与碰撞器之间，只有静态碰撞器与静态触发器彼此之间碰撞或者接触，是无法进入物理触发事件的。 而其它类型之间接触，哪怕碰撞器没有开启触发器，甚至没有触发器属性（角色碰撞器），只要有任意一方是触发器，那也会自动进入触发器的生命周期。 2.4.4 使用生命周期方法 创建Script3D脚本 生命周期的方法，只能在脚本类里使用，所以，我们需要创建一个脚本，3D游戏必须要继承3D的脚本Script3D。空脚本的示例代码如下： /** * TypeScript语言的3D脚本示例 */ export default class TSDemo extends Laya.Script3D { constructor() { super(); } } 2D脚本与3D脚本不要混用，如果是用IDE创建的脚本模板，需要将继承的2D脚本类（Laya.Script）改为3D脚本类（Laya.Script3D）， 添加物理脚本 只有为节点添加了我们自定义的脚本，我们才可以让该节点使用生命周期方法。 添加的方式很简单，直接在代码中，用节点的addComponent()方法，就可以轻松的把继承了脚本类的3D脚本添加到节点上。 例如，我们创建一个3D盒子，并为其绑定刚刚创建的TSDemo脚本。示例代码如下： //引入自定义脚本TSDemo import TSDemo from \"./TSDemo\"; /** * TypeScript语言示例 */ export default class GameUI extends GameUIBase { /* ……省略若干代码 */ private addBox(): void { //创建盒型MeshSprite3D let box = this.newScene.addChild(new Laya.MeshSprite3D(Laya.PrimitiveMesh.createBox(0.75, 0.5, 0.5))) as Laya.MeshSprite3D; //设置材质 box.meshRenderer.material = this.mat1; //设置空间位置 let transform = box.transform; let pos = transform.position; pos.setValue(1, 6, 0); transform.position = pos; //创建刚体碰撞器 let _rigidBody = box.addComponent(Laya.Rigidbody3D) as Laya.Rigidbody3D; //创建盒子形状碰撞器 let boxShape = new Laya.BoxColliderShape(0.75, 0.5, 0.5); //设置盒子的碰撞形状 _rigidBody.colliderShape = boxShape; //添加自定义脚本组件TSDemo box.addComponent(TSDemo); } /* ……省略若干代码 */ } 重写物理生命周期方法 之前介绍过，物理事件的生命周期方法分别为三个碰撞事件方法和三个触发事件方法。我们在使用的时候，重写这些虚方法即可，当物理行为触发了对应的物理事件就会自动执行。 重写生命周期方法的示例代码如下： /** * TypeScript语言的3D脚本示例 */ export default class TSDemo extends Laya.Script3D { constructor() { super(); } onTriggerEnter(): void { /* ……省略若干逻辑代码 */ console.log(\"触发器物理事件onTriggerEnter\"); } onTriggerStay(): void { /* ……省略若干逻辑代码 */ console.log(\"触发器物理事件onTriggerStay\"); } onTriggerExit(): void { /* ……省略若干逻辑代码 */ console.log(\"触发器物理事件onTriggerExit\"); } onCollisionEnter(): void { /* ……省略若干逻辑代码 */ console.log(\"碰撞器物理事件onCollisionEnter\"); } onCollisionStay(): void { /* ……省略若干逻辑代码 */ console.log(\"碰撞器物理事件onCollisionStay\"); } onCollisionExit(): void { /* ……省略若干逻辑代码 */ console.log(\"碰撞器物理事件onCollisionExit\"); } } 2.5 碰撞分组与过滤碰撞组 当我们产生复杂的碰撞需求时，例如，想碰哪个，不碰哪个。这时候就需要进行分组，并指定可以与哪个碰撞组进行碰撞。另外，设置碰撞组过滤，还会优化性能。 各种碰撞器从物理组件父类PhysicsComponent那里继承了collisionGroup与canCollideWith属性，用以实现碰撞分组和指定碰撞组。 2.5.1 碰撞组 collisionGroup 碰撞组的值，我们通常设置为2的N次幂值。如果应用场景比较复杂，需要用到的碰撞分组比较多，记不住太多2的N次幂值，也可以直接使用LayaAir引擎内置的碰撞组工具类。 LayaAir引擎内置了17个碰撞组属性值，用于过滤不需要的碰撞。 引擎内置的碰撞组工具类为Laya.Physics3DUtils。 全部可碰撞的组 由于碰撞组之间的碰撞依据是位运算的按位与，按位与的计算结果非0则可以碰撞，为0则不可碰撞。 Physics3DUtils工具类的COLLISIONFILTERGROUP_ALLFILTER属性值为-1，-1与任何2的幂值进行按位与都非0，所以取该属性值为分组时，则所有的碰撞组都可碰撞。 使用示例为： //指定xxx碰撞器所属哪个碰撞组（-1组与LayaAir任何内置组都可碰撞） xxx.collisionGroup = Laya.Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER; 自定义碰撞分组 LayaAir内置的碰撞组，不包括刚刚讲的-1（COLLISIONFILTERGROUP_ALLFILTER），我们可以用的还有10个，分别是COLLISIONFILTERGROUP_CUSTOMFILTER1......10。全都是2的幂，从64到32768。 为了方便记忆，我们可以不记实际值，记住CUSTOMFILTER后1到10的ID号区别即可。 使用示例为： //指定xxx碰撞器所属哪个碰撞组（COLLISIONFILTERGROUP_CUSTOMFILTER2对应的值为128） xxx.collisionGroup = Laya.Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER2; 特定的碰撞分组 除了以上的分组外，LayaAir也对接了一些Bullet物理引擎预留的特定分组，用于比较简单的碰撞过滤需求。 例如，当前场景我们只有动态刚体碰撞器，静态碰撞器，运动学刚体碰撞器，只是对这几种碰撞器之间作碰撞过滤，那么我们就可以分别使用对应的默认碰撞组、静态碰撞组、运动学刚体碰撞组。 具体的预留分组属性说明如下： 碰撞组属性名 属性值 说明 COLLISIONFILTERGROUP_DEFAULTFILTER 1 默认碰撞组 COLLISIONFILTERGROUP_STATICFILTER 2 静态碰撞组 COLLISIONFILTERGROUP_KINEMATICFILTER 4 运动学刚体碰撞组 COLLISIONFILTERGROUP_DEBRISFILTER 8 碎片碰撞组 COLLISIONFILTERGROUP_SENSORTRIGGER 16 传感器触发器 COLLISIONFILTERGROUP_CHARACTERFILTER 32 字符过滤器 以上的属性是原样对接了Bullet物理引擎，例如碎片碰撞组和字符过滤器的概念，当前的引擎版本还没有。开发者想用也可以，但建议不采用，推荐使用自定义碰撞分组，以ID为分组标记更便于记忆。 2.5.2 过滤碰撞组 canCollideWith 指定碰撞单个组 碰撞器的canCollideWith属性可以用于指定与哪个组碰撞，指定哪个，就可以与哪个碰撞。其它的都不可以碰撞，起到了过滤其它碰撞组的效果。 使用示例为： //指定xxx碰撞器可以与其发生碰撞的碰撞组(本例只与自定义组1碰撞) xxx.canCollideWith = Laya.Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER1; 指定碰撞多个组 如果我们想碰撞多个组，可以采用位运算的按位或| ，去指定多个可以与其发生碰撞的碰撞组。 使用示例为： //指定xxx碰撞器可以与其发生碰撞的碰撞组(本例只与自定义组1、2、5进行碰撞) xxx.canCollideWith = Laya.Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER1 | Laya.Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER2 | Laya.Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER5; 关于位运算用于碰撞的基础原理，如果不明白的可以参考2D物理 指定不可碰撞的组 在多个碰撞分组的情况下，如果我们只想排除掉某个或者某几个碰撞组不与其发生碰撞，与其它所有的碰撞组发生碰撞如何处理呢？ 这时候可以通过异或运算符^来实现。用 -1去异或^任何2的幂值，那该值的碰撞组就不会被碰撞。 使用示例为： //指定不可以与其发生碰撞的碰撞组(本例将不与自定义组2、5进行碰撞，除自定义2与5组之外，都可以发生碰撞) xxx.canCollideWith = Laya.Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER ^ Laya.Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER2 ^ Laya.Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER5; 三、物理约束 在物理世界中，有些物体的运动会受到其它物体的影响，例如：人体关节、钟摆、链条、滑轮组、等等。 这种限制物体运动，避免其运动超出一定限度的物理方法就是约束。由于其还具有着关节的特性表现，所以有些引擎也称为关节。 3.1 LayaAir支持哪些约束 目前在LayaAir引擎中只支持两种，分别是固定约束Fixed Constraint和可配置约束Configurable Constraint。 固定约束是比较常用的约束，而可配置约束可以模拟任意约束的效果，所以这两种约束可以满足绝大多数的常用需求。 3.2 固定约束Fixed Constraint 固定约束将对象的移动限制为依赖于另一个对象，一个物体产生位移变化 ，另一个与其约束的物体也会随之变化 。有些类似父子节点关系，但它与父子节点不同，位移不是通过transform实现，而是基于物理引擎。 固定关节类似2D物理（Box2D）里的焊接关节，适用于游戏中的物体对象永久或暂时粘在一起的需求，最好是两个没有父子关系的物理一起运动。好处是不必通过脚本更改对象的层级视图来实现所需的效果。代价是所有使用固定关节的对象都必须使用刚体。 3.2.1 设置连接刚体 setConnectRigidBody setConnectRigidBody用于指定固定约束要连接的刚体，若不指定，则该约束连接到世界。 3.2.2 断开力 breakForce breakForce用于设置破坏固定约束需要施加的最大力。 3.2.3 断开力矩 breakTorque breakTorque用于设置破坏固定约束需要施加的最大力矩。 3.3 可配置约束Configurable Constraint 可配置约束可实现各种约束类型的所有功能，比如上文介绍过的固定约束，也可以通过可配置约束来实现，并且提供更强大的角色移动控制。 当开发者想要自定义布娃娃的运动并对角色强制实施某些姿势时，这种约束特别有用。使用可配置约束还可以将约束修改为开发者自行设计的高度专业化约束。 3.3.1 设置连接刚体 setConnectRigidBody setConnectRigidBody用于指定固定约束要连接的刚体，若不指定，则该约束连接到世界。 3.3.2 锚点 anchor 锚点anchor 是用于定义自身刚体约束中心的点。物理模拟会使用此点作为计算的中心点。 3.3.3 主轴 axis 主轴 axis用于基于物理模拟来定义对象自然旋转的局部轴，该轴决定了对象在物理模拟下自然旋转的方向。 3.3.4 连接锚点 connectAnchor 连接锚点connectAnchor 用于设置所连接刚体的约束锚点。 例如自己是车轮，连接的刚体是车身。那锚点就是车轮的约束中心点，连接锚点就是所连接的车身约束中心点。 3.3.5 副轴 secondaryAxis 副轴secondaryAxis的作用是与主轴axis共同定义了约束的局部坐标系。第三个轴会与这两个轴所构成的平面相垂直。 3.3.6 沿XYZ轴平移约束模式 (X\\Y\\Z)Motion (X\\Y\\Z)Motion是表示沿 X、Y 、Z 轴平移约束的模式，根据属性设置的不同，约束的模式也不同。可以设置的值分别是：自由移动Free、锁定移动 Locked、限制性移动 Limited。 自由移动Free就是不作限制的沿某轴移动。 锁定移动 Locked是没有运动，完全固定住。 限制性移动 Limited是平移运动受限于用户定义的约束。 3.3.7 绕XYZ轴旋转的角运动约束模式angular (X\\Y\\Z)Motion angular (X\\Y\\Z)Motion是表示绕X、Y 、Z 轴旋转的角运动约束模式，也是根据自由移动Free、锁定移动 Locked、限制性移动 Limited三种值的设置来区别约束模式，与(X\\Y\\Z)Motion类似，只是运动形式的线性平移和角运动旋转的区别。 3.3.8 弹簧线性限制 （linearLimitSpring、linearDamp） 弹簧力Spring 其中的弹簧力Spring 在LayaAir引擎中对应线性限制的弹簧力linearLimitSpring，如果此处的值设置为零，则无法逾越限制；零以外的值将使限制变得有弹性。 阻尼Damper 其中的阻尼Damper在LayaAir引擎中对应线性阻尼linearDamp，设置为大于零的值可让约束抑制振荡（否则将不断的进行振荡）。 3.3.9 线性移动限制（minLinearLimit、maxLinearLimit、linearBounce） 限制Limit 其中的Limit是从原点到限制位置的距离。在LayaAir引擎中需要分别设置线性移动限制的最小值minLinearLimit和线性移动限制的最大值maxLinearLimit。 反弹力Boundciness 其中的反弹力 Bounciness 是当对象达到限制距离时，要将对象拉回而施加的弹力。在LayaAir引擎中对应线性反弹力linearBounce。 3.3.10 弹簧角运动限制（angularLimitSpring、angularDamp） 弹簧力Spring 其中的弹簧力Spring 在LayaAir引擎中对应角运动旋转限制的弹簧力angularLimitSpring，如果此处的值设置为零，则无法逾越限制；零以外的值将使限制变得有弹性。 阻尼Damper 其中的阻尼Damper在LayaAir引擎中对应角运动旋转阻尼angularDamp，设置为大于零的值可让约束抑制振荡（否则将不断的进行振荡）。 3.3.11 角运动限制（minAngularLimit、maxAngularLimit、angularBounce） 限制Limit 其中的Limit是限制旋转角度，设置对象旋转角度的下限值。在LayaAir引擎中需要分别设置旋转角度限制的最小值minAngularLimit和旋转角度限制的最大值maxAngularLimit。这两个值都是3D向量值。 旋转限制最小值的X对应X轴旋转的下限Low Angular X Limit值，Y对应Y轴旋转的限制Angular Y Limit值取负，Z对应Z轴旋转的限制Angular Z Limit值取负。 旋转限制最大值的X对应X轴旋转的上限Hight Angular X Limit值，Y对应Y轴旋转的限制Angular Y Limit值，Z对应Z轴旋转的限制Angular Z Limit值。 反弹力Boundciness 其中的反弹力 Bounciness 是当对象的旋转达到限制角度时在对象上施加的反弹力矩。在LayaAir引擎中对应角度反弹力矩angularBounce。 四、物理射线 4.1 什么是物理射线 射线的定义是只有一个端点无限延长形成的直的线。LayaAir引擎的数学对象Laya.Ray()就是只有起点和方向的射线。 在LayaAir引擎中，射线常用于基础的碰撞检测，所以具有射线的发射特性，但用于碰撞检测功能的射线称为物理射线。 需要注意的是，射线可以用于物理射线检测，但是物理射线并不等同于射线。 4.2 创建射线 LayaAir引擎提供了创建3D空间射线的类Laya.Ray()，以及通过摄像机从屏幕空间点去生成这个射线的方法viewportPointToRay()。 示例代码如下所示： /* ……省略若干代码 */ //创建一个屏幕点 let point = new Laya.Vector2(); //创建一个射线 Laya.Ray(射线的起点，射线的方向) let ray = new Laya.Ray(new Laya.Vector3(0, 0, 0), new Laya.Vector3(0, 0, 0)); //以鼠标点击的点作为原点 point.x = Laya.stage.mouseX; point.y = Laya.stage.mouseY; //计算一个从屏幕空间生成的射线 _camera.viewportPointToRay(point, ray); /* ……省略若干代码 */ 4.3 使用物理射线 在LayaAir 3D中实现射线检测是使用物理模拟器类PhysicsSimulation。 射线检测的方法有4个，分别为射线检测第一个碰撞物体的方法raycast 和 raycastFromTo以及射线检测所有碰撞物体的方法raycastAll和raycastAllFromTo。 检测一个和所有的区别比较容易理解，就是碰到第一个物体后射线立即结束，和射线可穿透所有碰撞物体一直不结束，这两种区别。如图4-1所示。 （图4-1） 那为什么同样的功能名称还有带FromTo和不带FromTo两种，又有什么区别呢？ 与数学对象的射线所不同的是，用于检测碰撞的物理射线是有长度的，或者是需要设置世界空间的结束位置。 带FromTo的是使用两个点（射线的起始位置点和结束位置点）作为参数。 而不带FromTo的则是直接使用已经创建好的射线，不需要设置射线的结束位置点，但需要设置长度，如果我们不设置长度，则采用默认值长度2147483647。 如果是不带FromTo的射线检测，我们可以沿用上个小节创建射线的示例，稍加补充一下，具体代码如下所示： /* ……省略若干代码 */ //创建一个屏幕点 let point = new Laya.Vector2(); //创建一个射线 Laya.Ray(射线的起点，射线的方向) let ray = new Laya.Ray(new Laya.Vector3(0, 0, 0), new Laya.Vector3(0, 0, 0)); //以鼠标点击的点作为原点 point.x = Laya.stage.mouseX; point.y = Laya.stage.mouseY; //计算一个从屏幕空间生成的射线 _camera.viewportPointToRay(point, ray); //拿到3D场景中射线碰撞的物体 _scene3D.physicsSimulation.rayCastAll(ray,this.outs); //如果射线碰撞到物体 if (this.outs.length !== 0) { for (let i = 0; i 带FromTo的射线检测使用示例，具体代码如下所示： /* ……省略若干代码 */ /*进行射线检测,检测所有碰撞的物体 //_scene3D.physicsSimulation.raycastAllFromTo(this.from, this.to, this.outs); //检测所有物体的射线使用与上个示例类似 */ //进行射线检测,检测第一个碰撞物体 _scene3D.physicsSimulation.raycastFromTo(this.from, this.to, this.out); //将射线碰撞到的物体设置为红色 ((this.out.collider.owner as Laya.MeshSprite3D).meshRenderer.sharedMaterial as Laya.BlinnPhongMaterial).albedoColor = new Laya.Vector4(1.0, 0.0, 0.0, 1.0); /* ……省略若干代码 */ 4.4 使用异形物理射线 常规的物理射线是用一条射线来检测碰撞，LayaAir引擎中也提供了与物理射线检测类似的功能，但采用的是自定义碰撞器形状检测来代替物理射线，相当于异形的射线检测功能。 与普通的射线检测一样，异形射线也是有检测第一个和检测所有两个检测方法，分别是shapeCast和shapeCastAll。 （图4-2） 图4-2的示例，就采用球形射线来实现碰撞检测，具体代码如下所示： //创建球型碰撞器 var sphereCollider:Laya.SphereColliderShape = new Laya.SphereColliderShape(0.5); //通过按钮this.castAll状态切换是采用检测全部还是检测第一个 if (this.castAll) { //采用球形碰撞器进行形状检测,检测所有碰撞的物体 this.scene.physicsSimulation.shapeCastAll(sphereCollider, this.from, this.to, this.outs); for (let i = 0; i 4.5 设置射线碰撞组 无论是普通射线还是异形射线，都可以设置碰撞组，以及指定射线可碰撞的组。 如何设置碰撞组值collisonGroup和如何指定可发生碰撞的组值canCollideWith在前文中已经介绍过， 我们将值带入射线检测对应的方法即可实现射线的选择性碰撞。 射线检测里用于指定检测碰撞组的参数collisionMask对应的是前文介绍的canCollideWith 五、其它物理引擎的使用 之前的章节一直在介绍LayaAir基于Bullet物理引擎封装的物理引擎API。Bullet虽然强大，但是有些开发者对于物理精度要求不高，物理功能的使用也比较基础，只对物理引擎库的体积有要求，比如Cannon物理引擎库，其体积只有不足200k。目前LayaAir3.0的物理引擎接口正在改进中，以支持更多的第三方物理引擎，因此Cannon物理引擎暂时从IDE中删除，等后续改进完将会告知开发者。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2024-02-21 17:22:30 "},"IDE/particleEditor/readme.html":{"url":"IDE/particleEditor/readme.html","title":"3D粒子编辑模块","keywords":"","body":"3D粒子编辑器一、3D粒子编辑器基础什么是3D粒子火焰效果展示二、LayaAir引擎中创建3D粒子三、3D粒子的使用3D粒子的使用由三部分构成粒子系统组件粒子渲染模块粒子着色器3.1 粒子系统组件 ParticleSystem3.2 粒子渲染模块 ShurikenParticleRenderer3.3 粒子着色器 PARTICLESHURIKEN四、火焰效果制作示例五、应用场景及代码示例5.1 自定义Particle3D类5.2 自定义对象池类5.3 代码调用3D粒子编辑器 一、3D粒子编辑器基础 什么是3D粒子 在百科中，粒子是指能够以自由状态存在的最小物质组成部分。 在LayaAir引擎中，3D粒子系统中的粒子可用于模拟中烟、雾、水、火、雨、雪、流光等非固定形态的自然现象。而上述这些自然物体的形态由于没有固定的形态，所以不能用固定的模型来模拟实现，需要用多个模型组合成一个完整的视觉效果，而3D粒子正是组合效果的最小单元，但需要注意的是，粒子并非是三维模型，而是面片模型。 火焰效果展示 （动图1） 二、LayaAir引擎中创建3D粒子 2.1 粒子节点 在场景中的Scene3D节点下，可以通过鼠标右键来创建3D粒子 （图2.1.1-1） 默认粒子系统添加完成效果 （动图2） 2.2 预制体 如果考虑到3D粒子是需要复用的，建议使用预制体，在Assets下创建预制体，双击打开预制体后，在Sprite3D节点下通过鼠标右键来创建3D粒子 （图2.1.2） 三、3D粒子的使用 3D粒子的使用由三部分构成 粒子系统组件 粒子渲染模块 粒子着色器 （图3.0）从图3.0中看到，当创建一个3D粒子后，会自动添加这三个组件，下面我们来详细了解各系统的使用 3.1 粒子系统组件 ParticleSystem 粒子系统是LayaAir引擎特效表现的基础，通常粒子系统在三维空间中的位置与运动是由发射器控制的。发射器主要由一组粒子行为参数以及在三维空间中的位置所表示。粒子行为参数可以包括粒子生成速度（即单位时间粒子生成的数目）、粒子初始速度向量（例如什么时候向什么方向运动）、粒子寿命（经过多长时间粒子湮灭）、粒子颜色、在粒子生命周期中的变化以及其它参数等等。 粒子系统组件分类 在LayaAir编辑器中，粒子系统组件由五个部分构成 （图3.1） 3.1.1 基础面板 General 默认的是粒子系统的通用模块，用于设置粒子系统的基础性的设置。此模块为固有模块，不可禁用。该模块定义了粒子初始化时的持续时间、循环方式、发射速度、大小等一些列基本的参数。 （图3.1.1-1） Duration：粒子系统不断发射粒子的持续时间，或者说一个周期时间内可以发射多次粒子，到达设置的时间后，粒子停止发射 ​ 注意：不是一个粒子的生命周期时间，下面会介绍一个粒子的生命周期时间 （动图3）Duration为5的效果，5秒到达时，粒子不在发射，同时Loop要设为不启动 Loop：如果启用，粒子系统在上述持续时间结束时，再次启动并继续重复循环 Play On Awake：如果启用，粒子系统会在创建对象时自动启动 Start Delay：启用后系统开始发射前的延迟时间，可选择两种延迟方式 Constant 固定时间 Random Between Two Constant 从最小到最大两个时间中随机取值 （动图4）展示了使用最小2到最大5秒随机的方式，可以看到当第4秒时，粒子开始发射 Start Lifetime：控制每个粒子的生命周期，也就是粒子发生多长时间后消失，它可以是两个数字之间的随机值 （动图5）展示了使用Start Lifetime为3时的效果，显示每个粒子从发射出生到消失用时3秒 Start Speed：每个粒子在适当方向上的初始速度，可选择两种延迟方式 Constant 固定值 Random Between Two Constant 从最小到最大中随机取值 ​ 动图5中展示了使用Start Speed为5时的速度效果 Start Size：每个粒子的初始大小，如果想分别控制每个轴的大小，请启用3D选项。可选择两种延迟方式 Constant 固定值 Random Between Two Constant 从最小到最大中随机取值 （图3.1.1-2） 展示了Start Size在1和5之间随机，可以看到左边粒子有大有小 ​ 注意：粒子的大小与它所使用的贴图大小是无关的，一个100像素的贴图与一个500像素的贴图绘制出来的同种粒子几乎差不多大，由此可见，StartSize规定了这个粒子的直径，而不是贴图缩放 Start Rotation：每个粒子的初始旋转角度。如果您想分别控制每个轴的旋转，请启用3D选项。可选择两种延迟方式 Constant 固定值 Random Between Two Constant 从最小到最大中随机取值 （图3.1.1-3） 展示了Start Rotation在1和360之间随机，可以看到左边粒子有各个方向的旋转 Start Color：每个粒子的初始颜色 （图3.1.1-4） 展示了Start Color为红色的效果 注意，即便在StartColor中规定了粒子为红色，显示出来的效果也不是纯红色，粒子与粒子，天空，红色方块叠加的地方都变成了不一样的颜色，这是因为画面的最终显示效果是由着色器调控的，我们在设置粒子材质的时候，选择的RenderingMode为Additive(叠加的)，所以最终显示效果会受到粒子背后传来的光的影响从而发生变色。可以尝试选择不同的着色器选项观察变化 （图3.1.1-5） 展示了RenderingMode为Additive的效果 Gravity Modifier：设置物理重力值。零值会关闭重力 （动图6）展示了使用Gravity Modifier为5时的效果 Simulation Space：控制粒子是否跟随粒子发射器移动 ​ Local：粒子生成后跟随粒子发射器坐标的移动而移动，这个模式下，粒子发射器的移动会表现在每个粒子上。 ​ World：粒子生成后不跟随粒子发射器，直接在世界坐标系中移动。 Simulation Speed：调整整个粒子系统更新的速度 Scale Mode：控制粒子的缩放模式 ​ Hierarchy：同时受自己与父节点的缩放影响 ​ Local：只受自己的影响 ​ World：不受影响 Max Particles：一次系统中的最大粒子数。如果达到限制，则会移除一些粒子。如果设置为1，则粒子系统会一个一个发射粒子 Auto Random Seed：自动粒子随机种子，启用后每次播放都会有不同。去掉勾选后，可以填随机种子的数值，不同的数值，发射粒子的表现略有不同 3.1.2 发射模块 Emission 该模块是粒子系统组件的一部分，用来指定发射粒子的属性。当创建新的粒子系统时，Emission 模块会默认启用。 （图3.1.2） Enable：是否启用 Rate over Time：每秒发射的粒子数 Rate over Distance 每个移动距离单位发射的粒子数，此模式对于模拟实际由对象运动产生的粒子非常有用（例如，泥路上车轮留下的尘土） Bursts：爆发是产生粒子的事件。这些设置允许在指定时间发射粒子。可以设置多组爆发点，分别修改时间，最小粒子数，最大粒子数 （动图7）展示了使用Rate Over Time为5，每秒发射5个粒子，同时使用一组Bursts，在第3秒时，突然发射30个粒子 3.1.3 形状模块 Shape 该模块定义了发射粒子的体积或表面，以及起始速度的方向。 （图3.1.3-1） Shape Type：形状的选择会影响可以发射粒子的区域，还会影响粒子的初始方向。例如，一个Sphere向各个方向向外发射粒子，一个Cone发射一个发散的粒子流。 1，Sphere ：球，可以向四面八方发射粒子 Radius：半径 Emit from shell：根据壳发射 Randomize Direction：随机化方向 （动图8）展示了使用球形，半径是3，从球体的边缘发射 2，Hemisphere：半球形状 Radius：半径 Emit from shell：根据壳发射 Randomize Direction：随机化方向 （图3.1.3-2） 3，cone：锥形，让粒子像手电筒的光一样从一点开始向一个圆型扇出 Angle DEG：形状的圆形方面的角度 Radius：半径 Length：长度 Emit from：发射方式 Base：基于锥形底部 Base Shell：基于锥形底部壳 Volume：基于锥形内部 Volume Shell：基于锥形内部壳 Randomize Direction：随机化方向 （动图9）展示了使用锥形，半径是2，锥形长度是6，从锥形内部发射 4，Box：盒子形，可以让所有粒子向单一方向发射，可以很好的模拟雨雪类粒子效果 Length：XYZ各个方向的长度 Randomize Direction：随机化方向 （图3.1.3-3） 5，circle：环形 Radius：半径 Angle DEG：环形的角度 Emit From Edge：基于边缘发射 Randomize Direction：随机化方向 （图3.1.3-4） 3.1.4 生命周期Lifetime 该模块定义了发射出的粒子的生命周期内的属性 （图3.1.4） 1，Velocity over Lifetime：生命周期中的速度 Constant：常数模式，速度是恒定的 Curve：曲线模式 Random from two Constant：随机速度模式 Random between two Curve：在两个曲线中随机取值 Space：空间 Local：模型空间 World：世界空间 2，Color over Lifetime：生命周期中的颜色 Constant：常数模式，颜色是恒定的 Gradient：梯度模式 Random from two Constant：随机两个颜色模式 Random between two Gradient：在两个梯度中随机取值 3，Size over Lifetime：生命周期中的大小 Separate Axes：按轴分离 Curve：曲线模式 Random Between Two Contants：在两个常数中随机取值 Random between two Curve：在两个曲线中随机取值 4，Rotation over Lifetime：生命周期中的旋转 Separate Axes：按轴分离 Constant：常数 Curve：曲线模式 Random Between Two Contants：在两个常数中随机取值 Random between two Curve：在两个曲线中随机取值 3.1.5 纹理动画 Texture Sheet 用来播放粒子动画的模块，粒子动画的原材料是一种纹理，它包含了一组帧动画，能够以动画方式渲染粒子。 帧动画：使用多张图片，每张图片为一帧，构成一个完整的动画叫帧动画。或一张大图片，图片中包含了一个动画的所有帧的图片 （图3.1.5-1） （图3.1.5-2） 目前LayaAir采用网格模式（Grid） Tiles：纹理在 X（水平）和 Y（垂直）方向上划分的图块数量 Animation：动画模式可以设置为整张或单行（即，每行代表一个单独的动画序列） Frame：设置帧 ​ Type：帧类型 ​ Constant：固定帧数 ​ Curve：一条曲线，指定动画帧如何随着时间的推移而增加。 ​ Random Between two constant：两个固定帧数之间随机 ​ Random Between two curve：两个曲线之间随机 Start Frame：起始帧，允许您指定粒子动画应该从哪一帧开始 Cycles：动画序列在粒子生命周期内重复的次数 （图3.1.5-3）第四节火焰示例中会介绍使用过程 3.2 粒子渲染模块 ShurikenParticleRenderer 渲染器模块的设置决定了一个粒子的图像，模型，如何被其它粒子变换、着色和过度绘制。 （图3.2） Receive Shadows：决定此系统中的粒子是否可以接收来自其它来源的阴影。只有不透明的材质才能接收阴影。 Cast Shadows：如果启用此属性，粒子系统会在投射阴影的灯光照射时创建阴影。 Scale In Lightmap：调整特定物体在最终LightMap中的像素密度。 Materials：用来渲染粒子的材质 Render Mode：如何从图形图像（或网格）生成渲染图像。 1，Billboard：将粒子渲染为广告牌，永远面向摄像机 2，Stretched Billboard：粒子面向摄像机的同时，允许使用粒子缩放 Speed Scale： 根据粒子速度设置长度 Length Scale ：通过比较粒子的宽度决定粒子的长度 3，Horizontal Billboard：粒子平面平行于XZ底平面 4，Vertical Billboard：粒子在Y轴上是直立的，但是面向相机 5，Mesh：粒子是从3D网格而不是纹理渲染的 （动图） Sorting Fudge：排序校正，使用这个将影响绘画顺序。粒子系统带有更低Sorting Fudge值，更有可能被最后绘制，从而显示在透明物体和其他粒子系统的前面 3.3 粒子着色器 PARTICLESHURIKEN 在材质中选择Laya的particle，可以添加Laya内置的粒子着色器（PARTICLESHURIKEN），其可渲染各种粒子系统 效果。所有的粒子都是用使用的这个材质。 （图3.3） Color：指定粒子的颜色。 Texture：指定粒子使用的纹理贴图 Alpha Test Value：透明测试开启时，当前像素根据设定条件决定是否输出颜色 Tiling Offset：获取纹理平铺和偏移 Material Render Mode：设置渲染模式 ​ Opaque：默认设置，适用于没有透明区域的普通实体对象。 ​ Cutout：允许创建在不透明和透明区域之间具有硬边的透明效果。在此模式下，没有半透明区域，纹理要么 100% 不透明，要么不可见。这在使用透明度来创建材料的形状（例如树叶或带孔和破烂的布）时很有用。 ​ Transparent： 适用于渲染逼真的透明材质，例如透明塑料或玻璃。在此模式下，材质本身将采用透明度值（基于纹理的 Alpha 通道和色调颜色的 Alpha），但反射和照明高光将在完全清晰的情况下保持可见，就像真正的透明材质一样。 ​ Additive： 叠加方式 ​ AlphaBlended： 透明混合方式 Cull：剔除方式 四、火焰效果制作示例 4.1 创建火焰预制体 （图4.1） 在Scene3D场景下，点击鼠标右键，选择创建Effects->Particle3D 默认创建一个3D粒子系统，命名为FireEffect，拖到Assets->Prefab目录下，创建好预制体 4.2 火焰序列帧动画 （图4.2） 准备好火焰序列帧动画贴图文件，放到Assets目录下，点击贴图，勾选sRGB和Alpha Channel，TextureType依然为Default，点击Apply按钮，确保修改成功 4.3 设置火焰材质 （图4.3） 在Assets下创建一个材质，命名为FlameRoundYellowParticle，Shader使用Laya.Particle，基本上所有的粒子特效都使用此Shader。Color设置为191,191,191,255，texture选择上面添加的贴图，Material Render Mode选择ADDITIVE方式 4.4 设置粒子系统渲染模块 （图4.4-1） 创建粒子系统后，Inspector面板中默认会添加ShurikenParticleRenderer组件，选择FlameRoundYellowParticle材质 （图4.4-2） 在Scene窗口中，可以看到粒子效果已经换成贴图，需要进一步设置贴图动画 4.5 使用贴图动画 （图4.5-1） 在粒子系统的TextureSheet中，创建一个Instance，由于火焰贴图的组成方式为10x5，此时修改Tiles为X：10，Y：5。修改后粒子系统贴图变为火焰效果，但是依然是静态图，下面来修改Frame帧动画，修改Frame->Type为Curve，点击Curve打开面板，横轴为时间线，纵轴为帧动画的帧数，我们希望的效果是1秒中火焰帧动画循环播放一遍，也就是从0到50帧，那么我们修改Curve为下图 （图4.5-2） 完成Curve后，再看火焰效果已经可以播放帧动画 （动图10） 4.6 设置基础属性 （图4.6） Start Speed的Constant为0，火焰发射时的初始速度为0，Start Size的Constant为2，放大2倍火焰的尺寸，Simulation Speed为2，可以加快火焰播放的速度 4.7 设置发射器 （图4.7） 修改每单位时间发射的粒子数为5，相当于每秒中会燃烧5个火焰 4.8 设置形状模块 （图4.8） 我们希望粒子在一个圆形内发射，可以达到火焰聚集燃烧效果 4.9 设置粒子生命周期 （图4.9-1） 最重要一环为设置粒子生命周期，首先设置火焰生命周期内颜色的过程，创建Color Over Lifetime实例，Type设置为Gradient梯度变化曲线，打开Gradient面板，上面3个箭头向下的指示标表明颜色的透明度从 0%的不透明->80%的不透明->100%的全透明，下面的2个箭头向上的指示标表明颜色的区间变化从c99451到ff4500 （图4.9-2） 由于火焰是粒子向上运动到消失，创建Velocity Over Lifetime实例，选择Curve曲线，只需要修改Y轴的位移为1秒钟从0到1，向上移动1个单位 （图4.9-3） 由于火焰是会尺寸上有缩小的过程，创建Size Over Lifetime实例，选择Curve曲线，只需要修改0.5秒时间内，Size从1到0.5，缩小一倍 （动图11） 此时在Scene窗口中看到，火焰效果已制作完成 五、应用场景及代码示例 往往在游戏的战斗过程中，需要大量创建粒子，那么需要用到对象池。对象池优化是游戏开发中非常重要的优化方式，也是影响游戏性能的重要因素之一。在游戏中有许多对象在不停的创建与移除，比如角色攻击子弹、特效的创建与移除，NPC的被消灭与刷新等，在创建过程中非常消耗性能，特别是数量多的情况下。对象池技术能很好解决以上问题，在对象移除消失的时候回收到对象池，需要新对象的时候直接从对象池中取出使用。优点是减少了实例化对象时的开销，且能让对象反复使用，减少了新内存分配与垃圾回收器运行的机会。 注意：对象移除时并不是立即从内存中抹去，只有认为内存不足时，才会使用垃圾回收机制清空，清空时很耗内存，很可能就会造成卡顿现象。用了对象池后将减少程序的垃圾对象，有效的提高程序的运行速度和稳定性。 5.1 自定义Particle3D类 import Node = Laya.Node; import Sprite3D = Laya.Sprite3D; import ShuriKenParticle3D = Laya.ShuriKenParticle3D; import ShurikenParticleSystem = Laya.ShurikenParticleSystem; import { Pool } from \"./Pool\"; //粒子特效的基类，包括创建，播放，暂停，销毁，清理对象池 export class Particle3D extends Sprite3D { private _isInited: boolean = false; private _filePath: string = null; private _particle: Laya.Sprite = null; private _shuriKenParticle3D: Array= []; private _shurikenParticleSystem: Array= []; constructor() { super(); } //通过传入粒子特效的路径，创建一个粒子特效，从对象池里拿一个 static Create(path: string): Particle3D { var ret:Particle3D = Pool.getInstance().getItemByClass(\"Particle3D@\" + path, Particle3D); ret.Init(path); return ret; } //粒子特效初始化 private Init(file_path:string): void { if (this._isInited) { return; } this._filePath = file_path; console.log(\"Particle3D\"); //从拿到的粒子系统克隆一个 var res = Laya.loader.getRes(file_path); var particle = res.clone(); this._particle = particle; //获取这个粒子特效的所有粒子系统，用于后面整体播放 for (var i = 0, len = this._particle.numChildren; i 5.2 自定义对象池类 export class Pool { private _poolDic:{[key: string]: any;} = {}; private InPoolSign: string = \"__InPool\"; constructor() { } private static _instance: Pool = new Pool(); public static getInstance() { return this._instance; } //通过名字找到对应的对象池 getPoolBySign(sign:string): any { return this._poolDic[sign] || (this._poolDic[sign] = []); }; //回收 recover(sign:string, item:any): void { item[\"__InPool\"] = true; }; //通过名字获得一个对象，如果对象池内没有对象，则创建一个 getItemByClass(sign:string, cls:any): any { var ret = null; var pool = this.getPoolBySign(sign); for (var i = 0, len = pool.length; i 5.3 代码调用 const { regClass, property } = Laya; import { Particle3D } from \"./Particle3D\"; @regClass() export class Main extends Laya.Script { //粒子特效的路径 private filePath = \"FireEffect\"; onStart() { console.log(\"Game start\"); //加载粒子特效资源 Laya.loader.load(this.filePath, Handler.create(this, () => { })); } //每次鼠标点下屏幕后，会创建一个特效 mouseDown(e: Event): void { var particle = Particle3D.Create(this.filePath); this.owner.addChild(particle); } //鼠标抬起后，会释放对象池 mouseUp(e: Event): void { Particle3D.ClearPool(this.filePath); } } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2024-01-17 11:15:05 "},"IDE/materialEditor/readme.html":{"url":"IDE/materialEditor/readme.html","title":"材质编辑模块","keywords":"","body":"IDE的材质属性1、材质的创建2、材质面板2.1 材质基础属性2.1.1 BlinnPhong 着色器2.1.2 Unlit 着色器2.1.3 PBR 着色器2.1.4 Particle 着色器2.1.5 Trail着色器2.1.6 SkyBox着色器2.1.7 SkyPanoamic 着色器2.1.8 SkyProcedural 着色器2.2 材质效果展示2.2.1 切换不同mesh的材质2.2.2 关闭灯光效果3、材质的使用IDE的材质属性 为了将场景中的物体绘制出来，我们需要描述物体的形状与外表，我们使用mesh来表示物体的形状，使用材质来表示物体的外表。材质与着色器是紧密相连的，我们使用的材质必须设置对应的着色器形式。 1、材质的创建 我们可以在IDE的项目面板内创建材质，创建材质操作如动图1-1所示： 动图1-1 我们创建一个材质，并将其命名为\"myMaterial\"。 2、材质面板 创建完材质之后我们看到右侧的Inspector面板上会出现新的属性说明，当我们选中创建的材质后，属性面板便会显示当前材质的属性内容，属性面板主要由材质基础属性与材质效果展示两部分组成，如图2-1所示，我们详细说明下材质属性面板的组成。 图2-1 2.1 材质基础属性 材质是根据不同的着色器模型来描述不同表面的，IDE内置了八种着色器类型，我们根据着色器类型来说明每种着色器对应材质的基础属性，切换材质的着色器是通过选择材质的Shader来实现的，具体操作图动图2-1-1所示，来切换到其他类型的着色器。 动图2-1-1 2.1.1 BlinnPhong 着色器 Blinn-Phong光照模型能够简单描述物体表面对光的吸收与反射，使物体表面呈现不同的明暗程度，主要描述物体表面的高光、漫反射光与环境光部分。 （1） VertexColor顶点颜色 是否支持顶点颜色的宏定义开关，开启后可以叠加mesh的顶点颜色内容。 （2） AlbedoTexture漫反射贴图 可以设置材质的漫反射贴图的内容，示例使用一个砖块的贴图，效果如动图2-1-1-2-1所示： 动图2-1-1-2-1 （3） AlbedoColor漫反射颜色 可以设置材质的整体漫反射颜色，如动图2-1-1-3所示： 动图2-1-1-3 （4） AlbedoIntensity 设置漫反射颜色的强度。 （5） SpecularTexture高光贴图 用来设置物体表面的高光镜面反射，根据物体当前顶点的uv在高光贴图上的rgb数值来反映物体当前顶点的光滑反射程度，如图2-1-1-5-1与图2-1-1-5-2所示： 图2-1-1-5-1 图2-1-1-5-2 在设置高光贴图前后，可以明显看到由于高光贴图的影响，只对墙壁的部分内容产生了高光效果，这样可以用来模拟不同的材质不同位置的高光现象。 （6） SpecularColor高光颜色 可以设置高光部分的颜色，如图2-1-1-6所示，将高光颜色设置为了绿色： 图2-1-1-6 （7） Shininess光泽度 用来设置高光的范围，效果如图2-1-1-7-1与2-1-1-7-2在不同的光泽度下的对比： 图2-1-1-7-1 图2-1-1-7-2 在shininess值较小的时候，整体的高光范围较大；当shininess值较大的时候，整体的高光范围较小。 （8）NormalTexture法线贴图 用来设置物体模型在切线空间下的法线，用于光照的计算，需要模型带有切线数据。 如图2-1-1-8-1与图2-1-1-8-2所示，在法线贴图参与下的光照与着色更为真实。 图2-1-1-8-1 图2-1-1-8-2 可见在添加了法线贴图之后，光照重新进行了计算，物体的表面也有了凹凸感更为真实。 （9）AlphaTestValue alpha测试值 这个需要配合材质的渲染模式为CUTOUT来使用，在CUTOUT模式下，当前顶点的片元颜色值的alpha小于AlphaTestValue时，这个片元的值会被直接丢弃，不进行渲染，我们使用一张蛛网的图作为漫反射贴图，通过调整AlphaTestValue的值来查看这个值的效果。蛛网图如2-1-1-9-1所示，AlphaTestValue的值如动图2-1-1-9-2所示： 图2-1-1-9-1 镂空部分的alpha通道值为0 动图2-1-1-9-2 可以看到随着值的变大，舍弃的片元原来越多，直到所有的片元都被丢弃不渲染。 （10）TilingOffset缩放偏移 可以设置物体模型uv的缩放与偏移，来实现采样AlbedoTexture的不同效果，如动图2-1-1-10所示： 动图2-1-1-10 （11）MaterialRenderMode材质渲染模式 OPAQUE：不透明模式，遮挡在物体后面的模型不会渲染出来。 CUTOUT：剔除模式，会根据albedo贴图的alpha值与AlphaTestValue的值来舍弃部分片元。 TRANSPARENT：透明模式，会与后面的物体混合来透明效果。 ADDITIVE：叠加模式，会叠加物体后面的像素 ALPHABLENDED：与透明模式相同的混合方式，与透明模式的区别是不会混合场景中的雾。 （12）RenderQueue渲染队列 可以用来设置材质着色器的渲染队列，RenderQueue越大的话，其渲染越靠后。一般设置材质的渲染模式之后会根据渲染模式来设置渲染队列。 OPAQUE模式对应的队列为2000； CUTOUT模式对应的队列为2450； TRANSPARENT模式对应的队列为3000； ADDITIVE模式对应的队列为3000； ALPHABLENDED模式对应的队列为3000； （13）Cull剔除模式 根据面顶点的不同连接顺序（顺时针或是逆时针）来进行剔除。 Off：关闭剔除 Back：剔除背面 Front：剔除前面 2.1.2 Unlit 着色器 Unlit着色器是不受光的材质，不会受到光照的影响，只靠材质的贴图与颜色来表现物体的表面效果。 （1）VertexColor顶点颜色 是否应用顶点颜色，开启此宏定义后会叠加模型顶点颜色。 （2）Texture贴图 设置用来描述物体描边颜色的贴图，如图2-1-2-2-1与图2-1-2-2-2所示，在设置贴图之后，物体表面根据uv来显示对应贴图部位的颜色，且能看到在场景中存在光的情况下，不会收到光照的影响。 图2-1-2-2-1 图2-1-2-2-2 （3）AlbedoColor漫反射颜色 同样AlbedoColor能够叠加颜色到物体表面，如图2-1-2-3-1所示，我们叠加一个红色到物体表面： 图2-1-2-3-1 （4）AlphaTestValue alpha测试值 这个同样也是需要在渲染模式为CUTOUT的模式下才生效，并配合使用，与Blinn-Phong着色器相同，也是通过判断当前顶点片元的alpha值与设置的AlphaTestValue的值大小，小于AlphaTestValue的值的都会被丢弃不进行渲染，我们还是使用上面Blinn-Phong着色器使用的蛛网贴图，来看下不同alphaTestValue的值的处理，如动图2-1-2-4-1所示： 动图2-1-2-4-1 可以看到与Blinn-Phong不同的是Unlit的alpha值会叠加AlbedoColor.a的值，我们的AlbedoColor的alpha为1.0，此时不会出现全部的片段都被丢弃的情况。 （5）TilingOffset缩放偏移 用来设置物体模型UV的缩放与偏移，与Blinn-Phong着色器的效果相同，如动图2-1-2-5-1所示： 动图2-1-2-5-1 （6）MaterialRenderMode 材质渲染模式 OPAQUE：不透明模式，遮挡在物体后面的模型不会渲染出来。 CUTOUT：剔除模式，会根据albedo贴图的alpha值与AlphaTestValue的值来舍弃部分片元。 TRANSPARENT：透明模式，会与后面的物体混合来透明效果。 ADDITIVE：叠加模式，会叠加物体后面的像素。 ALPHABLENDED：与透明模式相同的混合方式，与透明模式的区别是不会混合场景中的雾。 （7）RenderQueue 渲染队列 可以用来设置材质着色器的渲染队列，RenderQuere越大的话，其渲染越靠后。一般设置材质的渲染模式之后会根据渲染模式来设置渲染队列。 OPAQUE模式对应的队列为2000； CUTOUT模式对应的队列为2450； TRANSPARENT模式对应的队列为3000； ADDITIVE模式对应的队列为3000； ALPHABLENDED模式对应的队列为3000； （8）Cull 剔除模式 根据面顶点的不同连接顺序（顺时针或是逆时针）来进行剔除。 Off：关闭剔除 Back：剔除背面 Front：剔除前面 如何用unlit通过改设置，达到原来2.0引擎的effect材质效果 将MaterialRenderMode 材质渲染模式改成 addtive 或者 blend 模式，不排除颜色空间的话效果是一样的，3.0的颜色空间已经变成linear了 2.1.3 PBR 着色器 PBR材质是一种基于物理的渲染材质，可以提供灯光与曲面交互方式的精确表示，可以更为真实的描述物体表面性质。我们使用基于图像照明(IBL)的光照模式来更好的展示PBR的属性，我们需要将场景的环境光来源从SolidColor转化成球谐，并点击下面的GenerateLighing生成一个IBL的立方体贴图CubeMap，如图2-1-3-1所示： 图2-1-3-1 （1）AlbedoTexture漫反射贴图 为了设置物体表面材质的整体纹理，同样使用上面的墙体作为贴图，如图2-1-3-1-1与图2-1-3-1-2所示，设置AlbedoTexture的效果： 图2-1-3-1-1 图2-1-3-1-2 （2）AlbedoColor漫反射颜色 可以叠加一个整体的颜色到物体的表面上，如图2-1-3-2-1所示我们叠加一个黄色到材质上： 图2-1-3-2-1 （3）Metallic金属度 用来设置物体的表面金属光泽度的效果，一般我们使用使用0与1来设置物体的金属度，完全没有或者完全存在，当金属度为1时，能够反射出周围环境的内容。想象下当我们看向一个表面光滑的金属球时，它会反射出我们的脸。这样在IDE内我们已经设置了基于IBL的球谐立方体贴图作为环境光，当我们将材质的金属度越来越接近1时，物体表面会反射出周围环境的内容，同时我们将光滑度设置为1，这样能够更清楚的看到效果，如动图2-1-3-3-1所示： 动图2-1-3-3-1 当我们调节材质的金属度向1滑动时，能够看到物体表面渐渐反射了周围环境的内容，当金属度为1时，能够完全反射周围的环境。 （4）Smoothness光滑度 用来设置物体表面的光滑度，光滑度为0时，物体表面的漫反射明显，高光不足，光滑度为1时，高光部分更为明显。如动图2-1-3-4-1所示： 动图2-1-3-4-1 （5）SmoothnessSource光滑度来源 可以设置两个光滑度来源，分别从AlbedoTexture的alpha通道去获取、从MetallicGloassTexture的alpha通道去获取。实际上是将物体表面材质的光滑度映射到AlbedoTexture贴图的alpha通道、或者映射到MetallicGloass贴图的alpha通道上，这样可以根据物体每个顶点的光滑度来进行光照计算。 AlbedoTextureAlpha：从Albedo贴图的alpha通道来获取物体的表面光滑度。 MetallicGloassTextureAlpha：从MetallicGloass贴图的alpha通道来获取物体的表面光滑度。 （6）SmoothnessTextureScale光滑度贴图缩放值 当设置了从贴图的alpha通道来获取光滑度值时，可以通过设置这个缩放值来控制贴图alpha通道下的整体光滑值。我们设置光滑度来源为albedoTexture的alpha值，并使用上面的蛛网贴图作为albedo贴图，如动图2-1-3-6-1所示： 动图2-1-3-6-1 （7）NormalTexture法线贴图 设置物体的法线贴图，会根据物体法线贴图来计算光照，如图2-1-3-7-1与图2-1-3-7-2所示，设置法线贴图后，光照的高光部分与漫反射部分重新计算了： 图2-1-3-7-1 图2-1-3-7-2 （8）OcclusionTexture遮蔽贴图 通过采样Occlusion贴图的g通道，可以设置模型顶点的AO环境光遮蔽的值，这样在进行PBR的光照计算时，能够更为真实的模拟在细小接缝等位置的光照数值。 （9）OcclusionTextureStrength遮蔽贴图强度 用来调整遮蔽贴图的强度。强度为0时，整体的遮蔽值为1；强度为1时，采用遮蔽贴图的遮蔽值。 （10）Emission自发光 用来设置模型的自发光是否开启，再开启后会新增两个自发光的参数，分别是EmissionColor与EmissionTexture； EmissionColor自发光颜色 叠加的整体的自发光颜色，在漫反射部分会更为明显，如图2-1-3-10-1所示，叠加一个红色的自发光颜色： 图2-1-3-10-1 EmissionTexture自发光贴图 设置自发光贴图可以根据模型来对不同的顶点位置叠加上面设置的自发光颜色，如图2-1-3-10-2所示： 图2-1-3-10-2 （11）EmissionIntensity自发光强度 设置自发光颜色的强度，强度为0没有自发光效果；强度为1时叠加设置的自发光颜色。 （12）MetallicGlossTexture金属光滑贴图 可以设置存放物体表面材质金属度与光滑度的贴图，贴图的r通道存放模型材质的金属度信息，贴图的a通道存放模型材质的光滑度信息，下面我们使用一张纯黑与纯白的贴图来展示金属光滑度贴图对PBR材质的影响，如图2-1-3-12-1与图2-1-3-12-2所示： 图2-1-3-12-1 图2-1-3-12-2 图2-1-3-12-1中纯黑图的金属度与光滑度为0，基本只有立方体贴图的漫反射效果，图2-1-3-12-2中纯白图的金属度与光滑度为1，能够很好的反射周围的立体环境光内容。 （13）AlphaTestValue alpha测试值 同样是需要配合渲染模式为CUTOUT模式来使用，会根据AlbedoTexture与AlbedoColor的alpha叠加值来进行测试，小于AlphaTestValue值得片元会丢弃不进行渲染。 （14）TilingOffset 与Blinn-Phong和Unlit的效果相同，可以用来设置模型uv缩放与偏移值，实现对Albedo贴图不同位置的采样。 （15）MaterialRenderMode材质渲染模式 OPAQUE：不透明模式，遮挡在物体后面的模型不会渲染出来。 CUTOUT：剔除模式，会根据albedo贴图的alpha值与AlphaTestValue的值来舍弃部分片元。 TRANSPARENT：透明模式，会与后面的物体混合来透明效果。 ADDITIVE：叠加模式，会叠加物体后面的像素 ALPHABLENDED：与透明模式相同的混合方式，与透明模式的区别是不会混合场景中的雾。 （16）RenderQueue渲染队列 可以用来设置材质着色器的渲染队列，RenderQuere越大的话，其渲染越靠后。一般设置材质的渲染模式之后会根据渲染模式来设置渲染队列。 OPAQUE模式对应的队列为2000； CUTOUT模式对应的队列为2450； TRANSPARENT模式对应的队列为3000； ADDITIVE模式对应的队列为3000； ALPHABLENDED模式对应的队列为3000； （17）Cull剔除模式 根据面顶点的不同连接顺序（顺时针或是逆时针）来进行剔除。 Off：关闭剔除 Back：剔除背面 Front：剔除前面 2.1.4 Particle 着色器 粒子着色器用来设置粒子的表面显示，主要用于粒子特效中。我们需要在场景中创建一个粒子系统，如动图2-1-4-1所示： 动图2-1-4-1 同时需要将材质赋值给粒子系统，如动图2-1-4-2所示： 动图2-1-4-2 这样就将材质赋值给粒子系统来使用了，下面简单说下各个参数的作用。 （1）Color粒子颜色 用来设置粒子材质的颜色，如图2-1-4-1-1所示，我们设置为红色的粒子颜色，粒子系统此时发出的粒子变为红色： 图2-1-4-1-1 （2）Texture贴图 用来设置粒子的纹理样式，如图2-1-4-2-1所示： 图2-1-4-2-1 （3）AlphaTestValue alpha测试值 粒子着色器上的CUTOUT模式无效，alpha测试值不用设置。 （4）TilingOffset 与Blinn-Phong和Unlit得效果相同，可以用来设置模型得uv缩放与偏移值，实现对Albedo贴图不同效果的采样。 （5）MaterialRenderMode材质渲染模式 OPAQUE：不透明模式，遮挡在物体后面的模型不会渲染出来。 CUTOUT：粒子着色器下无效。 TRANSPARENT：透明模式，会与后面的物体混合来透明效果。 ADDITIVE：叠加模式，会叠加物体后面的像素 ALPHABLENDED：与透明模式相同的混合方式，与透明模式的区别是不会混合场景中的雾。 （6）RenderQueue渲染队列 可以用来设置材质着色器的渲染队列，RenderQuere越大的话，其渲染越靠后。一般设置材质的渲染模式之后会根据渲染模式来设置渲染队列。 OPAQUE模式对应的队列为2000； CUTOUT模式对应的队列为2450； TRANSPARENT模式对应的队列为3000； ADDITIVE模式对应的队列为3000； ALPHABLENDED模式对应的队列为3000； （7）Cull剔除模式 根据面顶点的不同连接顺序（顺时针或是逆时针）来进行剔除。 Off：关闭剔除 Back：剔除背面 Front：剔除前面 2.1.5 Trail着色器 Trail着色器用来实现拖尾的效果，我们需要拖尾特效对象来对应实现，在场景中创建一个拖尾特效对象入动图2-1-5-1所示： 动图2-1-5-1 我们给拖尾特效对象添加对应的材质如动图2-1-5-2所示，将myMaterial材质添加到拖尾特效对象上： 动图2-1-5-2 为了查看拖尾的效果，我们需要移动拖尾特效对象，为此我们添加一个Move脚本，使得特效对象能够沿着x轴进行移动。 （1）Color颜色 用来设置拖尾的颜色，如动图2-1-5-1-1所示，我们设置一个红色作为拖尾颜色： 动图2-1-5-1-1 （2）Texture贴图 用来设置拖尾的形状，如动图2-1-5-2-2中，我们添加一个图2-1-5-2-1作为贴图使用，拖尾着色器使用ADDITIVE模式实现透明叠加的效果： 图2-1-5-2-1 动图2-1-5-2-2 （3）AlphaTestValue alphaTest值 拖尾着色器只使用ADDITIVE与ALPHABLENDED模式，这个值在这里无效。 （4）TilingOffset缩放偏移 可以用来设置贴图采样时UV的缩放与偏移，实现贴图缩放与偏移的效果。 （5）MaterialRenderMode材质渲染模式 拖尾着色器只使用ADDITIVE与ALPHABLENDED模式： ADDITIVE：透明叠加模式，叠加后面像素的全部alpha值，实现透明效果。 ALPHABLENDED：与透明模式相同的混合方式，与透明模式的区别是不会混合场景中的雾，这个模式不会产生ADDITIVE的透明效果。 （6）RenderQueue渲染队列 可以用来设置材质着色器的渲染队列，RenderQuere越大的话，其渲染越靠后。一般设置材质的渲染模式之后会根据渲染模式来设置渲染队列。 OPAQUE模式对应的队列为2000； CUTOUT模式对应的队列为2450； TRANSPARENT模式对应的队列为3000； ADDITIVE模式对应的队列为3000； ALPHABLENDED模式对应的队列为3000； 拖尾着色器只使用ADDITIVE与ALPHABLENDED模式，这里设置为3000。 （7）Cull剔除模式 根据面顶点的不同连接顺序（顺时针或是逆时针）来进行剔除。 Off：关闭剔除 Back：剔除背面 Front：剔除前面 2.1.6 SkyBox着色器 天空盒着色器用来设置场景的天空盒样式，天空盒需要一个立方体贴图来进行采样，我们首先需要新建一个立方体贴图，并根据天空盒的上下左右前后面来设置贴图，如动图2-1-6-1所示： 动图2-1-6-1 设置天空盒需要修改Scene3D的天空盒材质，如动图2-1-6-2所示： 动图2-1-6-2 （1）TintColor颜色 叠加颜色到天空盒上，如图2-1-6-1-1所示，设置一个淡红色，使整个天空发红： 图2-1-6-1-1 （2）Exposure曝光度 用来设置天空盒的曝光度，当曝光为0时，天空盒为黑色；随着曝光值的增大，逐渐显示正常的立方体贴图颜色，随后会由于过曝导致天空盒全变为白色。如动图2-1-6-2-1所示： 动图2-1-6-2-1 （3）Rotation旋转 可以将立方体贴图绕着y轴旋转0~360度。 （4）CubeTexture球状贴图 用来设置天空盒的采样贴图，需要使用CubeMap类型的立方体贴图。 （5）AlphaTestValue alpha测试值 这个值在天空盒着色器上，切换到CUTOUT模式下不生效。 （6）TilingOffset 由于使用的是立方体贴图，这个值在天空盒着色器上不生效。 （7）MaterialRenderMode材质渲染模式 在天空盒着色器上，设置为CUTOUT、TRANSPARENT、ADDITIVE、ALPHABLENED模式均不生效。 （8）RenderQueue渲染队列 可以用来设置材质着色器的渲染队列，RenderQuere越大的话，其渲染越靠后。一般设置材质的渲染模式之后会根据渲染模式来设置渲染队列。 OPAQUE模式对应的队列为2000； CUTOUT模式对应的队列为2450； TRANSPARENT模式对应的队列为3000； ADDITIVE模式对应的队列为3000； ALPHABLENDED模式对应的队列为3000； 这里由于天空盒材质的渲染模式只在OPAQUE模式下生效，设置2000即可。 （9）Cull剔除模式 根据面顶点的不同连接顺序（顺时针或是逆时针）来进行剔除。 Off：关闭剔除 Back：剔除背面 Front：剔除前面 2.1.7 SkyPanoamic 着色器 天空盒全景贴图着色器，这里使用的是一张2D的全景贴图来以立方体贴图的方式包裹场景实现环境光效果，这个材质的使用与天空盒相同，直接赋值给3D场景的天空盒渲染器即可。 （1）TintColor颜色 与天空盒着色器功能相同，都是叠加一个颜色到全景图天空盒上。 （2）Rotation旋转 可以设置天空盒绕Y轴旋转的角度，在0~360之间。 （3）PanoramicTexture全景贴图 全景贴图需要一个使用经纬度的、圆柱形样式的2D贴图。 （4）AlphaTestValue alpha测试值 在全景天空盒着色器上由于只有OPAQUE模式生效，所以这个值在CUTOUT模式下无效。 （5）TilingOffset 由于使用的是2D贴图来实现立方体贴图的方式，这个值无效。 （6）MaterialRenderMode材质渲染模式 在全景图天空盒模式下只有OPAQUE模式生效。 （7）RenderQueue渲染队列 可以用来设置材质着色器的渲染队列，RenderQuere越大的话，其渲染越靠后。一般设置材质的渲染模式之后会根据渲染模式来设置渲染队列。 OPAQUE模式对应的队列为2000； CUTOUT模式对应的队列为2450； TRANSPARENT模式对应的队列为3000； ADDITIVE模式对应的队列为3000； ALPHABLENDED模式对应的队列为3000； 由于只有OPAQUE模式生效，这里设置为2000； （8）Cull剔除模式 根据面顶点的不同连接顺序（顺时针或是逆时针）来进行剔除。 Off：关闭剔除 Back：剔除背面 Front：剔除前面 2.1.8 SkyProcedural 着色器 程序化天空盒，通过设置太阳的参数来模拟天空。 （1）U_SunSize 太阳大小 太阳的圆盘大小设置，如图2-1-8-1-1所示，设置太阳大小为0.1： 图2-1-8-1-1 （2）Sun太阳类型 用来设置程序化天空盒的太阳类型，有如下三种类型： SUN_NONE 没有太阳，选择此模式后，天空盒上没有太阳显示。 SUN_HIGH_QUALITY 高品质太阳模拟，这个模式下，太阳光的发散与收敛可以进行调节。 SUN_SIMPLE 简单的太阳模拟，只能调整太阳的整体大小。 （3）U_SunSizeConvergence太阳大小收敛 太阳的大小收敛，值越小，整体的太阳圆盘越大，只在SUN_HIGH_QUALITY的模式下生效。如动图2-1-8-3-1所示： 动图2-1-8-3-1 （4）U_AtmosphereThickness大气层厚度 大气层的密度，更高密度的大气会吸收更多的颜色，如图2-1-8-4-1在密度为1时，与图2-1-8-4-2在密度为2时所示： 图2-1-8-4-1 图2-1-8-4-2 （5）U_SkyTint天空颜色 设置地平线以上天空的颜色。 （6）U_GroundTint地面颜色 设置地平线以下地面的颜色。 （7）U_Exposure曝光 通过曝光值来设置天空盒的明暗，如动图2-1-8-7-1所示： 动图2-1-8-7-1 （8）AlphaTestValue alpha测试值 由于程序化天空盒只使用OPAQUE，所以此值无效。 （9）TilingOffset 由于程序化天空并没有贴图，所以此值也无效。 （10）MaterialRenderMode材质渲染模式 只在OPAQUE模式下生效。 （11）RenderQueue渲染队列 可以用来设置材质着色器的渲染队列，RenderQuere越大的话，其渲染越靠后。一般设置材质的渲染模式之后会根据渲染模式来设置渲染队列。 OPAQUE模式对应的队列为2000； CUTOUT模式对应的队列为2450； TRANSPARENT模式对应的队列为3000； ADDITIVE模式对应的队列为3000； ALPHABLENDED模式对应的队列为3000； 由于程序化天空盒只在OPAQUE模式下生效，设置为2000. （12）Cull剔除模式 根据面顶点的不同连接顺序（顺时针或是逆时针）来进行剔除。 Off：关闭剔除 Back：剔除背面 Front：剔除前面 2.2 材质效果展示 材质效果展示主要用来显示设置属性后的材质效果，可以使用鼠标在此处进行交互来操作材质球不同方向上的效果。 2.2.1 切换不同mesh的材质 可以通过点击右侧的方块键来切换不同mesh下材质的效果，如动图2-2-1所示： 动图2-2-1 2.2.2 关闭灯光效果 可以通过点击右侧的灯泡按键来切换材质在受光与不受光的效果，如动图2-2-2所示： 动图2-2-2 3、材质的使用 当我们调整材质的属性为我们想要的效果之后，就可以将材质赋值给场景中的物体，设置物体的材质有两种方法可以使用，分别是下列动图3-1与动图3-2所示： 动图3-1 上面动图3-1可以直接将材质拖拽到Scene窗口内的物体上，或者也可以按照动图3-2所示，在对应物体的渲染器上选择相应的材质。 动图3-2 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-07-14 11:41:57 "},"IDE/ShaderBlueprint/readme.html":{"url":"IDE/ShaderBlueprint/readme.html","title":"蓝图编辑模块","keywords":"","body":"Shader蓝图1.蓝图概述1.1 创建蓝图1.2 蓝图界面预览2.与Shader的异同2.1 固定的三种基础材质类型2.2 材质混合方式2.3 ShaderName //待定项2.4 ShadowCaster2.5 DepthNormal2.6 AlphaTest2.7 SceneFog3.简单示例3.1 显示一个简单的模型3.2 显示一个简单的Blinnphong材质球4.节点数据的传输方式5.常见的节点类型5.1 坐标类5.2 相机类5.3 数学类5.4 纹理类5.5 颜色类6.常见的Params类型6.1 Float6.2 Texture2D6.3 Vector2/3/46.4 Color6.5 Define7.自定义函数8.进阶示例8.1 顶点着色器片段8.2 片段着色器片段拓展：快捷操作Shader蓝图 1.蓝图概述 1.1 创建蓝图 在Assert窗口右键Create菜单选择Shader BluePrint创建一个蓝图文件 在蓝图文件未打开时，蓝图文件对应的Shader文件并未创建；打开蓝图文件时才会创建Shader文件，完成蓝图与Shader的映射对应 图1-1 1.2 蓝图界面预览 图1-2 蓝图文件Inspector窗口 蓝图Params窗口 蓝图文件Pass窗口 蓝图预览窗口 2.与Shader的异同 2.1 固定的三种基础材质类型 2.1.1 PBR 常见的Shader属性： NormalWS 世界法线计算世界坐标中各顶点的光照结果 alphaTest 启用AlphaTest开关后，Shader通过alophatest的值来判断是否丢弃该像素 AlbedoColor 表面颜色（不包含光照） Metallica 金属度，描述物体的金属属性的值，实际上是在控制表面在多大程度上像“金属”，对于纯表面金属度的值可能是0或1，现实中的大多数物体其实是介于这个区间之间的 Smoothness 光滑度，描述物体的光滑程度，通常情况可以根据反射的模糊或者清晰度或者镜面反射高光的广度或者密集度加以确定 Occlusion 环境光遮蔽参数，环境光遮蔽是一种近似于光线因遮挡而衰减的效果，这是一种细微的表现，使角落，裂缝变得更暗，以创建一个更自然，现实的外观 Emission 自发光颜色 Anisotropy 各向异性参数，增加采样次数来补充贴图展示在模型上的细节 Alpha 透明度，选择了TRANSPARENT渲染模式，会根据Alpha值选择不同的透明度 图2-1展示了PBR材质类型是Shader蓝图的片段着色器内容 图2-1 2.1.2 UnLit NormalWS 世界法线计算世界坐标中各顶点的光照结果 AlphaTest 启用AlphaTest开关后，Shader通过alophatest的值来判断是否丢弃该像素 Color 基础颜色 Alpha 透明度，选择了TRANSPARENT渲染模式，会根据Alpha值选择不同的透明度 图2-2展示了UnLit材质类型是Shader蓝图的片段着色器内容 图2-2 2.1.3 Blinnphong NormalWS 世界法线计算世界坐标中各顶点的光照结果 AlphaTest 启用AlphaTest开关后，Shader通过alophatest的值来判断是否丢弃该像素 DiffuseColor 漫反射颜色（不产生光照的地方的颜色） SpecularColor 高光颜色（产生光照的地方的颜色） Shininess 表面光滑度 Gloss 表面粗糙度 Aplha 透明度，选择了TRANSPARENT渲染模式，会根据Alpha值选择不同的透明度 图2-3展示了Blinnphong材质类型是Shader蓝图的片段着色器内容 图2-3 2.2 材质混合方式 OPAQUE（不透明） 最终颜色 = 来源颜色。这意味着材质将绘制在背景前面。 CUTOUT（镂空） ​ 如果贴图中采样到的Aplha值 > AlphaTestValue，则最终颜色为来源颜色，否则废弃像素。 TRANSPARENT（半透明） 最终颜色 = 来源颜色不透明度 + 目标颜色（1 - 不透明度）。 ADDTIVE（加色混合） 最终颜色 = 来源颜色 + 目标颜色 ALPHABLENDED（透明混合） 这意味着对象为半透明的模式，但是最终像素的着色的混合模式不同，AlphaBlended混合方式为SrcAlpha SrcColor + （1 - SRCAlpha） DstColor，通常来说SrcAlpha来自纹理的Alpha值 2.3 ShaderName //待定项 ShaderName文本框中输入的是ShaderName 2.4 ShadowCaster 阴影计算开关，开启此开关时， 2.5 DepthNormal DepthNormal开关，开启此开关时，会加入DepthNormal Pass以计算场景的法线信息（部分后期处理可能会用到该功能） 2.6 AlphaTest Alpha测试开关，开启此开关的时，启用片段着色器的AlphaTest变量的Value值功能，启用透明裁剪，触发alphatest Value条件的像素直接丢弃，不填充颜色 2.7 SceneFog 场景雾效开关，开启此开关时，启用sceneFog通过屏幕空间的w值来计算雾效的范围 3.简单示例 3.1 显示一个简单的模型 图3-1 通过Params传入一张纹理 通过UV采样传入的纹理 将从纹理中采样到的颜色作为传入Unlit的Color 将世界法线传入Unlit的世界法线输入中 蓝图的结果展示如下 图3-2 3.2 显示一个简单的Blinnphong材质球 图3-3 传入世界法线 通过Params传入表面颜色 蓝图的结果展示如图 图3-4 4.节点数据的传输方式 在蓝图中一个节点中左侧为输入数据，右侧为输出数据 输入数据可以来自一个源数据、Params变量或者其他节点的输出 图4-1 5.常见的节点类型 5.1 坐标类 坐标类型 坐标释义 PositionWS 世界空间下的顶点世界坐标 normalWS 世界空间下的顶点法线世界坐标 tangentWS 世界空间下的顶点切线世界标 biNormalWS 世界空间下的顶点副切线世界坐标 worldMat 世界空间矩阵 5.2 相机类 属性类型 属性释义 viewDirection 视线向量（3D世界空间下的视线数学化表达) cameraPosition 相机位置世界空间坐标 cameraDirection 相机forward方向 cameraUp 相机Up方向 cameraNear 相机近平面大小 cameraFar 相机远平面大小 5.3 数学类 属性类型 属性释义 add / minus / multiply / divide 四则运算 sin / cos / tan 三角函数 clamp 钳取值在min和max范围内 mix / max 最小值，最大值 step / smoothstep x > value : 0.0 : 1.0 pow 幂次方 dot / cross 点乘向量，叉乘向量 5.4 纹理类 属性类型 属性释义 sampler2D 普通采样2D纹理贴图 samplerCube 采样3D CubeMap sampler2DNormal（OpenGL） 采样法线贴图（GL在左下角) sampler2DNormal(Directx) 采样法线贴图（DX在左上角) 5.5 颜色类 属性释义 属性类型 GammaToLinear 伽马空间转换到线性空间 LinearToGamma 线性空间转换到伽马空间 6.常见的Params类型 添加一个Params变量。在Params窗口下选中\"＋\"，选择相应的Parmas变量类型 图6-1 6.1 Float 定义一个float值，在检视面板中先试用一个float类型的对象 图6-2 6.2 Texture2D 定义一个2D纹理的值，在检视面板中显示一个2D纹理类型的对象 图6-3 6.3 Vector2/3/4 定义一个向量类型，根据不同的分量数量分为Vector2、Vector3、Vector4 图6-4 6.4 Color 定义一个颜色值，通常存在RGBA四种分量的数据 图6-5 6.5 Define 宏定义，用于对宏条件的不同触发结果来执行不同的结果内容，效率高于if-else 图6-6 7.自定义函数 7.1创建蓝图函数 在Project窗口右键Create菜单，选择Shader BluePrint Function创建一个蓝图函数 图7-1 7.2 添加参数 在蓝图编辑窗口下，右键空白处，选择ShaderFunction选项，选择Input In选项卡 图7-2 7.3 自动返回值 在最后的Default Output Result节点，输入的数据类型决定了该Shader函数的输出类型，函数蓝图会自动判断输出类型，如下图所示 图7-3 7.4 函数中调用函数 在蓝图函数界面，在需要放置蓝图函数节点的位置右键，在CustomFun-BlueMap项选择创建蓝图函数时定义的函数（蓝图函数文件名） 图7-4 8.进阶示例 简单的草 图8-1 8.1 顶点着色器片段 使用柏林噪声模拟出一个Vec4的向量 图8-2 对噪声值进行一些特殊的变换 把生成的噪声值缩小0.016，分别与外部传入的Color的g通道和a通道相乘，将分别乘完的结果求和，将得到的和与一个干扰值相加，最后与世界矩阵相乘 图8-3 3.将于世界矩阵相乘完的结果取出xz分量与positionOS的xz分量相加为新的positionOS的xz分量 图8-4 8.2 片段着色器片段 判断是否启用了SNOW宏，宏启用的时候计算 1- 顶点颜色g值的2次方在（0,1）的结果，宏关闭是值为0 图8-5 将UV坐标偏移与一个三角函数组成的2x2矩阵相乘再偏移回原来的位置 图8-6 采样草体纹理贴图，提取其中A通道转换为伽马值作为草体的Alpha值传入PBR函数，Albedo值为传入颜色值 * 纹理采样值 + 宏判断的值 图8-7 蓝图的结果展示如下 图8-7 拓展：快捷操作 节点类型 生成方式 快速生成float节点 长按数字键1，左键点击需要放置的位置 快速生成Vector2节点 长按数字键2，左键点击需要放置的位置 快速生成Vector3节点 长按数字键3，左键点击需要放置的位置 快速生成Vector4节点 长按数字键4，左键点击需要放置的位置 快速生成If节点 长按字母键i，左键点击需要放置的位置 快速生成bool节点 长按字母键b，左键点击需要放置的位置 快速生成sampler2D节点 长按子母键t，左键点击需要放置的位置 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-08-03 17:22:09 "},"IDE/Component/readme.html":{"url":"IDE/Component/readme.html","title":"内置组件","keywords":"","body":"内置组件网格拖尾像素线反射探针体积全局照明静态合批LOD组内置组件 引擎内置了大量的常用组件，方便开发者使用。 由于有一些组件与其它的功能联系紧密，就在其它的章节里进行体现，例如物理组件、动画组件等 本章节的组件包括： 网格 拖尾 像素线 反射探针 体积全局照明 静态合批 LOD组 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-07-03 18:05:44 "},"IDE/Component/Mesh/readme.html":{"url":"IDE/Component/Mesh/readme.html","title":"网格","keywords":"","body":"组件系统之Mesh1.Mesh1.1 Mesh 概述2.Mesh组件--MeshRenderer2.1 Mesh Renderer Inspector2.2 MeshRenderer的Material3.Mesh组件--MeshFilter3.1 MeshFilter Inspector 引用4.通过PrimitiveMesh创建简单Mesh组件系统之Mesh 1.Mesh 1.1 Mesh 概述 Mesh是指模型的网格数据，3D模型是由多边形拼接而成，而一个复杂的多边形，实际上是由多个三角形拼接而成。所以一个3D模型的表面是由多个彼此相连的三角面构成。三维空间中，构成这些三角形的顶点的数据以及三角形的索引数据的集合就是Mesh。 图1.1 1.2 Mesh数据 一个网格数据中包含了很多的数据信息，Shader中常见的顶点，法线等数据都是从Mesh数据中获取而来 一个标准的网格数据由以下的几部分属性组成 Vertex：三维空间中位置的集合 Topology：Mesh的基本片元类型 Index：索引数据，描述顶点组合片元的整数集合 Vertex：顶点数据 每个顶点可以具有以下的属性内容： position顶点 顶点位置标示顶点在模型空间的具体位置，在引擎中使用这个值来确定Mesh的表面，所有的网格都需要这个顶点属性，为必须项 normal法线 顶点法线表示从顶点位置的表面直接 “向外” 指出的方向。 tangent切线 顶点切线表示沿着顶点位置表面的“ u”(水平纹理)轴指向的方向 color颜色 顶点颜色表示顶点的基本颜色(如果有的话)。 uv坐标 一个网格最多可以包含八组纹理坐标。纹理坐标通常称为 UV，这些集合称为通道。 骨骼（可选） 在蒙皮网格中，混合指数表示哪些骨骼影响顶点，骨骼重量描述这些骨骼对顶点的影响程度 Topology：片元拓扑 网格的拓扑结构定义了索引缓冲区的结构，而索引缓冲区又描述了顶点位置如何组合成面。每种拓扑类型在索引数组中使用不同数量的元素来定义单个面 LayaAir支持以下网格拓扑: Triangle Quad Lines Points Index Data : 索引数据 索引数组包含引用顶点位置数组中元素的整数。这些整数称为索引 例如，对于包含下列值的索引数组的网格: 0,1,2,3,4,5 如果网格具有三角形拓扑，那么前三个元素(0,1,2)识别一个三角形，而后三个元素(3,4,5)识别另一个三角形。顶点可以贡献的面的数量没有限制。这意味着同一个顶点可以多次出现在索引数组中。 2.Mesh组件--MeshRenderer Mesh Renderer 组件用于渲染网格。该组件与同一个游戏对象上的 Mesh Filter组件配合使用；Mesh Renderer 组件渲染 Mesh Filter 组件引用的网格 在引擎代码中MeshRenderer类继承自BaseRender组件类 2.1 Mesh Renderer Inspector 图2-1 A：指定该Render是否显示投射阴影 B：指定当一个合适的光照射到Render上时，该渲染器是否投射阴影以及如何投射阴影 C：LightMap缩放大小 D：LightMap索引号 E：Render材质列表 2.2 MeshRenderer的Material Material与Share Material的区别‘ Material 当我们引用修改这个属性的时候，LayaAir会返回该Render下第一个实例化后的material赋予当前的MeshRederer组件。 那么，什么是第一个实例化后的material呢？ 每个MeshRenderer组件里有个Materals属性，这个数组决定了该物体下可以放几个material组件，默认是1。 当同一个物体上有很多个material的时候，我们可以手动更改material组件的上下位置关系。这里的第一个实例化后的material指的就是该物体上从上往下的第一个material组件，而不是MeshRenderer.materials[0]，也就是说我们每一次引用就会生成一个新的material到内存中。但是在引用后并不会改变我们项目工程中材质球的原始属性设置 Share Material 当我们改变Renderer.sharedMaterial的时候，所有使用这个材质球物体都会被改变，并且改变后的设置将会被保存在项目工程中 假设cube01和cube02共用一个材质redMat,当我们想通过sharedMaterial修改cube01上material的属性的时候，cube02上对应的属性也会被修改 总结 当使用MeshRenderer.material的时候，每次调用都会生成一个新的material到内存中。 当使用Renderer.sharedMaterial的时候并不会生成新的material，而是直接在原material上修改，并且修改后的设置就会被保存到项目工程中。一般不推荐使用这个去修改，当某个材质球只被一个gameobject使用的时候可以使用这个去修改，并且最好在修改之前把原属性设置保存，当使用完毕后立即恢复原设置，防止下次加载后的gameobject上还会残留之前的设置信息。 如果是主角这一类gameobject身上需要修改材质的属性或者shader属性比较多的时候，可以第一次使用material，这样可以动态的生成一个material实例，然后再使用sharedmaterial，动态的修改这个新生成的material，而且不会创建新的material 3.Mesh组件--MeshFilter Mesh Filter 组件包含对网格的引用。该组件与同一个游戏对象上的 Mesh Renderer组件配合使用；Mesh Renderer 组件渲染 Mesh Filter 组件引用的网格。 3.1 MeshFilter Inspector 引用 图3-1 Mesh属性 对网格资源的引用要更改MeshFilter组件引用的网格资源，请选择网格名称旁的箭头标识符来调用选取列表选择想要的Mesh网格 注意：当更改 Mesh Filter 组件引用的网格时，此游戏对象上其他组件的设置不会改变。例如，MeshRenderer 组件不会更新其设置，这可能会导致引擎使用非预期的属性渲染网格。如果发生这种情况，请根据需要调整其他组件的设置 4.通过PrimitiveMesh创建简单Mesh 在快速开启3D之旅的课程中，我们已用到了PrimitiveMesh的createBox方法创建一个盒子模型，本节课中介绍该类来创建其他的基础模型，并且使用transform来调整位置。更详细的使用情况可以查看API。 创建时需注意的是，加载到场景中的引擎自带模型，轴心点在模型正中心，因此我们是以模型中心点为参考进行移动、旋转、缩放。加载到场景中时，模型默认会放置到场景的世界座标原点上。 //创建一个空节点用来放置各模型 sprite3D = scene.addChild(new Laya.Sprite3D()); //正方体 var box = sprite3D.addChild(new Laya.MeshSprite3D(Laya.PrimitiveMesh.createBox(0.5, 0.5, 0.5))); box.transform.position = new Laya.Vector3(2.0, 0.25, 0.6); box.transform.rotate(new Laya.Vector3(0, 45, 0), false, false); //球体 var sphere = sprite3D.addChild(new Laya.MeshSprite3D(Laya.PrimitiveMesh.createSphere(0.25, 20, 20))); sphere.transform.position = new Laya.Vector3(1.0, 0.25, 0.6); //圆柱体 var cylinder = sprite3D.addChild(new Laya.MeshSprite3D(Laya.PrimitiveMesh.createCylinder(0.25, 1, 20))); cylinder.transform.position = new Laya.Vector3(0, 0.5, 0.6); //胶囊体 var capsule = sprite3D.addChild(new Laya.MeshSprite3D(Laya.PrimitiveMesh.createCapsule(0.25, 1, 10, 20))); capsule.transform.position = new Laya.Vector3(-1.0, 0.5, 0.6); //圆锥体 var cone = sprite3D.addChild(new Laya.MeshSprite3D(Laya.PrimitiveMesh.createCone(0.25, 0.75))); cone.transform.position = new Laya.Vector3(-2.0, 0.375, 0.6); //平面 var plane = sprite3D.addChild(new Laya.MeshSprite3D(Laya.PrimitiveMesh.createPlane(6, 6, 10, 10))); 效果如图2-2: 图2-2 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-12-19 12:25:12 "},"IDE/Component/Trail/readme.html":{"url":"IDE/Component/Trail/readme.html","title":"拖尾","keywords":"","body":"拖尾一、概述二、IDE中创建与使用2.1 创建拖尾对象2.2 属性设置2.3 拖尾材质2.4 拖尾过滤器拖尾 一、概述 拖尾渲染器（Trail Renderer）用于制作跟在场景中的物体后面的拖尾效果来代表它们在到处移动。像在物体移动路径的位置上出现的残影，就是一种拖尾效果。 （动图1-1） 如动图1-1所示，这是一个自身旋转的立方体，周围有拖尾效果。下面我们来看看在IDE中是如何创建和使用拖尾的 二、IDE中创建与使用 2.1 创建拖尾对象 在一个3D场景的Hierarchy窗口中，任何节点下，或者是空白位置，都可以通过鼠标右键来创建拖尾对象，如动图2-1所示 （动图2-1） 此时创建的拖尾对象，是看不到任何效果的，实际上就是创建了一个空节点，并添加了拖尾渲染器（Trail Renderer）组件，我们来了解一下组件的信息 2.2 属性设置 如图2-2所示，拖尾渲染器有如下的属性 （图2-2） 由于 Trail Renderer 组件是继承自 Base Renderer 组件，因此拖尾渲染器本身具备一些基础属性，如图2-3所示 （图2-3） 接收阴影 Receive Shadow ，产生阴影的设置 Case Shadow 和光照贴图的缩放和偏移等基础属性，在这里就不介绍了 2.3 拖尾材质 拖尾所使用的的材质，也就是需要使用 Laya.Trail 这个Shader 2.3.1 创建材质 首先我们在Asset下新建一个Material，默认情况下Material的Shader是BlinnPhone，接下来我们修改下Shader，如动图2-4所示 （动图2-4） 2.3.2 材质贴图 如图2-5所示，带 Laya.Trail Shader的材质有如下几个属性 （图2-5） 这里我们主要关注拖尾效果的贴图，如动图1-1示例中的效果，需要做出拖尾效果的话，需要一张拖尾效果的纹理贴图，如图2-6所示 （图2-6） 我们接下来将纹理贴图拖入材质中，如图2-7所示，这样拖尾的贴图就配置好了 （动图2-7） 2.3.3 纹理颜色 我们想让拖尾的效果是一种灰色的类似烟雾的效果，那么我们需要对材质的颜色做设置，如图2-8所示，选取灰色的颜色，并改透明图为55 （图2-8） 这样颜色就配置好了，同时我们需要改下 Material Render Mode为 Additive 模式，才能让贴图中黑色的颜色变为纯透明，并改变 Cull 为 Off，如图2-9所示 （图2-9） 这样修改后，效果才能如动图2-10所示 （动图2-10） 2.4 拖尾过滤器 拖尾材质可以指定拖尾的纹理效果，透明方式等等，但拖尾过滤器才可以设置拖尾的时间，轨迹，长度等等，就像3D粒子系统一样，如图2-11所示 （图2-11） 2.4.1 淡出时间 Time ：淡出时间，时间越长，拖尾淡出时间越长 默认是5秒，5秒之后才会消失，如动图2-12所示 （动图2-12） 但是我们可以调整时间为1秒，如动图2-13所示 （动图2-13） 2.4.2 轨迹准线 Alignment ：设置轨迹面向的方向 ​ VIEW： 轨迹面向摄像机 ​ TransformZ： 轨迹朝向其变换组件的 Z 轴 2.4.3 最小距离 Min Vertex Distance：获取新旧顶点之间最小距离，实际上是最小拖尾片段距离，相当于拖尾的长度 可以确定在将新段添加到该路径之前，应用轨迹的游戏对象必须行进的距离（采用世界单位）。像 0.1 这样较小的值会更频繁地创建轨迹段，从而形成更平滑的轨迹。像 1.5 这样较大的值会创建在外观上更有锯齿状的轨迹段。另外，当顶点非常靠近并且轨迹会在短距离内显著改变方向时，较宽的轨迹可能出现视觉瑕疵。 注意：出于性能原因，最好使用尽可能最大的值来实现要创建的效果 2.4.4 宽度设置 Width ：宽度值和曲线值以控制轨迹沿其长度的宽度。 曲线是在每个顶点处采样的，因此其精度受制于轨迹中的顶点数量。轨迹的总宽度由宽度值控制。 如动图2-9所示，我们可以通过鼠标双击红线上来添加曲线节点，并通过白色旋转轴来调整曲线角度，通过鼠标双击红色节点来删除 （动图2-14） 2.4.5 颜色设置 Color ：采用 colorGradient 方式设置，有两个可选模式 ​ Fixed 固定模式 ​ Blend 混合模式 如图2-15所示，为设置从半透明到白色，最后变为半透明的颜色设置 （图2-15） 2.4.6 纹理模式 texture Mode ：纹理模式，与普通纹理模式相同 ​ Stretch ：可沿着轨迹的整个长度应用纹理贴图 ​ Tile ：使纹理沿着轨迹的长度平铺 通常我们使用Stretch为主，主要是应用一张贴图变化的效果 如动图2-16，采用Tile平铺的方式效果 （动图2-16） 最终我们选择Stretch为拖尾效果，如动图2-17所示 （动图2-17） 到此，拖尾渲染器就介绍完了，结合动画编辑器的使用，使物体在场景中运动起来，这样拖尾效果才能看到运行的效果，开发者可以很好的利用拖尾渲染器做出类似烟雾，残影等效果！ Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:45 "},"IDE/Component/PixelLine/readme.html":{"url":"IDE/Component/PixelLine/readme.html","title":"像素线","keywords":"","body":"像素线一、概述二、IDE中创建与使用2.1 创建像素线3D精灵2.2 属性设置2.3 像素线材质2.4 像素线数据三、代码中创建与使用3.1 构造方法3.2 AddLine()3.3 Tool.linearModel()3.4 代码使用像素线 一、概述 像素线（Pixel Line ）也可以称之为像素线3D精灵，是通过渲染一组带有颜色的线，来绘制3D精灵的方式，如图1-1所示 （图1-1） 如图1-1所示，这是六种IDE提供的3D基础显示对象的网格模式，是一种用线条来展现网格的绘制方式 二、IDE中创建与使用 2.1 创建像素线3D精灵 在一个3D场景的Hierarchy窗口中，任何节点下，或者是空白位置，都可以通过鼠标右键来创建像素线3D精灵，如动图2-1所示 （动图2-1） 此时创建的像素线3D精灵，是看不到任何效果的，实际上就是创建了一个空的3D精灵节点，并添加了像素线渲染器（Pixel Line Renderer）组件，我们来了解一下像素线渲染器组件的信息 2.2 属性设置 如图2-2所示，像素线渲染器有如下的属性 （图2-2） 由于 Pixel Line Renderer 组件是继承自 Base Renderer 组件，因此像素线渲染器本身具备一些基础属性，如图2-3所示 （图2-3） 接收阴影 Receive Shadow ，产生阴影的设置 Case Shadow 和光照贴图的缩放和偏移等基础属性，在这里就不介绍了 2.3 像素线材质 首先我们在Asset下新建一个Material，默认情况下 Material 的 Shader 是 BlinnPhone，接下来我们先把这个Material拖入像素线渲染器的材质属性中，如动图2-4所示 （动图2-4） 第二步要修改 BlinnPhone 的 shader 为 Laya.Unlit shader ，并勾选 Vertex Color （动图2-5） 有了材质，剩下就需要添加像素线数据了 2.4 像素线数据 像素线数据就两点，像素线的最大线数量和像素线数据，如图2-6所示 （图2-6） Max Line Count：最大线数量 Pixel Lines Datas：像素线数据 注意：像素线数据的数量是不能超过最大线数量的 默认时，已经添加了一个像素线数据，从（0，0，0）点到（0，0，0）点的白色线，只不过是一个点，我们无法看到效果 我们可以通过修改 End Position 和颜色，如图2-7所示 （图2-7） 修改之后，我们可以看到一条最基本的像素线，如图2-8所示 （图2-8） 到此，像素线渲染器就介绍完了，通常我们通过IDE来添加每一条像素线来描绘一个网格是不可能的，往往我们会通过代码来实现，下面我们介绍代码是如何使用的 三、代码中创建与使用 PixelLineSprite3D 是 LayaAir引擎提供的像素线3D精灵类，我们看看这个类最重要的方法 3.1 构造方法 从下面的代码中可以看到，当初始化一个PixelLineSprite3D 的构造方法时，代码已经帮我们添加了 PixelLineRenderer 组件和 设置了 UnlitMaterial 材质并勾选了使用 VertexColor ，如上面2.3小节中手动添加材质的过程在代码中是自动做好了 /** * 创建一个 PixelLineSprite3D 实例。 * @param maxCount 最大线段数量。 * @param name 名字。 */ constructor(maxCount: number = 2, name: string = null) { super(name); this._render = this.addComponent(PixelLineRenderer); this._geometryFilter = (this._render as PixelLineRenderer)._pixelLineFilter; (this._render as PixelLineRenderer).maxLineCount = maxCount; let material = this._render.material = new UnlitMaterial(); material.enableVertexColor = true; } 3.2 AddLine() PixelLineSprite3D 已经直接调用了 PixelLineRenderer 组件的 addLine() ，看来可以直接设置点位置和颜色即可 /* * 增加一条线。 * @param startPosition 初始点位置 * @param endPosition 结束点位置 * @param startColor 初始点颜色 * @param endColor 结束点颜色 */ addLine(startPosition: Vector3, endPosition: Vector3, startColor: Color, endColor: Color): void { (this._render as PixelLineRenderer).addLine(startPosition, endPosition, startColor, endColor); } 3.3 Tool.linearModel() 通常我们可以利用addLine() 方法来实现把复杂的网格数据转变成像素线数据，我们可以写一个Tool工具类，方便转换使用： //Tool工具类 export class Tool { private static transVertex0: Vector3 = new Vector3(); private static transVertex1: Vector3 = new Vector3(); private static transVertex2: Vector3 = new Vector3(); private static corners: Vector3[] = []; //线性模型转换方法 static linearModel(sprite3D: Sprite3D, lineSprite3D: PixelLineSprite3D, color: Color): void { if (sprite3D instanceof MeshSprite3D) { var meshSprite3D: MeshSprite3D = sprite3D; //获得Sprite3D对象的网格数据 var mesh: Mesh = meshSprite3D.meshFilter.sharedMesh; var positions: Array = []; //拷贝并填充位置数据至数组 mesh.getPositions(positions); //拷贝并获取网格索引的副本 var indices = mesh.getSubMesh(0).getIndices(); for (var i: number = 0; i 3.4 代码使用 通过如下代码对工具类 Tool.linearModel 的使用，可以把一个 PixelLineSprite3D 对象的网格数据设置成像素线数据： //创建一个球体 var sphere: MeshSprite3D = (this.sprite3D.addChild(new MeshSprite3D(PrimitiveMesh.createSphere(0.25, 20, 20)))); sphere.transform.position = new Vector3(0.0, 0.75, 2); //创建一个像素线3D精灵 var sphereLineSprite3D: PixelLineSprite3D = (this.lineSprite3D.addChild(new PixelLineSprite3D(3500))); //转换球体的网格数据为像素线数据 Tool.linearModel(sphere, sphereLineSprite3D, Color.GREEN); 到此，像素线代码部分就介绍完了，往往我们也可以对一个外部模型转换成像素线数据来使用，在实际项目中可以丰富展现效果 如动图3-1所示，展示外部模型的像素线效果 （动图3-1） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:44 "},"IDE/Component/ReflectionProbe/readme.html":{"url":"IDE/Component/ReflectionProbe/readme.html","title":"反射探针","keywords":"","body":"Reflection Probe：反射探针1. 反射探针概述1.1 烘焙探针2.反射探针的属性2.1 Ambient Mode2.2 Importance2.3 Intensity2.4 Box Projection(盒式投影)2.5 Bounds2.6 环境光强度与反射强度2.7 采样大小与采样质量2.8 Clear信息2.9 IBL选项Reflection Probe：反射探针 1. 反射探针概述 传统形式的反射是通过反射贴图的形式来模拟来自对象的反射，对于静态的开放场景来说，传统反射贴图的形式得到的效果是可以接受的，但对象处于复杂环境中，反射贴图的效果就捉襟见肘了，LayaAir通过反射探针的形式，对对象所有场景的周围环境进行采样，利用反射探针可以在复杂的环境中来保证对象的反射效果足够的真实。当存在多个探针的时候，引擎会自动对每个探针采样到的反射结果进行插值以得到平滑的反射过渡效果。 反射探针使用CubeMap的贴图形式来从六个方向来收集并保存在CubeMap中，如下图中所示六个方向的反射结果 图1-1 1.1 烘焙探针 LayaAir引擎中的探针类型为Bake，烘焙探针捕获的反射只能为包含标记为Static的对象，具体的操作为选择需要烘焙反射的对象，选中该对象，在Inspector面板右上角勾选对象Static选项。 图1-2 在将需要烘焙反射信息的对象设置为Static完毕后，在Sprite3D对象添加Reflection Probe组件 图1-3 在Reflection Probe组件选择适合的采样等级采样大小，点击Bake按钮就可以开始反射探针的烘焙 图1-4 2.反射探针的属性 2.1 Ambient Mode 环境光模式有两种，一种是球谐模式一种是纯色模式 图2-1 球谐模式 通过球谐函数计算天空盒提供的环境光信息，反射探针收集到的为球谐函数计算得到的数值 纯色模式 在反射探针收集非指定位置的反射信息由纯色填充 2.2 Importance 重要性判断，当前引擎只支持单探针模式，如果当前新建的探针Important值大于主探针Important值，才用当前探针作为主探针 2.3 Intensity 应用于该反射探针在其着色器中的纹理的强度大小调节 2.4 Box Projection(盒式投影) 通常情况下，假设反射立方体贴图处于与任何给定对象之间无限远的距离。当对象转动时，立方体贴图的不同角度都将变为可见状态，但是对象不能进一步靠近或远离反射环境。这种状态通常对于室外场景表现良好，但其局限性表现在室内场景中；房间的内部墙壁显然不是无限远的距离，物体越靠近墙壁，墙壁的反射应该越大。 图2-2 2.5 Bounds 反射探针作用的范围用一个包围盒的形式来，反射探针只接受位于包围盒内物体的反射信息 Bounds Min：包围盒最小值坐标 Bounds Max：包围盒最大值坐标 包围盒Size = Max — Min 图2-3 2.6 环境光强度与反射强度 环境光强度：属性为接收到的环境光强度，作用到映射反射物体上的效果为反射效果中的环境光更强烈、更亮 反射强度：属性为接收到的反射内容强度，作用到映射反射物体上的效果为反射效果更强烈、更亮 2.7 采样大小与采样质量 烘焙反射探针采样大小：决定了烘焙CubeMap的单张RT的尺寸（分辨率） 烘焙反射探针采样质量：决定了烘焙CubeMap的单张RT的写入质量（高中低三挡） 图2-4 2.8 Clear信息 清除信息：除了反射内容部分，烘焙的探针内容时填充的内容可选项 清除颜色：当填充内容选择为SolidColor时，在ClearColor选项中选择填充的颜色 图2-5 2.9 IBL选项 IBL Tex：烘焙的反射探针IBL Texture IBL Tex RGBD：烘焙的纹理格式（颜色通道+深度通道） 图2-6 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:44 "},"IDE/Component/VolumetricGI/readme.html":{"url":"IDE/Component/VolumetricGI/readme.html","title":"体积全局照明","keywords":"","body":"Volumetric GI1.Volumetric GI概述2.Volumetric GI组件2.1 创建一个Volumetric GI组件2.2 Volume Bound2.3 Volumetric GI 具体参数Volumetric GI 1.Volumetric GI概述 体积全局照明（Volumetric GI）是指计算机图形学中使用的一种技术，用于模拟光与参与介质（如雾、烟或体积云）的相互作用。它旨在以逼真的方式捕捉媒体造成的散射和间接照明效果。 体积GI可以通过考虑光在参与媒体中的传播来增强场景的视觉质量和真实感。它考虑了介质的散射特性，并计算光如何反弹以及与周围对象和曲面的相互作用。此技术对于创建大气效果、动态照明场景以及半透明或体积材质的逼真渲染特别有用。 有各种算法和方法用于实现体积GI，包括： 基于体素的方法：这些技术将三维空间离散为体素网格，并模拟光在体素内的传播。基于体素的表示可以捕捉介质的密度和散射特性，从而实现逼真的效果。 光线行进：这项技术包括通过参与的媒介投射光线，并沿着光线的路径积累光线贡献。通过对介质重复采样并评估其散射特性，可以计算间接照明。 屏幕空间方法：这些方法利用屏幕空间信息，如深度和法线缓冲区，来近似体积GI效果。他们经常采用各种过滤和混合技术来模拟参与介质内的散射和间接照明。 预计算体积技术：在某些情况下，预计算的光传输数据可用于加速体积GI的渲染。这包括预计算参与介质中的光相互作用，并将其存储在数据结构中，以便在渲染期间进行高效查找。 体积GI是一个计算密集型过程，可能需要大量资源，尤其是对于实时应用。因此，它经常被选择性地使用或与其他照明技术相结合，以实现所需的视觉效果。 总的来说，体积GI通过准确模拟光与参与介质的相互作用，在创造逼真和身临其境的环境中发挥着至关重要的作用。它为虚拟场景添加了深度、氛围和自然的照明效果，增强了整体视觉质量和真实感。 2.Volumetric GI组件 2.1 创建一个Volumetric GI组件 可以向场景中的Sprite3D对象添加Volumetric GI组件，引擎的Volumetric GI组件可以在Volume的范围内提供实时的GI效果。 在属性设置面板中，创建Volumetric GI组件的方式如图2-1所示：增加组件 -> 渲染 -> Volumetric GI。 （图2-1） （图2-2） 2.2 Volume Bound 只有在Volume Bound范围中的物体才会收到Volumetric GI的影响，Volume Bound中均匀分布了一定数量的probe用于采集周围的球谐信息。 （图2-3） 2.3 Volumetric GI 具体参数 Bound Min：控制Bound在X、Y、Z轴负方向上的面。 Bound Max：控制Bound在X、Y、Z轴正方向上的面。 Importance 权重：控制不同的Volumetric之间的权重比例。 Probe Counts：在Bound中Porbe的排布数量。 图2-4展示了不同数量级的Probe排布： （图2-4） Normal Bias：表面沿着法线向内偏移量，减少遇到同像素采样引发的误差。 View Bias：表面沿着视野方向内偏移量，减少遇到同像素采样引发的误差。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-07-03 19:26:02 "},"IDE/Component/StaticBatchVolume/readme.html":{"url":"IDE/Component/StaticBatchVolume/readme.html","title":"静态合批","keywords":"","body":"Static Batch Volume组件Static Batch Volume组件 在Object的inspect面板，增加组件，选择Rendering选项，找到Static Batch Volume组件 图1 在Scene视窗中拖动小白点选择合适的Volume大小 图2 Static Batch Volume组件的使用: 在Scene中上面的Volume框选到合适的大小后，在组件的详情面板中，勾选Static Instance Batch，再点击reBatch，Volume中所框选的物件就会执行Batch操作，优化Draw Call，提升运行效率，勾选CheckLOD选项，启用LOD Cull Rate Array接管Volume中的物体LOD组，此时Volume中的所有物体的LOD判断不再是基于单个渲染对象的，而是基于Volume的LOD判断，系统会计算Volume与视野中计算出的Rate来选择不同的LOD层级。 在Game中Rebatch会自动调用, 位于Volume中的所有物体会自动判断并实行Static Batch Instance操作。 图3 图4 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:44 "},"IDE/Component/LOD/readme.html":{"url":"IDE/Component/LOD/readme.html","title":"LOD组","keywords":"","body":"LOD1. LOD概述2.LOD组件2.1 创建LOD组件2.2 LOD 等级滑块2.3 Renders3.导入LOD网格（实验性）4.LOD Cull Rate ArrayLOD 1. LOD概述 细节级别 (LOD) 是一种减少 LayaAir引擎渲染远距离网格所需的 GPU 操作数量的技术。 当场景中的某个游戏对象距离摄像机很远时，与距离摄像机很近的游戏对象相比，可以看到的细节将会减少。但默认情况下，引擎会使用相同数量的三角形来渲染两个远近不同距离的游戏对象。这可能会浪费 GPU 运算资源，从而影响场景中的性能。 LOD 技术允许引擎根据与摄像机的距离来相应减少为游戏对象渲染的三角形数量。要使用此技术，游戏对象必须具有大量网格，这些网格的几何体的细节级别逐渐降低。这些网格称为 LOD 级别。游戏对象离摄像机越远，引擎渲染的 LOD 细节级别越低。此技术减轻了这些远处游戏对象给硬件带来的负担，因此可以提高渲染性能。 2.LOD组件 2.1 创建LOD组件 可以通过创建一个LOD组件向场景中物件添加LOD组，引擎的LOD可以添加多个LOD组来实现不同距离实现不同的渲染结果 创建LODGroup组件的步骤：添加组件 -> 选择Rendering组件类型 -> 选择LOD Group组件 图2-1 图2-2 2.2 LOD 等级滑块 通过调整不同LOD等级在LOD等级滑块上的占比来调整不同LOD的切换范围 图2-3 LOD等级滑块被划分为一个从左到右范围为[100%, 0%]的区间, 每一级的区间显示百分比为当前区块的左区间值 黑线指示了当前相机所处的LOD等级, 黑色指示线是实时刷新的,会随着相机的移动而变换到不同的LOD区间内。 拓展 Mincull Rate 图2-4 每个 LOD 级别层级的Mincull Rate表示激活该级别的阈值。该阈值基于游戏对象的屏幕空间高度与屏幕总高度之比。例如，如果 LOD0的阈值设置为0.4，则当摄像机回拉得足够远，使得游戏对象的高度占视图的40%时，LOD0就会激活。 在上图中Mincull Rate的比值在图像中表现为绿色线的长度与黄色线长度的比值，通常情况为一个0.0到1.0的浮点小数 2.3 Renders 图2-5 Renders渲染器实际上是该LOD层级保存网格的Sprite3D对象。通常情况下这是具有LOD 组件的Sprite3D对象的子对象 Renders渲染器可以添加多个渲染对象在同一个LOD层级可以渲染多个对象 3.导入LOD网格（实验性） 在美术软件创建好一个带有LOD层级网格资源，当导入引擎IDE之后，选择网格模型文件，勾选中导入设置中的Add Lod Group功能 图3-1 4.LOD Cull Rate Array 实际上LOD Cull Rate Array是Static Batch Volume的其中一个功能。 LOD Cull Rate Array实际上是对这个Volume中的物体计算的Rate的N种等级的渲染。 例如当前视野与Volume的实际Rate为0.2， LOD Cull Rate Array中LOD2的等级为0.1， 所以当前视角的物体为渲染的LOD2的物体。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-08 20:46:05 "},"IDE/prefab/readme.html":{"url":"IDE/prefab/readme.html","title":"预制体模块","keywords":"","body":"预制体模块一、概述二、IDE中创建2.1 创建预制体(2D)2.2 创建预制体(3D)2.3 修改预制体编辑场景三、使用预制体3.1 2D预制体3.2 3D预制体四、预加载预制体预制体模块 一、概述 在项目开发中，经常会出现这样的情况： （1）立项的时候，美术定义一系列标准的字体颜色、字号，在各个UI中应用，有一天美术突然说要更改默认的字体颜色、字号，UI制作者就需要把所有界面都修改一次，这样会非常麻烦。针对这种情况，使用预制体就能轻松应付，只修改一个地方，就能影响全局。 （2）不同的2D界面，局部有相同的布局，希望修改一次，多个界面相同布局跟着一起变化。针对这种情况，使用预制体就能轻松应对。 （3）3D项目开发中，重复使用在同一场景中或者不同场景中的某种对象，例如模型、贴图、动画等设置都制作好了，就可以在场景中直接创建英雄、怪物、特效等。我们希望在使用的时候只需用代码加载即可。针对这种情况，使用预制体才能实现。 针对类似上面需求，LayaAirIDE提供了2D预制体和3D预制体，接下来本文将介绍这两种预设如何使用。 二、IDE中创建 创建预制体的过程只能在IDE中完成，通常预制体创建后都是以“.lh”为后缀的文件。本节介绍在IDE中如何创建预制体(2D)和预制体(3D) 2.1 创建预制体(2D) 预制体(2D)是针对2D界面开发过程中所使用的预制体，通常对于重复会用到的2D组件、局部界面等。 如动图2-1所示，在IDE中项目资源的assets下，开发者可以选择希望预制体存放的目录，在此目录下，鼠标右键的菜单中创建预制体(2D) （动图2-1） 创建好的预制体，通常开发者是需要重新命名的，这样才能通过名字来识别预制体的功能，如动图2-2所示 （动图2-2） 点击Title预制体，可以看到有一个根节点“Box”，如图2-3所示 （图2-3） 开发者可以在Box下创建2D组件，或者把Box节点转换成其它2D组件来使用，后面我们将详细介绍 2.2 创建预制体(3D) 创建预制体3D的过程同预制体2D一样，如动图2-4所示 （动图2-4） 不同的是，双击打开预制体3D，根节点是“Sprite3D”，也就是我们需要创建的3D精灵对象。同时图2-5右面是默认的IDE场景，用了IDE自带的天空盒 （图2-5） 2.3 修改预制体编辑场景 开发者可以通过如下的方式来更换3D预制体的编辑场景，如动图2-6所示 （动图2-6） 例如我们有一个3D的城市场景，在IDE的项目设置中 ，点击编辑选项，在预制体编辑场景中，拖入3D的城市场景文件，此时再次查看预制体的场景窗口，可以看到场景更换到3D城市了，这种情况下，可以更方便开发者更加灵活的在场景中制作3D预制体 三、使用预制体 3.1 2D预制体 第一小节中提到，由于开发过程中，会有很多界面使用类似于标题这样的字体，开发者最好通过预制体的方式来实现，当有需求改变所有界面标题的字体时，只需要修改一次预制体即可。 3.1.1 转换节点类型 由于创建的预制体默认是Box根节点，如果在Box下面创建标题的话，那么这个Box节点是多余的，如果界面中创建大量的标题，那么会创建很多的Box，对于性能的考虑来说是强烈不推荐的，因此我们希望使用转换节点来把Box改为Label组件。如动图3-1所示 （动图3-1） 3.1.2 设置字体 接下来，这里就不多介绍标题的制作过程了，如图3-2所示，我们暂时制作一个黄色的30号黑体的字体，作为标题，并改名为Title （图3-2） 3.1.3 IDE中使用预制体 当预制体制作好之后，可以在IDE中拖入到我们希望使用到的界面中，如动图3-3所示 （动图3-3） 场景中有一个List，我们希望item里会有一个标题，我们把Title预制体拖入到List的Box下，作为List的item项的Label标题。可以看到节点中，Label名字颜色是绿色的，代表这个节点是预制体节点，当然这个节点下所有的节点都会是绿色的。 3.1.4 修改预制体属性 当需求说想把所有的标题都改为红色时，也就是修改一次，多个界面跟着一起变化。那么只需要在Title预制体中修改文字的颜色即可，如动图3-4所示 （动图3-4） 修改预制体后，就能在使用预制体的场景界面中看到修改的效果。当然，在预制体的界面也可以直接运行看效果，开发者在编辑完成后，关闭预制体界面时，需要记得保存预制体文件，否则下次打开此预制体，会丢失之前的更改。 预制体中也可以继续添加新的UI组件，同理在场景中新加的UI组件同步过来了。这里就不展示了，开发者可以自己尝试。 注意：任何UI组件上添加的脚本，也可以同步到场景中，但是预制体下的runtime类不能同步 3.1.5 覆盖预制体属性 如果我们在场景中操作了预制体节点，比如新增加了UI组件，修改了UI组件的属性，UI组件上挂了脚本，如图3-3所示 （图3-3） 例如场景中List下的有个item节点为预制体，我们在List下做了几个改动，在图3-3中都会有标识 对Label组件增加了LabelScript脚本（有“+”号标识） 对item节点修改了width属性（属性设置面板有黄色线提示） 添加了Button组件（有“+”号标识） 这些修改也可以覆盖到预制体中，我们来看看如何操作。如图3-4所示 （图3-4） 点击item节点，在右边的属性面板中，点击 覆盖属性 按钮，可以打开 覆盖属性到 item 的操作面板 由于之前有三个操作，那么我们点击 item，LabelScript，Button，可以看到，如图3-8所示 （图3-8） IDE记录了这三个修改操作，我们可以分别对每一项进行撤销或者应用，也可以直接进行撤销全部或者应用全部 当每个操作点击应用或者使用应用全部后，回到item预制体窗口后，三个修改都会更新并保存到预制体中，如图3-9所示 （图3-9） 通过上面的操作，使用覆盖预制体属性的方式，也可以达到修改预制体的效果。 注意：如果预制体里设置了相对布局，那么在场景上使用该预制体对象时，场景上的相对布局无法设置为空（IDE不勾选或强制代码设置为null都是不允许的，也无用），会以预制体内的相对布局为准。 但是，如果场景里修改了相对布局的值，会以场景上的设置为准。例如，预制体的top设置为了10，场景在使用这个预制体的时候，top改为了20，那运行的时候，场景里以20为基准。 3.1.6 代码中使用预制体 通过代码添加预制体的方式，就像使用一个组件一样简单，如图3-5所示，我们希望把Title预制体放到Box下 （动图3-5） 示例代码如下： const { regClass, property } = Laya; @regClass() export class ScriptA extends Laya.Script { //declare owner : Laya.Sprite3D; @property( { type: Laya.Box } ) private box: Laya.Box; constructor() { super(); } onStart(): void { //加载预制体文件 Laya.loader.load(\"resources/Title.lh\").then( (res)=>{ //创建预制体 let label: Laya.Label = res.create(); //添加预制体Label字体到box节点下 this.box.addChild( label ); } ); } } 运行效果如图3-6所示 （图3-6） 3.2 3D预制体 3D预制体的使用过程同2D预制体一样，在这里我们就不介绍如何制作预制体了，通过下面的示例来看看3D预制体的使用效果 3.2.1 IDE中使用 假设我们已经创建了3D预制体，并通过添加模型，材质，动画状态机等组件，制作了LayaMonkey，如图3-7所示 （图3-7） 此时，制作好的LayaMonkey可以拖入任何场景中，如动图3-8所示 （动图3-8） 3.2.2 代码中使用 通过代码使用3D预制体是最常用的方式，往往在游戏战斗中的敌人是通过代码不断创建的，像上述IDE拖入LayaMonkey的情况，我们用代码来实现如下： const { regClass, property } = Laya; @regClass() export class Main extends Laya.Script { @property( { type : Laya.Camera } ) private camera: Laya.Camera; @property( { type : Laya.Scene3D } ) private scene: Laya.Scene3D; onStart() { console.log(\"Game start\"); //加载预制体文件 Laya.loader.load(\"resources/Prefab.lh\").then( (res)=>{ //创建预制体 let monkey: Laya.Sprite3D = res.create(); //添加预制体到场景中 this.scene.addChild( monkey ); monkey.transform.position = new Laya.Vector3(-28.9354,0.3,-63.20264); } ); } } 运行效果如动图3-9 （动图3-9） 四、预加载预制体 在开发过程中，我们会通过大量创建预制体的方式来实现各种功能，因此预制体也可以理解为一组资源的集合体，通过代码加载预制体文件时，可以一同加载所关联资源。因此在项目启动加载过程中，可以直接先加载所有的预制体，就像预加载场景一样，引擎会把关联的资源一起加载。 在LayaAir的2D入门示例代码中，可以看到，通过预加载一组预制体的实现代码： import { LoadingRTBase } from \"./LoadingRT.generated\"; const { regClass, property } = Laya; @regClass() export default class LoadingRT extends LoadingRTBase { onAwake(): void { Laya.loader.load( //先加载本场景要用的 [\"resources/UI/image.png\", \"resources/UI/progress.png\", \"resources/UI/progress$bar.png\"] ).then(() => { let resArr: Array = [ { url: \"resources/prefab/uiDemo/useUI/ChangeTexture.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/useUI/MouseThrough.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/useUI/PhysicalCollision.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/useUI/Progress.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/useUI/TextShow.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/page/IframeElement.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/page/UsePanel.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/list/BagList.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/list/ComboBox.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/list/LoopList.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/list/MailList.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/list/Refresh.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/list/TreeBox.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/list/TreeList.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/animation/AtlasAni.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/animation/FrameAni.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/animation/SkeletonAni.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/animation/TimelineAni.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/animation/TweenAni.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/interactive/Astar.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/interactive/Joystick.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/interactive/ShapeDetection.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/uiDemo/interactive/tiledMap.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/Bullet.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/closeBtn.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/ComboList.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/defaultButton.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/defaultLabel.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/DropBox.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/LoopImg.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/role.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/ani/cd.lh\", type: Laya.Loader.HIERARCHY }, { url: \"resources/prefab/ani/refresh.lh\", type: Laya.Loader.HIERARCHY }, ]; //3.0的load，同时可以加载2D,3D资源 Laya.loader.load(resArr, null, Laya.Handler.create(this, this.onLoading, null, false)).then(() => { // 加载完成后，处理逻辑 this.progress.value = 0.98; console.log(\"加载结束\", this.progress.value); //预加载的东西太少，为了本地看效果延迟一秒，真实项目不需要延迟 Laya.timer.once(1000, this, () => { //跳转到入口场景 Laya.Scene.open(\"Scenes/Index.ls\"); //不要使用Laya.Scene.open(\"./Scenes/Index.ls\"); }); }); // 侦听加载失败 Laya.loader.on(Laya.Event.ERROR, this, this.onError); }); } /** * 当报错时打印错误 * @param err 报错信息 */ onError(err: string): void { console.log(\"加载失败: \" + err); } /** * 加载时侦听 */ onLoading(progress: number): void { //接近完成加载时，让显示进度比实际进度慢一点，这是为打开场景时的自动加载预留，尤其是要打开的场景资源多，并没有完全放到预加载中，还需要再自动加载一部分时。 if (progress > 0.92) this.progress.value = 0.95; else this.progress.value = progress; console.log(\"加载进度: \" + progress, this.progress.value); } } 通过上述代码，可以在浏览器中的调试工具中看到引擎会加载全部预制体的资源。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2024-01-06 16:55:47 "},"IDE/layapackage/readme.html":{"url":"IDE/layapackage/readme.html","title":"IDE插件系统","keywords":"","body":"IDE插件系统插件开发说明插件导入使用说明官方插件IDE插件系统 从LayaAir3.1.x开始，开发者可以自定义插件，并且上传到资源商店。 插件开发说明 插件导入使用说明 官方插件 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2024-02-21 17:22:29 "},"IDE/layapackage/plug-in/readme.html":{"url":"IDE/layapackage/plug-in/readme.html","title":"插件开发说明","keywords":"","body":"插件开发说明一、插件能力二、插件运行环境2.1 在Laya.Script中使用本地能力2.2 UI进程脚本和Scene进程脚本通讯的方式2.3 脚本隔离机制三、制作编辑器UI四、程序化生成界面4.1 常用方法4.2 示例五、自定义Inspector字段编辑界面六、自定义面板七、使用对话框八、扩展内置菜单九、创建菜单十、在场景视图中绘制形状以及交互式手柄十一、自定义配置十二、扩展编辑器配置界面十三、扩展构建流程十四、自定义发布目标平台十五、资源导入预处理和后处理十六、国际化支持十七、命令行支持插件开发说明 一、插件能力 编辑器使用Electron框架开发，本质是对Chrome浏览器的封装。编辑器实际是一个HTML+JS+CSS制作的单页应用。但我们封装了大部分功能，所以游戏开发者和插件开发者都不需要学习HTML/CSS或者相关的前端框架。我们在开发插件时，需要使用编辑器提供的UI框架，一般不允许直接去修改编辑器的DOM结构。考虑到用户体验和兼容性，资源商店也一般不允许这类插件上架。 在项目的engine/types目录，有三个与编辑器插件开发相关的声明文件，editor.d.ts, editor-ui.d.ts, editor-env.d.ts，他们包含了大量编辑器的扩展API。 editor.d.ts 是编辑器UI进程的API。常用的是全局对象Editor和IEditor命名空间下的类和接口。 editor-env.d.ts 是场景场景进程的API。常用的是全局对象EditorEnv和IEditorEnv命名空间下的类和接口。 editor-ui.d.ts 编辑器UI库。使用IEditorUI命名空间下的类和接口。 其中IEditor.utils/IEditorEnv.utils暴露了大量实用的工具函数，包括UUID生成，加密解密，ZIP压缩/解压，文件/目录拷贝/移动，HTTP请求，上传/下载等等。 开发者可以直接使用node模块，另外，IDE也内置了一些常用的npm库，例如sharp，glob，pinyin, @svgdotjs/svg.js等。 //使用nodejs模块的方式 import fs from \"fs\"; import path from \"path\"; const sharp = window.require(\"sharp\"); const glob = window.require(\"glob\"); 二、插件运行环境 编辑器是多进程体系，主要有三个进程：Main进程/UI进程/Scene进程。插件只能运行在UI进程和Scene进程。UI进程没有载入引擎库，也就是没有LayaAir引擎环境；Scene进程有LayaAir引擎环境，与UI通讯只能通过编辑器提供的异步通讯API。此外，插件脚本也可能在预览（含编辑器内预览和外部浏览器预览）中运行，它与Scene进程的区别是，预览进程中没有node环境。总结一下，插件脚本可能运行的环境有3种： (1) UI进程：可直接使用node等本地模块，不可使用Laya引擎； (2) Scene进程：可直接使用node等本地模块，可使用Laya引擎； (3) 预览进程：不可使用node等本地模块，可使用Laya引擎； 如果插件脚本错误使用了当前环境中不存在的特性，脚本可能无法运行。例如，在一个Laya自定义组件脚本里使用node的fs模块去访问文件系统，会导致脚本在预览或者最终发布时运行报错。 为了脚本能在各种环境正确运行，开发者编写脚本时，需要自行在文件级别隔离这三种代码。比如，一个自定义面板的TS文件，不能引用Laya引擎，因为它是运行在UI进程里的。又比如，一个Laya.Script，不能使用fs，path等模块，因为它可能会运行在预览进程。但这两种需求也是常见的，应该怎么办？ 2.1 在Laya.Script中使用本地能力 下面是一个推荐做法： //Script.ts @Laya.regClass() class Script extends Laya.Script { wantToUseNode() { EditorEnv.scene.runScript(\"TestSceneScript.visitNode\"); } } //TestSceneScript.ts import fs from \"fs\"; //注意是IEditorEnv.regClass，不是Laya.regClass!! @IEditorEnv.regClass() class TestSceneScript { static visitNode() { fs.readFileSync(....) } } TestSceneScript.ts这个文件会在发布中被裁剪，因为它没有被Laya.Script直接引用。 2.2 UI进程脚本和Scene进程脚本通讯的方式 1、设置节点/组件属性后，场景里的节点/组件会自动刷新，无需代码。例如： //下面是UI进程代码 //获取选中的节点 let node = Editor.scene.getSelection()[0]; //修改节点属性，场景里的对象会自动同步，无需手动 node.props.x = 100; //修改组件属性，场景里的对象会自动同步，无需手动 node.getComponent(\"MeshRenderer\").props.enabled = false; 2、调用节点/组件的一个方法，并返回值。例如： //下面是UI进程代码 //获取选中的节点 let node = Editor.scene.getSelection()[0]; //调用MyScript组件里的test方法，传入参数abc let ret = await Editor.scene.runNodeScript(node.id, node.getComponent(\"MyScript\").id, \"test\", \"abc\"); console.log(ret); 3、自定义一个函数，并执行。例如： //下面是场景进程的代码 //注意：IEditorEnv.regClass是必须的 @IEditorEnv.regClass() export class TestSceneScript { //注意：this是当前的IEditorEnv.IGameScene对象，如果不需要，也可以省略这个声明 static test(this: IEditorEnv.IGameScene, msg: string) { console.log(msg); //hello return \"ok\"; } } //下面是UI进程的代码 let ret = await Editor.scene.runScript(\"TestSceneScript.test\", \"hello\"); console.log(ret); //ok 4、场景进程如果需要向UI进程发送消息，通过以下方法： //选中项目资源面板一个资源 EditorEnv.postMessageToPanel(\"ProjectPanel\", \"select\", assetId); //调用自定义的Panel的一个方法，并返回结果 let ret = await EditorEnv.sendMessageToPanel(\"MyPanel\", \"getResult\"); 2.3 脚本隔离机制 编辑器实现脚本隔离的机制是将脚本编译成三个js，bundle.js包含可以在预览环境，也就是在浏览器可以运行的版本；bundle.editor.js是在UI进程运行的脚本；bundle.scene.js是在Scene进程的脚本。这个机制是自动的，但开发者需了解这个机制的运作方式： 1、所有含有@Laya.regClass装饰器的脚本会编译进bundle.js和bundle.scene.js。注意，这里指的“所有”，仅限于Debug版本。在release版本的bundle.js里，只会包含有被场景引用的脚本。bundle.scene.js不会出现在发布版本中。 2、所有含有@IEditorEnv.regClass装饰器的脚本会编译进bundle.scene.js。这个js只在编辑器内部运行，可以放心使用node能力。 3、所有含有@IEditor.xxx装饰器的脚本会编译进bundle.editor.js。这个js只运行在UI进程，可以放心使用node能力，但如果引用Laya的类会报错。 虽然这种识别机制能够解决标记不同脚本使用用途的问题，但还是建议开发者自行用目录方式进行隔离。例如将UI进程运行的脚本放入到editor名称的目录，将只在编辑器内运行的脚本放入到scene名称的目录，这样维护起来会更清晰。 三、制作编辑器UI LayaAirIDE提供了开发编辑器UI的可视化编辑器。在项目资源面板的菜单里，新建一个编辑器界面预制体，例如MyWidget.widget。建议将此类预制体放置到editorResources目录或其子目录。 editorResources目录是一个LayaAirIDE里约定名称的特殊目录，它和resources的特性类似，也就是无论它放在多深的子目录下，资源的路径都可以从editorResources开始。例如一个资源位于”/MaDaHa/v1/editoResources/a/b.png“，在引用资源时可以直接填写”editorResources/a/b.png“，而不用理会前面的”MaDaHa/v1/“。 这在插件体系中是很重要的，因为在开发插件时，插件开发者无法确定用户使用时会将插件资源放置在什么目录下，只能确定用户不会破坏插件内部的目录结构。 resources目录里具有相同的特性，差别在于，resources目录在发布时会拷贝到发布目录里，但editorResources则永远不会。 双击打开MyWidget.widget，使用内置UI编辑器制作好插件需要的UI界面。 以面板为例，代码里载入该预制体的方法为： @IEditor.panel(\"Test\") export class MyPanel extends IEditor.EditorPanel { async create() { this._panel = await gui.UIPackage.createWidget(\"editorResources/UI/MyWidget.widget\"); let input: gui.TextInput = this._panel.getChild(\"TextInput\").getChild(\"title\"); input.on(\"changed\", () => { console.log(\"改变了！\"); }) } } 四、程序化生成界面 4.1 常用方法 除了使用UI编辑器制作界面，也可以使用代码的方式去创建一些常用的UI组件，它们在IEditor.GUIUtils。 export interface IGUIUtils { /** * 编辑器默认的背景颜色 */ bgColor: gui.Color; /** * 编辑器默认的分割线颜色 */ lineColor: gui.Color; /** * 编辑器默认的文字颜色 */ textColor: gui.Color; createButton(autoSize?: boolean): gui.Button; createIconButton(flat?: boolean): gui.Button; createCheckbox(autoSize?: boolean): gui.Button; createIconCheckbox(flat?: boolean): gui.Button; createRadio(): gui.Button; createComboBox(): gui.ComboBox; createTextInput(): TextInput; createTextArea(): TextArea; createSearchInput(): SearchInput; createNumericInput(): NumericInput; createColorInput(): ColorInput; createGradientInput(): GradientInput; createCurveInput(): CurveInput; createResourceInput(): ResourceInput; createNodeRefInput(): NodeRefInput; createProgressBar(): gui.ProgressBar; createSlider(): gui.Slider; createListItem(): ListItem; createIconListItem(): ListItem; createCheckboxListItem(): ListItem; createCheckboxIconListItem(): ListItem; createInspectorPanel(): InspectorPanel; } 4.2 示例 例如要动态创建一个按钮，可以用以下代码。 let button = IEditor.GUIUtils.createButton(); //它实现的功能其实和以下代码是相同的，只是更加简洁 //let button = gui.UIPackage.createWidgetSync(\"~/ui/basics/Button/Button.widget\"); IEditor.InspectorPanel是一个通过配置生成界面的通用界面类，下面举一个例子，完全通过配置方式生成一个面板 @IEditor.panel(\"Test\") export class MyPanel extends IEditor.EditorPanel { private _data : any; declare _panel : IEditor.InspectorPanel; async create() { this._panel = IEditor.GUIUtils.createInspectorPanel(); Editor.typeRegistry.addTypes([ { name : \"MyPanelType\", //请注意，名字是全局唯一的，一定要长 properties : [ { name : \"text\", type : \"string\" }, { name : \"count\" , type: \"number\" }, { name : \"actions\", inspector: \"Buttons\", options : { buttons : [ { caption : \"点我\", event: \"my_click\" } ] } } ] } ]); this._panel.allowUndo = true; //根据需要设置 //如果不需要undo功能，也可以直接this._data = {}; this._data = IEditor.DataWatcher.watch({}); //inspect可以多次调用，将多个数据组合在一个面板编辑 this._panel.inspect(this._data, \"MyPanelType\"); this._panel.on(\"my_click\", ()=> { alert(\"hello\"); }); } } 执行效果如下： 如果不需要顶部的'My Panel Type'栏目显示，可以稍微修改代码，加入以下红字： { name : \"MyPanelType\", catalogBarStyle: \"hidden\", properties : [ .... ] } 效果如下： 配置方式可以生成非常复杂的界面，它不但可以用于制作单一的面板，也可以嵌入到其他UI中。例如，在UI编辑器制作界面时中拖入InspectorPanel预制体（它放在\"editor-widgets/baisc/Inspector/InspectorPanel.widget），然后在代码里通过getChild获得的Widget对象类型则自动为IEditor.InspectorPanel，然后可以通过上述的API（inspect等）进行填充。 类型和属性定义语法请参考文档。 五、自定义Inspector字段编辑界面 当我们编写一个组件，并暴露某些字段到IDE编辑后，有时希望能够自定义某个字段的编辑界面，可以通过以下步骤： 1、编写一个InspectorField @IEditor.inspectorField(\"MyTestField\") export class TestField extends IEditor.PropertyField { @IEditor.onLoad static async onLoad() { await gui.UIPackage.resourceMgr.load(\"MyField.widget\"); } create() { let input = gui.UIPackage.createWidgetSync(\"MyField.widget\"); return { ui: input }; } refresh() { //这里负责将数据设置到界面上 } } MyTestField是注册的名字，实际应用需要保证不要和其他人取的名字冲突，所以建议取\"com.layabox.test\"这样的名字。 InspectorField的create方法是同步的，所以这里不能用createWidget，而需要用createWidgetSync。这需要确保预制体在创建之前已经载入。所以这里使用了一个IEditor.onLoad的回调用于提前载入资源。 2、设置字段的inspector属性为刚才取的名字，这里为MyTestField @Laya.regClass() export class Script extends Laya.Script { @property({ type : Laya.Node, inspector: \"MyTestField\" }) public node: Laya.Node; } 3、实际效果： 六、自定义面板 可以通过以下方式给编辑器增加一个面板 @IEditor.panel(\"test\", { title: \"Test\", icon : \"editorResources/20230710-161955.png\" }) export class TestPanel extends IEditor.EditorPanel { async create() { this._panel = await gui.UIPackage.createWidget(\"MyPanel.widget\"); } } 效果如下图： 七、使用对话框 可以通过以下方式创建一个弹出的对话框： //MyDialog.ts export class MyDialog extends IEditor.Dialog { async create() { this.contentPane = await gui.UIPackage.createWidget(\"MyDialog.widget\"); } onShown() { } onHide() { } } 在编辑器内，所有对话框都是单例。显示这个对话框的方式为： import { MyDialog } from \"./MyDialog\"; Editor.showDialog(MyDialog, null); 八、扩展内置菜单 支持对编辑器现有菜单的扩展。如以下代码，在应用程序菜单栏的工具菜单下，新增了一个test的菜单，并且点击菜单会调用test函数。 class AnyName { @IEditor.menu(\"App/tool/test\") static test() { console.log(\"click menu\"); } } menu的第一个参数表示菜单的路径，路径用\"/\"分隔，\"App/tool/test\"表示App菜单下的tool子菜单的test子项。注意这里的路径使用的是ID，不是菜单显示的文字。编辑器内部支持扩展的所有菜单名称和它的子菜单可以通过下面的方法打印出来参考： menu方法的第二个参数是可选参数，通过它可以进行一些额外的配置。例如： class AnyName { @IEditor.menu(\"App/tool/test\", { position: \"before openDevTools\" } ) static test() { console.log(\"click menu\"); } } 通过position选项可以设置这个新加的test菜单显示在原有菜单“打开开发者工具 - 编辑器\"的前面，而不是默认加到最后。 常用的选项有： position : 设置菜单的位置，支持的语法: \"first\" / \"last\" / \"before ids\" / \"after ids\" / \"beforeGroup ids\" / \"afterGroup ids\"。 \"before\"和\"beforeGroup\"的区别是，\"before\"是插入到参考菜单的前面，而\"beforeGroup\"是插入到参考菜单前面最近的一个分割线之前。 \"after\"和\"afterGroup\"的区别是，\"after\"是插入到参考菜单的后面，而\"afterGroup\"是插入到参考菜单后面最近的一个分割线之后。 在同一个类的扩展定义里，默认是添加到上一个扩展的菜单的后面。如果不在同一个类里，不指定position则默认添加到菜单的最后面。 多个参考菜单的id值用逗号分隔。 checkbox : 设置菜单为一个可以打勾的效果。 sepBefore : 在此菜单之前显示一条分割线。 sepAfter: 在此菜单之后显示一条分割线。 enableTest : 给定返回布尔值的一个函数，在菜单显示之前会执行此函数，用于决定菜单的激活（变灰）状态。App菜单不支持。 visibleTest: 给定返回布尔值的一个函数，在菜单显示之前会执行此函数，用于决定菜单的显隐状态。仅调用show方法弹出的菜单有效。App菜单不支持。 checkedTest：给定返回布尔值的一个函数，在菜单显示之前会执行此函数，用于决定菜单的显隐状态。App菜单不支持。 下面的例子演示了enableTest的用法。这个新加的菜单， 如果场景中没有选中的物体，则会显示变灰并且无法触发点击回调。 class AnyName { static testEnable() { return Editor.secene.getSelection().length > 0; } @IEditor.menu(\"Hierarchy/test\", { enableTest: ()=> AnyName.testEnable() } ) static test() { console.log(\"click menu\"); } } 九、创建菜单 可以创建新菜单，并用代码控制弹出。方法为： let menu = IEditor.Menu.create([ { label: \"test\" , click : function() { console.log(\"clicked\"); } } ]); //当需要弹出时 menu.show(); 菜单也支持级联，并且不限层数。例如： IEditor.Menu.create([ { label: \"test\" , submenu: [ { label : \"a\" }, { label : \"b\", submenu : [ { label : \"c\" } ] } ] } ]); 可以给菜单指定一个ID，通过ID引用菜单。但要注意ID值不要和编辑器内置的菜单或者其他人的菜单的ID冲突。 IEditor.Menu.create(\"MyTestMenu\", [ { label: \"test\" , click : function() { console.log(\"clicked\"); } } ]); //当需要弹出时 IEditor.Menu.getById(\"MyTestMenu\").show(); 十、在场景视图中绘制形状以及交互式手柄 使用IEditorEnv.Gizmos/IEditorEnv.Handles/IEditorEnv.Gizmos2D提供的接口，在场景视图中绘制形状和交互式手柄。假设我们已经有一个自定义的组件Script1，通过IEditorEnv.customEditor这个装饰器，给Script1绑定一个CustomEditor脚本，以实现在编辑器内的自定义编辑。 //Script1.ts @regClass() export class Script1 extends Laya.Script { declare owner : Laya.Sprite3D; } //TestCustomEditor.ts @IEditorEnv.customEditor(Script1) export class TestCustomEditor extends IEditorEnv.CustomEditor { declare owner: Laya.Sprite3D; onSceneGUI(): void { IEditorEnv.Handles.drawHemiSphere(this.owner.transform.position, 2); } onDrawGizmos(): void { IEditorEnv.Gizmos.drawIcon(this.owner.transform.position, \"editorResources/UI/ready1.png\"); } } 实现效果如下： 2D的实现方式有所不同，它必须通过IEditorEnv.Gizmos2D接口，并且目前只支持onDrawGizmosSelected事件，不支持onDrawGizmos和onSceneGUI事件。 以下是2D的一个例子： @IEditorEnv.customEditor(Script2) export class TestCustomEditor extends IEditorEnv.CustomEditor { private _c: IEditorEnv.IGizmoCircle; onDrawGizmosSelected(): void { if (!this._c) { let manager = IEditorEnv.Gizmos2D.getManager(this.owner); this._c = manager.createCircle(10); this._c.fill(\"#ff0\"); } this._c.setLocalPos(10, 10); } } 实现效果如下： 十一、自定义配置 插件开发者可以自定义一些配置数据，这些数据可以保存到文件，也可以只保存在内存中。例如： @IEditor.onLoad static onLoad() { //注意这里面的属性不要使用到Laya引擎里的类型，比如Vector3这些，是不可以的 Editor.typeRegistry.addTypes([ { name: \"MyTestSettingsType\", properties: [ { name: \"option1\", type: \"boolean\", default: true }, { name: \"option2\", type: \"string\", default: \"\", } ] } ]); Editor.extensionManager.createSettings(\"MyTestSettings\", \"project\", \"MyTestSettingsType\"); } createSettings的第一个参数是这个配置的名称，它是全局的，请取一个不会和其他人冲突的名字。第二个参数是配置数据放置的地方，可选的值为： project : 保存到路径“项目/settings”。这是一个项目所有成员共享的配置文件放置位置。保存的文件名是\"plugin-配置名称.json”，plugin前缀使用户能够清晰地分辨出这是第三方插件创建的配置文件。 local: 保存到路径“项目/local\"。这是IDE使用者对项目的个性设置。这里的文件通常不建议项目成员间共享。 application: 保存到系统的用户数据目录。这是IDE使用者对IDE的个性设置，它应该是和具体项目不相关的。 memory：仅存在于内存中，不会保存到文件。 第三个参数是类型名称，对应上面addTypes的操作。如果类型名称和配置名称一致，第三个参数也可以省略。 配置创建后，UI进程可以通过Editor.getSettings访问配置数据，然后进行读写，例如： let data = Editor.getSettings(\"MyTestSettings\").data; data.option2 = \"hello\"; 配置是自动载入和保存的，无需手动操作。 场景进程可以通过EditorEnv.getSettings访问配置数据，但是是只读的，无法修改。而且因为是跨进程，所以要获得最新的数据，要先调用sync，例如： let settings = EditorEnv.getSettings(\"MyTestSettings\"); await settings.sync(); console.log(settings.data.option2); //hello 十二、扩展编辑器配置界面 如果我们通过上一节创建了一些自定义的配置数据，可以将它展现在项目配置界面，或者首选项界面让用户修改。例如： @IEditor.panel(\"TestSettings\", { usage: \"project-settings\", title: \"测试\" }) export class TestSettings extends IEditor.EditorPanel { async create() { let panel = IEditor.GUIUtils.createInspectorPanel(); panel.inspect(Editor.getSettings(\"MyTestSettings\").data, \"MyTestSettings\"); this._panel = panel; } } @IEditor.panel这个装饰器在“六、使用面板”中已经介绍过，这里不再赘述，唯一不同的是usage这个选项的设置。usage可以取的值有： project-settings: 显示在项目配置界面 build-settings：显示在构建发布界面 preference: 显示在首选项界面 上述代码的显示效果为： 十三、扩展构建流程 构建流程除了在界面中启动外，也可以通过API调用，下面的例子演示了通过一个自定义菜单启动构建任务: class Abc { IEditor.menu(\"App/my/build\") static build() { IEditor.BuildTask.start(\"web\"); } } 在场景进程也可以手动启动构建任务： IEditorEnv.BuildTask.start(\"web\"); 通过构建插件定制插件流程，构建插件的接口是IBuildTask。IBuildTask的定义为： export interface IBuildPlugin { /** * 构建任务初始化时。可以在这个事件里修改config和platformConfig等配置。 * @param task */ onSetup?(task: IBuildTask): Promise; /** * 构建任务开始。可以在这个事件里在初始化目标目录的结构，或者进行必要的检查和安装等。 * @param task */ onStart?(task: IBuildTask): Promise; /** * 正在收集需要发布的资源。assets集合是系统根据依赖、resources目录规则等所有有效的规则收集的所有需要发布的资源对象，你可以额外向集合添加资源对象。 * @param task * @param assets */ onCollectAssets?(task: IBuildTask, assets: Set): Promise; /** * 正在导出资源。exportInfoMap包含了导出资源的信息，包括保存的位置等信息。可以修改outPath自定义资源的输出位置。 * @param task * @param exportInfoMap */ onBeforeExportAssets?(task: IBuildTask, exportInfoMap: Map): Promise; /** * 导出资源完成。如果开发者需要添加自己的文件，或者及进行压缩等操作，可以在这个事件里处理。 * @param task * @param exportInfoMap */ onAfterExportAssets?(task: IBuildTask): Promise; /** * 构建已经完成，可以在这个事件生成一些清单文件，配置文件等。 */ onCreateManifest?(task: IBuildTask): Promise; /** * 如果有原生的构建流程，在这里处理。 * @param task */ onCreatePackage?(task: IBuildTask): Promise; /** * 构建任务完成事件。 * @param task */ onEnd?(task: IBuildTask): Promise; } 所有钩子函数都是可选的，可以根据需要实现需要的逻辑。需要通过IEditorEnv.regBuildPlugin装饰器注册插件。下面的例子演示了怎样在web这个平台构建时，手动添加一个参加构建的资源。 @IEditorEnv.regBuildPlugin(\"web\") class MyBuildPlugin implements IEditorEnv.IBuildPlugin { async onCollectAssets(task : IEditorEnv.IBuildTask, assets: Set) { let myAsset = ... assets.add(myAsset); //在发布插件里，需要使用task.logger输出日志 task.logger.debug(\"add my asset\"); } } 如果需要构建插件在所有平台都生效，那么regBuildPlugin的第一个参数可以传递\"*\"。regBuildPlugin的第二个参数可以传递一个优先级的数值，优先级越大，构建时这个插件会被更早的调用。 在插件中经常会用到的一些工具方法有： （1）使用task.logger接口记录日志； （2）使用IEditorEnv.utils.renderTemplateFile渲染模版文件，使用的是mustache库； （3）使用task.mergeConfigFile合并配置文件。即，如果在内置模版目录和项目模版目录(build-templates)有相同路径和名字的json格式的配置文件，通过此方法可以将他们合并； （4）使用IEditorEnv.utils.intallCli安装公共的一些cli包，它将安装在library/cli-package下。例如： await IEditorEnv.utils.installCli(\"@oppo-minigame/cli\", options); （6) 使用IEditorEnv.utils.exec执行任意本地命令。 （7） 使用IEditorEnv.utils.downloadFile下载文件。 （8）使用IEditorEnv.utils.ZipFileR解压文件。 可以扩展构建选项面板，添加一些自定义的参数，如“自定义面板”一节中描述那样，我们将面板的usage设置为“build-settings\"即可。 @IEditor.panel(\"TestBuildSettings\", { usage: \"build-settings\", title: \"测试\" }) export class TestBuildSettings extends IEditor.EditorPanel { @IEditor.onLoad static start() { Editor.typeRegistry.addTypes([ { name: \"MyBuildSettings\", catalogBarStyle : \"hidden\", properties: [ { name: \"option1\", type: \"boolean\", default: true }, { name: \"option2\", type: \"string\", default: \"2332\", } ] } ]); Editor.extensionManager.createSettings(\"MyBuildSettings\", \"project\"); } async create() { let panel = IEditor.GUIUtils.createInspectorPanel(); panel.allowUndo = true; panel.inspect(Editor.getSettings(\"MyBuildSettings\").data, \"MyBuildSettings\"); this._panel = panel; } } 效果如下： 在构建插件中可以通过Settings机制访问这些参数，例如： @IEditorEnv.regBuildPlugin(\"web\") class MyBuildPlugin implements IEditorEnv.IBuildPlugin { async onSetup(task : IEditorEnv.IBuildTask) { let mySettings = EditorEnv.getSettings(\"MyBuildSettings\"); await mySettings.sync(); task.logger.debug(mySettings.data.option1); } } 十四、自定义发布目标平台 可以通过插件给IDE新增一个发布目标平台。例如： Editor.extensionManager.createBuildTarget(\"test\", //平台的唯一id，不能冲突 { caption: \"自定义平台\", //目标名称 settingsName:\"MyBuildPlatformtSettings\", //需要先用Edition.extensionManager.createSettings注册 inspector: \"TestBuildSettings\" //一个usage为build-settings的面板 templatePath : \"editorResources/testTemplate\" //可选的一个参数，指定的目录内放置构建模版文件，构建时将会自动拷贝到输出目录 }); 以下是一个完整的实例： @IEditor.panel(\"TestBuildSettings\", { usage: \"build-settings\", title: \"测试\" }) export class TestBuildSettings extends IEditor.EditorPanel { @IEditor.onLoad static start() { Editor.typeRegistry.addTypes([ { name: \"MyTestSettings2\", catalogBarStyle : \"hidden\", properties: [ { name: \"option1\", type: \"boolean\", default: true }, { name: \"option2\", type: \"string\", default: \"2332\", } ] } ]); Editor.extensionManager.createSettings(\"MyBuildPlatformtSettings\", \"project\"); Editor.extensionManager.createBuildTarget(\"test\", { caption: \"自定义平台\", settingsName:\"MyTestSettings2\", inspector: \"TestBuildSettings\" }); } async create() { let panel = IEditor.GUIUtils.createInspectorPanel(); panel.allowUndo = true; panel.inspect(Editor.getSettings(\"MyBuildPlatformtSettings\").data, \"MyBuildPlatformtSettings\"); this._panel = panel; } } 效果如下： 在场景进程中，需要添加一个或者多个构建插件，用于这个新的自定义平台。 @IEditorEnv.regBuildPlugin(\"test\") export class TestBuildPlugin implements IEditorEnv.IBuildPlugin { async onCreatePackage(task: IEditorEnv.IBuildTask) { //这里platformConfig，对应的是MyBuildPlatformtSettings，不需要自行再getSettings task.logger.info(task.platformConfig.option2); } } 构建完成后，如果需要支持“运行”，构建插件需要定义runHandler。下面这个例子演示了通过Web访问构建后的内容，Web站的根目录就是构建的目标目录，所以传入了一个空串，如果是子目录，可以传入子目录的路径。 @IEditorEnv.regBuildPlugin(\"test\") export class TestBuildPlugin implements IEditorEnv.IBuildPlugin { async onCreatePackage(task: IEditorEnv.IBuildTask) { task.config.runHandler = { serveRootPath : \"\" }; } } 十五、资源导入预处理和后处理 我们有时候需要在导入资源的时候做一些自动化处理，比如导入图片时自动设置为精灵纹理，设置压缩格式等，这时可以使用IAssetProcessor接口，接口的定义如下： export interface IAssetProcessor { //在图片资源被导入前调用 onPreprocessImage?(assetImporter: IImageAssetImporter): void | Promise; //在任意类型资源被导入前调用 onPreprocessAsset?(assetImporter: IAssetImporter): void | Promise; //在图片资源被导入后调用 onPostprocessImage?(assetImporter: IImageAssetImporter): void | Promise; //在任意类型资源被导入后调用 onPostprocessAsset?(assetImporter: IAssetImporter): void | Promise; } 实现IAssetProcessor接口的类需要通过装饰器IEditorEnv.regAssetProcessor注册。以下是一个AssetProcessor的简单例子，它把类型不是精灵纹理的图片都设置为压缩格式。 @IEditorEnv.regAssetProcessor() export class TestAssetProcessor implements IEditorEnv.IAssetProcessor { onPreprocessImage(assetImporter: IEditorEnv.IImageAssetImporter): void | Promise { if (assetImporter.config.textureType != 2) { assetImporter.config.platformDefault = { format: 10 }; } } } (1)可以使用assetImporter.isNew区分是否是新增加的资源； (2)增加或者修改IAssetProcessor后，资源库没有自动为现有资源重新执行脚本的行为。需要用户自己使用资源库的右键菜单“重新导入”。当然也可以通过插件代码重新导入：EditorEnv.assetMgr.importAsset(asset). 十六、国际化支持 使用LayaAirIDE提供的接口，可以实现插件界面国际化以及插件代码里输出的信息国际化。首先我们需要一个新建一个配置文件，如果这个配置是用于界面国际化，请将它新建在你的所有界面文件所在的目录或上级目录。 标识：国际化配置文件的唯一标识，自动生成，不可修改（如果确实要修改，可以用文本方式打开配置文件直接修改，但需要自行保证唯一。但修改后已经在界面上绑定的会全部丢失）。 使用范围：运行时或编辑器扩展。运行时表示用于游戏（暂不支持）。目前我们选择编辑器扩展，即在插件界面中使用。 默认语言ID：通过可视化方式制作编辑器预制体时，在界面设计时使用的文本语言。举例，如果你用中文制作界面，那这里就是zh-CN，如果你用英文制作界面，那这里是en，等等。如果这里设定的语言与运行时的语言一致，那么将直接使用界面上的文本，不会使用翻译文件进行替换。 后备语言ID：如果找不到匹配运行时语言的翻译文件，就会使用后备语言ID继续进行匹配。例如，如果运行时语言是德语，而翻译文件里没有德语（de）的翻译文件，就会使用后备语言ID（en）的翻译文件。 翻译参考：一般用于自动收集界面上的文字，形成一个参考文件。然后用这个参考文件去翻译成各种语言，再添加到翻译文件列表中。参考文件不需要添加到翻译文件列表中，因为参考文件内的文字都是界面上现存的。 收集文本：点击后，将分析配置文件所在目录和子目录下的所有预制体文件，收集所有需要翻译的文字到参考文件中，并将这些文本转换为国际化的格式。如果参考文件未设定，则会自动生成一个。 同步：当重新收集文本后，点击同步，可以使所有翻译文件的条目与参考文件匹配。例如，如果界面上新建了一个文本“abc”，点击收集文本后，参考文件将增加一个条目“abc\"。点击同步后，所有翻译文件都会增加一个条目\"abc\"。 除了自动收集界面上的文字，我们也可以手动设定，例如一个按钮的标题： 点击右上角的按钮，将弹出界面： 在这里可以选择，或者新建语言文件中的条目。选择一项后，输入框更新显示为： 绿色的横条显示着翻译文件的键值，表示这个文本已经国际化。 界面国际化后，语言的适配是全自动的，无需代码干预。 除了界面国际化，代码输出的信息也需要国际化。通常我们建议使用另外的配置文件，不要和界面使用的配置文件混淆。我们新建一个国际化配置： 这里只要手动创建多个翻译文件，拖入到翻译文件列表中就可以了。这些文件的键值需要自行同步。 翻译参考功能可以忽略，因为无需从界面上收集。 代码里使用的方式为： myI18n: gui.Translations; @IEditor.onLoad async onLoad() { myI18n = await gui.UIPackage.resourceMgr.load(\"editorResources/i18nSettings.i18ns\"); } test() { console.log(myI18n.t(\"a\")); } 在很多情况下，如果只是代码里用到的一些小量国际化的支持，并不想创建多个json文件，那么也有全代码的方法。 //第一个参数需要全局唯一 let myI18n = gui.Translations.create(\"LodSimplify\"); myI18n.setContent(\"zh-CN\", { meshRate : \"模型压缩比例\", meshRateTips : \"根据设置的比例对模型网格进行压缩2x\" }); Editor.typeRegistry.addTypes([ { name: \"LodSimplifyData\", properties: [ { name: \"meshRate\", type : \"number\", caption: myI18n.t(\"meshRate\", \"Mesh Rate\"), tips: myI18n.t(\"meshRateTips\", \"Compress the model mesh based on the set ratio.\"), } ] } 可以多次调用setContent添加不同语言的翻译，下面的例子添加了语言en的翻译，所以在应用t函数时可以省略默认值。 //第二个参数是备用语言ID，默认是en，所以在这里是可以省略不写的 let myI18n = gui.Translations.create(\"LodSimplify\", \"en\"); myI18n.setContent(\"zh-CN\", { meshRate : \"模型压缩比例\", meshRateTips : \"根据设置的比例对模型网格进行压缩2x\" }).setContent(\"en\", { meshRate: \"Mesh Rate2\", meshRateTips: \"Compress the model mesh based on the set ratio.\" }); Editor.typeRegistry.addTypes([ { name: \"LodSimplifyData\", properties: [ { name: \"meshRate\", type : \"number\", caption: myI18n.t(\"meshRate\"), tips: myI18n.t(\"meshRateTips\"), } ] } 十七、命令行支持 可以在终端中启动编辑器，并在后台执行脚本，参数为： > LayaAirIDE --project=/path/to/project --script=MyScript.buildWeb --project: 项目路径 --script: 指定执行的脚本 例如，使用以下脚本，可以使用命令行构建Web平台。脚本执行结束后，后台进程会自动退出。 @IEditorEnv.regClass() class MyScript { static async buildWeb() { return IEditorEnv.BuildTask.start(\"web\").waitForCompletion(); } } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2024-02-21 17:22:28 "},"IDE/layapackage/pluginImport/readme.html":{"url":"IDE/layapackage/pluginImport/readme.html","title":"插件导入使用说明","keywords":"","body":"插件导入使用说明一、购买插件1.1 入口1.2 插件分类1.3 购买二、导入使用2.1 资源商店导入2.2 本地导入插件三、视频教程插件导入使用说明 LayaAir3.1版本新增了资源商店，用户的LayaAir IDE最低版本需更新至3.1才能使用资源商店中的资源。 一、购买插件 1.1 入口 用户可以从以下入口进入资源商店： 1、3.1及以上版本的IDE内 （图1-1） 2、直接在浏览器里输入网址（https://store.layaair.com/） （图1-2） 3、官网的顶部导航 （图1-3） 1.2 插件分类 资源商店的插件总共分为以下几类： 1、项目源码类：用于完整的项目包。 （图1-4） 2、资源类：美术或音效等纯资源，无代码。 （图1-5） 3、基于IDE的插件系统：调用插件API，扩展IDE的开发能力。 （图1-6） 4、工具类：衔接外部工具，导入到IDE里使用，有助于IDE的集成化开发。 （图1-7） 5、其它项目相关的库资源或项目代码：例如第三方的物理引擎库、Shader代码等。 （图1-8） 注意：第一种项目源码类插件，导入的方式与其它的不同，第二节会进行详细说明。 1.3 购买 用户首先需要在资源商店首页进行账号注册，有手机号和微信两种登录方式。 （图1-9） 注册后就可以进行购买了。需要注意的是，资源商店里的付费资源，在购买时，除非严重与描述不符合，否则不会退款。所以建议付费资源在购买前，可以先与插件作者进行沟通确认。 购买资源时，首先点击添加至我的资源， （图1-10） 购买后，点击查看我的资源， （图1-11） 可以跳转到已购资源页面，购买的资源就都在这里了。 （图1-12） 二、导入使用 2.1 资源商店导入 2.1.1 源码类插件导入 如果是导入像“飞机大战游戏源码”这样的项目源码类插件， （图2-1） 点击在LayaAirIDE中打开，并在弹框中点击打开， （动图2-2） 如果本地安装了LayaAirIDE的3.1及以上的版本，点击后就会打开IDE，在侧边栏的已购源码菜单中，有已经购买的飞机大战游戏源码。 （图2-3） 选择后点击下载模板， （图2-4） 下载完成后点击创建项目，即可创建此游戏的工程项目。 （图2-5） 2.1.2 普通插件导入 如果是其它类型的普通插件，例如“细节层次减面插件”， （图2-6） 它是属于普通插件，点击在LayaAirIDE中打开后，要先在IDE中创建一个项目， （动图2-7） 然后会提示导入资源。 （图2-8） 如果在资源商店点击前就已经有打开的LayaAir项目，则可以直接导入资源，导入后会直接打开插件面板。 （动图2-9） 2.1.3 更新插件 另外要说明的一点是，如果商户对资源商店的资源进行了更新，用户需要在已购资源页面，手动更新资源。 以“LayaAIGC插件”为例，首先需要查看更新日志，然后在点击更新前，建议开发者自行备份旧插件包，最后点击更新按钮，并重新将插件导入到IDE即可完成更新。 （动图2-10） 2.2 本地导入插件 如果用户想要导入以前自己保存过的资源包，可以在IDE中，点击工具菜单栏下的导入资源包，注意资源包文件名后缀为.layapkg。 （图2-11） 如果用户将资源包存在了远端，可以选择从网络导入资源包，填写远端地址即可。 三、视频教程 用户还可以观看官方提供的视频教程，完成插件导入：LayaAir3.1资源商店教程合集。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2024-02-21 17:22:29 "},"IDE/layapackage/Layabox/readme.html":{"url":"IDE/layapackage/Layabox/readme.html","title":"官方插件","keywords":"","body":"官方插件LOD减面插件3D骨骼动作烘焙插件官方插件 LayaAir官方提供了一些插件供开发者使用： LOD减面插件 3D骨骼动作烘焙插件 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2024-02-23 20:37:59 "},"IDE/layapackage/Layabox/LOD/readme.html":{"url":"IDE/layapackage/Layabox/LOD/readme.html","title":"LOD减面插件","keywords":"","body":"细节层次(LOD)减面工具插件一、插件概述1.1 插件简介1.2 主要功能二、使用说明3.1 导入插件3.2 参数说明细节层次(LOD)减面工具插件 Author: Charley 欢迎使用细节层次(LOD)减面工具插件。本插件具有强大的模型优化功能，可以帮助开发者减少游戏引擎在展示3D模型时的性能压力。 一、插件概述 1.1 插件简介 LOD是\"Level of Detail\"的缩写，通常译为“细节层次”，有的文档也会译为”细节级别“，都是一回事，它是计算机图形学中用于处理大规模场景的一种通用技术方案。 这个方案中认为，模型的复杂度应该根据视点与模型之间的距离、模型在屏幕上的投影大小等因素动态调整。这样，近处、大的、重要的模型用高分辨率的细节表示，而远处、小的、不重要的模型用低分辨率的细节表示。 借助LOD技术方案，计算机只需展示摄像角度当前能看到的场景细节，降低了大幅度的计算负担、降低了硬件设备的性能要求，在保证画质和动画流畅度的同时，允许更庞大的场景，更为复杂的景物设定，这在一定程度上提升了游戏或者其他可视化产品的表现力和用户体验。 LOD常用于电子游戏、虚拟现实、城市模拟等领域。在游戏中，比如说角色离你越远，模型的多边形就越少，贴图就越模糊，角色离你越近，模型的多边形就越多，贴图就越清晰，这样可以充分利用硬件性能，提供更佳的游戏体验。 Layabox官方出品的LOD减面插件用于创建和管理3D模型的细节层次（LOD）以及减少模型Mesh面数。LOD技术通过根据物体在3D场景中的距离调整其显示的多边形数量，能够极大地提高3D游戏和应用的性能。本插件有效降低渲染数量，减少了存在复杂模型时的GPU硬件计算压力，特别适用于在有限硬件资源中运行的设备。 1.2 主要功能 (图1) 层次生成与删除：用户可以设置多个LOD层次，也可以对新增的层次进行删除。 模型减面压缩：细节层次减面工具，能自动计算模型的三角面数量并依据压缩比例生成各个层次的减化模型。 指定层次的剔除率：对于每个层次的模型，可以自定义在场景中优化剔除的比例条件。 二、使用说明 3.1 导入插件 当我们将IDE资源商店的资源添加至我的资源后，在已购资源的列表中，点击在LayaAirIDE中打开，会弹出浏览器调用IDE的控件，再次点击打开LayaAirIDE，操作流程如图2-1所示。 （图2-1） 如上操作之后，控件会调起LayaAir3-IDE并弹出导入资源的窗口。 我们点击窗口的导入，当导入完成后，会弹出导入完成的提示面板，点击确定即完成了插件的导入。操作如图2-2所示。 （图2-2） 导入完成后的界面如图2-3所示： （图2-3） 插件更新 插件的开发者推出新版本后，不会为插件使用者主动更新版本（有的使用者也许不想升级），所以插件开发者需要手动在资源商店点击更新，更新之后，再点击“在LayaAirIDE中打开”才会重新导入并打开新版本的插件。操作如图2-4所示。 3.2 参数说明 3.2.1 目标类型与减面目标 LOD减面的目标对象通过两个参数来指定， 一是目标类型，该项支持的三种类型分别是：节点（Node）、预制体（prefab）、模型网格（Mesh）。 二是减面目标，减面目标是具体要减面的资源，会根据目标类型来控制减面的目标资源。 例如，节点类型时，只能从层级面板拖拽3D节点对象到减面目标，而预制体与模型网格，只能从项目资源面板里拖拽对应类型的资源。如图3-1所示： (图3-1) 3.2.2 保留边界 保留边界的概念是指，在简化模型的过程中，不对位于拓扑边界的顶点进行移动。拓扑边界的顶点是指那些在三角形边缘上但没有配对三角形的顶点。 边界的顶点是重要的特征点，移动这些顶点可能会严重改变模型的形状，甚至造成视觉上的错误。通过保留边界的功能，可以在保持模型的整体形状和相对精度的同时，达到简化模型的目的。 该功能在简化大型网格的一部分时会非常有用。 在使用时，如果勾选该功能，工具在生成LOD模型时，会保持这些位于边界的顶点不动，只移动和简化其他的顶点和元素，不会对模型的边缘进行过度简化。这样可以确保在模型被简化后，它的边界依然保持原样，防止边界形状的改变带来的视觉影响。 3.2.3 指定存储路径 点击 减面 按钮会生成减面后的模型资源，默认是生成到assets下的根目录（以网格名称作为目录命名）。 当勾选指定存储路径后，会出现存储路径的输入框，如图3-2所示，用于自定义某个目录作为减面后生成的模型目录。 （图3-2） 3.2.4 细节层次配置 细节层次（LOD）的配置，主要分为三个模块：细节层次增减、模型压缩比例配置、最小剔除率。 增加与删除细节层次 工具默认是3个细节层次的设定，0层表示原始层次，值均为100%，1为50%比例的层次设定，2表示10%比例的层次设定。 如果要增加层次，点击加号即可，如图3-3所示。 (图3-3) 如果要删除层次，点击层次ID前的删除图标即可，如图3-4所示。 (图3-4) 模型压缩比例配置 每一个层次，都可以设置一个不同的压缩比例，100%为原始尺寸，不压缩。低于100%的会根据比例，对模型的网格进行压缩。 最小剔除率 最小剔除率指的是对象在对应的细节层次下，如果其在屏幕上的尺寸低于设置的最小视角占比，那么对象会被完全剔除，即不再渲染。这帮助优化渲染性能并减少资源消耗。 剔除率的比例与模型在3D场景中显示的相对尺寸有关，一般是以百分比形式描述。通常，物体离摄像机越近，在屏幕上的尺寸就越大，反之则越小。例如，如果细节层次的最小剔除率设置为50%，这表示模型高度占场景显示高度的一半。当模型的占比小于50%时，那些在LOD组中大于或等于该占比的模型将不被渲染，转而渲染LOD组中下一级别的模型。 简而言之，最小剔除率用于确定渲染哪个细节层次的模型，通常是在物体靠近摄像机时使用细节更丰富的高分辨率模型，在远处使用较低分辨率模型或者只保留模型的轮廓以减少渲染开销。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2024-02-21 17:22:27 "},"IDE/layapackage/Layabox/BakeAnimation/readme.html":{"url":"IDE/layapackage/Layabox/BakeAnimation/readme.html","title":"3D骨骼动作烘焙插件","keywords":"","body":"3D骨骼动作烘焙插件一、插件概述二、使用说明2.1 导入插件2.2具体使用3D骨骼动作烘焙插件 一、插件概述 动画烘焙是一种特殊的动画优化方案，它将所有动画提前计算一次；将所有的骨骼节点预计算，存入内存中；GPU直接通过内存读取对应节点的矩阵值；进行渲染的方式。通过使用动画烘焙，可以降低CPU的消耗，因为GPU动画效率高于CPU动画，对于大量使用骨骼动画的场景，可以大大提高性能。 优点：性能高，可用于大量骨骼动画场景; 缺点：动画之间不能平滑切换，不能使用动画遮罩等功能； 二、使用说明 2.1 导入插件 当将IDE资源商店的资源添加至我的资源后，在已购资源的列表中，点击在LayaAirIDE中打开，会弹出浏览器调用IDE的控件，再次点击打开LayaAirIDE，如图2-1所示。 （图2-1） 之后，控件会调起LayaAir3-IDE并弹出导入资源的窗口。点击窗口的导入，当导入完成后，会弹出导入完成的提示面板，点击确定即完成了插件的导入。如图2-2所示。 （图2-2） 导入完成后的界面如图2-3所示： （图2-3） 插件更新 插件的开发者推出新版本后，不会为插件使用者主动更新版本（有的使用者也许不想升级），所以插件开发者需要手动在资源商店点击更新，更新之后，再点击“在LayaAirIDE中打开”才会重新导入并打开新版本的插件。 2.2具体使用 详细参考《动画烘焙详解》文档。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2024-02-26 16:36:36 "},"basics/2.x-Upgrade/readme.html":{"url":"basics/2.x-Upgrade/readme.html","title":"2.x引擎项目升级指南","keywords":"","body":"2.0引擎开发者使用3.0的差异汇总1、LayaAir3.0 Loader修改1.1加载一个资源1.2 加载多个资源（用数组）1.3 加载多个文件（组合）1.5 加载HTMLImage1.6 使用Options。1.7 预制体/场景的问题1.8 旧版本引擎load和create的兼容性问题1.9扩展Loader能力2、关于动态加载IDE里的资源说明3、LayaAir3.0 输入处理模块修改3.1 2D和3D统一接口，3.2 2D能对3D正确遮挡。3.3 新增 MOUSE_DRAG和MOUSE_DRAG_END3.4 删除了RIGHT_MOUSE_DOWN和RIGHT_MOUSE_UP3.5 事件汇总4、LayaAir3.0 组件系统修改5、Runtime的使用差异6、2D动画2.0引擎开发者使用3.0的差异汇总 Author：谷主 && Charley [!Note] 本篇文档仅适用3.0以前的旧版引擎开发者，熟悉一些项目差异，后续还会进一步进行总结。 1、LayaAir3.0 Loader修改 1.1加载一个资源 示例： var url = \"xxx.png\"; var type = Laya.Loader.IMAGE; Laya.loader.load(url).then((res)=> { //不带类型，用于常规的资源 }); Laya.loader.load(url, type).then((res)=> { //带类型，用于区别同一后缀不同作用的资源。 //例如，图片xxx.png被定义为TextureCube，使用load(\"xxx.png\", Laya.Loader.TEXTURECUBE)。得到的是TextureCube。 }); 1.2 加载多个资源（用数组） var url1 = \"xxx.png\"; var url2 = \"xxxxx.png\"; var type1 = Laya.Loader.IMAGE; var type2 = Laya.Loader.TEXTURE2D; Laya.loader.load([url1, url2]).then((res:Array)=> { //加载多个，不带类型 }); Laya.loader.load([url1, url2], type).then((res:Array)=> { //加载多个，统一设置类型 }); Laya.loader.load([{ url:url1, type: type1 }, { url:url2, type: type2 }]).then((res:Array)=> { //加载多个，分别设置类型 }); 1.3 加载多个文件（组合） let tasks:Array> = []; tasks.push(Laya.loader.load(url)); tasks.push(Laya.loader.load(url2)); Promise.all(tasks).then((res:Array)=> { //用于异步加载 }); 1.4 Texture和Texture2D的问题 同一个资源地址，无论是加载Texture还是Texture2D，他们在内存中都只有一份，但可以获取不同类型。 Laya.loader.load(\"1.png\").then((res)=> { /* res是Texture */ }); Laya.loader.load(\"1.png\", Loader.Texture2D).then((res)=> { /* res是Texture2D */ }); Laya.loader.getRes(\"1.png\"); //res是Texture Laya.loader.getRes(\"1.png\", Loader.Texture2D); //res是Texture2D Laya.Loader.getTexture2D(\"1.png\"); //res是Texture2D 1.5 加载HTMLImage Laya.loader.fetch(\"1.png\", Laya.Loader.IMAGE).then((res)=> { /* res是HTMLImage */ }); [!Type|label:Tips] 不能使用Loader.getRes获得fetch结果，因为fetch方法不缓存 1.6 使用Options。 Laya.loader.load(url, { group:xx, piority:1 }); //priority不限制0-5。为任意整数，数字越大优先级越高。 1.7 预制体/场景的问题 加载lh/ls/gltf这三种文件，会下载和加载所有依赖的资源。 但不会自动创建节点。缓存的也不是节点。 Laya.loader.load(\"1.lh\").then(res=> { /* 注意res不是节点类型！ 类型也不必关心，只需要知道它有一个create方法实例化节点树。*/ let node = res.create(); }); 1.8 旧版本引擎load和create的兼容性问题 3.0以前的引擎，有Laya.loader.load()和Laya.loader.create()方法两个方法，分别用于加载2D和3D资源。 3.0引擎版本统一使用load()方法即可， 对于lh/ls/gltf这类资源，旧版本的create方法相当于3.0引擎的load+createNodes， 对于其他资源，create方法和load方法没有区别。旧引擎的create方法在3.0引擎中已取消，因为这个方法的不当使用会造成内存泄露，所以需要报编译错误强制开发者修改。 1.9扩展Loader能力 原来的parseMap，createMap都已经取消。 编写一个类实现IResourceLoader接口，例如一个最简单的实现： class MyLoader { load(task:ILoadTask) { return task.loader.fetch(task.url, \"json\", task.createCallback()).then(data=> { let obj = /*解析data*/; return obj; }); } } 加载类里不需要考虑是单独加载，还是是批量加载其中一个环节，因为task.createCallback可以很好的将总体进度归一化为0~1。 复杂的例子可以参考引擎里的TextureLoader/MaterialLoader/MeshLoader之类。 然后使用Loader.registerLoader注册这个类。例如 Loader.registerLoader([\"xyz\"], YourLoader); 2、关于动态加载IDE里的资源说明 无论加载什么资源，编辑器内文件名是什么，路径就填什么。不用放到bin目录，直接放到assets目录，以assets为根路径。 例如： 1、拖入了FBX或者GLTF后，使用load(\"xxx.FBX\", Laya.Loader.HIERARCHY) 加载编辑器里的fbx或者gltf。不需要自己手动搞成lh。编辑器会自动使用转换后的结果。 2、加载蓝图shader用load(\"xxxx.lbp\")，而不是\"xxx.shader\"。 3、LayaAir3.0 输入处理模块修改 原有的MouseManager和KeyboardManager合并为InputManager。MouseManager以前在游戏中应该很少直接用到，所以影响不大。KeyboardManager原来只有一个接口hasKeyDown，现在改为调用InputManager.hasKeyDown即可。 新的输入处理系统的特性有： 3.1 2D和3D统一接口， 都可以通过事件监听方式和Laya.Script命名函数方式处理输入。例如： this.aNode.on(Laya.Event.CLICK, ()=> { console.log(\"clicked\"); }); class MyScript extends Laya.Script { //脚本事件 onMouseClick(e:Event) { console.log(\"clicked\"); } } aNode.addComponent(MyScript); 以上两种方式是等价的，且在纯2D，或2D/3D混合这两种情况中均可正常使用。 3.2 2D能对3D正确遮挡。 输入处理时，2D能对3D正确遮挡。 3.3 新增 MOUSE_DRAG和MOUSE_DRAG_END 新增了两个事件：MOUSE_DRAG和MOUSE_DRAG_END。 在对一个物体按下鼠标并移动（无论是否在此物体上方），将持续对此物体派发MOUSE_DRAG， 松开鼠标后（无论是否在此物体上方）对此物体派发MOUSE_DRAG_END。 3.4 删除了RIGHT_MOUSE_DOWN和RIGHT_MOUSE_UP 删除了RIGHT_MOUSE_DOWN和RIGHT_MOUSE_UP，改为派发MOUSE_DOWN和MOUSE_UP，可以通过Event.button区分鼠标左中右键。 3.5 事件汇总 Laya.Script 里相关的输入处理函数有： /** * 鼠标按下时执行 */ onMouseDown?(evt: Event): void; /** * 鼠标抬起时执行 */ onMouseUp?(evt: Event): void; /** * 鼠标在节点上移动时执行 */ onMouseMove?(evt: Event): void; /** * 鼠标进入节点时执行 */ onMouseOver?(evt: Event): void; /** * 鼠标离开节点时执行 */ onMouseOut?(evt: Event): void; /** * 鼠标按住一个物体后，拖拽时执行 */ onMouseDrag?(evt: Event): void; /** * 鼠标按住一个物体，拖拽一定距离，释放鼠标按键后执行 */ onMouseDragEnd?(evt: Event): void; /** * 鼠标点击时执行 */ onMouseClick?(evt: Event): void; /** * 鼠标双击时执行 */ onMouseDoubleClick?(evt: Event): void; /** * 鼠标右键点击时执行 */ onMouseRightClick?(evt: Event): void; /** * 键盘按下时执行 */ onKeyDown?(evt: Event): void; /** * 键盘产生一个字符时执行 */ onKeyPress?(evt: Event): void; /** * 键盘抬起时执行 */ onKeyUp?(evt: Event): void; 和老版本比较，有如下改变 1) onClick 名字变更为 onMouseClick 2) onDoubleClick 名字变更为 onMouseDoubleClick 3) 删除了onStageMouseDown，onStageMouseUp，onStageClick，onStageMouseMove 4) 删除了onMouseEnter，它与onMouseOver重复。 4、LayaAir3.0 组件系统修改 4.1 LayaAir2的组件系统中有3种组件的基类，Component、Script和Script3D。 LayaAir3.0合并了Scirpt和Script3D，也就是只使用Script即可。Script3D仍然可以使用，但它只是Script的别名。Script可以挂载到2D对象，也可以挂载到3D对象。 4.2 LayaAir2中，Component与Script的区别，是Component主要通过继承方式写逻辑，Script则是比较纯正的组件机制。 在LayaAir3.0中，Component具有完整的生命周期，即onAwake,onStart,onEnable,onUpdate,onLateUpdate,onDisable,onDestroy，不再使用_onEnable,_onDisable等下划线函数。 _onEnable,_onDisable等下换线函数仍然给内部使用 对比Component, Script增加了交互行为，即onTriggerEnter, onCollisionEnter, onMouseClick, onKeyDown等与输入输出相关的回调。除此之外，Script与Component无本质区别。开发者一般使用Script。 4.3 Component或Script的Update/LateUpdate方法是否在IDE编辑模式下运行，由他们的runInEditor属性决定。开发者则一般通过给Script附加装饰@runInEditor实现。默认不运行。 关于修饰符的使用，参照下面的示例： const { regClass, property } = Laya; //有了@regClass()，才会被识别为script脚本类 @regClass() export class Script extends Laya.Script { //属性上面有了@property()，才会被识别为IDE里可暴露的属性，每一个属性只要需要暴露，上面就都需要加上@property()。 @property( { type : String } ) public text: string = \"\"; constructor() { super(); } } 5、Runtime的使用差异 3.0的场景与2.0完全不是一个概念， 3.0的runtime只能在场景上的2D根节点Scene2D或预制体的根节点上设置，其它的子级节点，不再支持runtime，如果有代码的需求，要使用脚本script来实现。 3.0的UI没有var属性，name与var合并了，默认只需要name，如果需要在场景继承类上runtime通过this.xxx访问，那把name后面的 Declare Var给勾选上即可导出该属性到场景的基类里。 3.0不再把场景类统一生成到一个文件里，而是生成到Runtime类的同级目录，当为runtime指定一个场景类后，该场景类的同级目录会自动生成一个文件名相同，但后缀不同的基类。场景类基类的后缀名字为xxx.generated.ts 如果开发者不想看到.generated.ts的文件，可以在vscode的配置文件里，加上.generated.ts后缀名屏蔽生成的基类。 6、2D动画 2D动画不再支持ani格式，采用状态机与动画文件结合来使用 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-04-06 14:38:57 "},"2D/advanced/readme.html":{"url":"2D/advanced/readme.html","title":"2D进阶","keywords":"","body":"2D进阶文本进阶使用TiledMap地图2D性能优化2D进阶 2D进阶部分包括一些引擎扩展功能、引擎功能的综合性使用，进阶性使用等相关的文档。 文本进阶使用 TiledMap地图 2D性能优化 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:43 "},"2D/advanced/useText/readme.html":{"url":"2D/advanced/useText/readme.html","title":"文本进阶使用","keywords":"","body":"文本进阶使用一、显示文本组件二、位图显示文本组件三、HTML、UBB、模板四、可输入文本组件五、关于文本的性能优化5.1 尽可能使用对应的文本组件5.2 尽可能避免使用文本描边5.3 被文本打断的DrawCall优化文本进阶使用 LayaAir引擎与IDE提供了丰富的文本组件，适用于各种文本应用场景。本篇分别就IDE中的显示文本组件、位图文本组件、可输入文本组件，这几个类型的组件进行介绍，让大家全面了解一下LayaAir引擎的各个文本组件。 一、显示文本组件 显示文本就是只能看，不能编辑修改的基础文本。LayaAirIDE中提供了Text和Label这两种基础的显示文本组件。 1.1、文本的底层渲染机制 LayaAir引擎在文本的底层渲染上，有两种方式。 分别是Text文本类的文本统一提交方式，和Graphics类的fillText文本单字符绘制提交方式。 如果采用了Text文本，那每一个Text文本对象中的文本字符会一起形成小图集提交到大图合集中，比如游戏中某个文本对象有300字，其中一个字符发生改变，也会对该文本对象的300字整段文本图集重新提到大图合集中。 又假如，在一个剧情游戏中，两人在对话。那其中一个文本对象，要不断的重新取值和赋值操作，使得该文本对象的显示内容频繁发生改变。此时，Text文本对象，就会不断的向大图合集进行文本图集的提交，占满大图集后，又需要创建一个新的图集继续提交，而不用的旧图集，如果没达到GC条件，也会一直存在，所以如果此次查看内存占用统计信息，就可以看到会一直在涨内存，直到GC条件达到之后，才会被销毁。并且GC在清空垃圾内存的时候，还有可能会导致瞬间的卡顿。 而采用Graphics类的fillText文本绘制，则是按单个字符向大图合集中进行提交，并且大图合集中已经存在的字符不会重复提交。所以对于图集的利用率比较好，即便是发生文本改变的时候，也不会向Text文本那样，创建很多垃圾图集。 这样看来，是不是fillText就是最好用的呢？ 如果文本不需要改变，那按单字提交图集的效率是不如一次性直接提交的。 所以，我们还是要看文本的类型，对应文本使用时的类型，选用相应的引擎API，才会更好。 1.2、静态文本与动态文本 基于上一小节的文本渲染提交的机制，以及文本仅用于展示或用于交互的区别，我们分成两种概念，就是把仅用于显示，文本内容无需改变的文本叫静态文本。对于文本内容需要改变的文本叫动态文本。 Text和Label都属于处理静态文本的类，它们都是把文本的每次改动都统一提交大图集的渲染机制。 fillText、fillBorderText、strokeText等，都是Graphics类中用于单字符提交的文本绘制方法。 在LayaAirIDE中，Text和Label属于静态文本组件，而LayaAir引擎中Graphics类的fillText、fillBorderText、strokeText等文本绘制方法，在IDE中是没有封装为组件的，需要在项目代码中直接使用引擎的API。 1.3、不同的文本API的使用区别与选择 如果我们已经理解了什么是静态文本和动态文本，那使用起来的选择就比较简单了，例如，一些导航和标签按钮等，他在UI上完全没有必要进行改变，完全可以使用静态文本。文字剧情和任务等，就需要动态文本了。 那静态文本组件有Text和Label两种，那是怎么选择呢。 其中Text是最基础的文本组件，他直接继承于Sprite，而Label继承于UIComponent再往上才是Sprite，从原理上，路径越短，性能自然越好。所以，比较简单的文本，当Text可以满足时，原则上优先使用Text，而Label由于属性非常丰富，适用于相对布局等等Text无法满足的应用场景。 对于fillText而言，我们不仅要了解它的优势，也要了解他的不足。fillText文本由于是引擎自己绘制的，目前只适用于中英文等主流国家语言，对于泰国语、阿拉伯语等复杂的语言，显示可能会有异常。所以对于这些排版复杂的国际语言游戏，那只能是采用静态文本组件的系统字或者是位图字，尽可能减少文本动态修改的产品需求。 1.4、使用时要注意的 静态的文本优先使用Text组件，因为只显示静态文本的时候性能最好。动态文本优先使用fillText，除非是国际化等需求不能满足的时候。 静态文本，对于有相对布局等复杂需求时，Label组件的功能比较强大。 fillText的代码使用方法说明如下： /** * 在画布上绘制文本。 * @param text 在画布上输出的文本。 * @param x 开始绘制文本的 x 坐标位置（相对于画布）。 * @param y 开始绘制文本的 y 坐标位置（相对于画布）。 * @param font 定义字号和字体，比如\"20px Arial\"。 * @param color 定义文本颜色，比如\"#ff0000\"。 * @param textAlign 文本对齐方式，可选值：\"left\"，\"center\"，\"right\"。 */ fillText(text: string | WordText, x: number, y: number, font: string, color: string, textAlign: string): FillTextCmd { return this.addCmd(FillTextCmd.create(text, x, y, font, color, textAlign, 0, \"\")); } 这里重点介绍一下fillText中font属性与其它几个文本font属性区别，fillText示例代码如下： /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { let sprite = new Laya.Sprite(); Laya.stage.addChild(sprite); sprite.graphics.fillText(\"fillText:引擎绘制的文本，适合简单的单行文本\", 100, 300, \" 60px simHei \", \"#ff0000\", \"left\"); } 在Text与Label中，font仅仅是指系统字体，例如该文本是Microsoft YaHei还是Arial，选择或者输入对应的字体就可以。而fillText中，font是字体与字体大小的设置值，也可以把所有相关的文本样式（大小、字体、斜体、加粗）也在这里指定。 例如，当值为 60px simHei ，是将文本大小设置为60像素大小，采用simHei字体。如下图1-1所示： （图1-1） 值为60px simHei italic 增加了斜体效果。如下图1-2所示： （图1-2） 值为bold 60px simHei italic 增加了文本加粗效果。如下图1-3所示： （图1-3） Tips: 大小与字体是必须设置的，并且在字体必需要放到文本px大小的后面。 bold需要放到文本px大小的前面。 二、位图显示文本组件 位图显示文本，是一种基于位图的文本，虽然显示的是文本的内容，其本质还是位图。通常用于系统上不通用的字体或者美术设计的个性字体，通过位图的方式可以保障字体的兼容性与美观。对于文本效果与位置要求比较严格的游戏，建议采用位图文本。 普通的文本，在不同运行环境下，可能会存在像素级的位置偏移。比如Chrome低版本和高版本也存在位置偏移。所以要求高的静态UI文本，可以采用位图显示文本。 位图文本适用于文本单字总量不大需求，常用于第X关，X连击等标题性文本。对于文字剧情这种游戏，就不太适合。 1、FontClip字体剪辑组件 FontClip组件是LayaAir基于等份切割原理将完整的位图切分成一个个独立的文本单元，然后任意剪辑拼接起来。效果如图2-1所示， （图2-1） 图2-1的数字0-9是美术原图效果的展示，数字999是FontClip组件效果。 在图2-1右侧的属性面板上，sheet值对应位图的9个数字，此时数字要完全对应起来，因为这个值不仅是引擎切割份数的参考依据，更是文本映射关系。只有对应起来，属性value中输入什么值就会显示什么值，例如图2-1的999。并且FontClip组件还可以控制切割后的位图文本间距等效果。 如果位图文本不是数字，是字母或者中文等，内容比较多，美术出图时也可以将文本多行排行，但是每个文本之间必须要等高等宽等距进行排列。此时用于映射的sheet值，要在每行结束位置加一个空格，让引擎知道这个位图文本是多行排行的。效果如下图所示： （图2-2） 通过图2-2，我们可以看出sheet属性值鼠牛虎兔龙蛇马羊 猴鸡狗猪年快乐对应了位图上的文本，并且在羊后加了一个空格，此时就可以在value输入位图上的文本字符了，而且我们还展示了竖向排版的效果，说明切割后的文本还可以排版控制的。 如果细心的开发者会发现，位图字是繁体的，sheet的值是简体的，但展示的效果并没有受到影响。这是因为sheet值只是起到映射关系的作用，哪怕这十二生肖的文本对应的就是生肖图片，那也会显示对应的生肖图。但是映射的文本与位图上的数量一定要是完整的，否则切片的份数不对，就会导致位图剪辑后的显示错误。 最后再说一下空格，如果当前的FontClip组件是图2-1那样面向单行的整句文本，此时sheet值是不支持空格的。而对于图2-2的多行文本，sheet值里的空格表示换行，并不是空一格。如果在Value值里加一个空格，可以从图2-2中看出，会空出一个完整的文本位置。其实不止是空格，所有sheet值中不存在的文本，输入在value中都会以空的完整字符占位。 2、BitmapFont位图字体 通常FontClip已经可以满足关卡、特效等单行位图文本的需求。如果有特殊情况，就是想要空格或者某些系统里没有的艺术字体，那也可以通过BitmapFont位图字体来实现。在LayaAir IDE里，可以直接创建制作位图字体，下面就来介绍这一功能。 如图2-3所示，在项目资源面板中，右键创建位图字体。 （图2-3） 创建后，如图2-4所示，会生成一个BitmapFont.fnt字体文件， （图2-4） 点击选中后，在如图2-5所示的属性设置面板中，就可以创建位图字体了。 （图2-5） 点击“编辑字符集”的+创建一个字符，如图2-6所示： （图2-6） 参数 意义 允许缩放 勾选后，可以按文本中的字体大小设置进行缩放显示。如果这里不勾选，则会无视字体大小设置，仅按位图文本的实际大小显示 字号 勾选允许缩放后，此处的字体大小用于实际文本字体大小的缩放调节。例如，实际文本的字体大小设置为24，位图字体的字体大小设置为12，那么位图字体最终将放大1倍显示，此处建议与文本组件的”font size“属性保持一致，这样获得的缩放效果最准确。如果不允许缩放，那此处与实际文本的字体大小设置均无效，会始终保持位图字体的源图大小 自定义行高 勾选后，可以设置行高。如果不勾选，则使用默认行高。行高决定了文本多行显示时每行所占高度，主要用于文本垂直方向的排版。如果为0，就是采用字号大小作为行高。如果大于0，就是实际文本的行间距（两个位图字体上边界之间的距离）。创建后可以在文本组件的”leading“属性中设置行高 字符 图片对应的字符，只支持单字符，可以是数字或者字符串 图片 资源库里的一张图片 占位 如果值为0，创建后表示一个字符的水平占位宽度，它由字符图片的宽度决定。如果值大于0，则使用该值作为字符之间的字间距（两个位图字体左边界之间的距离） 如图2-7所示，在resources文件夹下有十二张图片，分别是”鼠牛虎兔龙蛇马羊猴鸡狗猪“十二个字的位图，将这十二张图作为位图字体。图片的高度为151 px，所以行高设置为151。占位默认为0，创建后会变为144，即图片的宽度。编辑好之后点击”应用“，点击后还会再创建一张BitmapFont.png图片用于预览位图字体。 （图2-7） 位图字体可以在Text、Label、TextInput、TextArea等文本组件的Font属性中被选择，并且能够调整字体大小与行间距等。下面以Text为例，演示位图字体的使用。如动图2-8所示，在Text中选择好刚刚创建的位图字体，然后在文本中输入位图字体对应的”字符“即可使用位图字体了。 （动图2-8） Tips： 开发者也可以通过外部工具制作完成后，再导入使用。这里推荐一个开源工具：https://snowb.org/，在线即可制作。 三、HTML、UBB、模板 在所有的文本相关的UI组件上使用HTML标签，并且可以与其它的UBB标签、文本模板、普通文本混合使用，开发者只需设置对应的syntax属性即可，支持的语法与使用方式请参考文档《基础文本》。 四、可输入文本组件 可输入文本组件为单行输入组件TextInput和多行文本域组件TextArea。 从组件名字其实上就可以看出区别， 一个是不能换行，用于单行输入。比如注册信息上的那些单行输入框用TextInput。 另一个是能换行的多行文本组件TextArea，比如个人简介，备注说明等等。而且TextArea文本组件支持右侧的垂直滚动条，和底部的水平滚动条。 由于可输入文本组件的用法比较简单，组件也比较容易理解。这里就不详细介绍了，具体在使用过程中，可以看提示进行尝试或者直接看对应的组件属性说明文档。 五、关于文本的性能优化 5.1 尽可能使用对应的文本组件 每个不同的组件都是有自己独特的作用，所以一定要充分了解组件的作用，对应特点来使用。 上文中也讲到过，静态显示文本Text组件的性能是最好的，所以，在项目开发时，能用Text尽可能要用Text组件。当Text组件不满足的时候再用Label。 对于无需改变内容的静态文本，当文本组件节点较多时，我们可以开启cacheAs，设置normal可以优化节点数，设置bitmap可以优化DrawCall数。 而当文本内容需要改变时，哪怕只改变一个字符，如果FillText可以满足需求的话，那尽可能优先使用FillText文本组件。FillText不能满足时，其次考虑位图文本组件是否可以满足，最后再考虑静态文本组件。 5.2 尽可能避免使用文本描边 在运行时，设置了描边的文本比没有描边的文本多调用一次绘图指令。此时，文本对CPU的使用量和文本的数量成正比。因此，尽量使用替代方案来完成同样的需求。例如，字符量较少的时候，可以使用位图文本。 5.3 被文本打断的DrawCall优化 在2D的UI布局时，如果开发者将文本与其它UI节点混合排列，那么必然会打断图集的合并渲染，增加DrawCall数量，产生不必要的性能开销。所以，有两个方案来优化。 一是，LayaAir IDE编辑布局时，将所有文本组件在节点中顺序排列，不要与其它UI组件穿插。 二是，LayaAir IDE中的组件中有一个drawCallOptimize属性，我们为所有文本的父级节点drawCallOptimize属性设置true值。当这样设置之后，引擎会自动启用文本合并优化，将所有的文本提取到最上层，而开发者无需再刻意调整图集资源和文本的排序，即可实现drawCall自动优化的目标，而且优化的更加干脆彻底。 需要提醒的是，drawCallOptimize优化方案由于会自动将文本提升显示层级，不适用于必须要将文本半遮挡的特殊需求。当然，绝大多数情况下文本是要处于全文显示的，如果有全隐藏的情况，可以直接设置隐藏属性。所以，建议开发者开启该优化方案。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-06-12 20:59:58 "},"2D/useBinaryImage/readme.html":{"url":"2D/useBinaryImage/readme.html","title":"使用二进制图片","keywords":"","body":"使用二进制图片一、图片与二进制二、如何加载三、Laya中如何使用使用二进制图片 一、图片与二进制 在页游时代，为了防止资源被盗取，通常的做法就是把图片等资源进行加密。所谓的加密就是打乱资源本来的存储字节，或者穿插一些东西。但是到了html5时代，发现基本都是直接加载的图片，为什么和页游时代做法不一样了呢？是不是html5不能加载解码二进制图片？当然不是。之所以不进行加密这层操作，主要是我们项目的源码完全暴露在浏览器端，根本没有什么秘密可言，即便加密了，写个脚本执行下就能拿到你的源码。但是为了满足开发者这方面的需求，我们来讲解下LayaAir3.0是如何进行二进制图片操作的。 二、如何加载 关于如何加载，这里我们先从原生开始，然后在过渡到LayaAir引擎，这样开发者可以理解其中的含义。以二进制流的方式加载，这里我们采用XMLHttpRequest二进制流的方式来加载。关于XMLHttpRequest的操作我们这里不在陈述，我们先按照二进制的方式来加载试试。这里我们先用js脚本进行操作。代码如下： var xhr = new XMLHttpRequest(); xhr.open(\"get\", \"res/atlas/comp.png\", true); xhr.responseType = \"arraybuffer\"; xhr.onload = function () { if (this.status == 200) { var blob = new Blob([this.response], { type: \"image/png\" }); var img = document.createElement(\"img\"); img.onload = function (e) { window.URL.revokeObjectURL(img.src); // 清除释放; }; img.src = window.URL.createObjectURL(blob); document.body.appendChild(img); } } xhr.send(); 上面这个方法是用了浏览器自身提供的方法来把二进制转换成图片，二进制转换成图片其实还有很多种方法，比如加载进来二进制，解码成base64，然后在赋值给你img，或者把二进制数据用canvas绘制出图片，然后toDataURL赋值给你img的src等等，方法很多，我们这里就用最简单有效的办法转换图片。 图片加载完成之后，实例化一个XMLHttpRequest对象xhr ，responseType属性设置成 arraybuffer，实例化一个Blob对象blob，用来创建一个img标签，window.URL.createObjectURL(blob)创建一个指向该参数对象的URL，把创建的img对象我们添加到网页的body上进行显示。把这段代码嵌入到index.html文件中，运行可以看到网页已经正常的显示我们的图片。 三、Laya中如何使用 上面的简单例子我们是用的js脚本书写，那么在LayaAir3.0项目中是怎么使用的呢 在项目中的脚本中添加如下代码： //test.bin为二进制图片，图片加密数据是在图片的前面写入了四个字节的数据 Laya.loader.fetch(\"resources/res/test.bin\",\"arraybuffer\").then((res)=>{ //获得res的ArrayBuffer数据 let arraybuffer: ArrayBuffer = res; //Byte数组接收arraybuffer let byte:Byte = new Byte(arraybuffer); //从第四个字节开始读取数据 byte.writeArrayBuffer(arraybuffer,4); //获得最终的ArrayBuffer let imageArrayBuffer = byte.buffer; //实例化一个Blob对象blob，用来创建一个img标签 let imgBlob = new Blob([imageArrayBuffer], { type: \"image/png\" }); //转换为Base64图片格式 let reader = new FileReader(); reader.readAsDataURL(imgBlob); reader.onload = (e)=> { let sp1:Sprite = new Sprite(); //加载Base64图片数据 sp1.loadImage(e.target.result as string); this.owner.addChild(sp1); } }); 上述代码中，用 Laya.loader.fetch 加载图片二进制数据，根据自定义的规则，可以解析数据加密方式，并获得完整图片数据。在这里我们更多的介绍一下 LayaAir3.0引擎的 Laya.loader.fetch 方法。使用 Laya.loader.fetch 的好处是它是较为底层的下载资源的方法，它和load方法不同，不对返回的数据进行解析，也不会缓存下载的内容。 当选取图片数据的ArrayBuffer后，可以创建Image的Blob对象，通过FileReader类可以转换为Base64图片数据显示图片。这里不是用DOM来显示图片的，而是通过Laya.Sprite绘制。 开发者也可以使用Laya.Texture的方式，通过Laya.Sprite的drawTexture方式渲染，代码如下： //创建一个url对象； var url:string = Laya.Browser.window.URL.createObjectURL(imgBlob); //加载URL获得HTMLImageElement Laya.loader.fetch( url,\"image\" ).then((res)=>{ //创建Texture2D var t2d: Texture2D = new Texture2D(res.width, res.height, TextureFormat.R8G8B8A8, false, false, true); t2d.setImageData(res, true, false); //创建Texture var texture: Texture = new Texture(t2d); let sp2:Sprite = new Sprite(); //使用Sprite对象的绘制纹理方式 sp2.graphics.drawTexture(texture, 150, 0); this.owner.addChild(sp2); }); 当创建好Blob对象后，通过window.URL.createObjectURL(blob)创建一个指向该参数对象的URL，再通过Laya.loader.fetch 加载URL获得HTMLImageElement 对象，通过Laya.Texture2D 的setImageData 可以把HTMLImageElement 对象数据转换为 Laya.Texture2D，最后创建Laya.Texture来绘制 在上述代码中，也可以通过传递 Option 参数来使用Laya.loader.fetch，可以把 blob对象作为参数直接传递，代码如下： //创建Option let option:any = {}; option.blob = imgBlob; //通过传递Option参数，其中包含blob对象，来获得HTMLImageElement对象 Laya.loader.fetch( \"\" ,\"image\", null, option).then((res)=>{ //创建Texture2D var t2d: Texture2D = new Texture2D(res.width, res.height, TextureFormat.R8G8B8A8, false, false, true); t2d.setImageData(res, true, false); //创建Texture var texture: Texture = new Texture(t2d); let sp2:Sprite = new Sprite(); //使用Sprite对象的绘制纹理方式 sp2.graphics.drawTexture(texture, 150, 0); this.owner.addChild(sp2); }); 以上方法就是二进制图片的处理方法，开发者可以根据需求制定更多的二进制数据规则，可以把很多图片打包成一个图片集合文件，一次性解析并加载等待。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:43 "},"2D/TiledMap/readme.html":{"url":"2D/TiledMap/readme.html","title":"TiledMap地图","keywords":"","body":"使用TiledMap地图一、概述二、导出引擎支持的Tiled Map地图2.1 Tiled Map Editor下载安装2.2 导出引擎支持的Tiled Map地图格式三、LayaAir引擎使用Tiled Map 地图3.1 IDE勾选laya.tiledmap组件3.2 创建TiledMap地图3.3 控制地图3.4 拖动地图四、Tiled Map 使用优化4.1 销毁地图4.2 缓存相关4.3 合并图层4.4 移除被覆盖的格子使用TiledMap地图 一、概述 Tiled Map Editor是一个免费的地图编辑器，可以用来编辑2D游戏地图，LayaAir引擎支持解析Tiled Map导出的地图。本文将介绍如何在LayaAir引擎开发中使用Tiled Map Editor导出的地图。 注意：本文仅面向熟悉和使用Tiled Map地图工具的开发者。在文中介绍Tiled Map Editor导出的地图在LayaAir引擎的项目中如何使用，关于Tiled Map Editor工具的自身内容请自行查找第三方教程文档。 二、导出引擎支持的Tiled Map地图 2.1 Tiled Map Editor下载安装 打开官方首页（http://www.mapeditor.org/）后，直接点击`DownLoad at itch.io`按钮进入下载链接（https://thorbjorn.itch.io/tiled）。 （图2-1） 如果官网改版，也可以直接从下载页 http://www.mapeditor.org/download.html 找到下载链接。 找到对应的系统版本链接，下载安装即可，(本篇文档采用的版本为Tiled 1.9.2 )。 Tips： 打开下载会弹出赞助该软件的付费页面，如果不想付费，可以直接点击 No thanks, just take me to the downloads，会带你进入一个免费下载的链接。 2.2 导出引擎支持的Tiled Map地图格式 Tiled Map工具的具体使用方式，本文不多讲，可以自行在百度或谷歌中搜索相关教程文档。和引擎有莫大关系的是格式。需要开发者特别注意，一般出问题都是在这里没有注意。 2.2.1 创建地图时，对图块层格式的要求 点击新建地图，设置好地图大小和块大小等初始参数后，点击另存为，存在你指定的位置即完成了创建。 然而，图块层格式需要特别注意，由于LayaAir引擎不支持Tiled Map地图为Base64的图块层格式。所以在创建新地图时必须为CSV格式，如图2-2所示。 （图2-2） 如果创建的时候选错了，也可以在属性面板里，将图块层格式改为CSV或者是XML，如图2-3所示，Base64相关的格式都不支持。 （图2-3） 2.2.2 导出为json格式 本例中，我们直接打开Tiled Map的示例地图 orthogonal-outside.tmx（位于Tiled Map地图安装目录的 examples目录下），如图2-4所示 （图2-4） 在导出的时候，我们要选择json的格式。 在Tiled工具的文件菜单里，点击另存为，将已完成的Tiled地图，另存为json文件类型，本例命名为 orthogonal.json（文件名开发者随意，后面保持一致即可），点击保存，存到项目目录内（本例为项目根目录\\assets\\resources\\TiledMap\\），如图2-5所示。 （图2-5） 2.2.3 修改图集路径和复制Tiled资源 只是存为json文件还不够，我们还要更改image绝对路径为相对路径。 我们通过IDE，打开刚刚保存的 orthogonal.json，搜索关键字 image 我们会发现默认的图集路径位于Tiled安装目录中。如图2-6所示。 （图2-6） 路径在Tiled安装目录中肯定是不行的， 所以，我们需要先将这个图片复制到项目目录，与之前保存的orthogonal.json同级， 如图2-7所示。 （图2-7） 同时，我们要把图片文件在IDE里的格式做修改，支持透明通道 （图2-8） 然后将 orthogonal.json 中的图集路径修改为相对路径，如图2-9所示 （图2-9） 准备阶段结束，下面开始步入编码阶段…… 三、LayaAir引擎使用Tiled Map 地图 3.1 IDE勾选laya.tiledmap组件 （图3-1） 如图3-1，勾选laya.tiledmap组件后，引擎类库中才支持 tiledmap 3.2 创建TiledMap地图 3.2.1 createMap API 说明 laya.TiledMap类中的createMap方法可以创建一个 TiledMap 地图。基础的参数说明如图3-2所示。 （图3-2） 3.2.2 创建地图示例 const { regClass, property } = Laya; @regClass() export class Main extends Laya.Script { private tMap:Laya.TiledMap; onEnable() { //创建地图对象 this.tMap = new Laya.TiledMap(); //创建Rectangle实例，视口区域 var viewRect:Laya.Rectangle = new Laya.Rectangle(0, 0, Laya.stage.designWidth, Laya.stage.designHeight); //创建TiledMap地图 this.tMap.createMap(\"resources/TiledMap/orthogonal.json\", viewRect, new Laya.Handler(this, this.completeHandler)); } //添加地图到Scene2D下 private onLoaded(): void { this.tMap.mapSprite().removeSelf(); this.owner.addChild(this.tMap.mapSprite()); } //地图加载完成的回调 private completeHandler(e: any = null): void { this.onLoaded(); } } 编译运行代码，效果如图3-3所示，说明地图已创建成功。 （图3-3） 3.3 控制地图 控制地图必须要先加载地图的json，然后在回调方法里控制。下面将结合实例了解相关的用法。 3.3.1 地图的缩放 laya.map.TiledMap类中的scale属性可以控制地图的缩放比例。我们沿用之前的示例，在createMap方法内，增加回调，然后使用scale属性对地图进行缩放。 示例代码如下： private onLoaded():void { this.tMap.mapSprite().removeSelf(); this.owner.addChild(this.tMap.mapSprite()); //将原地图放大2倍 this.tMap.scale = 2; } 运行效果如图3-4所示。 （图3-4） 3.3.2 设置地图缩放的中心点 很明显，图3-4中的效果并不是我们想要的。放大后。有一部分并没有显示出来。这是默认的缩放的中心点是在视口的中心区域造成的。 视口区域与默认的缩放中心点位置 视口区域在创建地图方法 （createMap）的第二个参数中所设置， //创建地图对象 this.tMap = new Laya.TiledMap(); //创建Rectangle实例，视口区域 var viewRect:Laya.Rectangle = new Laya.Rectangle(0, 0, Laya.stage.designWidth, Laya.stage.designHeight); //创建TiledMap地图 this.tMap.createMap(\"resources/TiledMap/orthogonal.json\", viewRect, new Laya.Handler(this, this.completeHandler)); 通过查看代码，我们发现视口被设置为（ Laya.stage.designWidth, Laya.stage.designHeight）。而控制缩放的方法 setViewPortPivotByScale 默认值为0.5。那么中心点位置如图3-5所图。 （图3-5） 当地图放大两倍时（this.tMap.scale = 2;）由于是以视口区域的x与y轴的中心点进行的缩放，所以放大后，会产生图3-6的效果。 （图3-6） 下面我们通过动图3-7，从原图比例的0.1到2倍的缩放变化效果，来进一步理解scale属性的中心点。 （动图3-7） 用setViewPortPivotByScale方法设置缩放中心点 前文中介绍的是默认的缩放中心点效果。那如何设置和改变缩放中心点呢。在laya.map.TiledMap类中的setViewPortPivotByScale()方法可以设置视口的中心点。API基础说明如图3-8所示。 （图3-8） setViewPortPivotByScale() 方法的第一个参数 scaleX 是X轴方向的缩放坐标比例，scaleY 是Y轴方向的缩放坐标比例。 例如： this.tMap.setViewPortPivotByScale(0.1,0.5); 代码说明： 假设视口大小为1136*640 scaleX 值 0.1 表示x轴缩放中心点的坐标为113.6（1136*0.1） scaleY 值 0.5 表示y轴缩放中心点的坐标为320（640*0.5） 代码运行时以x轴113.6，y轴320为视口的中心点坐标进行缩放。 将缩放中心点设置为视口的左上角 当 setViewPortPivotByScale 的缩放中心点设置为0,0时，为视口的左上角。继续沿用前面的示例，编码如下： //添加地图到Scene2D下 private onLoaded(): void { this.tMap.mapSprite().removeSelf(); this.owner.addChild(this.tMap.mapSprite()); //设置缩放中心点为视口的左上角 this.tMap.setViewPortPivotByScale(0,0); //将原地图放大2倍 this.tMap.scale = 2; } 将缩放中心点设置在视口的左上角，再放大2倍时，效果如图3-9所示。 （图3-9） 3.4 拖动地图 当地图被放大后，无法全部显示。这时就需要拖动地图查看全部。 拖动地图除了前文中介绍的方法外，还需要用到moveViewPort()（移动视口）方法和changeViewPort()（改变视口大小）方法。 这两个API的基础说明如图3-10与3-11所示。 （图3-10） （图3-11） 下面直接查看代码，了解这两个方法的使用。 const { regClass, property } = Laya; @regClass() export class Main extends Laya.Script { private tMap:Laya.TiledMap; private MapX:number = 0; private MapY:number = 0; private mLastMouseX:number; private mLastMouseY:number; onEnable() { //创建地图对象 this.tMap = new Laya.TiledMap(); //创建Rectangle实例，视口区域 var viewRect:Laya.Rectangle = new Laya.Rectangle(0, 0, Laya.stage.designWidth, Laya.stage.designHeight); //创建TiledMap地图 this.tMap.createMap(\"resources/TiledMap/orthogonal.json\", viewRect, new Laya.Handler(this, this.completeHandler)); } //添加地图到Scene2D下 private onLoaded(): void { this.tMap.mapSprite().removeSelf(); this.owner.addChild(this.tMap.mapSprite()); //设置缩放中心点为视口的左上角 this.tMap.setViewPortPivotByScale(0,0); //将原地图放大3倍 this.tMap.scale = 3; Laya.stage.on(Laya.Event.RESIZE,this,this.resize); Laya.stage.on(Laya.Event.MOUSE_DOWN, this, this.mouseDown); Laya.stage.on(Laya.Event.MOUSE_UP, this, this.mouseUp); this.resize(); } //地图加载完成的回调 private completeHandler(e: any = null): void { this.onLoaded(); } /** * 移动地图视口 */ private mouseMove():void{ var moveX:number = this.MapX - (Laya.stage.mouseX - this.mLastMouseX); var moveY:number = this.MapY - (Laya.stage.mouseY - this.mLastMouseY) //移动地图视口 this.tMap.moveViewPort(moveX, moveY); } private mouseUp():void { this.MapX = this.MapX - (Laya.stage.mouseX - this.mLastMouseX); this.MapY = this.MapY - (Laya.stage.mouseY - this.mLastMouseY); Laya.stage.off(Laya.Event.MOUSE_MOVE, this, this.mouseMove); } private mouseDown():void { this.mLastMouseX = Laya.stage.mouseX; this.mLastMouseY = Laya.stage.mouseY; Laya.stage.on(Laya.Event.MOUSE_MOVE, this, this.mouseMove); } /** * 改变视口大小 * 重设地图视口区域 */ private resize():void { //改变视口大小 this.tMap.changeViewPort(this.MapX, this.MapY, Laya.stage.designWidth, Laya.stage.designHeight); } } 代码运行效果如动图3-12所示。 （动图3-12） 四、Tiled Map 使用优化 4.1 销毁地图 当Tiled Map不再使用的时候，需要使用destroy()方法进行销毁，回收被占用的内存。 例如： this.tMap.destroy(); 4.2 缓存相关 4.2.1 开启和关闭自动缓存 LayaAir引擎使用TiledMap时，默认会将没有动画的地块自动缓存起来，并且缓存类型默认为normal。 //自动缓存没有动画的地块 this.tMap.autoCache = true; //自动缓存的类型，地图较大时建议使用normal this.tMap.autoCacheType = \"normal\"; //消除缩放导致的缝隙，也就是去黑边 this.tMap.antiCrack = true; 以上的代码属性是引擎的默认值，在多数情况下，保持默认值即可，无需额外设置。 那么为什么要再介绍一遍呢？ 因为有的时候，缓存后的Tiled地图会出现黑边（缝隙）。尽管有 antiCrack 属性，可以消除绝大多数因 normal 缓存导致的黑边。但如果偶现的黑边问题仍未得到解决时。可以通过关闭自动缓存来解决黑边（缝隙）问题。 4.2.2 设置缓存区块大小 缓存区块的设置推荐 TiledMap 地图都是由一个个单元区块拼接组成。如果缓存时保持原大小，当小图区块很多时会对性能产生影响。因此建议开启缓存区块设置，并将缓存区块的大小设置为512像素左右，必须保持原小图区块的整数倍。 例如，本文示例中的单图区块大小为16*16，那么缓存区块可以设置 16的32倍，即为 512*512。 如果单图是15*15，缓存可区块可以设置为510*510（34倍），以此类推，尽量在原区块整数倍的前提下，设置在512左右。推荐为 512*512。 缓存区块的具体设置方法 缓存区块的设置需要在 createMap（创建地图）的时候设置。设置第四个参数 gridSize，示例如下： //为第二个参数创建Rectangle实例，视口区域 var viewRect:Laya.Rectangle = new Laya.Rectangle(0, 0, Laya.Browser.width, Laya.Browser.height); //为第四个参数gridSize创建一个512*512大小的Point对象实例 var gridSize:Laya.Point = new Laya.Point(512, 512); //创建TiledMap地图 this.tMap.createMap(\"res/TiledMap/orthogonal.json\",viewRect, Laya.Handler.create(this,this.onMapLoaded), null, gridSize); 4.3 合并图层 4.3.1 开启合并图层 当 TiledMap 里有多个图层时，开启合并图层的属性 enableMergeLayer，可以将图层合并，会对性能有所提高。 开启的方式为： //开启图层合并 this.tMap.enableMergeLayer = true; Tips: 需要注意的是，如果需要对合并前的图层进行操作，那就不能直接合并。因为合并后会导致无法对合并前的图层进行操作。 4.3.2 图层合并分组 如果没有在 TiledMap 里将图层分组，那么图层合并时，会将所有图层合并到一起。因此，需要分为多个图层并分别操作时。可以在 TiledMap 里将图层分组。 TiledMap图层分组方式 打开 TiledMap 地图编辑器，选中要分组的图层，在图层的自定义属性栏，添加一个名为layer的string类型属性。操作如图4-1所示。 （图4-1） 点击OK，添加完成后，将所有添加了自定义属性layer的图层。设置分组名称。 例如，我们将块层2与块层3的分组名称设置为 layaAir，那么名为 layaAir 的图层，开启 enableMergeLayer 后，会合并到同一个图层。操作如图4-2所示。 (图4-2) 开启合并图层时，图层属性内可添加layer属性，运行时将会将相邻的layer属性相同的图层进行合并以提高性能 4.4 移除被覆盖的格子 如果下层的格子被遮挡，并且遮挡地块并不是透明的，那么被遮挡的部分直接移除而不被渲染，可以提高性能。 移除被覆盖的开启方式为： //移除被非透明地块覆盖的部分 this.tMap.removeCoveredTile = true; Tips： 如果开启后，需要对移除的部分进行操作，是不可能的。所以开启该功能前要确认，不再对移除部分进行操作。 removeCoveredTile 开启的前提 如果在Tiled Map中没有对图块设置 type 属性，那么即便开启了 removeCoveredTile ，也是无效的。所以，开启之前，需要先在 TiledMap 编辑器中，为图块新增自定义属性type，并将设置为1。 Tiled Map中设置图块type的操作方式 在图块面板中，点击图块编辑，打开图块地形编辑面板。操作如图4-3所示。 (图4-3) 在图块地形编辑面板内，选中地形，在自定义属性栏，点击+号图标，添加int类型的type属性。然后点击OK，完成添加。操作如图4-4所示。 (图4-4) 完成添加后，设置type属性值为1。操作如图4-5所示。 (图4-5) 只要是自定义属性type设置为1的地形，当 removeCoveredTile 开启后。被遮挡不可见时都可以被移除，以提高性能。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:43 "},"2D/performanceOptimization/readme.html":{"url":"2D/performanceOptimization/readme.html","title":"2D性能优化","keywords":"","body":"性能优化一、 内存优化方式1.1 通过对象池优化内存1.2 释放内存1.3 资源卸载1.4 关于滤镜、遮罩二、渲染优化方式2.1 优化Sprite2.2 优化DrawCall2.3 优化Canvas2.4 CacheAs2.5 文字描边2.6 跳过文本排版，直接渲染三、减少CPU使用量3.1 减少动态属性查找3.2 性能消耗的回收3.3 获取显示对象边界的做法3.4 根据活动状态改变帧频3.5 使用callLater3.6 图片/图集加载四、其它优化策略4.1 减少粒子的使用数量4.2 尽量减少旋转，缩放，alpha等属性的使用4.3 不要在Timer的循环里创建对象及复杂计算4.4 尽量少用autoSize与getBounds4.5 被try catch的函数执行会变得非常慢五、使用chrome的性能分析器5.1 CPU占用分析5.2 内存占用分析六、纹理压缩的使用性能优化 一、 内存优化方式 1.1 通过对象池优化内存 对象池优化是游戏开发中非常重要的优化方式，也是影响游戏性能的重要因素之一。 在游戏中有许多对象在不停的创建与移除，比如角色攻击子弹、特效的创建与移除，NPC的被消灭与刷新等，在创建过程中非常消耗性能，特别是数量多的情况下。 对象池技术能很好解决以上问题，在对象移除消失的时候回收到对象池，需要新对象的时候直接从对象池中取出使用。 优点是减少了实例化对象时的开销，且能让对象反复使用，减少了新内存分配与垃圾回收器运行的机会。 注意：对象移除时并不是立即从内存中抹去，只有认为内存不足时，才会使用垃圾回收机制清空，清空时很耗内存，很可能就会造成卡顿现象。用了对象池后将减少程序的垃圾对象，有效的提高程序的运行速度和稳定性。 具体使用方式请参考《对象池》文档 1.2 释放内存 JavaScript运行时无法启动垃圾回收器。要确保一个对象能够被回收，需要删除对该对象的所有引用。Sprite提供的destory()方法会帮助设置内部引用为null。 例如，以下代码确保对象能够被作为垃圾回收： //创建一个Sprite实例 var sp:Laya.Sprite = new Laya.Sprite(); //将sp内部引用设置为null sp.destroy(); 当对象设置为null，不会立即将其从内存中删除。只有系统认为内存足够低时，垃圾回收器才会运行。内存分配（而不是对象删除）会触发垃圾回收。 垃圾回收期间可能占用大量CPU并影响性能。通过重用对象，尝试限制使用垃圾回收。此外，尽可能将引用设置为null，以便垃圾回收器用较少时间来查找对象。有时（比如两个对象相互引用），无法同时设置两个引用为null，垃圾回收器将扫描无法被访问到的对象，并将其清除，这会比引用计数更消耗性能。 1.3 资源卸载 游戏运行时总会加载许多资源，这些资源在使用完成后应及时卸载，否则一直残留在内存中。 下例演示加载资源后对比资源卸载前和卸载后的资源状态： var assets: Array = [] assets.push(\"resources/apes/monkey0.png\"); assets.push(\"resources/apes/monkey1.png\"); assets.push(\"resources/apes/monkey2.png\"); assets.push(\"resources/apes/monkey3.png\"); Laya.loader.load(assets).then(()=>{ for(var i:number = 0, len: number = assets.length; i 1.4 关于滤镜、遮罩 尝试尽量减少使用滤镜效果。将滤镜（BlurFilter和GlowFilter）应用于显示对象时，运行时将在内存中创建两张位图。其中每个位图的大小与显示对象相同。将第一个位图创建为显示对象的栅格化版本，然后用于生成应用滤镜的另一个位图： （图1-1） 应用滤镜时内存中的两个位图 当修改滤镜的某个属性或者显示对象时，内存中的两个位图都将更新以创建生成的位图，这两个位图可能会占用大量内存。此外，此过程涉及CPU计算，动态更新时将会降低性能。 ColorFiter在WebGL下的GPU消耗可以忽略不计。 最佳的做法是，尽可能使用图像创作工具创建的位图来模拟滤镜。避免在运行时中创建动态位图，可以帮助减少CPU或GPU负载。特别是一张应用了滤镜并且不会在修改的图像。 二、渲染优化方式 2.1 优化Sprite 尽量减少不必要的层次嵌套，减少Sprite数量。 非可见区域的对象尽量从显示列表移除或者设置visible=false。 对于容器内有大量静态内容或者不经常变化的内容（比如按钮），可以对整个容器设置cacheAs属性，能大量减少Sprite的数量，显著提高性能。如果有动态内容，最好和静态内容分开，以便只缓存静态内容。 Panel内，会针对panel区域外的直接子对象（子对象的子对象判断不了）进行不渲染处理，超出panel区域的子对象是不产生消耗的。 2.2 优化DrawCall 对复杂静态内容设置cacheAs，能大量减少DrawCall，使用好cacheAs是游戏优化的关键。 尽量保证同图集的图片渲染顺序是挨着的，如果不同图集交叉渲染，会增加DrawCall数量。 尽量保证同一个面板中的所有资源用一个图集，这样能减少提交批次。 2.3 优化Canvas 在对Canvas优化时，我们需要注意，在以下场合不要使用cacheAs： 对象非常简单，比如一个字或者一个图片，设置cacheAs=”bitmap”不但不提高性能，反而会损失性能。 容器内有经常变化的内容，比如容器内有一个动画或者倒计时，如果再对这个容器设置cacheAs=”bitmap”，会损失性能。 可以通过查看Canvas统计信息的第一个值，判断是否一直在刷新Canvas缓存。 2.4 CacheAs 设置cacheAs可将显示对象缓存为静态图像，当cacheAs时，子对象发生变化，会自动重新缓存，同时也可以手动调用reCache方法更新缓存。 建议把不经常变化的复杂内容，缓存为静态图像，能极大提高渲染性能，cacheAs有”none”，”normal”和”bitmap”三个值可选。 默认为”none”，不做任何缓存。 当值为”normal”时，进行命令缓存。 当值为”bitmap”时，使用renderTarget缓存。这里需要注意的是，webGL下renderTarget缓存模式有2048大小限制，超出2048会额外增加内存开销。另外，不断重绘时开销也比较大，但是会减少drawcall，渲染性能最高。 webGL下命令缓存模式只会减少节点遍历及命令组织，不会减少drawcall，性能中等。 设置cacheAs后，还可以设置staticCache=true以阻止自动更新缓存，同时可以手动调用reCache方法更新缓存。 cacheAs主要通过两方面提升性能。一是减少节点遍历和顶点计算；二是减少drawCall。善用cacheAs将是引擎优化性能的利器。 下例绘制10000个文本(根据电脑性能而定，本例为10000)： class Test { private text:Laya.Text; constructor() { Laya.init(550,400,Laya.WebGL); Laya.Stat.show(); var textBox=new Laya.Sprite(); for(var i=0;i 下面是笔者电脑上的运行时截图，FPS稳定于52上下。 （图2-1） 当我们对文字所在的容器设置为cacheAs之后，如下面的例子所示，性能获得较大的提升，FPS达到到了60帧。 //...省略其他代码 var textBox=new Laya.Sprite(); textBox.cacheAs=\"bitmap\"; //...省略其他代码 （图2-2） 2.5 文字描边 在运行时，设置了描边的文本比没有描边的文本多调用一次绘图指令。此时，文本对CPU的使用量和文本的数量成正比。因此，尽量使用替代方案来完成同样的需求。 · 对于几乎不变动的文本内容，可以使用cacheAs降低性能消耗 · 对于内容经常变动，但是使用的字符数量较少的文本域，可以选择使用位图字体。 2.6 跳过文本排版，直接渲染 大多数情况下，很多文本都不需要复杂的排版，仅仅简单地显示一行字。为了迎合这一需求，Text提供的名为changeText的方法可以直接跳过排版。 this.text.text=\"text\"; Laya.stage.addChild(this.text); //后面只是更新文字内容，使用changeText能提高性能 this.text.changeText(\"text changed.\"); Text.changeText会直接修改绘图指令中该文本绘制的最后一条指令，这种前面的绘图指令依旧存在的行为会导致changeText只使用于以下情况： · 文本始终只有一行。 · 文本的样式始终不变（颜色、粗细、斜体、对齐等等）。 即使如此，实际编程中依旧会经常使用到这样的需要。 三、减少CPU使用量 3.1 减少动态属性查找 JavaScript中任何对象都是动态的，你可以任意地添加属性。然而，在大量的属性里查找某属性可能很耗时。如果需要频繁使用某个属性值，可以使用局部变量来保存它： foo() { var prop=this.target.prop; //使用prop this.process1(prop); this.process2(prop); this.process3(prop); } 3.2 性能消耗的回收 日常在使用消耗性能的功能时，尤其是循环处理，当无需使用时，一定要及时回收，或停止循环。 LayaAir提供两种计时器循环来执行代码块。 Laya.timer.frameLoop执行频率依赖于帧频率，可通过Stat.FPS查看当前帧频。 Laya.timer.loop执行频率依赖于参数指定时间。 Laya.timer.frameLoop(1, this, this.animateFrameRateBased); Laya.stage.on(\"click\", this, this.dispose); dispose() { Laya.timer.clear(this, this.animateFrameRateBased); } 当一个对象的生命周期结束时，记得清除其内部的Timer 3.3 获取显示对象边界的做法 在相对布局中，很经常需要正确地获取显示对象的边界。获取显示对象的边界也有多种做法，而其间差异很有必要知道。 使用getBounds/ getGraphicBounds。 var sp=new Laya.Sprite(); sp.graphics.drawRect(0,0,100,100,\"#FF0000\"); var bounds:Laya.Rectangle=sp.getGraphicBounds(); Laya.stage.addChild(sp); getBounds可以满足多数多数需求，但由于其需要计算边界，不适合频繁调用。 设置容器的autoSize为true。 var sp=new Laya.Sprite(); sp.autoSize=true; sp.graphics.drawRect(0,0,100,100,\"#FF0000\"); Laya.stage.addChild(sp); 上述代码可以在运行时正确获取宽高。autoSize在获取宽高并且显示列表的状态发生改变时会重新计算（autoSize通过getBoudns计算宽高）。所以对拥有大量子对象的容器应用autoSize是不可取的。如果设置了size，autoSize将不起效。 使用loadImage后获取宽高： var sp=new Laya.Sprite(); sp.loadImage(\"res/apes/monkey2.png\",0,0,0,0,Laya.Handler.create(this,function() { console.log(sp.width,sp.height); })); Laya.stage.addChild(sp); loadImage在加载完成的回调函数触发之后才可以正确获取宽高。 直接调用size设置： Laya.loader.load(\"res/apes/monkey2.png\",Laya.Handler.create(this,function() { var texture=Laya.loader.getRes(\"res/apes/monkey2.png\"); var sp=new Laya.Sprite(); sp.graphics.drawTexture(texture,0,0); sp.size(texture.width,texture.height); Laya.stage.addChild(sp); })); 使用Graphics.drawTexture并不会自动设置容器的宽高，但是可以使用Texture的宽高赋予容器。毋庸置疑，这是最高效的方式。 注：getGraphicsBounds用于获取矢量绘图宽高。 3.4 根据活动状态改变帧频 帧频有三种模式， Stage.FRAME_FAST fast模式，最高FPS为显示器的最大帧率，如果显示器最大帧率是60，则最大FPS为60，显示器最大帧率是120，则最大FPS为120。 Stage.FRAME_SLOW slow模式，最高FPS为显示器最大帧率的一半，在游戏运行的过程中，引擎会隔帧丢弃。如果实际可以达到40帧，那游戏最终帧率只是20，如果帧率能达到100，那最终帧只能是50。 Stage.FRAME_MOUSE mouse模式则选择性在fast模式与slow模式之间切换，有时并不需要让游戏以满帧速率执行，比如60帧满帧的时候，30FPS已经能够满足多数情况下人类视觉的响应，但是鼠标交互时，30FPS可能会造成画面的不连贯，于是Stage.FRAME_MOUSE应运而生。 下例展示以Stage.FRAME_SLOW的帧率，在画布上移动鼠标，使圆球跟随鼠标移动： Laya.init(this.Browser.width,this.Browser.height); Laya.Stat.show(); Laya.stage.frameRate=Laya.Stage.FRAME_SLOW; var sp=new Laya.Sprite(); sp.graphics.drawCircle(0,0,20,\"#990000\"); Laya.stage.addChild(sp); Laya.stage.on(Laya.Event.MOUSE_MOVE,this,function() { sp.pos(Laya.stage.mouseX,Laya.stage.mouseY); }); （图3-1） 此时FPS显示30，并且在鼠标移动时，可以感觉到圆球位置的更新不连贯。设置Stage.frameRate为Stage.FRAME_MOUSE： Laya.stage.frameRate = Laya.Stage.FRAME_MOUSE; （图3-2） 此时在鼠标移动后FPS会显示60，并且画面流畅度提升。在鼠标静止2秒不动后，FPS又会恢复到30帧。 3.5 使用callLater callLater使代码块延迟至本帧渲染前执行。如果当前的操作频繁改变某对象的状态，此时可以考虑使用callLater，以减少重复计算。 考虑一个图形，对它设置任何改变外观的属性都将导致图形重绘： var rotation=0, scale=1, position=0; private function setRotation(value):void { this.rotation=value; update(); } private function setScale(value):void { this.scale = value; update(); } private function setPosition(value):void { this.position = value; update(); } public function update() { console.log('rotation: ' + this.rotation + '\\tscale: ' + this.scale + '\\tposition: ' + this.position); } 调用以下代码更改状态： setRotation(90); setScale(2); setPosition(30); 控制台的打印结果是: rotation: 90scale: 1position: 0 rotation: 90scale: 2position: 0 rotation: 90scale: 2position: 30 update被调用了三次，并且最后的结果是正确的，但是前面两次调用都是不需要的。 尝试将三处update改为： Laya.timer.callLater(this, update); 此时，update只会调用一次，并且是我们想要的结果。 3.6 图片/图集加载 在完成图片/图集的加载之后，引擎就会开始处理图片资源。如果加载的是一张图集，会处理每张子图片。如果一次性处理大量的图片，这个过程可能会造成长时间的卡顿。 在游戏的资源加载中，可以将资源按照关卡、场景等分类加载。在同一时间处理的图片越少，当时的游戏响应速度也会更快。在资源使用完成后，也可以予以卸载，释放内存。 四、其它优化策略 4.1 减少粒子的使用数量 由于粒子属于矢量绘制，大量使用粒子对CPU压力大，但WebGL模式下可以采用GPU运算，能减轻CPU压力，但也要尽量控制，尤其是移动平台，减少使用量。 4.2 尽量减少旋转，缩放，alpha等属性的使用 旋转，缩放，alpha等属性，这些属性会对性能产生消耗，不过引擎采用WebGL渲染模式，极大优化了性能。 4.3 不要在Timer的循环里创建对象及复杂计算 由于Timer的loop()与frameLoop()方法里会不断的循环执行，当创建对象及复杂计算时，会导致大量的性能消耗出现在循环里，因此，尽可能不要在循环里创建对象及复杂计算。 4.4 尽量少用autoSize与getBounds autoSize()与getBounds()需要大量计算，对性能的影响较大，尽量少用。 4.5 被try catch的函数执行会变得非常慢 项目中尽量减少try catch的使用，被try catch的函数执行会变得非常慢。 五、使用chrome的性能分析器 性能分析器（Profiles）是 chrome 开发者工具的一部分，可以通过在页面右键选择审查元素或在谷歌浏览器页面按F12 打开 chrome 开发者工具。然后点击 Profiles 切换至性能分析器（Profiles）面板。 5.1 CPU占用分析 启动CPU性能分析器 选中 Record JavaScript CPU Profile，点击 Start 按钮或左上角的实心圆点，这个时候Chrome 就会开始记录当前网页的方法的执行。如图5-1所示。 （图5-1） 结束CPU性能分析器的监控 结束这个性能分析器的监控记录需要点击Stop按钮（或左侧的红色实心圆圈）。如图5-2所示。 （图5-2） 查看CPU性能分析器的记录 结束监控后，在左侧 Profiles 下会列出一个监控结果文件，单击可以打开此监控结果文件。如图5-3所示 （图5-3） 监控结果是以数据表格形式展现的。我们可以根据消耗排行，找到Function中提供的函数名，针对性能消耗较大的地方进行优化。 5.2 内存占用分析 启动内存分析 选中 Take Heap Snapshot，点击 Take Snapshot 按钮（也可以点击左边黑色实心圆圈），如图5-4所示， （图5-4） 生成的内存快照文件是以数据表格的形式记录了，当前网页对象的个数、所占的内存大小等。 内存快照记录 在启动内存分析后，很快就会在左侧的 Profiles 栏目下生成一个当前网页的内存快照记录文件。单击可以查看相关数据，如图5-5所示。 （图5-5） 内存快照分析 在拍完第一个内存快照后，点击左上角的圆点，可以记录一个新的内存快照。单击选择第二个内存快照，可以选择 Comparison 模式对此第二个快照与第一个快照之间的变化。通过分析，对网页进行优化。 （图5-6） （图5-7） 六、纹理压缩的使用 使用纹理压缩的好处： 1，降低内存，特别是移动端应用，内存占用不应过大，否则低端机很容易崩溃 2，降低带宽，手游类应用，在渲染时会有大量贴图传输到GPU，不限制的话不仅会严重影响渲染性能，同时会带来很严重的发热 具体使用方式请参考《纹理压缩》文档 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-10-08 19:41:50 "},"2D/useWorker/readme.html":{"url":"2D/useWorker/readme.html","title":"多线程Worker","keywords":"","body":"多线程worker原生worker属性Laya中应用多线程worker 本文档中的worker仅限于浏览器模式中的HTML5模式运行支持，LayaNative打包APP方案中暂不支持worker 从传统意义上来说，浏览器是单线程的，它们会强制应用程序中的所有脚本一起在单个 UI 线程中运行。虽然你可以通过使用文档对象模型 (DOM) 事件和 setTimeout等API 造成一种多个任务同时在运行的假象，但只需一个计算密集型任务就会使用户体验急转直下。在html5引入了worker的功能，通过使用Web Worker， 我们可以在浏览器后台运行JavaScript， 而不占用浏览器自身线程。Web Worker可以提高应用的总体性能，并且提升用户体验。线程可以执行任务而不干扰用户界面。 原生worker web worker分为两种，专用线程dedicated web worker，以及共享线程shared web worker。 Dedicated web worker随当前页面的关闭而结束；这意味着Dedicated web worker只能被创建它的页面访问。与之相对应的Shared web worker可以被多个页面访问。但是web worker有些限制，并非所有的接口和方法都能使用。 Web Worker无法访问DOM节点； Web Worker无法访问全局变量或是全局函数； Web Worker无法调用alert()或者confirm之类的函数； Web Worker无法访问window、document之类的浏览器全局变量； workder 支持的函数 页面提供了一个 worker 支持的全局函数列表。开发者可以自己看下相应的方法。 方法概述 构造函数Worker() 该构造函数创建一个 web worker，它能执行位于指定 URL 上的脚本。脚本必须遵循 同源策略。 postMessage()： 向 worker 的内部作用域内传递消息。该方法接收一个单独的参数，即要传递给 worker 的数据。数据可以是任何值或者是经过结构化拷贝算法处理过的 JavaScript 对象，换句话说，可以包含循环引用。 #参数 aMessage 传输给 worker 的对象；它将包含于传递给 onmessage 处理函数的事件对象中的 data 字段内。你可以传递任意值或是经过结构化拷贝算法处理过的 JavaScript 对象，即可以包含循环引用。 transferList 一个可选的对象数组，用于转让它们的所有权。如果一个对象的所有权被转让，那么它在原来的上下文内将不可使用，而只能在转让到的 worker 内可用。 terminate() 立即终止 worker。该方法不会给 worker 留下任何完成操作的机会；就是简单的立即停止 属性 Property Type Description onmessage EventListener 一个事件监听函数，每当拥有message属性的MessageEvent从worker中冒泡出来时就会执行该函数。事件的data属性存有消息内容。 onerror EventListener 一个事件监听函数，每当类型为error的ErrorEvent 从 worker 中冒泡出来时就会执行该函数。 下面我们用原生js看下如何使用。 新建一个js文件，放到index.html中。代码如下： var myWorker = new Worker(\"js/my_task.js\"); myWorker.onmessage = function (oEvent) { console.log(\"Called back by the worker!\\n\"); }; myWorker.postMessage(\"start\"); // start the worker. 新建一个my_task.js文件，放到js文件夹下，代码如下： self.addEventListener('message', function (e) { var xmlreq = new XMLHttpRequest(); xmlreq.responseType = \"text\"; xmlreq.onload = function (e) { var data = e.currentTarget.response; self.postMessage(data); } xmlreq.open(\"get\",\"../atlas/comp.json\"); xmlreq.send() }, false); 这个例子是在worker中进行加载文件，加载完毕传给主进程，运行这个例子可以在浏览器控制台看到数据输出来。 var myWorker = new Worker(\"my_task.js\")实例化一个worker，传进去一个js文件，通过myWorker.postMessage(\"start\")通知worker线程启动。 self.addEventListener('message',xxx)监听主线程通知的消息。 self.postMessage(data);发送数据给主线程。 注意：web worker不支持文件协议，所以直接打开是不能运行的，开发者可以配合IDE内置的服务器，通过网址来运行就可以看到效果。打开控制台可以看到数据已经打印出来了。 Laya中应用 在LayaAir3.0中内部封装了worker，解决加载解码图片卡顿现象，开发者可以打开开关，也可以自定义worker，解决项目中耗费cpu的地方，下面我们分别来介绍下。 新建一个项目，为了方便显示，我们新建一个ui项目。简单的调用接口如下： class LayaUISample { constructor() { //初始化引擎 Laya.init(600,400,Laya.WebGL); //设置Laya提供的worker.js路径 Laya.WorkerLoader.workerPath = \"libs/worker.js\"; //开启worker线程 Laya.WorkerLoader.enable = true; //加载引擎需要的资源 Laya.loader.load(\"../atlas/comp.atlas\",Laya.Handler.create(this,this.onLoaded)); } private onLoaded():void{ //实例UI界面 var testView:ui.test.TestPageUI = new ui.test.TestPageUI(); Laya.stage.addChild(testView); } } new LayaUISample; WorkerLoader.workerPath = \"libs/worker.js\"; 设置worker.js的路径，这个worker.js是Laya官方提供的，我们把他拷贝复制到我们自己设置的路径，这个js在Laya的引擎库当中。我这里设置的是libs下。 WorkerLoader.enable = true; 开启worker模式加载解码图片，大大解放了主线程解码的压力。 上面的方法是2.0官方的解码的做法，在LayaAir3.0中我们也可以自定义worker来优化项目当中的耗费cpu的地方。 下面通过简单的例子来演示下用法。我们可以把教程开头的js脚本移植过来。 var worker:any = new Laya.Browser.window.Worker(\"js/my_task.js\"); worker.onmessage = function(oEvent):void{ console.log(\"Called back by the worker!\\n\"); }; worker.postMessage(\"start\"); // start the worker. my_task.js中的代码还是加载一个文件。代码如下： self.addEventListener('message', function (e) { var xmlreq = new XMLHttpRequest(); xmlreq.responseType = \"text\"; xmlreq.onload = function (e) { var data = e.currentTarget.response; self.postMessage(data); } xmlreq.open(\"get\",\"../atlas/comp.atlas\"); xmlreq.send() }, false); 编译运行代码，可以看到控制台输出了我们加载comp.atlas的数据。 总结：web worker我们一般应用到解析加载大的文件，比如大的json文件，比较费时的计算，或者不需要即时加载的一些资源都可以放到后台线程来完成，这样用户基本感受不到主线程的卡顿。增强项目的流畅性。提高用户体验。 详细的Web Workers，请看 W3C的xhr 标准; 详细的api和介绍参考这里 workder 支持的函数 页面提供了一个 worker 支持的全局函数列表。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2024-03-01 11:00:43 "},"2D/dom/readme.html":{"url":"2D/dom/readme.html","title":"和原生Dom交互","keywords":"","body":"LayaAir和原生DomLayaAir之SVGLayaAir之Dom元素ImageLayaAir之Dom元素videoLayaAir之dom元素FileLayaAir之dom元素script标签LayaAir之dom元素iframeLayaAir和原生Dom 在开发项目中，开发者难免遇到dom元素支持，但是LayaAir中不支持或者支持的不完善。那么本节我们就来看下在开发中遇到的一些技巧。 LayaAir之SVG 什么是svg？可能大部分开发者听说过这个名词，或者也知道它是w3c规定的矢量图像描述格式。关于svg的一些定义和历史这里我们不再陈述，感兴趣的开发者可以参考这里。但是在项目中真正用到它的地方很少。但是svg的强大是不容忽视的，有些简单的图形，几行文本就可以描述出来，不必进行网络的加载。比如丰富的艺术字，比如奇形怪状的图形，比如文字的透视效果等等假如用程序实现，可能会困难重重，比如下面这个： 假如你的项目中有这种文字如何处理呢？可能我们想到的是美术出图片。那有没有更简单的方法呢？这里我们选择用svg来进行处理。我们知道在dom元素中用div+css样式来显示这种效果是最简单快捷的方法。那么我们来借助css样式来展示这种效果。下面我们看下简单的脚本怎么实现这种效果。 var data = '' + '' + '' + 'I like ' + '' + 'cheese' + '' + '' + ''; var DOMURL = window.URL || window.webkitURL || window; var img = new Image(); var svg = new Blob([data], {type: 'image/svg+xml'}); var url = DOMURL.createObjectURL(svg); img.src = url; img.style.position =\"absolute\"; img.style.zIndex = 99999 document.body.appendChild(img); 怎么运行上边这段代码呢？打开谷歌浏览器，随便打开一个空白网页，F12，把上面的代码粘贴到控制台，然后回车，就能看到上面截图的效果。或者新建个html把代码粘贴进去，用浏览器打开。是不是很简单呢？然后我们可以任意修改显示的文字。开发者可以修改试试看效果。我们简单的介绍下这段代码。其中data是svg的数据格式，这个可以参考svg的定义和描述。 //这里是重点，文字的效果我们是通过svg支持的css样式来设置 text-shadow设置的是文字的css样式效果，假如开发者想改变文字的样式，可以修改style即可。 上面是在JavaScript中，用原生的dom元素img来进行显示，那么在游戏中我们想用的话该怎么办呢？这个其实很简单，现在我们已经用img显示到页面上了，那么接下来我们要做的是如何在项目中应用和显示这个img。我们新建个项目。代码如下所示： var data: string = \"data:image/svg+xml,\" + '' + '' + '' + 'I like ' + '' + 'cheese' + '' + '' + ''; var sp: Laya.Sprite = new Laya.Sprite(); sp.loadImage(data, 0, 0, 200, 200); Laya.stage.addChild(sp); 通过data来当做url传递给loadImage这个方法引擎就会帮我们加载并解码显示出来。loadImage这个方法中的参数不仅仅有接收地址的url还接收base64和svg的格式。编译运行上面的代码我们看到下图中的效果。 总结：上面的代码给我们很好的启示，在项目中我们的特殊艺术字可以用这种方法更加简单方便。开发者可以自行找一些更加绚丽的效果，比如3D的透视效果，图文混排，阴影，倒影等等。这种方法不仅仅减少了网络的宽带，更重要的是方便我们时时修改。设置好一种样式，项目中导出都可以应用。假如用上面的方法代替位图字体的做法是不是更加高效快捷呢。 LayaAir之Dom元素Image 在html5中，image标签功能强大，这里我们不想过多的介绍其特性，这里我们介绍简单的击中常用形式。 二维码 比较常见的一种功能是在项目中显示当前的二维码地址。用户长按可以识别。这里生成二维码，我们借助第三方的js类库来生成二维码。类库代码可以再GitHub上下载，这里用的是这个地址。 新建个项目，把下载的qrcode.js添加到index.html中。qrcode的api请参考地址。具体的逻辑代码如下： var div:any = Laya.Browser.document.createElement(\"div\"); this.qrcode = new Laya.Browser.window.QRCode(div,{ width:100, height:100 }); var url:string = \"http://layabox.com/\"; this.qrcode.makeCode(url); Laya.stage.once(\"click\",this,this.clickHandler); this.qrcodeSp = new Laya.Sprite(); Laya.stage.addChild(this.qrcodeSp); 编译运行上面的代码，然后点击舞台可以看到，二维码已经显示到了舞台上，可以用手机扫下，发现手机已经跳转到了官网。注意：这个时候生成的二维码在微信或者浏览器中长按没有任何反应，因为qrcode生成的是canvas标签而不是image标签。所以要想长按弹出识别的选项，只有用image标签才可以。这个开发者可以自行扩展。 LayaAir之Dom元素video 视频直播 在html5时代，视频播放基本用的是video标签来播放，视频播放假如没有丰富的经验，最好的选择是用成熟的播放插件来实现。目前流行的是video.js, hls.js, plyr.js。无论在兼容性，体验和性能方面都是非常优秀的。这些插件的官方都给出了的demo。比如https://plyr.io/，http://video-dev.github.io/hls.js/demo/，http://codepen.io/sampotts/pen/JKEMqB。 下面我们就以Plyr + hls.js来为例子，看看在LayaAir中我们应该怎么写。 在index.html文件中加入如下代码： 播放器的样式文件， 添加video标签。命名id为“player”，这个一会我们在程序中会用到。 这是播放器用到的类库。开发者在生产环境中记得下载到自己的项目中或者服务器中。 下面是主类的逻辑： class LayaUISample { constructor() { //初始化引擎 Laya.init(0,0); var Hls:any = Laya.Browser.window.Hls;//获取对Hls的引用。 var plyr:any = Laya.Browser.window.plyr;//获取对plyr的引用 //获取video对象，就是页面上命名为“player”的标签 var video:any = Laya.Browser.document.querySelector('#player'); if(Hls.isSupported()){ var hls:any = new Hls(); //加载m3u8源 hls.loadSource('http://content.jwplatform.com/manifests/vM7nH0Kl.m3u8'); hls.attachMedia(video); hls.on(Hls.Events.MANIFEST_PARSED,function():void{ video.play(); }); } plyr.setup(video); } } new LayaUISample; 编译运行代码，发现网页已经可以播放视频了。开发者可能注意到这里我们初始化引擎的时候是这样的： Laya.init(0,0);//初始化引擎;设置尺寸为0，因为这里我们没有和舞台的交互。所以我们这里设置为0，我们甚至可以不初始化。假如开发者项目中含有和舞台交互的逻辑，可以设置适合自己的尺寸。 在播放的过程中开发者可以F12 打开谷歌的控制台，切换到Network标签看下我们的视频是一段段的ts文件。 随着播放的进行，发现文件的个数越来越多。其实这就是基于hls协议的播放。该技术基本原理是将视频文件或视频流切分成小片(ts)并建立索引文件(m3u8)。更深层次的原理，比如视频解码，视频帧数据，开发者可以参考如下： https://developer.apple.com/streaming/。 https://developer.mozilla.org/zh_CN/docs/Web/API/MediaSource。 https://github.com/nickdesaulniers/netfix https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement 上面的例子我们使用hls+plyr来进行播放。其他的方法请开发者参考本教程进行扩展。 摄像头 html5的video做摄像头浏览器的支持度是有限的，而且需要https的协议谷歌和新版的微信支持度还是不错的。假如你的兼容性不要求那么高，可以尝试下添加摄像头的功能。 下面我们先来看下mdn上给的例子。 https://mdn.github.io/webaudio-examples/stream-source-buffer/ 开发者用手机或者微信打开这个地址测试下你手机的支持度。 这个是个测试的连接，协议也是https的，开发者在调用摄像头的时候要注意这一点。自己的远端地址一定要https。 更多的资料可以参考这里:https://github.com/mdn/webaudio-examples 这里的链接是mdn给出的声音和视频的例子。 LayaAir关于摄像头也有相应的封装，下面我们来看下用法。 class Main { private video:Laya.Video; constructor() { //初始化引擎 Laya.init(Laya.Browser.width,Laya.Browser.height); if(Laya.Media.supported() === false){ alert(\"当前浏览器不支持\"); } else{ this.showMessage(); var options:any = { audio:true, video:{ facingMode: { exact: \"environment\" }, // 后置摄像头，默认值就是，不设至也可以。 width: Laya.stage.width, height:Laya.stage.height } }; Laya.Media.getMedia(options,Laya.Handler.create(this,this.onSuccess),Laya.Handler.create(this,this.onError)); } } private showMessage():void{ var tex:Laya.Text = new Laya.Text(); Laya.stage.addChild(tex); tex.text = \"单击舞台播放和暂停\"; tex.color = \"#ffffff\"; tex.fontSize = 100; tex.valign = \"middle\"; tex.align = \"center\"; tex.size(Laya.stage.width,Laya.stage.height); } private onSuccess(url:string):void{ this.video = new Laya.Video(Laya.stage.width,Laya.stage.height); this.video.load(url); Laya.stage.addChild(this.video); Laya.stage.on(\"click\",this,this.onStageClick); } private onerror(error:Error):void{ alert(error.message); } private onStageClick():void{ //切换播放和暂停 if(!this.video.paused){ this.video.pause(); } else{ this.video.play(); } } } new Main; 编译运行上面的例子，发现打不开。这很正常，运行这个例子要自己搭建一个https的服务器。然后用手机打开这个地址对应的index.html。搭建一个简单的htpps服务器也很简单。这里我们借助Laya的命令行工具就可以。 下载地址https://nodejs.org/en/进行安装。 安装完成之后 打开cmd 命令行，输入 npm install -g layacmd 等待安装完成。 找到我们刚才编译的那个index.html。按住shift+右键 在此处打开cmd窗口 输入layacmd open ，然后就会启动一个http和htpps的静态服务器，根据命令行输出的地址，然后我们用手机谷歌浏览器或者微信访问这个地址 比如我们这里是https://10.10.20.34:8001/index.html。 LayaAir之dom元素File 在项目开发中我们可能会用到让用户上传图片的需求。这个我们需要借助html5的file标签（微信的要用微信提供的接口，后面的教程我们专门在微信教程中讲。其他浏览器也可能存在兼容性问题）。下面我们写的简单的例子。 class Main { private video:Laya.Video; constructor() { //初始化引擎 Laya.init(100,100); var file:any = Laya.Browser.document.createElement(\"input\"); file.type = \"file\"; file.style.position = \"absolute\"; file.style.zIndex = 999; Laya.Browser.document.body.appendChild(file);//添加到舞台 var fileReader:any = new Laya.Browser.window.FileReader(); file.onchange = function(e:any):void { if(file.files.length){ fileReader.readAsDataURL(file.files[0]); } }; fileReader.onload = function(evt):void { if(Laya.Browser.window.FileReader.DONE == fileReader.readyState) { var sp:Laya.Sprite = new Laya.Sprite(); sp.loadImage(fileReader.result,0,0,300,300); Laya.stage.addChild(sp); } } } } new Main; 编译上面的代码，点击按钮。选择一个图片文件或者相机进行拍照，发现图片已经显示到舞台上了。那么一个简单的调用相册或者相机的程序就这样完成了。但是我们发现这个“按钮”非常丑陋。那么怎么改变这个按钮样式呢?这个就需要借助css样式来处理下。传统的做法就是把这个按钮的透明值设置为0，然后在放一个和他重合的按钮来代替。通过这样的假象来改变他的样式，其实实际点击的还是他。只不过用户感觉不到。那么我们就来修改下，看看怎么改变样式。 //创建隐藏的file并且把它和按钮对齐。达到位置一致，这里我们默认在0点位置 var file:any = Laya.Browser.document.createElement(\"input\"); //设置file样式 file.style=\"filter:alpha(opacity=0);opacity:0;width: 150px;height:60px;\"; file.type =\"file\";//设置类型是file类型。 file.accept=\"image/png\";//设置文件的格式为png； file.style.position =\"absolute\"; file.style.zIndex = 999; 下面看下完整的代码： class Main { private video:Laya.Video; constructor() { //初始化引擎 Laya.init(100,100); var skins:any = [\"res/a.png\"]; Laya.loader.load(skins,Laya.Handler.create(this,this.onUIAssetsLoaded)); } private onUIAssetsLoaded():void{ var btn:Laya.Button = new Laya.Button(\"res/a.png\"); Laya.stage.addChild(btn); //创建隐藏的file并且把它和按钮对齐。达到位置一致，这里我们默认在0点位置 var file:any = Laya.Browser.document.createElement(\"input\"); //设置file样式 file.style=\"filter:alpha(opacity=0);opacity:0;width: 150px;height:60px;\"; file.type =\"file\";//设置类型是file类型。 file.accept=\"image/png\";//设置文件的格式为png； file.style.position =\"absolute\"; file.style.zIndex = 999; Laya.Browser.document.body.appendChild(file);//添加到页面； var fileReader:any = new Laya.Browser.window.FileReader(); file.onchange = function(e:any):void { if(file.files.length>0) { fileReader.readAsDataURL(file.files[0]); } }; fileReader.onload = function(evt):void { if(Laya.Browser.window.FileReader.DONE == fileReader.readyState) { var sp:Laya.Sprite = new Laya.Sprite(); sp.loadImage(fileReader.result,0,0,100,100); Laya.stage.addChild(sp); } }; } } new Main; 编译运行代码，可以看到，那个丑陋的dom按钮不见了。我们点击我们自定义的按钮，一样可以选择图片，显示到舞台上。 上面的例子我们是把它在原点重合，设置透明度为0,伪装成了不可见。开发者可以试着放到其他的位置来测试下，本节教程不在具体实现。关于file的其他api请参考mdn和w3c相关说明。除了显示到舞台上，可能还有上传服务器的操作，这时候可以用FormData。这个开发者可以尝试下。 LayaAir之dom元素script标签 有时候我们项目的js文件很多，很大，一次性的全部加载进来不仅仅是流量的浪费，还会造成页面的卡顿，导致极差的用户体验。用压缩混淆的方式虽然能减小些，但是稍微大一点的项目，代码量就会很大。或者地方的js文件，首屏加载时不必要的，这时候我们就需要自适当的时候在加载，因此拆分文件和模块非常必要。拆分文件，就会涉及到即用即加载。那么这时候script标签就会派上用场。 通过script的src来加载远端脚本，可以实现这种功能。也可以通过设置script的innerHTML来实现，当然还有第三种eval。下面我们就这几种情况分别说明下用法。 通过设置src来实现 script的创建可以手动添加到页面，也可以代码动态的创建。这里我们以代码创建为例子进行说明。我们先上代码. 代码逻辑如下： class Main { private video:Laya.Video; constructor() { //初始化引擎 Laya.init(500,500); var script:any = Laya.Browser.document.createElement(\"script\"); script.src = \"demo1.js\"; script.onload = function():void{ //加载完成函数，开始调用模块的功能。 //new一个js中的对象 var client:any = new Laya.Browser.window.Demo1(); client.start(); } script.onerror = function():void{ //加载错误函数 } Laya.Browser.document.body.appendChild(script); } } new Main; 然后再新建一个js文件，简单代码如下： var Demo1 = (function () { function Client() { } Client.prototype.start = function () { // body... console.log(\"调用方法\"); }; return Client; })(); console.log(\"我被加载进来了\"); 下面我们简单的讲解下这两段代码。 var script:any = Laya.Browser.document.createElement(\"script\");创建一个script标签。 script.src = \"demo1.js\";设置要加载的js的路径。 script.onload = ......和script.onerror =....分别是加载完成和加载失败的回调函数。 Laya.Browser.document.body.appendChild(script);把创建的script标签添加到页面。 var client:any = new Laya.Browser.window.Demo1();实例化js声明的那个类。 client.start();调用实例的函数。 编译运行上面的代码。打开谷歌的控制台，可以看到输出： “我被加载进来了” “调用方法” 通过script的innerHTML设置 设置innerHTML其实就是把js的文本格式赋值给innerHTML。这个我们可以通过加载文件的格式把远端加载的文件转换成文本内容赋值给标签。下面看下例子。 class Main { private video:Laya.Video; constructor() { //初始化引擎 Laya.init(500,500); var httpreq:Laya.HttpRequest = new Laya.HttpRequest(); httpreq.on(Laya.Event.COMPLETE,this,this.completeHandler); httpreq.on(Laya.Event.ERROR,this,this.errorHandler); httpreq.send(\"demo1.js\"); } private completeHandler(e:any):void{ var script:any = Laya.Browser.document.createElement(\"script\"); Laya.Browser.document.body.appendChild(script); script.innerHTML = e; var client:any = new Laya.Browser.window.Demo1(); client.start(); } private errorHandler(e:any):void{ } } new Main; 编译运行上面的代码，可以看到效果和用src加载的效果是一样的。这个例子是用HttpRequest来加载文件然后把加载的内容赋值给script.innerHTML。标签自行解析执行js。当然本例子是用的HttpRequest来加载，开发者也可以用Laya.loader.load的方法来进行加载。 eval方法进行加载 private completeHandler(e:any):void { Laya.Browser.window.eval(e); var client:any = new Laya.Browser.window.Demo1(); client.start(); } 我们把前面的加载完成函数改上面的 `Laya.Browser.window.eval(e);` 然后编译，打开控制台，发现效果是一样的。这个和script标签已经没有什么关系了。 总结:上面的三种常用的方法都可以实现动态加载js文件。三种方法有什么不同呢？ - script标签src的方式加载的是js文件，这个js文件可以和当前页面不同源，也就是说可以跨域加载。 - script.innerHTML的方法接收的是一段js文件的文本格式，用的是XMLHttpRequest方式进行加载，所以文件不能跨域，或者说允许加载才可以，优点就是这个js文件可以自定义格式，比如进行加密，穿插别的格式，然后用二进制的格式进行加载，在程序中在解码成真正的js。 - eval的方法和script.innerHTML的方式基本差不多。加载的内容也是很随意。不过不推荐eval这种方式，eval是快被废弃的方法，无论在性能还是安全性方面都是不推荐使用的。具体的原因请看mdn的解释 [https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval。](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval) **其实加载的方式我们还可以放到worker中去，这样更加的减少了页面的渲染压力和卡顿现象。开发者可以阅读worker的教程进行发散。** ### LayaAir之dom元素声音 说起html5的声音，开发者可能第一个想到的是audio标签，但是audio标签对于开发项目极其鸡肋，今天我们讲到的是另一个接口，HTML5提供给JavaScript编程用的Audio API则让我们有能力在代码中直接操作原始的音频流数据，对其进行任意加工再造。音频的api，w3c给我提供了足够的[接口](https://www.w3.org/TR/webaudio/)，在[mdn](https://developer.mozilla.org/zh-CN/docs/Web/API/AudioContext)上面介绍的也比较详细。在支持比较完善的浏览器上，声音的api能做出的视觉效果极其丰富。由于声音的api极其丰富，我们这里就抛砖引玉，简单介绍下用法，至于音频的合成，混音，音效，音频数据进行频谱分析，音频加上滤镜比如提高音色等开发者可以查阅mdn或者相关资料。 我们先看下mdn上的一个例子。在这个例子中, 创建一个2秒的缓冲器,并用白噪音填充它, 然后通过[`AudioBufferSourceNode`](https://developer.mozilla.org/zh-CN/docs/Web/API/AudioBufferSourceNode)来播放它. 注释里说明了它的功能。 ```javascript var audioCtx = new (window.AudioContext || window.webkitAudioContext)(); // Stereo var channels = 2; // Create an empty two-second stereo buffer at the // sample rate of the AudioContext var frameCount = audioCtx.sampleRate * 2.0; var myArrayBuffer = audioCtx.createBuffer(2, frameCount, audioCtx.sampleRate); window.onclick = function() { // Fill the buffer with white noise; //just random values between -1.0 and 1.0 for (var channel = 0; channel 运行上面的js代码，单击页面就会听到声音播放出来了。那么用LayaAir怎么写呢？ var audioCtx: any = new (Laya.Browser.window.AudioContext || Laya.Browser.window.webkitAudioContext)(); //Stereo var channels: number = 2; // Create an empty two-second stereo buffer at the // sample rate of the AudioContext var frameCount: number = audioCtx.sampleRate * 2.0; var myArrayBuffer: any = audioCtx.createBuffer(2, frameCount, audioCtx.sampleRate); Laya.stage.on(Laya.Event.CLICK, this, function (): void { // Fill the buffer with white noise; //just random values between -1.0 and 1.0 for (var channel: number = 0; channel 编译运行上面的例子，单击舞台，就会听到声音播放出来。这个例子很简单，就是在内存中构建出一个声音。那么外部加载的怎么办呢？ 下面这个例子我们就外部加载一个声音文件。顺便把声音的频谱我们画出来。 class Main { private AudioContext:any; private audioContext:any; private analyser:any; private audioBufferSourceNode:any; constructor() { //初始化引擎 Laya.init(500, 500); AudioContext = Laya.Browser.window.AudioContext || Laya.Browser.window.webkitAudioContext; this.audioContext = new AudioContext(); this.analyser = this.audioContext.createAnalyser(); this.analyser.fftSize = 256; Laya.stage.once(Laya.Event.CLICK,this,this.clickHandler); } private clickHandler(e:any):void { var http:Laya.HttpRequest = new Laya.HttpRequest(); http.on(Laya.Event.COMPLETE,this,this.completeHandler); http.send(\"res/3.mp3\",\"\",\"get\",Laya.Loader.BUFFER); } private completeHandler(e:any):void { this.audioContext.decodeAudioData(e,this.decodeAudioData.bind(this)); } private decodeAudioData(buffer:any):void { this.audioBufferSourceNode = this.audioContext.createBufferSource(); this.audioBufferSourceNode.connect(this.analyser); this.analyser.connect(this.audioContext.destination); this.audioBufferSourceNode.buffer = buffer; this.audioBufferSourceNode.start(0); Laya.timer.loop(1,this,this.drawHandler); } private drawHandler():void { Laya.stage.graphics.clear(); var dataArray:Uint8Array = new Uint8Array(this.analyser.frequencyBinCount); this.analyser.getByteFrequencyData(dataArray); var step:number = Math.round(dataArray.length / 60); for (var i:number = 0; i 编译运行上面的项目，点击舞台可以看到，声音的频谱就显示出来了。如下图所示： 总结:可以看到 web的声音功能越来越强大，假如不考虑某些低端机的兼容性，完全可以做一个web的播放器。这里只是做出了一个频谱的效果，开发者可以试试混音，给声音加滤镜等等功能。相关的api可以查阅下mdn。 LayaAir之dom元素iframe 在插入三方的一些网站的时候我们一般会用到iframe，甚至三方的渠道基本都是用iframe嵌入一个应用。我们项目中也会遇到用iframe的情况。下面的例子就是演示在项目中应用iframe。 代码如下所示： var iframe:any = Laya.Browser.document.createElement(\"iframe\"); iframe.style.position =\"absolute\";//设置布局定位。这个不能少。 iframe.style.zIndex = 100;//设置层级 iframe.style.left =\"100px\"; iframe.style.top =\"100px\"; iframe.src = \"http://ask.layaair.com/\"; Laya.Browser.document.body.appendChild(iframe); 这里面需要提醒开发者的就是定位和层级要记得设置。很多开发者不注意导致iframe跑到游戏层的下面而看不见。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-06-29 22:55:00 "},"3D/advanced/readme.html":{"url":"3D/advanced/readme.html","title":"3D进阶","keywords":"","body":"3D进阶自定义Shader后处理CommandBuffer3D性能优化WebXRUnity资源导出插件3D进阶 3D进阶部分包括引擎功能的综合性使用，进阶性使用等相关的文档。 自定义Shader 后处理 CommandBuffer 3D性能优化 WebXR Unity资源导出插件 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-08-10 17:06:04 "},"3D/advanced/customShader/readme.html":{"url":"3D/advanced/customShader/readme.html","title":"自定义Shader","keywords":"","body":"一篇学会自定义Shader一、Shader基础知识1.1 Shader是什么？1.2 LayaAir引擎的Shader2.如何自定义Shader2.1 Mesh中常见的属性2.2 规则说明3.uniformMap4.子着色器SubShader4.1 什么是SubShader4.2 什么是Pass5.Shader文件结构详述5.1 Instancing5.2 ReflectionProbe5.3 attributeMap5.4 defines5.5 styles6.GLSL语法简述6.1 常见的变量类型6.2 常见的向量类型6.3 常见的矩阵类型6.4 varying7.ShaderPass8.GLSL Block9.开始编写一个LayaAir Shader9.1 创建一个Shader9.2 编写一个Shader10.顶点着色器片段11.片段着色器片段12.GLSL数据传递12.1 应用处理阶段12.2 顶点着色器阶段12.3 片段着色器片段13. 材质的渲染模式与Shader的渲染模式一篇学会自定义Shader 本篇文档属于LayaAir引擎3D使用的进阶性文档，在阅读前需要具备3D顶点、法线、UV等通用的3D基础知识，如果涉及到不理解的名词，请先阅读相关的基础概念文档。 一、Shader基础知识 1.1 Shader是什么？ Shader 中文名为着色器， Shader本质上是一段采用GLSL着色语言编写在GPU上运行的程序 ， 用于告诉图形软件如何计算和输出图像。小到每一个像素，大到整个屏幕。 着色语言好几种，LayaAir引擎基于webGL，只能用GLSL语言。 Shader主要分两类：顶点着色器Vertex Shader和片段着色器Fragment Shader（也叫片元着色器） 。 1.1.1 顶点着色器Vertex Shader 顶点着色器是用来处理顶点数据的程序，如顶点坐标、法线、颜色和纹理坐标。 它在每个顶点上调用，可将几何图形（例如：三角形）从一个位置转换为另一个位置， 例如，用于顶点变换、纹理坐标生成、 纹理坐标变换等等。 由于3D图形是一个个三角面片组成的，所以，顶点Shader要计算每个三角面片上的顶点，并为最终的像素渲染做准备。 1.1.2 片段着色器Fragment Shader 片段着色器用来计算和填充每个像素的颜色，所以也称为像素着色器。可用于插值的运算、 纹理存取、纹理应用 、 雾 、 色彩计算等。 对于由图元覆盖的像素的每个样本，都会生成“片段”。每个片段都有一个“窗口空间”位置以及其他一些值，并且它包含来自上一个“顶点处理”阶段的所有内插的每个顶点输出值。片段着色器的输出是深度值，可能的模板值（片段着色器未修改）以及可能会写入当前帧缓冲区中的缓冲区的零个或多个颜色值。片段着色器将单个片段作为输入，并生成单个片段作为输出。 1.2 LayaAir引擎的Shader 1.2.1 结构与组成 LayaAir引擎中的Shader主要是围绕着.shader文件为核心，在引擎核心中.shader文件是Shader3D类对象抽象为文本化表示的结果，在选择不同的Shader效果会生成不同的.shader文件，这些.shader文件成为模型材质各不相同的核心因素。 如何创建.shader文件？ 在项目资源窗口右键菜单栏 -> 选择创建 -> 选择着色器（如图1-1所示），有五种内置Shader可选。 （图1-1） 1.2.2 应用范围 LayaAir引擎中的Shader的应用主要体现在对不同物体的材质效果表达，通过对不同Shader的选择，物体的材质随之改变形成了各不相同的效果。 LayaAir引擎内置的默认Shader有：BlinnPhong（布林冯），Unlit（不受光），PBR（基于物理渲染），Particle（粒子），PostProcess（后期处理）。 2.如何自定义Shader 2.1 Mesh中常见的属性 polygon这个词来自希腊语，由poly(很多)和gnow(角)组成，根据定义，多边形是指以线段为界的封闭平面图形 在不同的3D软件或游戏引擎中我们可以找到最基本的常见3D物体：球体，圆柱体，胶囊体，方块，这些基本的3D物体由若干的多边形组合而成，这些3D物体的形状不相同，但性质相似，它们都存在顶点、法线、UV坐标、顶点颜色等属性，这些都存储在定义为Mesh的数据结构中。我们可以在一个Shader中独立访问所有的这些属性，并将它们保存在一些常见的数据结构中，例如Vector，这样是很好的，因为我们可以修改他们的数值，从而产生令人兴奋的效果。 下图2-1展示的是顶点、多边形、边缘的可视化三种形态， （图2-1） 接下来单独介绍Mesh数据结构中常见的属性： 顶点 顶点是什么？顶点是三角形中两条边相交的点，因此每个三角形都由三个顶点组成，所以一个最基本的三角形片元拥有三个顶点， 下图2-2展示的是物体对象的transform和物体顶点坐标的可视化形态。 （图2-2） 法线 假设我们有一张空白的纸，我们让一个朋友在纸的正面画画。如果两侧相等，我们如何确定哪一个是空白页的正面？这就是法线存在的原因。法线对应于多边形曲面上的垂直向量，用于确定面或顶点的方向或方向。 在3D软件中我们可以选择可视化顶点的法线，它可以让我们看到顶点在空间中的位置， 下图2-3展示的是物体对象的法线可视化的结果。 （图2-3） UV坐标 纹理坐标，也称UV坐标，映射了纹理的宽度和高度；在UV坐标上定位顶点的过程称为“UV映射”。这是一个创建、编辑和组织显示为对象网格的平面二维表示的UV的过程。在我们的着色器中，我们可以访问此属性，以在三维模型上定位纹理或在其中保存信息，图2-4展示了Mesh和UV坐标的形态关系。 （图2-4） UV坐标的面积等于0.0f到1.0f的范围，其中0.0f表示起点，1.0表示终点，下图2-5展示了UV坐标的可视化表达。 （图2-5） VertexColor 当我们从 3D 软件中导出对象时，软件会为要受影响的对象分配颜色，通过照明或复制另一种颜色。 这种颜色称为顶点颜色，默认情况下对应于白色，在 RGBA 通道中具有值“1.0”。 2.2 规则说明 Shader3D Start/End Shader文件头/尾 用于声明渲染pass，渲染状态、材质参数等参数 Shader3D Start { //此处填写Shader渲染pass、渲染状态、材质参数等属性 } Shader3D End name Shader名称 用于解释该Shader的名称，区别不同的Shader的功能与效果 Shader3D Start { //此处ShaderName为Shader的名字，非.shader文件名字，实际为Shader3D对象的名称 name: ShaderName } Shader3D End type Shader类型 目前LayaAir仅支持Shader3D类型，考虑后续支持Compute Shader等高级Shader类型 Shader3D Start { type:Shader3D } Shader3D End 3.uniformMap Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，但uniform和顶点属性有些不同。首先，uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。 UniformMap则是存储这样一堆Uniform变量的数据结构，通过组合的形式更直观的让开发者了解到在Shader中所使用到的Uniform变量。 3.1 Uniform常见变量类型 Uniform变量的常见类型：Texture2D，Color，Vector2，Vector3，Vector4，Bool，Float，Matrix4x4，TextureCube Texture2D用于2D纹理采样的图片类型，图片本地支持格式：JPG，PNG Color 颜色类型，为四个Float类型组成的向量值，单位为0-1范围的RGB值变量 Vector2 向量2类型，多用于2D的坐标位置表示，常用于UV坐标和屏幕坐标 Vector3向量3类型，最常用的3D坐标位置表示，三个分量xyz表达3D空间中的具体位置 Vector4 向量4类型，多用于齐次化3D空间的坐标位置表示 Bool 布尔类型 Float浮点类型 Matrix4X4 4X4齐次矩阵 TextureCube 用于3D纹理采样的图片类型，图片本地支持格式：PNG，JPG，HDR Shader3D Start { //联动上面2.2节提到的属性(name, type) type: Shader3D name: ExampleShader uniformMap : { u_Color : {type: Color, default:[1,1,1,1]}, u_MainTex : {type: Texture, default: \"white\"}, u_SampleTexcoord : {type: Vector2, default:[1,1]}, u_LightDir : {type: Vector3, default:[1,1,1]}, u_vecPos : {type:Vector4, default:[1,1,1,1]}, u_isWebGL2 : {type: bool, default: true}, u_spend : {type:float, default:1.0}, u_SkyMap : {type:TextureCube, defalue: \"black\"} u_defaultMat : {type:Matrix4x4, default:[ 1,0,0,0 0,1,0,0, 0,0,1,0, 0.0,0, ]} } } Shader3D End 3.2 引擎常见内置Uniform 注意：以下列举的Uniform变量仅为引擎常用的Uniform变量，其余引擎涉及到的Uniform变量为高阶的使用方法在本文中不会做详细的介绍，感兴趣的开发者可以在引擎中的xx.glsl文件中可以找到相对应的Uniform变量，在此篇幅仅介绍在常用的Shader编写中所使用的到的一些高频的Uniform变量。 变量名 描述 所属GLSL文件(高阶操作不推荐直接使用) u_WorldMat 世界矩阵 Sprite3DCommon.glsl u_ProjectionParams(near, far, invert, 1 / far) 投影参数 Camera.glsl u_Viewport(x, y, width, height) 视口 Camera.glsl u_CameraDirection 相机方向 Camera.glsl u_CameraUp 相机上朝向 Camera.glsl u_CameraPos 相机位置 Camera.glsl u_ZBufferParams：1.0 - far / near, far / near, (near - far) / (near * far), 1 / near Zbuffer参数 Camera.glsl u_CameraDepthTexture 深度纹理 Camera.glsl u_Time 时间 Scene.glsl u_FogParams(Start, range, Density, 缺省) 雾效参数 Scene.glsl u_FogColor 雾效颜色 Scene.glsl 4.子着色器SubShader 4.1 什么是SubShader SubShader子着色器可以理解为Shader的渲染方案。每个Shader至少一个SubShader，可以有多个SubShader，子着色器用将Shader对象分为多个部分，分别兼容不同的硬件、渲染管线和运行设置信息。 在一个subShader中包含有： 有关此子着色器的硬件、管线和运行时设置等信息。 一个或者多个pass。 4.2 什么是Pass Pass是Shader对象的基本元素，SubShader中定义了一系列的Pass，它包含设置GPU状态的质量和在GPU上运行的Shader程序。 但是过多的Pass存在一个SubShader中会造成渲染效率的下降，产生性能瓶颈。 Shader3D Start { ..... shaderPass:[ { //Shader VS/FS Info here } ] } Shader3D End 5.Shader文件结构详述 5.1 Instancing 5.1.1 什么是Instancing 当渲染的时候如果存在一类相同顶点数据的物体，只不过是世界空间位置不同，这样的物体就是适合Instancing渲染。想象一个充满草的场景：每根草都是一个包含几个三角形的小模型。你可能会需要绘制很多根草，最终在每帧中你可能会需要渲染上千或者上万根草。因为每一根草仅仅是由几个三角形构成，渲染几乎是瞬间完成的，但上千个渲染函数调用却会极大地影响性能。 如果启动Instancing，将这类数据一次性发送给GPU，然后调用一次绘制函数让OpenGL利用这些数据绘制多个物体，这样就十分的方便，这就是Instancing。Instancing可以让我们使用一个DrawCall来绘制多个物体，节省每次绘制时CPU->GPU的通信。 5.1.2 enableInstancing开关 enableInstancing：是否启用Instancing。 当启用enableInstancing为true时，Shader启用Instancing功能，当启用enableInstancing为false是，Shader不开启Instancing功能。 Shader3D Start { .... enableInstancing:true, .... .... } Shader3D End 5.2 ReflectionProbe 5.2.1 什么是ReflectionProbe 反射探针可以从各个方向捕获周围的环境，然后将捕获到的内容存储为CubeMap（立方体贴图），可供给具有反射材料的对象使用。在一个场景中可以使用多个反射探针，探针可在场景中的关键点对视觉环境进行采样。当反射对象靠近探针时，探针采样的反射可用于对象的反射贴图。此外，当几个探针位于彼此附近时，引擎可在它们之间进行插值，从而实现反射的逐渐变化。因此，使用反射探针可以产生非常逼真的反射，同时将处理开销控制在可接受的水平。 5.2.2 反射探针的工作原理 探针的捕获环境可由CubeMap表示，CubeMap在概念上很像一个在内部表面绘制有立方体六个面图像的盒子，需要Shader必须能够采样CubeMap的图像。对象表面的每个点都可在表面朝向的方向（即表面法向矢量的方向）上“看到”立方体贴图的一小块区域。着色器在此处使用立方体贴图的颜色来计算对象表面应该是什么颜色，下图5-1展示了CubeMap和天空盒的对比结果。 (图5-1) 5.2.3 supportReflectionProbe开关 supportReflectionProbe ：ReflectionProbe开关。 当场景中存在探针时，将开关启用为True，当场景中不存在探针时，将开关启用为False。 Shader3D Start { .... .... supportReflectionProbe:false, .... .... } Shader3D End 5.3 attributeMap attribute通常是来自Mesh顶点中的数据，该属性的变量值是只读的，通常情况下是不需要设置的，引擎中默认有一套attributeMap，满足常见的mesh顶点类型，只有需要特殊mesh数据的时候才需要对attributeMap中设置特殊的变量 在LayaAir3D中的顶点数据是逐精灵的，在这里只介绍常用的模型精灵相关的顶点数据。（即不包含拖尾精灵与粒子精灵） 该表格会列出目前所有会有引擎传入的顶点数据的变量名与对应的顶点通道。 描述 通道 顶点在模型空间下的位置 VertexMesh.MESH_POSITION0 顶点在模型空间下的法向量 VertexMesh.MESH_NORMAL0 模型空间的切向量 VertexMesh.MESH_TANGENT0 第一个uv坐标 VertexMesh.MESH_TEXTURECOORDINATE0 第二个uv坐标 VertexMesh.MESH_TEXTURECOORDINATE1 骨骼权重 VertexMesh.MESH_BLENDWEIGHT0 骨骼索引 VertexMesh.MESH_BLENDINDICES0 MVP矩阵 VertexMesh.MESH_MVPMATRIX_ROW0 世界矩阵 VertexMesh.MESH_WORLDMATRIX_ROW0 顶点色 VertexMesh.MESH_COLOR0 用户自定义预留位 VertexMesh.MESH_CUSTOME0 5.4 defines 5.4.1 基本用法 使用宏开关来控制顶点着色器和片段着色器产生不同分支条件的Shader指令，在defines中宏开关的基本构成为： defineName ：宏开关的名称。 type：一般为bool，true或false触发两个不同的分支。 private：当private值为false时，在材质的属性设置面板，Shader窗口中宏开关会显示为勾选开关的形式，供开发者按需在面板控制宏的开启与关闭；当private值为true，不显示勾选开关。 （下图5-2展示了勾选开关在Shader窗口的展示，图5-3展示了defines在Shader文件中的具体使用方法） (图5-2) (图5-3) 5.4.2 与uniformMap联动 defines中的宏开关可与uniformMap中的全局属性进行联动设置，例如，下面的示例代码： uniformMap:{ //修改u_AlbedoTexture1时同时define A u_AlbedoTexture1: { type: Texture2D, define: A }, //修改u_AlbedoTexture2时同时define A和B u_AlbedoTexture2: { type: Texture2D, define: [A,B] } }, defines: { A : { type: Bool }, B : { type: Bool }, C : { type: Bool } }, 在材质的属性设置面板中，给u_AlbedoTexture1添加纹理，会使A被勾选；给u_AlbedoTexture2添加纹理，会使A和B被勾选，效果如动图5-4所示。 （动图5-4） 5.5 styles 原来在uniformMap或者defines中，可以直接对uniform或者define在UI上的显示细节调整，现在也可以把这些细节移到styles段，使uniformMap和defines更简洁。 5.5.1 对于uniformMap 原来在uniformMap中，需要定义更多的细节，例如（原有写法）： uniformMap:{ u_Number: { type: Float, default:0, alias:\"数字\", range:[0,100], fractionDigits: 2 } }, 如果细节较多，为了uniformMap的简洁性，可以将这些细节移到styles： uniformMap:{ u_Number: { type: Float, default:0 } }, styles: { u_Number: { caption:\"数字\", range:[0,100], fractionDigits: 2 } }, 5.5.2 对于defines styles更重要的功能是可以定义只用于UI而不属于uniform和define的属性。例如： defines: { RAIN : { type: Bool, default: true }, SNOWY : { type: Bool, default: false } }, styles: { RAIN : { caption: \"下雨\", inspector : null }, //inspector为null，不显示在属性面板 SNOWY : { caption: \"下雪\"}, // 定义不属于uniform和define的属性 weather : { caption:\"天气\", inspector: RadioGroup, options: { members: [RAIN, SNOWY] }} }, RAIN和SNOWY在defines中，但是在styles中RAIN的inspector为null，所以不显示。SNOWY正常显示。weather是只用于UI而不属于uniform和define的属性，效果如图5-5所示。 （图5-5） 6.GLSL语法简述 GLSL的变量类型跟uniformMap存在部分重合的内容，LayaAir引擎的Shader文件是基于GLSL语言的封装的，目的是为了提升开发者编写着色器的易用性。GLSL是基于GL系的图形API而推出的着色器语言，包含了一些常见的变量类型和针对向量和矩阵的操作，使得渲染管线具有可编程的特性。 6.1 常见的变量类型 变量类型 说明 LayaAir 中的默认值 bool 布尔型标量数据类型 false float/vec2/vec3/vec4 包含 1，2，3，4 个浮点型向量 0/[0, 0]/[0, 0, 0]/[0, 0, 0, 0] sampler2D 表示 2D 纹理 “white” samplerCube 表示立方体纹理 mat4 表示 4x4 的矩阵 6.2 常见的向量类型 向量的构造方式可以通过下面的三种形式构造 vec2 v1 = vec2(1.0, 0.0); vec3 v2 = vec3(1.0); // v2 = [1.0, 1.0, 1.0] vec4 v3 = vec4(1.0, 0.0, vec2Value); //v3 = [1.0, 1.0, vec2Value.x, vec2Value.y] 向量可以通过x，y，z，w和r，g，b，a进行访问操作，glsl支持同时访问多个下标 eg: vec.xyz 6.3 常见的矩阵类型 mat4 marixt4x4 = mat4(1.0); // marixt4x4 = { 1.0, 0.0, 0.0, 0.0, // 0.0, 1.0, 0.0, 0.0 // 0.0, 0.0, 1.0, 0.0 // 0.0, 0.0, 0.0, 1.0 } mat2 matrix2x2 = mat2(coll1, col2); mat3 matrix3x3 = mat3(0.0, 0.0, 0.0, // 第一列 0.0, 0.0, 0.0, // 第二列 0.0, 0.0, 0.0); // 第三列 6.4 varying varying 是由顶点着色器输出并传输给片元着色器的变量。在管线的作用下，变量值并不会和顶点着色器输出的保持一致，而是由管线进行插值，这就可能会出现顶点输出的法线没有归一化的情况。此时需要手动归一化，代码示例如下： // 归一化法线 vec3 normal = normalize(v_normal); 7.ShaderPass 前面我们在SubShader中简要的介绍了Pass的作用，在本节中我们会结合详细的Shader内容来展示ShaderPass的具体功能 Shader3D Start { type:Shader3D name:exmpleShader enableInstancing:true, supportReflectionProbe:false, uniformMap: { u_MVPMatrix : {type: Matrix4x4}, u_OutLineWidth : {type: float, default:0.0} } shaderPass:[ { pipeline:Forward, VS:OutLineVS, FS:OutLineFS } { pipeline:Forward, VS:OutLine1VS, FS:OutLine1FS } ] } Shader3D End Shader3D Block设置了Shader的type和name以及对instancing、探针的支持情况，对shader中需要的uniform变量做了声明，shaderpass定义了渲染的方式为前向渲染和相对于的glsl的vs和fs的GLSL Block内容。 8.GLSL Block 该部分的内容主要是定义上述ShaderPass中不同渲染片段中的vs和fs中的glsl语句内容 开始和结束标志：GLSL Start / GLSL End Pass 对应的VS和FS片段标记：#defineGLSL “name” / #endGLSL 其中，#defineGLSL 和#endGLSL 中包含的内容为与之着色器功能相对于的glsl的语句 GLSL Start #defineGLSL OutlineVS void main() { vec4 position = vec4(a_Position.xyz + a_Normal * u_OutlineWidth, 1.0); gl_Position = u_MvpMatrix * position; } #endGLSL #defineGLSL OutlineFS varying vec3 v_Normal; varying vec2 v_Texcoord0; void main() { gl_Position = u_MvpMatrix * a_Position; mat3 worldMat=mat3(u_WorldMat); v_Normal=worldMat*a_Normal; v_Texcoord0 = a_Texcoord0; gl_Position=remapGLPositionZ(gl_Position); } #endGLSL GLSL End 9.开始编写一个LayaAir Shader 9.1 创建一个Shader 在LayaAir IDE界面，找到项目资源窗口 -> 右键打开菜单界面 -> 选择创建选项 -> 选择着色器选项（如下图9-1所示）。可以创建一个“不受光”类型的.shader文件，然后用编辑器打开，编写自定义的Shader。 （图9-1） 开发者在学习本节时，着重感受FS片段和VS片段所实现的功能，具体的原理会在第10节和第11节说明。 9.2 编写一个Shader 9.2.1 基本属性信息 刚才创建的Shader文件，默认创建的Shader里面包含一些实际开发中可能遇到的常见功能： Shader3D Start Shader文件开始头。 Shader3D End Shader文件结束头。 Shader3D Start/End 中的内容为Shader的一些属性信息，不涉及glsl语句。 下图9-2展示了一个基本Shader3D Start/Shader3D End 结构中包含的基本信息： （图9-2） type: 设置type为Shader3D。 name: 设置Shader名称为NewShader（原来的名称为UnlitShader）。 enableInstancing: 是否启用Instancing。 supportReflectionProbe： 是否启用光照探针支持。 UniformMap： 创建了四个Uniform变量，下图9-3显示了材质与Shader绑定后在IDE面板上显示的结果。当材质与Shader绑定之后，UniformMap中的变量就会成为IDE材质编辑器上的一个面板接口，可以在面板接口上对uniform值进行修改。 （图9-3） shaderPass：当前Shader只有一个pass，vs内容为unlitVS，fs内容为unlitPS，渲染模式为前向渲染。 9.2.2 FS片段与VS片段 GLSL Start / GLSL End： 每个Pass的VS与FS对的开始与结束，#defineGLSL 定义 VS或FS的glsl语句片段。 FS片段 将原来UnlitShader.shader中，FS片段main()中的内容删除。 下面实现几种简单的效果： （1）给物体填一个纯色，将gl_FragColor设置为一个带有透明通道的vec4变量，实际的结果如下图9-4所示， （图9-4） （2）给物体填上纹理的颜色，将gl_FragColor设置为采样纹理的颜色值，具体效果如下图9-5所示，图中左上角为原始纹理示意图， （图9-5） （3）给物体颜色填充为uniform变量的颜色，在IDE中调节颜色，具体效果如下图9-6所示， （图9-6） （4）使用TilingOffset对UV纹理的采样进行偏移，具体效果如下图9-7所示， （图9-7） 注意：此时的v_Texcoord0是在VS中进行放缩偏移变换的，并非在FS中变换的，此处先按下不表，在VS部分会详细讲解。 对UV纹理的采样进行偏移时，需要使用二次幂的纹理图才能显示出图9-7的效果。如果是非二次幂的图像，需要按照图9-8所示进行设置，将图像进行二次幂缩放设置后，点击应用。 （图9-8） VS片段 示例代码如下： #defineGLSL unlitVS #define SHADER_NAME UnlitShader #include \"Math.glsl\"; #include \"Scene.glsl\"; #include \"SceneFogInput.glsl\"; #include \"Camera.glsl\"; #include \"Sprite3DVertex.glsl\"; #include \"VertexCommon.glsl\"; #ifdef UV varying vec2 v_Texcoord0; #endif // UV #ifdef COLOR varying vec4 v_VertexColor; #endif // COLOR void main() { Vertex vertex; getVertexParams(vertex); #ifdef UV v_Texcoord0 = transformUV(vertex.texCoord0, u_TilingOffset); #endif // UV #ifdef COLOR v_VertexColor = vertex.vertexColor; #endif // COLOR mat4 worldMat = getWorldMatrix(); vec4 pos = (worldMat * vec4(vertex.positionOS, 1.0)); vec3 positionWS = pos.xyz / pos.w; gl_Position = getPositionCS(positionWS); gl_Position = remapPositionZ(gl_Position); } #endGLSL LayaAir Shader中的#include类似于C语言的include，xxx.glsl中内置了一些引擎已经打包好的shader算法，上述代码展示了一部分这些算法的用法。 在图形学中常常有围绕着变换进行的一些用法：例如世界矩阵、投影矩阵、裁剪空间，UV变换等等，在LayaAir的.glsl头文件中存在了这样一些用法，如下： getWorldMatrix() 返回一个mat4类型的世界矩阵( ) ，模型空间坐标 世界矩阵 = 世界空间坐标。*[ Sprite3DVertex.glsl ] getVertexParams() 返回一个Vertex结构体，结构体中包含Mesh的原始数据：顶点坐标、法线、UV（UV宏）、切线（NEEDTBN宏）、副切线（NEEDTBN宏）、顶点颜色（COLOR宏）。[ VertexCommon.glsl ] transfromUV() 返回一个vec2的新UV坐标，按照函数第二参数进行放缩和偏移的操作，实际的算法为：newUV = (oldUV.x x + tilloffset.z, oldUV.y y + tilloffset.w) tilloffset的xy对应xy的放缩值，zw对应xy的偏移值。 [ Sprite3DCommon.glsl ] 结构体PixelParams定义了一些世界空间下的顶点属性：顶点坐标、法线、UV（UV宏）、切线（NEEDTBN宏）、副切线（NEEDTBN宏）。结构体PixelParams只是定义了这些世界的顶点属性，并没有初始化，InitPixelParams() 返回初始化后的PixelPaams变量。[ BlinnPhongCommon.glsl ] getPositionCS() 传入世界坐标返回的是裁剪空间的坐标。[ Camera.glsl ] remapPositionZ() 对裁剪空间的坐标Z进行重映射。[ Camera.glsl ] 9.2.3 Shader引用glsl文件 在LayaAir IDE的.shader文件中，如果引用的是引擎内置的glsl（通常是在ShaderInit3D.ts中，通过Shader3D.ts的addInclude方法注册的），则直接引用即可。例如： #include \"Color.glsl\"; 如果是自定义的.glsl文件，它可以放置在assets文件夹下的任何地方。然后.shader文件通过相对路径引用.glsl文件，即使是同级目录，也要使用./开头，例如： #include \"./abc.glsl\"; #include \"./path/to/abc.glsl\"; #include \"../path/abc.glsl\"; 10.顶点着色器片段 顶点着色器的主要功能是对输入的顶点进行变换，从模型空间变换到裁剪空间下输出到片段着色器，图10-1展示了一个顶点着色器简单的输入与输出。 （图10-1） 读者不必深入了解WebGL的运行细节，只需要专注于GLSL的语句的内容，就可以轻松的完成Shader内容的创作，前面章节简述了GLSL的一些内容，下图10-2展示了顶点着色器在图形渲染管线中的运行阶段图示。 （图10-2） 在上图所示的阶段，从模型中的顶点经过了图10-3的一系列变换内容。 （图10-3） Local Space 局部坐标，也可以称之为模型坐标。可以理解为就是相对于父节点的坐标。 World Space 世界坐标。世界坐标是一个很大的空间范围，相对于世界原点。通过模型坐标与世界矩阵相乘之后得出。 View Space 观察坐标。可以理解为将世界坐标转换到相机空间的坐标，转换后的值是相对于相机原点。通过世界坐标与观察矩阵相乘之后得出。 Clip Space 裁剪坐标。也就是将观察坐标处理到 -1.0 ～ 1.0 的范围，也就是我们在 WebGL 里提供的标准设备化坐标，最终剔除超出 -1 ～ 1 的坐标。通过观察坐标结合投影矩阵得出。 Screen Space 屏幕坐标。这个过程其实就是将 -1.0 ～ 1.0 范围的坐标转换到 gl.viewport 所定义的坐标范围内。最后变换出来的坐标会送到光栅器，转换成片段。 11.片段着色器片段 片段着色器的主要功能是计算每个像素片段的颜色，从顶点着色器获得颜色的差值，从纹理中采样出颜色数据。图11-1展示了模型采样纹理的着色结果。 （图11-1） 12.GLSL数据传递 12.1 应用处理阶段 模型在应用处理阶段被整合为基本片元（三角形），从模型中获取到不同的属性坐标信息，图12-1红色框选部分为应用处理阶段。 （图12-1） 12.2 顶点着色器阶段 应用阶段完成计算后的一些值作为uniform传入顶点着色器参与计算，然后再通过varing类型的形式传入到光栅化以及后面的片段着色器部分，图12-2红色框选部分为顶点着色器阶段。 （图12-2） 12.3 片段着色器片段 在光栅化阶段完成颜色插值之后的varing类型结果，传入到片段着色器中，片段着色器对颜色值进行处理，将结果输出到对应的缓冲区（分为颜色缓冲区和深度缓冲区），这个步骤为图12-3中的红色框选部分。 （图12-3） 13. 材质的渲染模式与Shader的渲染模式 在LayaAir中不同的材质有着不同的渲染模式，不同的模式下的渲染结果是不相同的，常见的渲染模式如下图13-1红色框选内容所示： （图13-1） 材质相关的内容可以参考《材质编辑模块》。 OPAQUE（不透明） 无任何透明效果，即使贴图中有半透明，模型也不会发生半透明效果，Alpha值不影响最终渲染效果，始终为1。 CUTOUT（镂空） （图13-2） 根据包含Alpha信息的贴图中采样出来的Alpha值进行透明裁剪，也可以根据图13-2中的AlphaTest的值与贴图中采样的Alpha值进行对比来进行裁切，这样裁剪出来的结果造成的空洞部分与正常部分会产生严重的锯齿，但效率高，如果锯齿效果影响严重，建议是采样TRANSPARENT模式，透明的结果就会比较线性。 TRANSPARENT（半透明） 根据贴图中Alpha值来进行半透明的渲染或者给定固定的Alpha值来进行渲染。 ADDTIVE（加色混合） 主要用于一些透明并颜色亮度较高的材质，它会根据贴图像素的亮度进行加色混合，模型正面与背面贴图颜色、相重叠的模型的贴图颜色会相互叠加，形成高亮半透明效果。 （图13-3） ALPHABLENDED（透明混合） 这意味着对象为半透明的模式，但是最终像素的着色的混合模式不同，AlphaBlended混合方式为SrcAlpha SrcColor + （1 - SRCAlpha） DstColor，通常来说SrcAlpha来自纹理的Alpha值。 （图13-4） 在引擎内部Shader的RenderMode会和材质上的RenderMode做一个比较，一般是以材质上的RenderMode为主。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-10-18 11:45:53 "},"3D/advanced/customPhysicsEngine/readme.html":{"url":"3D/advanced/customPhysicsEngine/readme.html","title":"自定义物理引擎","keywords":"","body":"自定义物理引擎库一、理解内置的物理引擎1.1 内置物理引擎对应了哪些类1.2 把引擎编译为物理库二、自定义物理引擎库的流程2.1 选择并获取第三方的物理引擎库2.2 适配第三方的物理引擎2.3 合并为完整的物理引擎库三、使用自定义物理引擎库自定义物理引擎库 一、理解内置的物理引擎 1.1 内置物理引擎对应了哪些类 LayaAir3引擎在2D方面内置了Box2D物理引擎，对应了引擎源码Physics目录下的类，如图1-1所示： (图1-1) 在3D方面内置了Bullet与PhysX物理引擎，对应了引擎源码Physics3D目录下的类，如图1-2所示。 （图1-2） 1.2 把引擎编译为物理库 内置物理引擎，并非是直接将第三方物理引擎拿来就用。 而是要将第三方物理引擎的接口与LayaAir引擎的接口进行逐个对接，也就是将第三方物理引擎内置到LayaAir引擎中。这样，开发者最终就可以通过LayaAir引擎的物理接口，直接切换使用各种物理引擎。并且在IDE中，通过物理组件的方式，进行可视化的编辑。 而开发者，最终使用的物理引擎，是基于第三方物理引擎以及LayaAir引擎的物理对接类，整合打包后的完整物理库。 自定义物理引擎库与引擎内置的物理引擎库，对接过程上，都是同样的流程。区别仅仅是内置引擎是引擎官方开发者对接好了并内置到开源引擎中，而自定义引擎是项目开发者通过了解与参照引擎的对接流程与接口，自行与第三方物理引擎对接，并整合形成的物理引擎库。 下面，我们就通过分析引擎源码中的编译脚本，了解需要将哪些类文件编译整合为一个独立的物理引擎库。 首先，我们打开gulp脚本中的build任务，仅通过子任务名称，就可以清晰的看出用于复制第三方引擎库的任务copyJsLibs以及各种物理引擎库处理的子任务，如图2-1所示。 （图2-1） 如果查看任务的代码，会更加清晰的看出，copyJsLibs任务中通过gulp.src()指定要处理的文件规则，然后按这个规则把符合条件的文件通过gulp.dest()复制到指定的目录中去。在物理引擎库的任务代码中，也可以直观的看出，每一个LayaAir物理引擎库都是LayaAir引擎的物理引擎对接代码与第三方物理引擎JS库合并后的一个新库。 (图2-2) 当然，一个完整的物理引擎实现，除了对应第三方的物理引擎库之外，还是存在物理组件等基础的物理功能。这些作为物理引擎基础库来使用，2D与3D均存在物理引擎基础库，分别为laya.physics2D.js与laya.physics3D.js，如图2-3所示。 （图2-3） 通过分析引擎库的编译过程，我们能理解到，内置物理引擎分成三个部分，LayaAir引擎的物理基础与物理组件的实现、LayaAir引擎与物理引擎的适配库（对接代码）、第三方的物理引擎库。 最终，LayaAir引擎的物理基础库与物理组件的实现，形成了LayaAir引擎物理基础库，LayaAir引擎物理适配库与第三方的物理库合并成为一个完整的物理引擎库。 二、自定义物理引擎库的流程 理解完LayaAir内置物理引擎的结构，本小节，我们来了解开发者在自定义物理引擎库的过程中，需要做哪些工作。 自定义物理引擎，需要具有引擎代码的阅读和编写能力，如果无法完成自定义的对接，可以联系微信LayaAir_Engine进行商业定制 2.1 选择并获取第三方的物理引擎库 尽管Box2D、Bullet、PhysX这些内置的物理引擎都是国际上顶级的知名引擎。但是某些开发者也存在一些特定的需求。例如，有的项目，不需要精度很高的物理引擎，仅仅需要一些基础的物理特性，但要求引擎库比较轻量等需求。通过自定义引擎库的方式，使得这些开发者可以选用最适合项目的引擎。 例如，2D物理轻量引擎matter.js以及3D物理轻量引擎cannon.js等。 开发者可以自行从开源网站中获得这些物理引擎的源代码或编译好的引擎库。 无论是通过源码代码编译成引擎库，还是获得现成的JS引擎库，上一小节中介绍的物理引擎库的三部分之一\"第三方物理引擎库\"的准备工作就完成了。 2.2 适配第三方的物理引擎 另外的两部分，LayaAir引擎物理基础库，不需要开发者重写，直接默认使用引擎编译好的库即可。 开发者仅需要对物理引擎的适配库进行对接。为了帮助大家更方便的理解如何对接第三方的物理引擎，我们在LayaAir引擎库之外，以Cannon物理库的适配接入为例，独立开源了一个物理引擎适配库LayaAir3Physics-Cannon，这样可以让开发者更加简洁的理解适配的全过程。 具体的操作如下： 首先，我们通过Git克隆我们适配好的Cannon.js库的项目源码，地址为：https://github.com/layabox/LayaAir3Physics-Cannon.git 源码项目克隆到本地之后，我们根据 开源使用文档（README.zh-CN.md） 来配置好项目的编译环境。 在这个项目源码中，src目录下就没那么复杂了，这里只包括了物理引擎适配的代码。如图3-1所示： (图3-1) 当我们阅读和理解完了src下的适配源码，我们可以用此源码作为参照，适配其它的物理引擎库。 在适配的过程中，有一点需要重点提醒一下。如果开发者需要在场景初始化流程插入自己的初始化流程，例如有些物理引擎使用了wasm，需要在初始化阶段去下载资源，那么就需要使用Laya.addBeforeInitCallback()来注册方法，代码使用示例如图3-2所示。 (图3-2) 2.3 合并为完整的物理引擎库 完成适配工作后，开发者可以参照Cannon适配源码中的gulp脚本，将物理引擎适配源码编译，然后与第三方的物理引擎库合并为一个独立的物理引擎库。 在cannon适配源码中，我们可以参照gulp脚本中的build流程，进行分析需要做哪些工作。 这里我们仍然以Cannon源码项目为例，重点描述一下，需要做哪几块工作。 第一，开发者把获取的第三方物理引擎库放到libs目录下， 本例中的cannon.js就是第三方物理引擎的原始库文件，如图3-3所示，开发者可以修改gulp替换为自己的第三方物理引擎库。 （图3-3） 第二，适配完成后，修改gulp脚本中的适配库生成文件名，将laya.cannon替换为自己的物理引擎库名称，然后执行脚本。脚本会自动完成编译以及引擎库的合并与输出工作。 三、使用自定义物理引擎库 合并完成后的引擎库可以放到IDE的资源面板下的assets目录下， 然后对于2D引擎库或3D引擎库选项，先设置自定义（Custom），然后拖拽自定义的物理引擎库文件到自定义的输入框中，如图4-1所示： 至此， 自定义引擎的基础流程已介绍完毕。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2024-04-03 18:11:39 "},"3D/advanced/PostProcessing/readme.html":{"url":"3D/advanced/PostProcessing/readme.html","title":"后处理","keywords":"","body":"后处理1.后处理概述2.添加一个内置后处理效果3.引擎内置后处理类型：ScalableAO4.引擎内置后处理类型：Bloom5.引擎内置后处理类型：GaussianDoF6.引擎自定义后处理类型后处理 1.后处理概述 后处理是现代游戏中必不可少的技术之一，PostProcessing，通常在普通的场景渲染结束后对结果进行处理，将一张或数张Texture处理得到一张新的Texture。 PostProcessing的渲染Pipeline普通的模型渲染一样，不同之处在于在顶点着色器中通常只是简单的拷贝，主要的逻辑写在片段着色器中 下面的图像展示了应用和未应用后期处理的场景。 未应用后期处理的场景 应用后期处理后的场景 2.添加一个内置后处理效果 在Scene中选择需要添加后处理效果的相机对象 图2-1 在相机对象的组件面板中PostProcess组件 图2-2 选择实例化PostProcess组件 图2-3 在Effects中添加合适的后处理效果 图2-4 3.引擎内置后处理类型：ScalableAO 环境光遮蔽效果用于计算场景中暴露在环境照明下的点。然后，它会使隐藏在环境光之外的区域变暗，例如折痕、孔洞和靠近的物体之间的空间。 您可以通过两种方式实现环境光遮蔽效果：作为全屏后期处理效果实时实现。实时环境光遮蔽效果可能会占用大量资源。它对处理时间的影响取决于屏幕分辨率和效果属性。 图3-1 可拓展环境光遮蔽参数类型： 参数类型 参数解释 AO Color 设置环境光遮挡的颜色 Intensity 环境光遮挡产生强度 Radius 设置采样点的半径，以控制环境光遮蔽区域的范围 AO Quality 环境光遮蔽效果质量（高-中-低三档） 4.引擎内置后处理类型：Bloom Bloom效应使图像中的明亮区域发光。为了做到这一点，它创建的边缘光从明亮的领域扩展到你的形象。这模拟了真实世界中的照相机在光线淹没镜头时所产生的效果。布鲁姆效果也有一个肮脏的功能，你可以用它来应用一个全屏幕层的污迹或灰尘来衍射Bloom效果。 图4-1 Bloom参数类型： 参数类型 参数解释 Clamp 设置钳制像素的值以控制 Bloom 数量 Color 选择 Bloom 的颜色 Fast Mode 快速模式 Dirt Texture 选择一个肮脏的纹理添加污迹或灰尘的镜头 Intensity 设置镜头肮脏的强度 Threshold 设置亮度级别以过滤掉此级别下的像素 Soft Knee 为低于/超过阈值(0 = 硬阈值，1 = 软阈值)之间的转换设置渐进阈值。 Diffusion 与屏幕分辨率无关的方式设置面纱效果的范围。 Anamorphic Ratio 设置比例以垂直(范围[ -1,0])或水平(范围[0,1])缩放 Bloom。这模拟了变形透镜的效果。 5.引擎内置后处理类型：GaussianDoF 景深是一种常见的模拟相机镜头焦距特性的后处理效果。在现实生活中，相机只能在一定距离内对物体进行锐利的聚焦; 离相机较近或较远的物体会有点失焦。这种模糊不仅提供了一个关于物体距离的视觉线索，而且还引入了 Bokeh，这是一个术语，用来描述当图像的明亮区域失焦时出现的令人愉快的视觉伪影。 图5-1 GaussianDoF参数类型： 参数类型 参数解释 Far Start 景深开始值 Far End 景深结束值 Max Radius 最大模糊景深半径 6.引擎自定义后处理类型 在3.0引擎中编写好自己的后处理效果后，在类定义前加上关键字@regClass()就可以将自定义好的后处理效果显式的展现在Camera的后处理组件的效果列表中 图6-1 图6-2 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:44 "},"3D/advanced/CommandBuffer/readme.html":{"url":"3D/advanced/CommandBuffer/readme.html","title":"CommandBuffer","keywords":"","body":"CommandBuffer文档1.简介2.使用步骤3.使用示例CommandBuffer文档 1.简介 CommandBuffer为渲染命令缓冲区，保存了渲染命令列表。当我们将一些渲染指令添加到CommandBuffer后，可以实现对渲染流程的控制，将这些指令在我们想要的时机进行执行。command buffer设置渲染目标或绘制给定网格，可以设置在摄像机渲染期间的不同点执行 CommandBuffer是一个高阶的3D渲染功能，用来拓展LayaAir引擎渲染管线的渲染效果。在实现毛玻璃（玻璃透明模糊感）、轮廓透视描边或者边缘光效、沙滩脚印、景深等等效果时非常好用，懂的人都明白，CommandBuffer非常强大，也是3A级大作经常用到的渲染功能，并且不会有额外的功能损耗，甚至某些效果比其它方案更省性能，是一种小游戏平台中也可以用来加强3D渲染效果的渲染扩展功能 2.使用步骤 1.创建好CommandBuffer后，添加渲染指令给CommandBuffer 添加代码接口如下： var buf:CommandBuffer = new CommandBuffer();buf.setRenderTarget(renderTexture);buf.drawRender(renders[i],materials[i],0); 2.需要将CBuffer绑定到Camera的渲染事件中，目前laya支持的Camera事件如下： BeforeForwardOpaque = 0,//在渲染非透明物体之前BeforeSkyBox = 2,//在渲染天空盒之前BeforeTransparent = 4,//在渲染透明物体之BeforeImageEffect = 6,//在后期处理之前AfterEveryThing = 8,//所有渲染之后 添加CommandBuffer到相机事件的接口如下： this.camera.addCommandBuffer(this.cameraEventFlag,this.commandBuffer); 删除CommandBuffer的接口如下： this.camera.removeCommandBuffer(this.cameraEventFlag,this.commandBuffer); CommandBuffer是一个渲染指令集，组成这个渲染指令集的是一个一个的独立的渲染指令 setShaderData//设置shader数据，可以设置shader中的texture vector number等 setGlobalShaderData//设置全局数据，可以用于所有的shaderblitScreenQuad//通过全屏四边形将源纹理渲染到目标渲染纹理指令。blitScreenQuadByMaterial//通过全屏四边形将源纹理渲染到目标渲染纹理指令setRenderTarget//设置指令渲染目标，调用后，所有的渲染都会渲染到方法绑定的图片上clearRenderTarget//清理绑定的渲染纹理drawMesh//渲染一个MeshdrawRender//渲染一个Render 可以组合不同的渲染指令然后放入不同的渲染流程，下面具体分析官方示例来更好的理解一下CommandBuffer的用法。 3.使用示例 3.1.BlurryGlass示例（毛玻璃示例） 效果图 示例原理 毛玻璃属于透明材质，后面的三个胶囊体都是非透明材质，所以我们需要每帧将毛玻璃模型后面的所有渲染物体全部拿出，进行模糊，再将图片按屏幕uv采样到毛玻璃上面，便可以实现这样的效果 示例代码 createCommandBuffer(camera:Camera){ //当需要在渲染透明物体之前拿到摄像机渲染结果，所以调用下面的属性true camera.enableBuiltInRenderTexture = true; //创建CommandBuffer var buf:CommandBuffer = new CommandBuffer(); //创建需要模糊使用的屏幕RenderTexture var viewPort:Viewport = camera.viewport; //创建新的RenderTexture var renderTexture = RenderTexture.createFromPool(viewPort.width,viewPort.height,RenderTextureFormat.R8G8B8,RenderTextureDepthFormat.DEPTHSTENCIL_NONE); this.texture = renderTexture; //将当前渲染的结果拷贝到创建好的RenderTexture buf.blitScreenTriangle(null,renderTexture); //获得模糊shader var shader:Shader3D = Shader3D.find(\"blurEffect\"); //设置模糊参数 var shaderValue:ShaderData = new ShaderData(); //down Sample level设置降采样等级 var downSampleFactor:number = 4; var downSampleWidth:number = viewPort.width/downSampleFactor; var downSampleheigh:number = viewPort.height/downSampleFactor; //设置模糊材质参数 var texSize:Vector4 = new Vector4(1.0/viewPort.width,1.0/viewPort.height,viewPort.width,downSampleheigh); shaderValue.setNumber(BlurEffect.SHADERVALUE_DOWNSAMPLEVALUE,1); shaderValue.setVector(BlurEffect.SHADERVALUE_TEXELSIZE,texSize); //创建降采样RenderTexture1 var downRenderTexture = RenderTexture.createFromPool(downSampleWidth,downSampleheigh,RenderTextureFormat.R8G8B8,RenderTextureDepthFormat.DEPTHSTENCIL_NONE); //降采样命令流 buf.blitScreenTriangle(renderTexture,downRenderTexture,null,shader,shaderValue,0); //创建降采样RenderTexture2 var blurTexture:RenderTexture = RenderTexture.createFromPool(downSampleWidth,downSampleheigh,RenderTextureFormat.R8G8B8,RenderTextureDepthFormat.DEPTHSTENCIL_NONE); blurTexture.filterMode = FilterMode.Bilinear; //Horizontal blur buf.blitScreenTriangle(downRenderTexture,blurTexture,null,shader,shaderValue,1); //vertical blur buf.blitScreenTriangle(blurTexture,downRenderTexture,null,shader,shaderValue,2); //Horizontal blur buf.blitScreenTriangle(downRenderTexture,blurTexture,null,shader,shaderValue,1); //vertical blur buf.blitScreenTriangle(blurTexture,downRenderTexture,null,shader,shaderValue,2); //至此 模糊图片已经生成在downRenderTexture中 //设置全局uniform变量 var globalUniformNameID:number = Shader3D.propertyNameToID(\"u_screenTexture\"); //将全局变量u_screenTexture赋值为模糊图片 buf.setGlobalTexture(globalUniformNameID,downRenderTexture); //将commandBuffer加入渲染流程 camera.addCommandBuffer(CameraEventFlags.BeforeTransparent,buf); //回收用过的RenderTexture RenderTexture.recoverToPool(downRenderTexture); RenderTexture.recoverToPool(blurTexture); return; } 3.2.OutLine示例（轮廓线描边） 效果图： 示例原理： 在渲染完成之后，绑定另外一个黑色的Rendertexture，重新画好粒子，Box，猴子为纯红色，再将图片模糊，模糊图片颜色减去没模糊的图片，就能得到渲染边框，最后将渲染边框重新加到渲染好的画布上面，便可实现轮廓效果 代码如下 createDrawMeshCommandBuffer(camera:Camera,renders:BaseRender[],materials:Material[]):CommandBuffer{ var buf:CommandBuffer = new CommandBuffer(); //当需要在流程中拿摄像机渲染效果的时候 设置true camera.enableBuiltInRenderTexture = true; //创建和屏幕一样大的Rendertexture var viewPort:Viewport = camera.viewport; var renderTexture = RenderTexture.createFromPool(viewPort.width,viewPort.height,RenderTextureFormat.R8G8B8A8,RenderTextureDepthFormat.DEPTHSTENCIL_NONE); //将RenderTexture设置为渲染目标 buf.setRenderTarget(renderTexture); //清楚渲染目标的颜色为黑色，不清理深度 buf.clearRenderTarget(true,false,new Vector4(0,0,0,0)); //将传入的Render渲染到纹理上 for(var i = 0,n = renders.length;i Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:44 "},"3D/advanced/performanceOptimization/readme.html":{"url":"3D/advanced/performanceOptimization/readme.html","title":"3D性能优化","keywords":"","body":"3D性能优化1.图形性能的基本认知1.1 降低渲染的CPU成本1.2 降低渲染的GPU成本2.优化Draw Call3.GPU instance4.Dynamic Batch5.Static Batch6.Custom Static Batch(Static Batch Volume组件)3D性能优化 1.图形性能的基本认知 1.1 降低渲染的CPU成本 在渲染过程中，对CPU渲染时间影响时间最大的因素是将渲染指令发送到GPU的成本，渲染指令包括Draw Call以及在绘制3D物体之前更改GPU上设置的命令。 以下的几种手段都可以降低渲染的CPU成本： 减少场景中渲染物体的数量 考虑减少场景中对象的总数，例如：使用天空盒来代替远距离3D物体的渲染 对场景中的物体执行更高效的剔除手段，以便减少引擎中渲染的压力。 减少渲染对象的次数 在适当情况下，使用LightMap烘焙光照和阴影，该操作会增加显存使用量和构建时间，但可以提到运行效率 减少光源的数量 慎用实时阴影 慎用反射探针 1.2 降低渲染的GPU成本 受内存带宽限制，纹理尺寸太高，纹理数量过多，会引发GPU渲染瓶颈 为与相机的距离在运行时变化的纹理启用 mipmap。（例如，3D 场景中使用的大多数纹理）。这会增加这些纹理的内存使用量和存储空间，但可以提高运行时 GPU 性能。 使用合适的压缩格式来减小内存中纹理的大小。这可以缩短加载时间、减少内存占用并改善 GPU 渲染性能。压缩纹理仅使用未压缩纹理所需内存带宽的一小部分。 如果应用受到顶点处理的限制，意味着GPU在顶点处理阶段可以处理更多的顶点 降低顶点着色器的执行成本。 优化几何图形：不要使用不必要的三角形，并尽量保持 UV 映射接缝和硬边（双倍顶点）的数量尽可能少。 使用LOD优化不同的Mesh类型，优化顶点数量。 2.优化Draw Call 由于呈现状态更改会占用大量资源，因此对其进行优化非常重要。优化渲染状态更改的主要方法是减少它们的数量。有两种方法可以执行此操作： 减少绘制调用的总数。减少绘制调用的数量时，也会减少它们之间的渲染状态更改的数量。 以减少对呈现状态的更改次数的方式组织绘制调用。如果图形 API 可以使用相同的呈现状态来执行多个绘制调用，则可以将绘制调用组合在一起，而无需执行尽可能多的渲染状态更改。 LayaAir中提供了以下几种方法: GPU instance Dynamic Batch Static Batch Custom Static Batch 3.GPU instance GPU 实例化是一个绘制调用优化方法，它在一个绘制调用中呈现具有相同材质的多个网格副本。网格的每个副本称为一个实例。这对于绘制场景中出现多次的事物很有用，例如，树木或草体。 GPU 实例在相同的绘制调用中呈现相同的网格。要添加变化并减少重复的外观，每个实例可以具有不同的属性，如 Color 或 Scale。绘制调用，呈现多个实例出现在框架调试器绘制网格(实例)。 GPU Instance需要硬件的支持，确保你当前所使用的硬件可以支持GPU Instance渲染 上图展示了一个GPU Instance测试场景和测试场景相对应的详细绘制信息，图中红-绿-蓝-黄为四种不同的材质 当前Instance DrawCall仅为三个，引擎自动为符合Instance条件的物体执行了Instance渲染流程 引擎Instance渲染条件： 相同的Mesh 相同的材质 enableInstance（自定义Shader上的开关，引擎默认shader开启了Instance） 阴影状态是否相同（是否接收阴影） 反射探针状态是否相同 红-绿-蓝三类物体，具有不同的Mesh、不同的材质，但每一个红色、绿色或者蓝色的物体都是具有相同的材质、相同的Mesh、相同的Instance状态、相同的阴影状态、相同的反射探针状态。所以这三类物体符合引擎Instance渲染判断流程。引擎自动为这三类物体进行了实例化渲染，将红-绿-蓝三种物体将每种颜色的所有物体实例化以一个InstanceDraw Call的形式完成了渲染流程。黄色物体满足了Instance渲染判断的几乎所有内容，但是因为Mesh网格数据不同、引擎不会对所有的黄色物体进行Instance实例化渲染。 综上，一个基本的Instance渲染条件基本可以归纳为三个点：开启了enableInstance，相同Mesh，相同材质。 如果需要自己定制具有个性化的Instance渲染判断，开发者需要通过CommandBuffer的形式自己组织渲染的数据 4.Dynamic Batch 动态合并分为 实例合并 与 顶点合并 两种。这两种优化都无需开发者进行任何设置，而且物体可动态移动，不受限制。但是合并原则相对严格。以下是两种合并最基本条件。 实例合并: 需要同Mesh和同材质双条件满足。在三维场景中同Mesh同材质的模型还是可能大量存在的，在这时实例合并有不小的发挥空间。 顶点合并: 需要同材质且模型顶点小于10个。顶点合并目前在一些假阴影和特效模型上有发挥空间。 注意：半透明的物体需要连续渲染才能动态合并，所以半透明物体的动态合并几率低。 关闭动态合批选项 在引擎的Config3D.ts文件中enableDynamicBatch值选项，true为开启动态合批，false为关闭动态合批 图4-1 5.Static Batch 静态批处理是一种绘制调用批处理方法，它组合不移动的网格以减少绘制调用。 它将组合的网格转换为世界空间，并为它们构建一个共享的顶点和索引缓冲区。 然后，对于可见网格，引擎执行一系列简单的绘制调用，每个调用之间几乎没有状态变化。 静态批处理不会减少绘制调用的次数，而是减少它们之间渲染状态更改的次数。 静态批处理比动态批处理更有效，因为静态批处理不会在 CPU 上转换顶点。 关闭静态合批选项 在引擎的Config3D.ts文件中enableStaticBatch值选项，true为开启动态合批，false为关闭动态合批 图5-1 静态合批的条件： 物体为Static（包括子物体） 使用同种材质的统一模型 图5-2 6.Custom Static Batch(Static Batch Volume组件) 在Object的inspect面板，增加组件，选择Rendering选项，找到Static Batch Volume组件 图6-1 在Scene视窗中拖动小白点选择合适的Volume大小 图6-2 Static Batch Volume组件的使用: 上面的Volume框选到合适的大小后，在组件的详情面板中，勾选Static Instance Batch，再点击reBatch，Volume中所框选的物件就会执行Batch操作，优化Draw Call，提升运行效率。勾选了CheckLOD选项的Batch组件, 会自动检查Volume中的物体LOD属性信息, 然后将Volume中的所有物体按照LOD Cull Rate Array的物体LOD等级划分为不同的LOD渲染对象 图6-3 图6-4 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-05-10 20:43:05 "},"3D/WebXR/readme.html":{"url":"3D/WebXR/readme.html","title":"WebXR","keywords":"","body":"WebXR使用说明一、WebXR简介二、WebXR的现状与前景三、LayaAir引擎WebXR应用WebXR使用说明 一、WebXR简介 WebXR 是一组支持将渲染3D场景用来呈现虚拟世界（虚拟现实，也称作VR）或将图形图像添加到现实世界（增强现实，也称作AR）的标准。 WebXR 设备 API 实现了 WebXR 功能集的核心，管理输出设备的选择，以适当的帧速率将3D场景呈现给所选设备，并管理使用输入控制器创建的运动矢量。 从引擎层面上，通过计算应用于场景的透视图，以从每个用户的视角呈现场景，从而在3D中呈现场景，考虑到眼睛之间的常规距离，然后渲染场景两次，每只眼睛一次。然后将生成的图像(场景在一个帧上呈现两次，每只眼睛一半)显示给用户。如图1所示。 （图1） 二、WebXR的现状与前景 XR我们可以理解为VR与AR的统称。无论是纯虚拟世界沉浸式体验的VR设备，还是现实世界增强显示体验的AR设备，均已开始走入到人们的生活，设备购买的人数不断在增加。这正如同智能手机早期的状态，随着设备越来越轻，佩戴体验越来越友好，相信普及度也会越来越广。 当然，我们也要认清当下的XR设备，如果普及度要达到智能手机的规模，那还是有不少硬指标要实现的。例如，要达到还原现实世界的视觉体验，必须要考虑VR设备的视场角（简称FOV）。人的单眼在没有遮挡的情况下所能看到的水平角度大概是150°左右，垂直角度大概在120°左右。如果我们要想在接近这个的FOV体验下达到视网膜级别的高清显示，那单眼就需要8K，双眼达到16K的视觉显示大小。这对web端的传输带宽和硬件性能的压力，绝对不是短期之内可以解决的。即便是采用毫秒级的眼球追踪技术，也需要达到单眼4K，双眼8K的物理分辨率。考虑到5G的普及速度与硬件性能的提升速度，产品的携带与佩戴体验等。至少也要几年后才勉强可以进入了全民级的基础门槛。 尽管当下和近期无法达到全民应用的级别，但VR的硬件配置、佩戴体验，平台内容质量等等生态都在明显的变好，所以用户量也是不断的增长。再加上2021年元宇宙的概念一波又一波的热度，使得资本市场对这种沉浸式体验的未来前景更加看好。所以2维显示的时代（没有真实空间感），早晚会过渡到沉浸式的3维显示时代。 提前了解与布局XR，率先进入蓝海领域，是不可错过的时代机遇。 LayaAir引擎于2.13版本开始支持WebXR标准，可以在主流VR设备的浏览器中直接运行，也可以在支持WebXR标准的手机端Chrome浏览器中运行。 三、LayaAir引擎WebXR应用 3.1 在手机里显示 3.1.1 支持webXR的手机浏览器 在手机里运行的时候，那种能夹住手机的VR盒子就可以满足VR的显示。如动图2所示。 （动图2） 由于现在手机里的浏览器对webXR支持的并不友好，目前已知的WebXR浏览器环境，只有Chrome 安卓79以上的版本和Samsung Internet 11.2以上的版本才可以。并且还需要翻墙去下webXR运行所必须的服务。交互操作方面，当前也没有非常成熟的配套设备。所以，手机上的VR，除了看片之外，对于互动体验的游戏来说，VR完全不适合我们当前的普通手机这种应用场景，除非是没有交互的3D展馆等演示性需求，我们并不推荐基于手机进行VR的开发。 3.1.2 准备好webXR运行环境 本篇文档编写时的硬件设备是OPPO iQOO机型，浏览器环境采用的是Chrome 96。 还需要通过翻墙（中国香港的VPN）去下载安装Google Play应用商店。然后在应用商店里搜索安装Google Play Services For AR与Google VR服务。 运行环境不必和本篇完全一样，能安装好Google Play应用商店，和最新版的Chrome浏览器（安卓）即可。 完成以上准备后，才可以正常显示基于webXR标准的链接。 3.1.3 如何用LayaAir开发webXR标准的产品 关于webXR的显示，官网的webXR已经有全部的示例代码，这里对主要的流程进行描述介绍，大家也可以前往官网示例查看完整的示例源码。 首先，场景的加载，摄像机的控制，脚本的添加，UI等，这与普通的3D游戏的编写没有什么区别（所以就不介绍这部分了）。 在启动VR模式之前， 通常开发者需要判断一下当前的环境是否支持webXR的VR模式，再决定是否启动VR模式，或者激活启动VR模式的UI按钮。 是否支持VR的API为：WebXRExperienceHelper.supportXR(\"immersive-vr\") //判断浏览器是否支持VR模式,有三种模式immersive-vr\\immersive-ar\\inline this.changeActionButton.visible = await WebXRExperienceHelper.supportXR(\"immersive-vr\"); immersive-vr就是VR模式的参数，如果是AR模式，参数换成immersive-ar即可。本篇文档只介绍VR模式。 如果检测到支持VR环境，那就可以直接进入VR模式，或者激活进入VR模式的UI按钮，通过侦听按钮的点击来进入VR模式。 /** 初始化XR */ async initXR(){ //创建一个webXR的摄像机 let caInfo : WebXRCameraInfo = new WebXRCameraInfo(); //设置远裁面 caInfo.depthFar = this.camera.farPlane; //设置近裁面 caInfo.depthNear = this.camera.nearPlane; //申请XR的交互，传入VR需要的信息 let webXRSessionManager = await WebXRExperienceHelper.enterXRAsync(\"imersive-vr\",\"local\",caInfo); //设置WebXR摄像机 WebXRExperienceHelper.setWebXRCamera(this.camera, webXRSessionManager); } 通过以上的代码，就可以完成VR的显示了。 3.2 在Oculus里显示与交互 3.2.1 代码部分 无论是手机浏览器还是Oculus VR设备，由于都是基于WebXR标准的，不管是在哪里显示，开发者的代码流程上都是一样的。 只是，相对于手机浏览器，Oculus等专用的VR头显设备，不仅仅是天然的webXR环境（不需要额外安装XR服务），在交互操作方面也非常友好，这也是我们推荐的VR开发与体验环境。 所以，在这个小节里，我们不再介绍VR显示的部分，直接介绍交互部分即可。 /** 初始化XR */ async initXR(){ //创建一个webXR的摄像机 let caInfo : WebXRCameraInfo = new WebXRCameraInfo(); //设置远裁面 caInfo.depthFar = this.camera.farPlane; //设置近裁面 caInfo.depthNear = this.camera.nearPlane; //申请XR的交互，传入VR需要的信息 let webXRSessionManager = await WebXRExperienceHelper.enterXRAsync(\"imersive-vr\",\"local\",caInfo); //设置WebXR摄像机 let webXRCameraManager = WebXRExperienceHelper.setWebXRCamera(this.camera, webXRSessionManager); //注意，这里开始对VR进入手柄输入的控制交互 let webXRInput = WebXEExperienceHelper.setWebXRInput(webXRSessionManager, webXRCameraManager); this.bindMeshRender(webXRInput); } bindMeshRender(webXRInput:WebXRInputManager){ let rightControl = Laya.loader.getRes(\"res/OculusController/controller.gltf\") as Sprite3D; let leftControl = Laya.loader.getRes(\"res/OculusController/controller-left.gltf\") as Sprite3D; let pixelright = new PixelLineSprite3D(20,\"right\"); let pixelleft = new PixelLineSprite3D(20,\"left\"); this.scene.addChild(rightControl); this.scene.addChild(leftControl); this.scene.addChild(pixelright); this.scene.addChild(pixelleft); webXRInput.bindMeshNode(leftControl,WebXRInput.HANDNESS_LEFT); webXRInput.bindMeshNode(rightControl,WebXRInput.HANDNESS_RIGHT); webXRInput.bindRayNode(pixelleft,WebXRInput.HANDNESS_LEFT); webXRInput.bindRayNode(pixelright,WebXRInput.HANDNESS_RIGHT); //获得xrInput的帧循环方案 webXRInput.getController(WebXRInput.HANDNESS_RIGHT).on(WebXRInput.EVENT_FRAMEUPDATA_WEBXRINPUT,this,this.getRightInput); webXRInput.getController(WebXRInput.HANDNESS_LEFT).on(WebXRInput.EVENT_FRAMEUPDATA_WEBXRINPUT,this,this.getLeftInput); /** * 0 扳机 * 1 侧扳机 * 3 摇杆按下 * 4 X、A键 * 5 Y、B键 */ // 左控制器监听 let leftXRInput = webXRInput.getController(WebXRInput.HANDNESS_LEFT); // 左控制器的按钮事件监听 leftXRInput.addButtonEvent(0,ButtonGamepad.EVENT_TOUCH_OUT,this,this.LeftbuttonEvent0); // 注意同一按钮的不同触发 leftXRInput.addButtonEvent(1,ButtonGamepad.EVENT_TOUCH_STAY,this,this.LeftbuttonEvent1); leftXRInput.addButtonEvent(1,ButtonGamepad.EVENT_TOUCH_OUT,this,this.LeftbuttonEvent1_1); leftXRInput.addButtonEvent(3,ButtonGamepad.EVENT_TOUCH_OUT,this,this.LeftbuttonEvent3); leftXRInput.addButtonEvent(4,ButtonGamepad.EVENT_TOUCH_ENTER,this,this.LeftbuttonEvent4); leftXRInput.addButtonEvent(5,ButtonGamepad.EVENT_TOUCH_OUT,this,this.LeftbuttonEvent5); // 左控制器的摇杆事件监听 leftXRInput.addAxisEvent(1,AxiGamepad.EVENT_OUTPUT,this,this.LeftAxisEvent); // 右控制器监听 let rightXRInput = webXRInput.getController(WebXRInput.HANDNESS_RIGHT); // 右控制器的按钮事件监听 rightXRInput.addButtonEvent(0,ButtonGamepad.EVENT_PRESS_ENTER,this,this.RightbuttonEvent0); rightXRInput.addButtonEvent(0,ButtonGamepad.EVENT_PRESS_VALUE, this, this.rightTriggerOn); // 注意同一按钮的不同触发 rightXRInput.addButtonEvent(1,ButtonGamepad.EVENT_PRESS_STAY,this,this.RightbuttonEvent1); rightXRInput.addButtonEvent(1,ButtonGamepad.EVENT_PRESS_OUT,this,this.RightbuttonEvent1_1); rightXRInput.addButtonEvent(3,ButtonGamepad.EVENT_PRESS_OUT,this,this.RightbuttonEvent3); rightXRInput.addButtonEvent(4,ButtonGamepad.EVENT_PRESS_ENTER,this,this.RightbuttonEvent4); rightXRInput.addButtonEvent(5,ButtonGamepad.EVENT_PRESS_OUT,this,this.RightbuttonEvent5); // 右控制器的摇杆事件监听 rightXRInput.addAxisEvent(1,AxiGamepad.EVENT_OUTPUT,this,this.RightAxisEvent); } /** 省略的代码请前往官网示例查看 **/ 以上的代码，并不是全部代码，关于oculus显示与交互的全部代码请前往官网示例中查看。 3.2.2 demo测试提示 代码编译好之后，直接前往Oculus Quest自带的浏览器中输入测试地址，即可运行测试效果。 提醒：Oculus Quest 设备的帐号激活也需要VPN翻墙 示例中默认状态为正常模式，需要点击按钮切换到WebXR模式，此时可查看VR示例并通过控制器进行交互。 在设定好VR设备的游戏区域后，打开VR设备的浏览器并跳转到WebXRController示例的地址，等待示例加载运行后，示例中默认状态为正常模式，同样需要点击按钮切换到WebXR模式，此时可查看VR示例并通过控制器进行交互。 示例的控制器交互说明： 射线检测并拾取物体 在VR场景内可见左右控制器及射线，可以通过射线来检测并拾取物体，具体操作为将射线末端或射线方向指向要拾取的物体，并持续按下左右控制器的侧扳机来锁定物体。 调节与拾取物体的距离 拾取到物体后，可以通过控制器上的按键来调节与物体的距离；右控制器上，”B“键为增加与物体的距离、”A“键为减小与物体的距离；左控制器上，”Y“键为增加与物体的距离、”X“键为减小与物体的距离。需要注意左控制器的X、Y按键为TOUCH类型的事件，触发灵敏，触摸按键即可触发。 调整拾取物体的旋转速度 拾取到物体后，可以通过控制器上的扳机键来控制物体的旋转速度；右控制器的扳机范围为线性范围，可在0~1的范围内通过对扳机施加的力度来控制旋转速度；左控制器的扳机事件也可以为线性范围，为了区别事件触发，左控制器扳机设置为固定值，无法通过左扳机进行调节。 调整拾取物体在x、y轴上的旋转角度 拾取到物体后，可以通过控制器上的摇杆来调整物体在x、y轴上的旋转角度，两个控制器摇杆逻辑一致，摇杆的前后移动调整物体在x轴上的角度；摇杆的左右移动调整物体在y轴上的角度。 控制器事件监听 控制器事件监听主要分为TOUCH与PRESS两大类，事件监听与实现逻辑如下： EVENT_TOUCH_ENTER与EVENT_PRESS_ENTER: 对应监听为左右控制器的X、A键，逻辑区别为X键轻触即可触发，A键需要按下才能触发。 EVENT_TOUCH_STAY与EVENT_PRESS_STAY: 对应监听为左右控制器的侧扳机按键，需要持续轻触或持续按下。 EVENT_TOUCH_OUT与EVENT_PRESS_OUT: 对应监听为左右控制器的Y、B键，逻辑区别为Y键轻触离开与B键按下离开。 EVENT_PRESS_VALUE: 对应监听是右扳机这类输出类型存在一个范围的事件。逻辑实现为根据扳机的按压力度来返回浮动的value值。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:33:44 "},"3D/advanced/Unity/readme.html":{"url":"3D/advanced/Unity/readme.html","title":"Unity资源导出插件","keywords":"","body":"Unity资源导出插件一、关于插件二、导入LayaAir的Unity插件2.1 项目中首次安装插件2.2 已有插件更新2.3 插件导入安装的提醒三、资源导出插件的功能3.1 场景导出3.2 预设导出3.3 帮助 help四、场景对象导出支持列表4.1 Inspector面板的基础属性4.2 相机的属性4.3 光照相关的属性4.4 模型相关的属性4.5 纹理的属性4.6 动画的属性4.7 预制体五、模型的导出文件与加载显示5.1 导出文件类型的说明5.2 加载显示六、常见问题Unity资源导出插件 一、关于插件 采用Unity插件方案的主要原因，主要是为了支持开发者在Unity资源商城中购买的资源可以无感的迁移到LayaAir IDE中进行相关的开发工作，Unity资源商城拥有一定数量的精美且高质量的美术资源，采用Untiy资源导出插件能将这些精美的美术资源迁移到LayaAir引擎的IDE中进行开发，对一些小而美的项目来说无疑是一种无形的帮助，更可以让有Unity经验的优质开发者可以更低学习成本进入HTML5和小游戏产业中来。 插件的项目地址：https://github.com/layabox/LayaAir3.0UnityPlugin.git 二、导入LayaAir的Unity插件 Unity里有一个导入自定义包的功能，通过这个功能，可以在Unity里导入LayaAir引擎提供的专属功能包，用来导出Unity里编辑好的场景和资源，然后再用以LayaAir引擎3D的开发。在Unity里导入这个自定义的LayaAir功能包的过程，我们可以视为安装了一个LayaAir引擎资源导出的Unity插件。本小节会针对这个过程进行详细介绍。 2.1 项目中首次安装插件 打开一个Unity项目后，如果还没有安装插件，那么需要在Unity菜单栏下打开Window->Package Manager窗口，如图2-1所示。 （图2-1） 然后，如图2-2所示，在打开的窗口中，点击左上角的+按钮，选择Add package from git URL。 （图2-2） 将插件的Git地址（https://github.com/layabox/LayaAir3.0UnityPlugin.git）填入后点击Add，如图2-3所示。 （图2-3） 点击后，插件会自动进行安装，安装完成后的效果如图2-4所示。 （图2-4） 插件安装完成后，可以看到菜单栏多出一个LayaAir3D，如图2-5所示。此时说明，已经导入成功。 （图2-5） 2.2 已有插件更新 如果LayaAir官方更新了插件，而开发者的Unity项目中已经安装过资源导出插件了，那么开发者只需要进行更新即可。如图2-6所示，在Package Manager窗口中找到LayaAir 3.0 Export Tool插件，点击Update即可更新。 （图2-6） 如果要删除插件，只需点击Remove即可。 2.3 插件导入安装的提醒 对于Unity还不太熟悉的开发者，需要提醒的是，LayaAir引擎Unity资源导出插件，不是一次导入所有项目通用。在每次创建新的项目工程后，都要重复上面导入LayaAir插件包的过程。 另外需要注意： 1.关于颜色空间的提醒： LayaAir为线性颜色空间，对于Unity颜色空间设置为Gamma的开发者可能会出现导出效果与LayaAir不一致的情况，开发者需要确认Unity是否设置为Linear颜色空间。 可以使用以下步骤查看Unity颜色空间的设置：Editor -> Project Setting -> Player -> Other Setting -> Color Space，操作如图2-7所示。 （图2-7） 2.关于法线贴图的提醒 Unity的法线贴图经过了压缩，在导出的时候可能会存在LayaAir IDE预览与Unity不一致的情况，对于自定义Shader的用户需要注意法线的变换。 三、资源导出插件的功能 3.1 场景导出 （图3-1）场景导出面板 3.1.1 节点设置 忽略未激活节点：如果勾选此选项，类似图3-2中Camera这类未激活的节点将不会被导出。 （图3-2） 3.1.2 模型设置 忽略顶点UV：如果勾选此选项，导出的Mesh数据不存在UV信息。 忽略顶点颜色：如果勾选此选项，导出的Mesh数据不存在顶点颜色信息。 忽略顶点法线：如果勾选此选项，导出的Mesh数据不存在顶点法线信息。 忽略顶点切线：如果勾选此选项，导出的Mesh数据不存在顶点切线信息。 自动生成UV1：如果勾选此选项，导出的Mesh数据UV Set设置为UV1。 3.1.3 其他设置 自定义导出根目录：如果勾选此选项，如图3-3所示，可以设置插件导出的资源路径(文本框填取绝对路径)。 （图3-3） 3.2 预设导出 （图3-4）预设导出面板 3.2.1 节点设置 忽略未激活节点：如果勾选此选项，类似图3-5中Camera这类未激活的节点将不会被导出。 （图3-5） 批量导出一级节点：如果勾选此选项，类似图3-6中这类节点最终导出的为LayaMonkey根节点。 （图3-6） 3.2.2 模型设置 忽略顶点UV：如果勾选此选项，导出的Mesh数据不存在UV信息。 忽略顶点颜色：如果勾选此选项，导出的Mesh数据不存在顶点颜色信息。 忽略顶点法线：如果勾选此选项，导出的Mesh数据不存在顶点法线信息。 忽略顶点切线：如果勾选此选项，导出的Mesh数据不存在顶点切线信息。 自动生成UV1：如果勾选此选项，导出的Mesh数据UV Set设置为UV1。 3.2.3 其他设置 自定义导出根目录：如果勾选此选项，如图3-7所示，可以设置插件导出的资源路径(文本框填取绝对路径)。 （图3-7） 3.3 帮助 help 帮助菜单项里，下级菜单有学习文档Study、问答社区Answsers这些外链菜单项，方便开发者快速进入对应的官网页面中。还有插件版本About LayaAir，如图3-8所示。 （图3-8） 四、场景对象导出支持列表 除了LayaAir引擎插件自身面板上的导出设置项，我们还要注意并且必须要了解Unity的功能面板有哪些是可以导出使用，哪些是不支持的。 因为LayaAir引擎的Unity插件并非是将Unity所有的功能全都支持导出。毕竟我们的LayaAir引擎设计与结构与Unity的引擎并不相同，虽然3D场景基于Unity编辑器进行编辑和导出，但我们需要按LayaAir引擎插件的支持规则来使用。 在本小节，我们就全面介绍LayaAir引擎与插件支持哪些Unity中的功能。如果在本小节支持清单中未提及的，都是当前不支持的。所以，如果是刚接触Unity的开发者，在学习Unity工具使用的时候，也不必要全部学习，可以把本小节中所涉及的支持内容，作为关键字搜索学习即可。 LayaAir引擎插件也会不断在更新，当升级新的引擎版本后，可以关注版本更新日志以及该文档的变化。 4.1 Inspector面板的基础属性 在Unity的Inspector面板中，可以查看和编辑Unity编辑器中几乎所有内容，下面，我们先了解一下Inspector面板的基础通用属性。 （图4-1） 在图4-1的基础属性里，LayaAir导出支持情况如下： Unity的Inspector基础属性 LayaAir是否支持导出的说明 GameObject Name（节点名称） 支持 Static（静态） 只支持勾选 或 不勾选 Layer（层） 只支持层的序号导出，开发者也可以在LayaAir引擎中设置Layer Position（位置） 支持（包括：X、Y、Z） Rotation（旋转） 支持（包括：X、Y、Z） Scale（缩放） 支持（包括：X、Y、Z） 对比上面的图和表格，我们看到Tag是不支持的。Static与Layer是部分支持。后续将不再提醒，关注表格中的支持状态即可。 这里特别说一下，静态Static勾选后是全选，也就是Everything，如图4-2所示。但实际上LayaAir引擎只支持了Lightmap Static和Batching Static，那开发者不选Everything，只勾选这两个行不行。当然是不行的，我们其实只认Static勾选或不勾选这个状态，如果此处单独选择，导出并没有效果。 （图4-2） 4.2 相机的属性 （图4-3） 在图4-3中的Unity相机属性里，LayaAir导出支持情况如下： Unity的相机属性 LayaAir是否支持导出的说明 Clear Flags（清除标志） 支持 （包括：Skybox天空盒（Background背景色）、Solid Color纯色（Background背景色）、Depth only仅深度、Don’t Clear不清除） Projection（投射方式） 支持（包括：Perspective透视（Field of View视野范围），Orthographic正交（size视野大小）） Clipping Planes（剪裁平面） 支持（包括：Near近点、Far远点） Viewport Rect（标准视图矩形） 支持（包括：X、Y、W、H） Allow HDR（允许渲染高动态色彩画面） 支持 Culling Mask在Unity中设置无效，但是layaAir引擎中是支持的，默认值相当于Unity中的Everything，也可以通过引擎的cullingMask进行设置层ID。 4.3 光照相关的属性 4.3.1 灯光的属性Light （图4-4） 在图4-4中的Unity灯光属性里，LayaAir导出支持情况如下： Unity的灯光属性 LayaAir是否支持导出的说明 Type（灯光类型） 部分支持（包括：Spot聚光（Range照射范围、Spot Angle聚光灯锥形角度）、Directional平行光、Point点光（Range照射范围）） Color（灯光颜色） 支持 Mode（灯光模式） 支持（包括：Realtime实时灯光、Baked烘焙光照贴图、Mixed混合光源） Intensity（灯光强度） 支持 Shadow Type（阴影类型） 支持（包括：Soft Shadows、Hard Shadows） 4.3.2 反射探针的属性 Reflection Probe （图4-5） 当Unity中添加Reflection Probe（反射探针）组件后，在图4-5中的属性里，LayaAir导出支持情况如下： Unity的反射探针相关配置属性 LayaAir是否支持导出的说明 Type（类型） 部分支持（包括：Baked烘焙模式、Custom自定义模式） Runtime settings （运行时设置） 部分支持（包括：Importance权重参数、Intensity亮度、Box projection盒式偏移反射、Box Size反射探针大小、Box Offset反射探针偏移） Cubemap capture settings（立方体贴图捕捉设置） 支持 4.4 模型相关的属性 关于模型的属性，分别支持普通模型和骨骼模型。 4.4.1 普通模型 普通模型需要Mesh Filter组件Mesh Render组件，下面分别进行介绍。 网格过滤器Mesh Filter （图4-6） 在图4-6中的Unity网格过滤器属性里，LayaAir导出支持情况如下： Unity的蒙皮网格渲染属性 LayaAir是否支持导出的说明 Mesh（网格） 支持 网格渲染器Mesh Renderer （图4-7） （图4-8） 在图4-7中Unity的Mesh Render组件属性里，LayaAir导出支持情况如下： Unity的网格渲染属性 LayaAir是否支持导出的说明 Materials（材质） 支持（包括：Size大小、Element材质球元素） Lightmap Static（ 静态光照贴图） 部分支持（包括：Lightmaps贴图（Baked Lightmap烘焙光照贴图（Lightmap Index、Tiling X、Tiling Y、Offset X、Offset Y））） 4.4.2 骨骼模型 骨骼模型的Mesh与Mesh Renderer不再分开，合并在组件Skinned Mesh Renderer里，如下图所示： （图4-9） 在图4-9中Unity的Skinned Mesh Renderer组件属性里，LayaAir导出支持情况如下： Unity的蒙皮网格渲染属性 LayaAir是否支持导出的说明 Mesh（网格） 支持 Root Bone（骨骼根节点） 支持 Bounds（包围盒） 支持（包括：Center中心（X、Y、Z）、Extent范围（X、Y、Z）） Materials（材质） 支持（包括：Size大小、Element材质球元素） 4.4.3 材质 对于模型的材质，这里我们介绍一下常见支持的材质类型。 分类 材质 Build in 管线 Standard 材质 Ulit Color/Texture/Cut Out/ Transparent 材质 URP 管线 URP Lit材质 URP Ulit材质 天空盒 Procedural 程序化天空盒 6 Sideed Panoramic 全景图 旧版着色器（只做兼容考虑, 不建议） Diffuse Fast Diffuse Diffuse Detail Bumped Diffuse Bumped Specular 除了上述提供的材质Shader外，Unity里的其他材质，都不能在LayaAir引擎中使用。 4.5 纹理的属性 在Assets（资源）面板里，找到2D图片资源，可以为其设置纹理的属性。 （图4-10） 在图4-10中的Unity纹理属性里，LayaAir导出支持情况如下： Unity的纹理属性 LayaAir是否支持导出的说明 Generate Mip Maps（生成Mipmap） 部分支持（仅支持是否勾选的状态） Wrap Mode（循环模式） 部分支持（包括：Repeat重复、Clamp强制拉伸） Filter Mode（过滤模式） 支持（包括：Point点过滤、Bilinear双线性过滤、Trilinear三线性过滤） Aniso Level（各向异性等级） 支持 4.6 动画的属性 在动画方面，LayaAir支持Animator组件和关联的Animator Controller面板的部分属性导出和使用。 4.6.1 Aniamtor组件 （图4-11） 在图4-11中的Unity动画属性里，LayaAir导出支持情况如下： Unity的动画属性 LayaAir是否支持导出的说明 Controller（动画控制器） 支持 Culling Mode（ 剔除模式） 部分支持（包括：Always Animate 总是播放、Cull Completely完全剔除） 4.6.2 Animator Controller State 在Aniamtor组件属性中双击Controller打开动画控制器的面板，选中State(状态)，可以看到图4-12所示的面板。 （图4-12） 在图4-12中的Unity动画控制器State属性里，LayaAir导出支持情况如下： Unity的动画控制器State属性 LayaAir是否支持导出的说明 Motion（选定动画） 支持 Speed（动画播放速度） 支持 4.7 预制体 如图4-13所示，Unity中的预制体支持导出，但是导出的预制体所包含的属性（灯光、材质等），必须是插件支持的属性，即本节所列出的属性。 （图4-13） 五、模型的导出文件与加载显示 当了解完插件的功能和使用规则后，我们就可以在Unity中进行编辑并导出了，但是导出后的文件名分别代表着什么，又是怎么进行加载使用的。本小节开始为大家介绍。 5.1 导出文件类型的说明 文件的后缀 导出文件类型的说明 .ls 场景文件，选择导出场景Scene3D类别时生成的文件类型。会导出完整的场景信息，其中包含了场景需要的各种数据、光照贴图、模型、位置等。所以，需要导出场景相关的设置时，必须要使用Scene3D类别导出，就可以看到.ls后缀的文件。 .lh 预设文件，选择导出预设Sprite3D类别时生成的文件类型。相对于.ls后缀的场景文件，会缺少环境光、环境反射、场景雾效等等与场景渲染相关的信息。 .lm 模型数据文件，通常是FBX格式的转换而成。 .lmat 材质数据文件，是在unity中为模型设置的材质信息。加载.ls或.lh文件时会自动加载.lmat文件来产生材质。可以使用 BaseMaterial 类来加载。 .lani 动画数据文件，如果模型上有动画，导出后将生成的动画配置文件，其中包含了动画帧数据。加载可以使用 AnimationClip 类来加载。 .jpg JPEG格式的纹理图片文件。 .png PNG格式的纹理图片文件。 .hdr 全景天空盒需要的HDR格式图片文件 5.2 加载显示 导出的Unity资源，在不考虑其它逻辑的情况下，要通过LayaAir引擎显示出来，就需要先加载资源。 5.2.1 场景的加载显示 当我们想导出整个场景时，可以选择场景，设置导出路径。如图5-1所示，导出路径建议设置为在LayaAir IDE项目工程目录下的assets文件夹，至于是assets目录下的什么目录，由开发者自行决定。 （图5-1） 导出之后只需在IDE中打开其中的.ls文件，即可加载场景。 打开场景后，导出的场景并不具有环境光sh信息，需要找到在Scene3D层级下的烘焙开关。如图5-2所示，点击烘焙，对当前场景的环境光sh数据进行预计算， 这样烘焙完成后的效果就是我们想要的效果了。 （图5-2） 5.2.2 预设的加载显示 如图5-3所示，预设的导出，主要是用于当不需要完整导出使用整个场景，只需要某些节点资源。又或者某些节点资源需要独立导出复用或代码动态使用等需求。 （图5-3） 六、常见问题 如果遇到下图的报错，原因是缺少一些包。 （图6-1） 这时需要在Window菜单中，打开包管理器Package Manager。打开后，如图6-2所示，搜索editor，然后选择”Editor Coroutines“和”Version Control“这两个包，添加即可。 （图6-2） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-11-29 17:33:41 "},"released/generalSetting/readme.html":{"url":"released/generalSetting/readme.html","title":"通用发布","keywords":"","body":"通用发布一、概述二、IDE中发布2.1 构建发布2.2 通用选项2.3 目标平台2.4 发布代码使用的资源（resources）2.5 IDE中使用的资源2.6 资源分包2.7 代码分包三、打包图集3.1 为什么要使用图集资源3.2 支持图集打包的格式3.3 用LayaAir IDE制作图集的方式3.4 打包生成的图集文件介绍3.5 如何在项目中使用图集中的小图四、发布原生资源通用发布 一、概述 在LayaAir中完成项目的开发后，需要将项目发布。发布项目是一个将开发者的游戏或应用程序打包并准备部署到目标平台的重要步骤，无论是 web 浏览器、移动设备、还是其他支持的平台。 LayaAir3.1.x在3.0.x的基础上，重构了发包流程。新版本支持批量发布、支持API调用、支持插件扩展。 二、IDE中发布 2.1 构建发布 使用IDE发布项目，开发者首先在文件菜单中，打开“构建发布”选项，如图2-1所示： （图2-1） 2.2 通用选项 构建发布选项打开后，可以看到有一个通用选项，对于每个目标平台来说，它们的通用选项都是一致的： 名称：项目的名称（对于Web发布来说，就是html中的title名称）。 输出目录：输出目录是指要发布到的目标目录，默认在项目的release目录下，这里不建议更改。当然，开发者如果有需求自定义输出目录，可以在项目所在的目录，也可以是与项目无关的目录。 压缩引擎库：一般建议勾选，勾选后，将使用压缩后的引擎类库，可以减少包体大小。 压缩JS文件：一般建议勾选，勾选后，将使用压缩后的JS文件，可以减少包体大小。 生成源代码映射：勾选后，输出目录会打包”.js.map“文件，用于源代码映射。 启动场景：启动项目运行时的第一个场景。 包含场景：包含的场景中，所引用的资源会拷贝到输出目录（详细参考2.5.1）。 始终包含的资源目录：所选资源目录下的资源始终拷贝到输出目录（详细参考2.5.2）。 拷贝BIN目录下文件：勾选后，发布的输出目录会包含工程目录中bin文件夹中的文件（详细参考第四节）。 开启版本管理：勾选后，将会对发布的文件名添加key值用于版本管理映射，可以有效避免缓存或CDN带来的错误加载影响。 开启分包：勾选后，开启分包功能（详细参考2.6、2.7）。 2.3 目标平台 目前，目标平台中有九种发布选项，分别为：Web、Android、iOS、抖音小游戏、OPPO小游戏、VIVO小游戏、微信小游戏、小米快游戏、支付宝小游戏。如图2-2所示，选择对应平台后，点击构建即可。 （图2-2） Web 是指发布为HTML5版本，运行于浏览器环境、webView、LayaNative的APP环境中。 Android 是指发布为安卓平台，运行于安卓的APP环境中。 iOS 是指发布为iOS平台，运行于iOS的APP环境中。 抖音小游戏 是指发布为已适配抖音小游戏的项目。 OPPO小游戏是指发布为已适配OPPO小游戏的项目。 VIVO小游戏是指发布为已适配VIVO小游戏的项目。 微信小游戏 是指发布为已适配微信小游戏的项目。 小米快游戏是指发布为已适配小米快游戏的项目。 支付宝小游戏是指发布为已适配支付宝小游戏的项目。 本篇主要介绍通用的发布设置，各发布平台可以点击以上链接查看文档。 还可以点击图2-2中的“构建其它”选项，直接发布为对应的平台。发布后，可以在“查看任务”中，看到发布结果。 2.4 发布代码使用的资源（resources） 开发者的项目中往往会使用代码引用的方式来使用资源，那么对于IDE来说就无法识别这些资源，因此IDE指定了 Resources 目录为开发者满足此需求，如图2-3所示： （图2-3） 这是一个示例项目，只通过代码来实现资源的使用，注意resources 目录下有两个图片 image 和 c1，来看下发布后的目录。 以Web发布为例，点击“构建Web”按钮，等待发布成功后，如图2-4所示。 （图2-4） 会看到web目录下（如果发布的是小游戏，则对应的是小游戏目录下），也会有一个 resources 目录，里面包括了 image 和 c1。同时web目录下还会有一个“fileconfig.json”文件，实际上json文件中是资源属性信息，文件内容如下： { \"sRGB\": true, \"wrapMode\": 0, \"filterMode\": 1, \"anisoLevel\": 0, \"readWrite\": false, \"mipmap\": false, \"pma\": true, \"hdrEncodeFormat\": 0, \"files\": [ { \"file\": \"\", \"ext\": \"png\", \"format\": 1 } ], \"platforms\": { \"0\": 0, \"1\": 0, \"2\": 0 } } 在不需要额外操作的情况下，resources 目录中的任何资源都会发布到输出目录中，因此开发者可以利用 resources 目录作为代码使用资源的目录。 2.5 IDE中使用的资源 上述 resources 目录主要是针对用代码使用资源的方式，资源需要存放到 resources 目录。但是在我们实际开发过程中，资源通常会放到assets目录下，包括场景和预制体文件等等，如图2-5所示， （图2-5） 这么多的资源目录，如果都改到 resources 目录是一件非常庞大的修改工作。因此IDE为开发者提供了两种更便捷的方式： 2.5.1 包含场景：场景中引用的资源 如图2-6所示，可以把Game等场景添加到包含场景中，这些场景所引用的资源都会发布到输出目录中，发布后打开发布后的目录。 （图2-6） 如图2-7所示，这些目录已经成功发布到输出目录中。 （图2-7） 接下来运行看看效果，如动图2-8所示： （动图2-8） 可以看到场景正常运行，但是没有发现敌人，并且没有音乐。打开调试信息，如图2-9所示，可以看到 enemy.lh 和 bgm.mp3 并没有在输出目录中，这是由于 enemy.lh 和 bgm.mp3 是通过代码执行的。代码里引用的资源，必须放到resources目录里，才会被复制到发布目录里，如果代码引用的资源不在resources目录下，也没有在场景中进行引用，则需要将该资源所在目录设置为始终包含的资源目录。 （图2-9） 这时，我们可以使用第二种方式 2.5.2 始终包含的资源目录：代码中引用的资源 在”始终包含的资源目录“选项中，点击+选择 enemy.lh 和 bgm.mp3 资源所在的文件夹，如图2-10所示 ： （图2-10） 此时，再次发布，等待发布成功后，查看输出目录，如图2-11所示，发现 enemy.lh 和 bgm.mp3 文件已经分别发布到 prefab 和 music 目录中。 （图2-11） 此时运行再看看效果，如图2-12所示，敌人已经正常运行，说明资源的发布都已经包含了。 （图2-12） 最后来总结一下，如图2-13所示，通过 resources目录、包含场景、始终包含的资源目录三种方式，可以让项目运行过程中所使用的资源都成功打包到输出目录中。 当项目需要的资源较少时，可以统一放在图中标号1的resources目录下，这样不论是场景中引用或者是代码中引用的资源，都可以发布到输出目录下；当项目的资源较多时，放在resources目录下不方便管理，那么发布时就需要对resources目录外的资源目录进行设置，场景要添加在标号2的”包含场景“中，代码中引用的资源要添加在标号为3的”始终包含的资源目录“中。 （图2-13） 开发者在项目开发的初始阶段，尽量提前规划好项目资源的目录结构，避免造成资源的重复使用，或者是项目后期不断修改资源目录，造成场景中资源引用错误的情况发生。 2.6 资源分包 在构建发布时，可以开启分包，其中的资源分包就是将选定的资源分成多个小包，以便于用户进行资源加载，还可以避免网络不稳定出现中断等问题。 下面以Web发布为例，来演示如何开启资源分包。如动图2-14所示，点击开启分包后，可以在下面增加一个或多个分包，动图中添加了两个分包（资源文件夹），选择路径\"sub1\"和\"sub2\"后，则这两个路径下所有资源，在发布后各成为一个分包。 ”sub1“中有预制体（Cube.lh）、材质（CubeMaterial.lmat）、纹理图（layaAir.png）；\"sub2\"中只有一个预制体（Sphere.lh）。 （动图2-14） 在配置资源分包时，需要设置如下参数： 参数 说明 资源文件夹 资源文件夹中的内容，就是要进行分包的资源 入口脚本 参考2.7节中代码分包 是否远程包 勾选后，该资源文件夹（分包）在版本发布后会发布到release\\xxx-remote目录下 启动时自动加载 勾选后，运行启动发布的项目时，该资源文件夹（分包）会自动加载 远程包地址 如果同时勾选“是否远程包”和“启动时自动加载”，会显示此参数，要求填写远程包的地址 Web发布后的远程包文件在web-remote文件夹下。小游戏也支持远程包，发布后的远程包位于release目录下，例如，微信小游戏发布后的远程包文件位于release\\wxgame-remote文件夹下，其它小游戏也是同理。 2.6.1 远程包 远程包是指可以将这部分资源放置到CDN（内容分发网络，不理解的读者可以先将它理解为一种服务器），来提供高性能、可扩展性及低成本的网络内容传递给用户。如果Web平台不使用远程包，则对其分包的意义不大。小游戏使用远程包则是为了减小包体。 例如动图2-15所示，如果设置\"sub1\"和\"sub2\"目录为远程包，则在发布后，这两个目录会发布到“release\\web-remote”目录下。 （动图2-15） 开发者需要自行将“web-remote”下所有的子目录传到CDN（不是传“web-remote”目录本身，要传该目录下的\"sub1\"和\"sub2\"），上传完成后可以将“web-remote”目录删除，防止占用空间（也可以保留）。这里为了方便演示，使用本地服务器来模拟代替CDN。 在桌面新建一个文件夹命名为“serve”，它表示本地服务器中的文件夹，里面新建了一个文本文件“这是一个本地服务器.txt”用来测试本地服务器启动成功。可以使用Node.js的anywhere启动一个本地服务器。如动图2-16所示，在“serve”文件夹中打开命令行cmd，输入anywhere 2840，然后点击键盘回车键就可以启动一个本地服务器了，其中2840是指定的端口号。 （动图2-16） 通过动图可以看到，本地服务器的地址为http://192.168.56.1:2840/，这个地址在后面的演示会用到。这里要注意，在运行发布的项目时，需要本地服务器为开启状态。 下一步就是将资源导入到本地服务器，在实际上传到CDN时，可以使用工具进行上传，但对于本地服务器来说，直接将远程包（\"sub1\"和\"sub2\"）从“web-remote”文件夹剪切或拷贝到“serve”文件夹即可。 将远程包导入本地服务器后，加载远程包有两种情况，在IDE中自动加载，和用代码进行加载。 2.6.2 IDE中自动加载 如图2-17所示，在IDE中引用了资源（添加资源在场景中）后， （图2-17） 在构建发布时，勾选启动时自动加载，然后填写远程包地址，就是本地服务器的地址http://192.168.56.1:2840/，如下动图所示： （动图2-18） 点击版本发布后，需要再次将\"sub1\"和\"sub2\"上传到本地服务器“serve”文件夹，如动图2-19所示： （动图2-19） 现在就可以运行发布的Web项目了，如动图2-20所示，同样也是使用本地调试的方法，在发布的文件夹中打开命令窗口，输入anywhere回车启动，运行Web项目时是默认端口号8000，注意要保持远程包地址http://192.168.56.1:2840/的本地服务器为开启状态。 （动图2-20） 可以看到资源都加载出来了，打开开发者工具，如图2-21所示，可以看到资源是从远程包http://192.168.56.1:2840/加载的。 （图2-21） 2.6.3 代码引用的资源 有时，我们不想让游戏一开始就加载过多的资源，这样负荷太大，这时就需要手动代码加载了。 如图2-22所示，场景中没有引用要分包的资源，在Scene2D节点的属性设置中添加一个自定义组件脚本， （图2-22） 然后在脚本中添加如下代码： const { regClass, property } = Laya; @regClass() export class Script extends Laya.Script { //declare owner : Laya.Sprite3D; @property({ type: Laya.Scene3D }) scene3d: Laya.Scene3D; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { //Web平台使用远程包 Laya.loader.loadPackage(\"sub1\",\"http://192.168.56.1:2840/\",this.printProgress).then(()=>{ Laya.loader.load(\"sub1/cube.lh\").then((res:Laya.PrefabImpl) =>{ let sp3:Laya.Sprite3D =res.create() as Laya.Sprite3D; this.scene3d.addChild(sp3); }); }) Laya.loader.loadPackage(\"sub2\",\"http://192.168.56.1:2840/\",this.printProgress).then(()=>{ Laya.loader.load(\"sub2/sphere.lh\").then((res:Laya.PrefabImpl) =>{ let sp3:Laya.Sprite3D =res.create() as Laya.Sprite3D; sp3.transform.localPositionX += 1.0; //防止球体和立方体都在初始位置发生重叠 this.scene3d.addChild(sp3); }); }) } printProgress(res: any) { console.log(\"加载进度\" + JSON.stringify(res)); //将res对象转换成JSON格式的字符串，此处打印的值为1。本句代码主要应用于小游戏发布后打印loadTask反应下载进度 } } 注：资源加载请参考《资源加载》。 利用代码加载时，不勾选启动时自动加载，但如果分包的资源不在resources目录下（本例中的\"sub1\"和\"sub2\"就不在），就要将包添加到始终包含的资源目录中，配置如下图所示： （图2-23） 发布后，与之前的操作一样，需要将\"sub1\"和\"sub2\"上传到本地服务器“serve”文件夹。 接下来就可以运行这个Web项目了，与之前的操作相同，使用anywhere启动，效果如图2-24所示： （图2-24） 可以看到资源加载出来了，打开开发者工具，如图2-25所示，可以看到资源是从远程包http://192.168.56.1:2840/加载的。 （图2-25） 2.7 代码分包 2.7.1 方法 除了资源分包，还可以将代码进行分包。一般用于小游戏的分包，可以降低首包体积（因为小游戏限制包体大小），加快加载速度。 代码分包需要使用脚本集定义，可以将指定目录的脚本（src目录下）自动打包成一个单独的js。它也适用于非分包用途，比如单纯地想拆分代码。如图2-26所示，在项目资源面板中可以创建一个脚本集定义。 （图2-26） 通常，自己编写的脚本文件都会集中在项目目录“bin\\js\\bundles”的bundle.js文件中。 如果拆分了某部分的代码，这部分的代码会转移到项目目录“bin\\js\\bundles”的“脚本集定义.js”文件中。 如图2-27所示，创建后，在其属性设置面板中，可以进行配置。 （图2-27） 激活：一般需要勾选。勾选后，代码分包被激活。 全局名称：一般不需要设置。用于模块命名，例如module1，那么其他模块可以通过”module1.xxx“访问这个模块导出的类和函数。 允许编辑器加载：一般需要勾选。勾选后，脚本在编辑器环境也会载入。 允许运行时加载和自动加载：一般需要勾选。勾选后，脚本会在运行时自动加载。 允许发布时压缩：构建发布时，若设置了“压缩JS文件”，则此脚本会被压缩。 入口文件和包含所有文件：控制哪些TS脚本一定被包含。分包定义是针对目录的，它在哪个目录，这个目录下的文件就会打进这个分包。 依赖：同JS插件一样，都是管理加载顺序的。即可以设置多个脚本，这些脚本将会安排优先载入。 配置好后，在项目发布时，只需将脚本集定义放在入口脚本处，然后在资源文件夹选择非主包的文件夹，注意该分包不可为远程包，如图2-28所示， （图2-28） 2.7.2 演示 这里以”2D入门示例“为例，演示代码分包流程。 新建示例项目后，如图2-29所示，在src文件夹下新建一个脚本集定义MyModule.bundledef，然后在其属性设置面板中，勾选包含所有文件。这里是将src目录下的代码全部进行了拆分，开发者可以根据自己的需求拆分代码。 （图2-29） 当激活MyModule后，项目目录“bin\\js\\bundles”的bundle.js文件体积会变小，同时会多出一个MyModule.js文件。 这就是将src目录下的代码进行了拆分，bundle.js中的代码拆分到了MyModule.js中。 然后在构建发布中，按照图2-30所示，将MyModule放在入口脚本处，并勾选启动时自动加载。其中，资源文件夹的script文件夹是在assets目录下新建的一个空文件夹，发布后的代码分包将位于该文件夹中。 （图2-30） 发布后可以发现，发布目录的js文件夹下，原来bundle.js中的代码拆分到了分包script文件夹中。 三、打包图集 图集(Atlas)是游戏开发中常见的一种美术资源，通过IDE发布流程将多张图片合并成一张大图，并通过atlas格式的文件存放原始图片资源信息。 图3-1就是采用LayaAirIDE打包好的一张png图集资源。 (图3-1) 3.1 为什么要使用图集资源 在游戏中使用多张图片合成的图集资源作为美术资源，有以下优势： 1 优化内存 合成图集时会去除每张图片周围的空白区域，加上可以在整体上实施各种优化算法，合成图集后可以大大减少游戏包体和内存占用。 2 减少CPU运算 多个 Sprite 如果渲染的是来自同一张图集的图片时，这些Sprite可以使用同一个渲染批次来处理，大大的减少CPU的运算时间，提高运行效率。 3.2 支持图集打包的格式 LayaAirIDE支持对PNG与JPG两种资源格式打包为图集。但是图集打包的原始资源，推荐使用PNG，因为JPG的体积会较大。 Tips： 需要注意的是，PNG原始资源的位深度不能超过32，否则打包出来的图集会出现花屏。打进图集的资源 Texttrue Type 属性要设置为 SpritetTextrue 。另外，PNG与JPG资源不能是其它格式的资源改名为PNG与JPG格式的。 3.3 用LayaAir IDE制作图集的方式 用LayaAir IDE制作图集有两种方式，第一种方式更为细致，第二种方式更为简单快捷，开发者可以自行选择。 3.3.1 自动生成 自动将图片资源打包只有在LayaAir IDE发布时才可以，但是需要添加和设置图集打包配置文件，这里我们通过一个示例来讲解，如图3-2所示： （图3-2） 1，所有的图片资源都放在 assets/resources 目录下，上文提到，由于项目开发中图片可能会使用代码的使用方式，因此在不指定“始终包含的资源目录”的情况下，放在resources目录下会直接发布到输出目录中。 2，resources目录下的atlas目录，用来存放一些散图和子文件夹（里面也有散图），这么做的好处是对资源做好分类管理，往往resources目录下还有其它资源目录，尽量把图片资源和其它资源分开存放。 3，atlas目录下，有两张图片（img_bg100-0.png和img_bg100-1.png）和子文件夹ui1、ui2，里面分别有很多散图，同时ui1目录下还有 a子文件夹。 如果不进行图集打包，那么在发布后，输出目录下的 atlas 目录里都是散图。下面来看看如何打包图集： 第一步：添加配置文件 如动图3-3所示，在atlas目录下添加配置文件。 （动图3-3） 在resources/atlas目录下，右键->创建，选择“自动图集设置”，则会创建一个AtlasConfig.atlascfg文件。放到atlas下的目的，是可以对atlas目录中的图片和子文件夹下的图片同时进行图集打包（支持单张图集和多个子文件夹图集）。开发者可以对此文件重命名。 第二步：图集设置文件属性 点击 AtlasConfig 文件，如图3-4所示： （图3-4） 子文件夹处理： 每个子目录创建一个纹理集：每个子文件夹打包一个图集。 共用一个纹理集：所有子文件夹和同级目录中的图片打包成一个大图集。 包含子文件夹： 勾选后，支持将子文件夹打包图集，不勾选，只处理同一级目录中的图片打包图集。 图集最大宽\\高度： 默认值为2048×2048，该值决定单个图集的最大尺寸。如果原始图片过多，超过单个图集最大宽高时，则会在打包时生成新的图集文件（多个图集）。 单图最大宽\\高度： 默认值为512×512，超过这个尺寸的单图将不会被打包到图集中。 Tips：超过512×512的单图不建议打包到图集中，可以单独预加载此图，但是，加载单图也不能超过1024×1024，否则会对性能有影响。 纹理集缩放： 这里可以通过缩放减少图集体积，比如改为0.5，IDE会按原图宽高分别乘0.5生成到图集中，显示的时候会保持会通过拉伸保持原图大小，这样处理后，虽然图集的尺寸会变小，但是显示的效果也会有所影响，可以视为一种图集的另类压缩方案。如果要保持设计时的图片精度，尽量不要调整默认值。 二次幂限制： 如果勾选，则生成的图集图片宽高将会是2的整次幂。这里，建议美术在设计的时候，就按2的整次幂来设计，通过图集工具强行保持2的整次幂，肯定会导致图集的体积变大。所以，除非是面临某些强制要求按2的整次幂优化的Runtime环境，常规情况下无需勾选，尽量提要求给美术设计人员，按32、64、128、256等2的整次幂来设计图片的宽高。 剪裁图片周边空白： 如果勾选，则生成的图集图片会自动把原始图片中空白区域裁剪掉。默认是是勾选状态，不要去掉。 纹理格式： png32为默认格式，此格式支持透明度和更多的颜色；png24，无透明度；纹理压缩参考文档《纹理压缩》。 第三步：发布生成图集 当设置好后，在“构建发布”进行发布，等待发布成功，这时来看看发布后的目录，如图3-5所示： （图3-5） 1、生成了3个图集（AtlasConfig，ui1 和 ui2），由于选择了 每个子目录创建一个纹理集 方式，ui1 和 ui2 各自生成一个图集（子文件夹打成的图集文件命名是按照文件夹名字），atlas下的图生成一个图集（AtlasConfig.atlascfg所在文件夹生成的图集文件命名按照AtlasConfig文件名）。 2、如果有尺寸超过了512x512的图，则不打入图集（512×512是图3-4的设置）。 3、ui1目录下存在一个a目录，并且勾选了包含子文件夹，所以在图集ui1中也打入了a文件夹下的散图。如果不勾选包含子文件夹，则ui1/a 目录会保留，下面还是散图。 3.3.2 工具制作 第二种方式更为快捷简单，但无法做到像第一种方式那样进行细致的属性设置，此方法在《动画节点》中也有提到，下面来为大家演示。 首先点击”工具“菜单中的”制作图集“。 （图3-6） 然后将所需要打包的文件夹拖入图片所在文件夹中，点击制作。 （图3-7） 也可以点击文件夹图标自行选择路径，如图3-8所示。 （图3-8） 点击制作之后，输入文件名点击保存如图3-9所示。 （图3-9） 这样图集就制作好了。 当我们对图集中包含的图片有增删时，只需要重复一次上面的流程，点击.atlas文件，点击是，即可成功替换，如图3-10所示。 （图3-10） [!Tip] 如果使用第二种图集打包方式，那么开发者要保证，此目录会非常稳定，后续不会进行图片资源的增删修改，如果不能保证稳定的目录，那么最好使用第一种打包方式。 3.4 打包生成的图集文件介绍 3.4.1 打包生成的图集文件 打包图集后，会生成图集专用资源（分别是同名的.atlas文件和.png文件） 3.4.2 atlas后缀文件 .atlas是LayaAirIDE特有的图集格式，仅用于图集，所以在加载.atlas时不需要填写类型，和加载普通的单图方式一样，更加方便，是推荐的图集加载方式。atlas方式加载图集的示例代码为： //atlas方式图集使用示例 Laya.loader.load(\"resources/atlas/Atlas_ui.atlas\").then( ()=>{} ); 3.5 如何在项目中使用图集中的小图 在项目中如果用到图集中的资源，则需先预加载图集资源，然后设置图片的皮肤（skin）属性值为“原小图目录名/原小图资源名.png”。 例如：现在我们将图3-5中原来的小图 img_head2.png 和 comp 目录下的 image.png 在项目中通过图集的方式显示出来，示例代码如下： let resArr: Array = [ { url: \"resources/atlas/Atlas.atlas\", type: Laya.Loader.ATLAS }, { url: \"resources/atlas/Atlas_ui.atlas\", type: Laya.Loader.ATLAS }, { url: \"resources/atlas/Atlas_comp.atlas\", type: Laya.Loader.ATLAS }]; Laya.loader.load(resArr).then( ()=>{ //创建Image1实例 var img1 = new Laya.Image(); //设置皮肤（取图集中小图的方式就是 原小图目录名/原小图资源名.png） img1.skin = \"resources/atlas/img_head2.png\"; //添加到舞台上显示 Laya.stage.addChild(img1); //创建Image2实例 var img2 = new Laya.Image(); //设置皮肤（取图集中小图的方式就是 原小图目录名/原小图资源名.png） img2.skin = \"resources/atlas/comp/image.png\"; //添加到舞台上显示 Laya.stage.addChild(img2); } ); 运行效果，如图3-11所示： （图3-11） 至此，打包图集就介绍完了，开发者需要提前规划好图片的目录管理，可以根据功能划分，每个功能创建一个子文件夹，这样图集的尺寸能尽量控制在合理范围内，按功能划分的好处也是方便查找。开发者在使用过程中如果遇到问题，欢迎随时和我们交流。 四、发布原生资源 原生资源是指通过原生JS实现DOM元素加载的资源，在项目开发中通常会用到，因此有的开发者希望在index.html里写入一些实现DOM的JS代码来加载这些图片或者视频资源，在预览运行时，由于index.html在bin目录下，因此这些资源只能存放在bin目录下。如图4-1所示： （图4-1） LayaAir 3.0.0 beta5 版本开始，会支持发布bin目录下原生资源的功能 在项目Web发布后，默认情况下，所有bin目录下的资源都会发布到web目录中，如图4-2所示： （图4-2） 同时，LayaAir3.0 IDE也为开发者提供了排除资源规则，在这里添加规则可以指示打包器排除bin文件夹下的部分文件或文件夹，例如排除一个文件夹可以使用‘abc/**’等，如图4-3所示 （图4-3） 点击发布后，上述bin文件夹下的原生资源都已经排除了，如图4-4所示： （图4-4） 推荐调用原生对象，下面来讲讲用LayaAir调用原生对象的好处。 我们来举一个例子 ，在bin目录下的index.html中加入一个img标签添加了一些样式，src指定为bin目录下的bg2.png，同时有点击图片隐藏图片的功能，如图4-5所示。发布后，这段DOM的代码也会一同发布到web目录下的index.html中。 （图4-5） 我们运行web目录下的index.html是没有问题的，但是bg2.png必须放在bin目录下，如果项目的开发中也可能会使用到这张图，也就是说assets目录下也会同样存放一张bg2.png，那么开发者就需要在两个地方维护同样的图，造成了一定的麻烦。因此我们推荐开发者使用LayaAir提供的调用原生对象的方式来处理，代码如下： //创建原生img对象 let img:any = Laya.Browser.document.createElement(\"img\"); //设置样式 img.style = \"position:absolute;left:10;top:10;cursor:pointer;\"; //指定资源地址 img.src = Laya.URL.postFormatURL(Laya.URL.formatURL(\"resources/bg2.png\")); //设置img元素的属性 img.setAttribute(\"onclick\", \"this.style.display=\\'none\\'\"); //添加到页面 Laya.Browser.document.body.appendChild(img); 我们把bin目录下index.html中的DOM代码删掉，并且把bg2.png剪切到assets的resources目录下，再次发布 这种情况下，web目录下的index.html没有任何DOM代码了，bg2.png也在resources目录下只有一份，同时运行效果也与之前一样！ 通过使用 Laya.URL.postFormatURL(Laya.URL.formatURL(\"resources/bg2.png\")); 在IDE的预览时和发布后运行时，LayaAir引擎都会使用 resources/bg2.png 作为原生img的src的图片地址，开发者可以自己来试一试。 到这里，通过LayaAir调用原生对象的方式就介绍完了，开发者可以根据自己的需求来使用。 注意：beta5之前的老项目导入，需要手动删除bin里index.html，预览时会重新生成新的模板 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2024-02-21 17:22:35 "},"released/web/readme.html":{"url":"released/web/readme.html","title":"Web发布","keywords":"","body":"Web发布一、概述二、发布为Web游戏2.1 选择目标平台2.2 发布后的目录三、本地运行发布后的Web项目Web发布 一、概述 Web发布功能是非常核心的功能，通常是指发布为HTML5版本，运行于浏览器环境、webView、LayaNative的APP环境中。在项目完成开发，或阶段性完成开发，准备提交到生产环境中进行测试时，通常会用到项目发布的功能。由于LayaAir 3.1.x IDE在结构上与3.0.x相比有很大的变化，在IDE Web发布上面来说，开发者需要更多的注意面板的变化。 在Web发布前，需要先进行通用设置。 二、发布为Web游戏 2.1 选择目标平台 在构建发布面板中，侧边栏选择目标平台为Web。如图2-1所示， （图2-1） 点击“构建Web”，或“构建其它”选项中的“Web”，即可发布项目为Web项目。 文件扩展名：勾选后，使用安全的文件扩展名。 压缩纹理：一般需要勾选“允许使用压缩纹理格式”，如果不勾选，则忽略所有图片对于压缩格式的设置。 纹理源文件：可以不勾选“始终包含纹理源文件”，如果勾选，则即使图片使用了压缩格式，仍然把源文件（png/jpg)打包。目的是遇到不支持压缩格式的系统时，fallback到源文件。 纹理格式的规则： 1、Web平台和各个小游戏平台的远程包，会同时发布PC/Android/iOS三种平台的格式； 2、微信平台会同时发布Android/iOS两种格式； 3、其他小游戏平台只发布Android格式。 4、特殊规则遵循上图说的两个选项。 发布后，点击“查看任务”，可以看到已经发布的任务。如图2-2所示， （图2-2） 打开文件夹：在资源文件管理器中，打开项目发布的文件目录。 查看日志：查看项目发布的日志。 再次构建：重新构建Web项目。 运行：在本地运行发布后的Web项目。 查看二维码：生成一个二维码，可以将手机与PC连接至同一局域网下，扫码预览发布的Web项目。 删除记录：删除发布的记录，但不会删除发布的项目。 2.2 发布后的目录 发布后的目录结构如图2-3所示， （图2-3） js目录 与 libs目录： 项目代码和引擎库。 resources目录 与 Scene.ls： 资源文件目录和场景文件。 fileconfig.json： 文件里包括了一些Web项目的配置信息。 三、本地运行发布后的Web项目 1、运行发布后的Web项目，可以在发布后，直接点击图2-2中的运行按钮，就可以在浏览器中运行发布后的Web项目了。 2、如果开发者不小心将发布记录删除了，可以打开项目发布的文件目录。在发布目录下，使用Node.js的anywhere启动一个本地服务器运行Web项目。如动图2-4所示，在“web”文件夹中打开命令行cmd，输入anywhere，然后点击键盘回车键就可以启动一个本地服务器了。 （动图2-4） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2024-02-21 17:22:35 "},"released/miniGame/readme.html":{"url":"released/miniGame/readme.html","title":"小游戏发布","keywords":"","body":"小游戏发布一、什么是小游戏？二、小游戏与HTML5的差异2.1 运行底层的差异2.2 包体的差异2.3 缓存与其它小游戏接口2.4 发布模板的设置三、LayaAir适配哪些小游戏平台小游戏发布 一、什么是小游戏？ 小游戏最早是来自于微信，微信小游戏的火爆开始带动其他平台的跟进。 那么小游戏到底是什么呢？ 微信小游戏官方的解释是： [!Note] 微信小游戏是微信小程序的一个类目，它即点即玩，无需下载安装，体验轻便，可以和微信内的好友一起玩，比如PK、围观等。 其表象体验的核心是：无需下载安装、即点即玩。至于好友关系链，并非所有平台的小游戏都适合利用关系链来推广。 其它特性将在其它章节介绍。 我们需要知道的是，尽管大多数平台延续了微信小游戏的命名，也叫XX小游戏，但也有其它的命名，例如华为与小米，均叫XX快游戏。 无论什么名称，但各平台的基本体验与特性都大同小异，所以我们可以泛指这些都是小游戏。 二、小游戏与HTML5的差异 那无需下载安装、即点即玩，HTML5不是也可以做到吗？那又和小游戏有着怎样的区别？ 2.1 运行底层的差异 HTML5链接通常是基于浏览器或webView直接运行的。 而发布成APP的时候，LayaAir引擎支持基于C++编写的自研Runtime底层引擎来运行LayaAir引擎项目。 小游戏的原理与LayaAir发布Native APP的机制类似。也是采用了平台内置的Runtime去兼容Canvas和WebGL的接口，从而实现HTML5无需下载安装与即点即玩的体验。 所以，严格上讲小游戏并非是HTML5游戏，因为小游戏并非支持HTML5所有的标准与图形API接口。 当然，LayaAir引擎已适配主流的小游戏平台，开发者采用LayaAir引擎开发项目，无需修改，即可直接发布成为小游戏产品。 2.2 包体的差异 HTML5的资源包与代码，是需要通过网络进行加载后使用的。 而小游戏的代码包，必须放到小游戏的平台里，通过上传小游戏的代码包与审核，可以让平台加强知识产权的监管等好处。 从技术上看，小游戏的代码包和资源包的体量控制，可以让开发人员根据小游戏的规则控制好项目包体的大小，保障游戏的加载体验不至于过久。 2.3 缓存与其它小游戏接口 除了以上游戏本身项目关系密切的介绍，其实小游戏更大的好处是，提供了比HTML5更多的开放接口，例如更多的设备接口、AI接口、支付接口、广告接口、缓存文件管理接口、好友关系链接口等等。 2.4 发布模板的设置 开发者可以在项目目录中建立build-templates/平台名称，例如build-templates/web等，发布时会将这里面的内容拷贝到输出目录。如果是json文件，还会进行合并。例如build-templates/wxgame里放置game.json，并且内容为 { “showStatusBar”: true } ，那么最终的game.json文件里这个key值就会被加入，并且引擎模版里的game.json其他key值会保留。 三、LayaAir适配哪些小游戏平台 LayaAir 3.0当前适配了以下平台： 微信小游戏 抖音小游戏 OPPO小游戏 vivo小游戏 小米快游戏 支付宝小游戏 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-09-14 17:38:18 "},"released/miniGame/wechat/readme.html":{"url":"released/miniGame/wechat/readme.html","title":"微信小游戏","keywords":"","body":"微信小游戏一、概述二、发布为微信小游戏2.1 选择目标平台2.2 发布后的小游戏目录介绍三、用微信开发者工具创建小游戏项目3.1 开发者帐号登录，选择项目类型3.2 导入小游戏项目3.3 微信开发者工具的编译3.4 真机测试与调试四、分包与动态资源加载4.1 分包4.2 网络动态加载五、生成开放数据域工程模板5.1 开放数据域5.2 构建模板目录微信小游戏 一、概述 微信小游戏的运行环境并不是浏览器，也不能在浏览器中运行，而是运行于微信APP中的Runtime。尽管微信小游戏的接口兼容大部分Canvas和Webgl，具有即点即玩，无需下载安装的HTML5特性。但从严格的定义来讲，微信小游戏不是标准的HTML5游戏。 强烈推荐要看一看微信小游戏官方的文档，LayaAir引擎的文档更多的是引擎相关的，当然也会混合了一些小游戏接口的应用介绍，但是仔细看看微信官方文档肯定没错。 下载并安装微信开发者工具 微信开发者工具主要用于小游戏产品的预览与调试、真机测试、上传提交等。是小游戏开发的必备工具。 如果是采用微信小游戏官方API开发的话，还是要有一些要注意的，比如不支持DOM与BOM、小游戏只能有一个画布、不支持Eval、不支持XML等等…… 但是，对于LayaAir引擎的开发者来讲，不用刻意去了解到底有哪些差异，照正常的LayaAir引擎开发规则去开发就可以了。 在微信小游戏发布前，需要先进行通用设置。 二、发布为微信小游戏 2.1 选择目标平台 在构建发布面板中，侧边栏选择目标平台为微信小游戏。如图2-1所示， （图2-1） 点击“构建微信小游戏”，或“构建其它”选项中的“微信小游戏”，即可发布项目为微信小游戏。 Appid：用户可以直接在发布的时候填写微信小游戏的AppID。 生成开放数据域工程模板：一般用来显示好友排行榜，发布完成后会生成openDataContext目录。（详见第五节） 压缩纹理：一般需要勾选“允许使用压缩纹理格式”，如果不勾选，则忽略所有图片对于压缩格式的设置。 纹理源文件：可以不勾选“始终包含纹理源文件”，如果勾选，则即使图片使用了压缩格式，仍然把源文件（png/jpg)打包。目的是遇到不支持压缩格式的系统时，fallback到源文件。 2.2 发布后的小游戏目录介绍 发布后的目录结构如图2-2所示。 （图2-2） js目录 与 libs目录： 项目代码和引擎库。 resources目录 与 Scene.ls： resources资源目录和场景文件Scene.ls，小游戏由于初始包的限制，建议将初始包的内容在规划好，最好能放到统一的目录下，便于初始包的剥离。 game.js： 微信小游戏的入口文件，游戏项目入口JS文件与适配库JS等都是在这里进行引入。IDE创建项目的时候已生成好，一般情况下，这里不需要动。 game.json： 小游戏的配置文件，开发者工具和客户端需要读取这个配置，完成相关界面渲染和属性设置。比如屏幕的横竖屏方向，状态栏的显示、小游戏分包等，都是在这里配置。具体如何配置，以及参数的使用，可以查看微信小游戏的开发文档。 fileconfig.json： 小游戏的项目配置文件，文件里包括了小游戏项目的一些信息，如果想修改appid等信息，可以直接在这里面编辑。 项目参数libVersion的值一定要是game，这里一般不会出错。但是，万一出现了LayaAirIDE里发布正常，也引用了适配库，发布为小游戏后，在开发者工具里还是有报错的话，可以检查libVersion里的值是不是game。不是的话要改为game。 weapp-adapter.js： 微信小游戏适配库文件。 三、用微信开发者工具创建小游戏项目 3.1 开发者帐号登录，选择项目类型 打开”微信web开发者工具“，用开发者的微信扫码登录。然后选择小游戏点击进入项目设置，选择导入，如图3-1所示。 （图3-1） 3.2 导入小游戏项目 选择项目目录，就是在LayaAirIDE发布后的目标目录（通常在项目根目录下的release\\wxgame） （图3-2） 选择wxgame目录之后，如图3-3所示 （图3-3） AppID 测试账号，可以点击注册，不输入也可以开发调试，可以使用测试号，不过功能会受到限制。所以最好还是输入 AppID 3.3 微信开发者工具的编译 完成小游戏项目的创建后，即可在工具内预览效果和调试。如图3-4所示 （图3-4） 3.4 真机测试与调试 由于LayaAirIDE里也可以调试项目效果，除非是适配相关的问题，基本上两边的效果不会有不一一致的情况。所以这里最重要的是点击预览功能，通过手机微信扫码，在微信内进行真机测试与调试。如图3-5所示 （图3-5） 至此，一个完整的小游戏开发流程就结束了。采用LayaAir IDE开发的小游戏项目，基本上是无缝用于微信小游戏项目。 四、分包与动态资源加载 在微信小游戏中加载资源，如果引用的是本地路径，比如： Laya.loader.load(\"resources/layaair.png\"); 如果项目的目录中，全部大小加起来不超过4M的话，只要能找到本地的资源，怎么写也没问题。 但是，微信小游戏的本地包有4M的限制，一旦超过这个限制，那就不允许上传，不允许真机预览。 所以，项目要是大于4M后，怎么处理呢？ 4.1 分包 一种方案是分包， 微信小游戏分包限制： 整个小游戏所有主包+分包大小不超过 20M 主包不超过 4M 单个普通分包不限制大小 单个独立分包不超过 4M 请参考微信小游戏官方文档。 下面来介绍LayaAir IDE给微信小游戏分包的方法，开发者可以先看一下通用设置的分包。 如图4-1所示，在构建发布中，开启分包后，选择要分包的文件夹，即可完成分包。开发者也可以选择是否使用远程包。 （图4-1） 与Web分包不同的是，小游戏分包代码引用的资源的方法不同。在web平台中，使用loadPackage方法加载包的参数有三个，而小游戏分包需要使用两个参数的重载方式，两个参数的重载方式不仅仅用于微信小游戏，别的小游戏平台也同样适用。下面给出一段代码加载分包的示例代码： const { regClass, property } = Laya; @regClass() export class Script extends Laya.Script { //declare owner : Laya.Sprite3D; @property({ type: Laya.Scene3D }) scene3d: Laya.Scene3D; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { //小游戏加载分包 Laya.loader.loadPackage(\"sub1\", this.printProgress).then(() => { Laya.loader.load(\"sub1/Cube.lh\").then((res: Laya.PrefabImpl) => { let sp3: Laya.Sprite3D = res.create() as Laya.Sprite3D; this.scene3d.addChild(sp3); }); }) Laya.loader.loadPackage(\"sub2\", this.printProgress).then(() => { Laya.loader.load(\"sub2/Sphere.lh\").then((res: any) => { let sp3 = res.create(); this.scene3d.addChild(sp3); }); }) } printProgress(res: any) { console.log(\"加载进度\" + JSON.stringify(res)); } } 下面重点介绍一下printProgress打印的内容，在微信开发者工具打开并编译我们导出的项目后，会打印如下日志： （图4-2） wx.loadSubpackage() 返回的一个 LoadSubpackageTask，可以通过它获取当前下载进度。 参考微信小游戏官方文档。 打印的参数的意义分别是： progress：下载进度； totalBytesWritten：已经下载的数据长度； totalBytesExpectedToWrite：预期需要下载的数据总长度。 4.2 网络动态加载 另一种方案就是网络动态加载， 我们在本地包内，JS代码是必须要放进去的，因为JS是不允许网络加载动态创建的。所以如果本地包内JS超过4M，首先考虑的是如何优化JS体积，比如混淆压缩，和UI代码分离。还是不行的话，只能是通过小游戏的分包方案解决。如果JS没有超过4M，那还可以视情况再放一些预加载用的基础资源。 那网络动态加载的路径怎么处理呢。在本地加载的load()方法之后使用URL.basePath方法。 例如： onAwake(): void { //网络动态加载 Laya.URL.basePath = \"https://XXXX\";//请把XXX换成自己的真实网址； //在此之下，再使用load加载资源，都会自动加入URL网址。从网络上动态加载。 Laya.loader.load(\"resources/layaair.png\").then((res: Laya.Texture) => { let sprite:Laya.Sprite = new Laya.Sprite(); sprite.texture = res; this.owner.addChild(sprite); }); } 使用URL.basePath方法后，再使用load加载本地路径，都会自动加上URL.basePath里的网址。这样就实现了本地与网络加载的结合。 [!Tip] 开发者在给URL.basePath赋值时，一定要看一下官方对于网络的说明文档，必须符合要求才可以。 这样就结束了吗？并没有！这里再拓展一个本地包白名单机制。 按刚刚的写法，resources/layabox.png如果已经上传到微信小游戏的本地目录，但是如果在使用URL.basePath之后，再次加载res/layabox.png则不会从本地加载使用，而是从网络动态加载使用。 所以，引擎针对使用URL.basePath之后，如何再次使用本地加载，进行了特殊目录和文件的处理，也就是本地包白名单机制。如下例所示： MiniAdpter.nativefiles=[ \"layaNativeDir\", \"wxlocal\", \"resources/layaair.png\" ] 代码位于发布目录的“libs\\min”下的“laya.wxmini.js”文件中，\"resources/layaair.png\"为手动增加的目录。 只要是MiniAdpter.nativefiles里存在的目录名或文件，引擎会自动将该目录视为本地目录，即便使用了URL.basePath，对于包含在nativefiles白名单内的目录名或文件，都不会从网络动态加载，只会从本地加载。 五、生成开放数据域工程模板 开放数据域一般用来显示好友排行榜。 5.1 开放数据域 首先，如图5-1所示，在层级面板中，向Scene2D中添加一个OpenDataContexView组件，即可激活开放数据域的显示（此时并没有排行榜的效果显示，需要发布后才能看到），组件的大小就是好友排行榜面板的大小。 （图5-1） 添加后，在其属性设置面板中，可以看到FPS属性，如图5-2所示，表示sharedCanvas更新到主域的帧率。 （图5-2） 然后构建发布时，勾选图2-1所示的生成开放数据域工程模板。发布完成后，如图5-3所示，会生成openDataContext目录。开发者可以根据需求修改这里面的内容，下次发布时，如果没有按照5.2那样构建模板目录，那么这个目录不会被清除或者修改。 （图5-3） 修改生成的工程模板（openDataContext目录里的文件），推荐使用一个轻量的第三方Canvas引擎解决这个需求。开发者可以使用此引擎制作自定义的好友排行榜，然后替换掉openDataContext目录下对应文件里的代码即可。 发布后，在“微信开发者工具”里进行调试，此时使用的是默认的工程模板，效果如图5-4所示。 （图5-4） 5.2 构建模板目录 开发者可以在项目目录中建立build-templates/平台名称，例如：build-templates/wxgame，发布时会将这里面的内容拷贝到输出目录。如果是json文件，还会进行合并。比如在build-templates/wxgame里放置game.json，并且内容为 {\"showStatusBar\": true }，那么最终的game.json文件里这个key值就会被加入，并且引擎模版里的game.json其他key值会保留。 在游戏好友排行榜的开发中，发布后的release目录一般不会加入版本管理，这里的openDataContext目录在协同开发中可能不方便，那么可以将自定义改好的openDataContext目录放入构建模版目录，即放置在图5-5所示的项目根目录下的build-templates下的wxgame，这样每次发布时选择的生成开放数据域工程模板就不再是图5-4所示的IDE默认的模板了，而会从模版目录build-templates/wxgame中拷贝。 （图5-5） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2024-02-21 17:22:35 "},"released/miniGame/byteDance/readme.html":{"url":"released/miniGame/byteDance/readme.html","title":"抖音小游戏","keywords":"","body":"抖音小游戏一、概述二、发布为抖音小游戏2.1 选择目标平台2.2 发布后的小游戏目录介绍三、用抖音开发者工具创建小游戏项目3.1 开发者帐号登录，选择项目类型3.2 导入小游戏项目3.3 抖音开发者工具的编译3.4 真机测试与调试四、分包加载抖音小游戏 一、概述 抖音小游戏不需用户进行下载，是点开即玩的全新游戏类型。 相较 APP，小游戏有着开发周期短、开发成本低等特性，能够让开发者更简单的参与到开发过程中。实现快速上线，快速变现。 小游戏有无需下载、玩法简单等特性，与图文、视频等场景有着天然的搭配性。全产品矩阵以内容分发为核心，通过内容带动小游戏分发，由内容为小游戏带量以及裂变。 推荐要看一看抖音小游戏的官方文档，LayaAir引擎的文档更多的是引擎相关的，当然也会混合了一些小游戏接口的应用介绍，但是仔细看看官方文档肯定没错。 下载并安装小游戏开发者工具 小游戏开发工具主要用于小游戏产品的预览与调试、真机测试、上传提交等。是小游戏开发的必备工具。 在抖音小游戏发布前，需要先进行通用设置。 二、发布为抖音小游戏 2.1 选择目标平台 在构建发布面板中，侧边栏选择目标平台为抖音小游戏。如图2-1所示， （图2-1） 点击“构建抖音小游戏”，或“构建其它”选项中的“抖音小游戏”，即可发布项目为抖音小游戏。 Appid：用户可以直接在发布的时候填写抖音小游戏的AppID。 压缩纹理：一般需要勾选“允许使用压缩纹理格式”，如果不勾选，则忽略所有图片对于压缩格式的设置。 纹理源文件：可以不勾选“始终包含纹理源文件”，如果勾选，则即使图片使用了压缩格式，仍然把源文件（png/jpg)打包。目的是遇到不支持压缩格式的系统时，fallback到源文件。 2.2 发布后的小游戏目录介绍 发布后的目录结构如图2-2所示 ： （图2-2） js目录 与 libs目录： 项目代码和引擎库。 resources目录 与 Scene.ls： resources资源目录和场景文件Scene.ls，小游戏由于初始包的限制，建议将初始包的内容在规划好，最好能放到统一的目录下，便于初始包的剥离。 game.js： 抖音小游戏的入口文件，游戏项目入口JS文件与适配库JS等都是在这里进行引入。IDE创建项目的时候已生成好，一般情况下，这里不需要动。 game.json： 小游戏的配置文件，开发者工具和客户端需要读取这个配置，完成相关界面渲染和属性设置。比如屏幕的横竖屏方向。 projectconfig.json： 小游戏的项目配置文件，文件里包括了小游戏项目的一些信息，如果想修改appid等信息，可以直接在这里面编辑。 microgame-adapter.js： 抖音小游戏适配库文件。 三、用抖音开发者工具创建小游戏项目 3.1 开发者帐号登录，选择项目类型 关于抖音开发平台的帐号创建与登录，以及小游戏项目的创建，工具的使用，产品的发布，可以查看抖音的小游戏开发者文档。打开”抖音开发者工具“，用“抖音”APP扫码登录。然后选择小游戏点击进入项目设置，选择新建，如图3-1所示。 （图3-1） 3.2 导入小游戏项目 选择导入目录，就是在LayaAir IDE发布后的目标目录（通常在项目根目录下的release\\bytedancegame） （图3-2） 选择bytedancegame目录之后，如图3-3所示 （图3-3） AppID 测试账号，可以点击注册，不输入也可以开发调试，可以使用测试号，不过功能会受到限制。所以最好还是输入 AppID 3.3 抖音开发者工具的编译 完成小游戏项目的创建后，即可在工具内预览效果和调试。如图3-4所示 （图3-4） 3.4 真机测试与调试 由于LayaAir IDE里也可以调试项目效果，除非是适配相关的问题，基本上两边的效果不会有不一一致的情况。所以这里最重要的是点击预览功能，通过抖音扫码，在抖音内进行真机测试与调试。如图3-5所示 （图3-5） 四、分包加载 下面来介绍LayaAir IDE给抖音小游戏分包的方法，开发者可以先看一下通用设置的分包。可以通过以下步骤进行分包加载，如图4-1所示，点击构建发布后，勾选开启分包，然后选择要分包的文件夹即可。开发者还可以选择是否开启远程包。 （图4-1） 抖音小游戏分包限制： 整个小玩法整体包（主包+分包）大小不超过 20M 单个主包不超过 4M 单个分包大小无限制 请参考抖音小游戏官方文档。 IDE自动加载分包需要在发布时勾选分包的“启动时自动加载”选项。如果是代码引用资源，方法与web发布略有不同，加载代码示例如下： const { regClass, property } = Laya; @regClass() export class Script extends Laya.Script { //declare owner : Laya.Sprite3D; @property({ type: Laya.Scene3D }) scene3d: Laya.Scene3D; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { //小游戏加载分包 Laya.loader.loadPackage(\"sub1\", this.printProgress).then(() => { Laya.loader.load(\"sub1/Cube.lh\").then((res: Laya.PrefabImpl) => { let sp3: Laya.Sprite3D = res.create() as Laya.Sprite3D; this.scene3d.addChild(sp3); }); }) Laya.loader.loadPackage(\"sub2\", this.printProgress).then(() => { Laya.loader.load(\"sub2/Sphere.lh\").then((res: any) => { let sp3 = res.create(); this.scene3d.addChild(sp3); }); }) } printProgress(res: any) { console.log(\"加载进度\" + JSON.stringify(res)); } } 这里主要介绍一下printProgress打印的内容，在抖音开发者工具打开并编译我们导出的项目后，会打印如下日志： （图4-2） tt.loadSubpackage会返回一个LoadSubpackageTask，可以通过它获取当前下载进度。 参考抖音小游戏官方文档。 打印的参数的意义分别是： name：分包的名字； progress：分包下载进度百分比； totalBytesWritten：已经下载的数据长度，单位 Bytes； totalBytesExpectedToWrite：预期需要下载的数据总长度，单位 Bytes。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2024-02-21 17:22:35 "},"released/miniGame/OPPO/readme.html":{"url":"released/miniGame/OPPO/readme.html","title":"OPPO小游戏","keywords":"","body":"OPPO小游戏一、概述二、发布为OPPO小游戏2.1 选择目标平台2.2 发布后的小游戏目录介绍三、Chrome联调OPPO小游戏3.1 OPPO小游戏发布、调试环境准备3.2 OPPO小游戏发布与接入完整流程3.3 真机调试与Chrome输出3.4 发布未成功的处理经验四、OPPO开发者工具调试五、分包加载OPPO小游戏 一、概述 推荐要看一看OPPO小游戏官方的文档，LayaAir引擎的文档更多的是引擎相关的，当然也会混合了一些小游戏接口的应用介绍，但是仔细看看OPPO官方文档肯定没错。 OPPO官方提供了可视化开发者工具，点击这里下载，在LayaAirIDE中配置好相关参数，然后直接在LayaAirIDE内一键发布成功（还会生成一个rpk的包），就可以用OPPO开发者工具调试了。 另一种调试方式则是通过OPPO手机里安装一个apk调试环境，在apk里选择打开rpk的文件，然后通过chrome在PC上用数据线连接手机进行调试。 在OPPO小游戏发布前，需要先进行通用设置。 二、发布为OPPO小游戏 2.1 选择目标平台 在构建发布面板中，侧边栏选择目标平台为OPPO小游戏。如图2-1所示， （图2-1） 点击“构建OPPO小游戏”，或“构建其它”选项中的“OPPO小游戏”，即可发布项目为OPPO小游戏。 下面我们来介绍一下这些功能参数的填写 1、游戏名称 一般都填写中文汉字，英文也可以。用于应用商店、桌面图标、弹窗等游戏入口处。一个好的名字是游戏能不能吸量的重要元素。OPPO是6个汉字以内就可以 2、游戏包名 游戏包名的格式是 com.company.module 第一位com不要变，第二位是公司名，第三位是项目名。都要写英文，例如：com.layabox.demoGame。 3、游戏图标 游戏图标也是重要的游戏入口标识，和游戏名称一样，是非常重要的吸量元素，如果游戏图标设计的好，游戏名称起的好。同样的位置会获得比其它游戏更多的点击率。游戏图标需要提供 192*192 的正方形尺寸。 4、游戏版本名称 游戏版本名称是真实的版本，一般是用于功能性版本的区别。比如我有个大版本改动。原来是1.0，可以变成2.0，如果只是改改Bug，那1.0完全可以改成1.1。以此类推，我们建议采用浮点数命名。比如“0.1”、“1.3”、“5.0”…… 5、游戏版本 游戏版本与版本名称用处不同，这里是渠道平台用于区别版本更新。每次提审都要至少递归+1，自己测试无所谓。但是提审这里的值必须要比上次提审的值至少要+1，+N也是可以的，绝对不能等于或者小于上个版本值，建议是提审版本号递归+1。这里需要注意的是，游戏版本必须为正整数。 6、最小平台版本 最小平台版本，按调试器上显示的平台版本号，进行填写即可。 7、日志等级 七种日志等级，先级从高到底依次为OFF、ERROR、WARN、INFO、LOG、DEBUG、TRACE，可以方便地知道当前程序的运行状态。 8、是否使用正式版签名 如果只是测试版本调试，这里可以不用勾选。正式上线发布前（提版本到平台）必须勾选。 如果勾选了，就会启用正式版签名。关于release签名: ①对于公司,一般一个公司只用一个签名，如果公司已经有签名了，推荐使用公司的签名。如果没有的话，IDE中的发布集成了这个功能，方便开发者生成签名。 ②对于个人开发者，可以多个项目使用一个正式签名。只需要生成一次即可。 如果已经release签名了，将签名文件放到Laya项目 sign/release 文件夹下。 9、压缩纹理 压缩纹理：一般需要勾选“允许使用压缩纹理格式”，如果不勾选，则忽略所有图片对于压缩格式的设置。 纹理源文件：可以不勾选“始终包含纹理源文件”，如果勾选，则即使图片使用了压缩格式，仍然把源文件（png/jpg)打包。目的是遇到不支持压缩格式的系统时，fallback到源文件。 2.2 发布后的小游戏目录介绍 点击版本发布，由于在发布前会检查rpk发布环境（用于生成rpk包），如果没有发布环境的，则会开始下载。 发布后的目录结构如图2-2所示， （图2-2） js目录 与 libs目录： 项目代码和引擎库。 resources目录 与 Scene.ls： resources资源目录和场景文件Scene.ls，小游戏由于初始包的限制，建议将初始包的内容在规划好，最好能放到统一的目录下，便于初始包的剥离。 main.js： OPPO小游戏的入口文件，游戏项目入口JS文件与适配库JS等都是在这里进行引入。IDE创建项目的时候已生成好，一般情况下，这里不需要动。 manifest.json： 小游戏的项目配置文件，文件里包括了小游戏项目的一些信息，如果想修改，可以直接在这里面编辑。 三、Chrome联调OPPO小游戏 3.1 OPPO小游戏发布、调试环境准备 1、OPPO品牌的手机。 2、下载安装OPPO真机测试APP “快应用”（OPPO 小游戏调试器 ） 前往OPPO官网文档 找到安装 runtime.apk 包到 OPPO 手机上这个栏目，通常会选择新版本，进行下载。 要注意的是，调试器的版本，文档中有注明最小平台版本号。LayaAirIDE发布的时候，要和这里最小平台版本号对应上。 3、PC电脑的chrome浏览器与手机数据连接线。 4、安装node.js 环境， 这里推荐安装14.x.x 稳定版本(10.x.x 以上版本可能出现不兼容问题)，node官网：https://nodejs.org/en/。 就是下载安装，比较简单，也不细介绍。能在命令行里调起npm命令就算是成功了。 5、安装ADB OPPO发布时，是通过 ADB 把rpk包推到手机的games目录上去，所以这个必须要装。 [ ADB官网下载: http://adbshell.com/downloads ] 提示一下，下载 ADB Kits，下载后的压缩包，建议解压放到一个路径简单一些的目录（如: D:\\adb）。要记得添加环境变量（不知如何添加环境变量的可自行百度）。 3.2 OPPO小游戏发布与接入完整流程 为了让发布OPPO顺利一些，有一些检查工作我们要做。 第一、PC里，node环境、ADB、Chrome这些，都必须要安装好。 第二、在OPPO的手机里，进入设置-> 其它设置-> 开发者选项 ，开发者选项与USB调试必须开启，如图3-1所示。 (图3-1) 另外要确保安装好OPPO小游戏调试环境“快应用”，如图3-2所示。 (图3-2) 第三、将PC电脑与手机用USB数据线相连，电脑里，可以出现类似图3-3一样的界面。比如，点击图3-3左上角的OPPO R9m，就可以进入手机存储。 (图3-3) 手机里要注意的是，屏幕保持点亮打开，在PC的IDE发布OPPO小游戏时，如果手机出现授权信息请求的时候，一定要点确定允许。如图3-4所示。 （图3-4） 3.3 真机调试与Chrome输出 OPPO的调试必须基于真机调试，PC的chrome只能输出信息，看不到画面。 如果准备工作没问题的话，正常情况下，LayaAirIDE里成功发布OPPO小游戏之后，是rpk的包会自动出现在小游戏的OPPO小游戏列表中的（IDE通过调用ADB推到指定的目录中），如图3-5所示。 （图3-5） 图3-5中的OPPO测试就是我们在发布的时候填写的游戏名称。如果我们看到自己对应的游戏名称，说明是正常发布成功了。点击秒开，就可以打开我们发布的游戏。 如果想看调试信息。这时就需要打开chrome浏览器。然后在输入栏里输入： devtools://devtools/bundled/inspector.html?v8only=true&ws=10.10.82.111:12345/00010002-0003-4004-8005-000600070008 上面示例的IP地址10.10.82.111替换成自己手机上的IP就行，12345是端口号，不行的话就换成12346。IP地址不知道怎么查的，自行百度。这里重点提示的是，PC电脑必须要和手机处于同一个网段的局域网环境下，调试时要保证手机打开在小游戏页面。 如果没问题，效果如图3-6所示，会打印出调试日志。 （图3-6） 发布与调试，顺利的话至此就完成了。 3.4 发布未成功的处理经验 发布文档中只讲功能使用，上面的文档是顺利情况下的流程。然而开发者可能不会那么顺利，那这里我们讲一讲经验。 调试列表中未见游戏，是什么情况 如果我们发布的时候没能将rpk自动发到小游戏目录内，那图3-5的列表中，就没办法直接看到刚发布的小游戏。 这时候就可以使用adb来确认环境了。 在cmd中 输入 adb devices 指令。 1.连接非正常情况： （图3-7-1） 此时就开发者需要检查手机连接，和权限是否正确。 2.在连接正常情况下： （图3-7-2） 这时说明手机已经连接成功，并且已经开起来了开发者模式与usb调试。此时可以尝试重启OPPO的快应用apk，再查看列表信息。 在连接正常的情况下，如果再出现问题。可能就和windows权限有关系，需要确保使用管理员权限启动LayaAirIDE。 关于adb相关，或者手机权限相关的问题，开发者可以自行了解。 另一方案，使我们可以采用手动模式，把rpk包，复制到手机存储的games目录下，如果没有games目录则自己手工创建一下。 rpk包位于项目的release/OPPOgame/dist 目录下。 将发布生成的rpk文件，复制到手机存储的games目录下，如图3-8所示。 （图3-8） 这种方法稳定性更高。 在 .rpk 文件生成成功的情况下，实际上发布流程已经结束。 如果打包流程出现问题，可以把问题反馈给Layabox官方团队，Layabox会与OPPO团队共同处理。 四、OPPO开发者工具调试 除了Chrome调试，开发者还可以使用官方提供的开发者工具。如图4-1所示，打开OPPO开发者工具，点击导入游戏引擎工程，然后选择路径即可。 （图4-1） 然后选择编译方式，如图4-2所示，默认为普通编译，如果进行了分包，则选择“编译分包”，选择后点击“编译”。 （图4-2） 编译成功后，usb连接真机，然后点击真机运行： （图4-3） 真机效果如图4-4所示： （图4-4） 此种方式相比Chrome浏览器调试的优势是，它能够实时显示手机的效果。 五、分包加载 让开发者在开发完成后，能够将项目中分包之外的其他文件打包成主包；再将整个包打成 .rpk 文件。开发者可以先看一下通用设置的分包。 OPPO分包加载包大小的限制 整个小游戏所有分包大小之和不超过 16 M 单个分包大小无限制 加上主包 4M，最终的 rpk 包大小不超过 20M 详细请参考官网文档。 使用LayaAirIDE分包，只需点击构建发布后，勾选开启分包，然后选择要分包的文件夹即可。在设置时需要注意，如果是代码加载的资源，在场景里没有引用，那么一定要添加到始终包含的资源目录。 发布后，开发者只需根据第三节、第四节的任一种调试方法进行调试即可。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2024-02-21 17:22:35 "},"released/miniGame/vivo/readme.html":{"url":"released/miniGame/vivo/readme.html","title":"vivo小游戏","keywords":"","body":"VIVO小游戏一、概述二、发布为vivo小游戏2.1 选择目标平台2.2 发布后的小游戏目录介绍三、用vivo小游戏调试器3.1 vivo小游戏发布、调试环境准备3.2 vivo小游戏发布与接入完整流程四、vivo小游戏分包五、常见问题VIVO小游戏 一、概述 推荐要看一看vivo小游戏官方的文档，LayaAir引擎的文档更多的是引擎相关的，当然也会混合了一些小游戏接口的应用介绍，但是仔细看看vivo官方文档肯定没错。 vivo小游戏中没有可视化开发调试工具，所以只能是在LayaAir IDE中配置好相关参数，然后直接在LayaAir IDE内一键发布成功（生成一个rpk的包）。至于调试方式，则是通过vivo手机里安装一个apk调试环境（vivo小游戏调试器），在apk里选择打开rpk的文件，然后通过Chrome在PC上用数据线连接手机进行调试。 在vivo小游戏发布前，需要先进行通用设置。 二、发布为vivo小游戏 2.1 选择目标平台 在构建发布面板中，侧边栏选择目标平台为vivo小游戏。如图2-1所示， （图2-1） 点击“构建vivo小游戏”，或“构建其它”选项中的“vivo小游戏”，即可发布项目为vivo小游戏。 下面介绍一下这些功能参数的填写： 1、游戏名称 一般都填写中文汉字，英文也可以。用于应用商店、桌面图标、弹窗等游戏入口处。一个好的名字是游戏能不能吸量的重要元素。vivo要求必须是6个汉字以内。 2、游戏包名 游戏包名的格式是 com.company.module 第一位com不要变，第二位是公司名，第三位是项目名。都要写英文，例如：com.layabox.demoGame。 3、游戏图标 游戏图标也是重要的游戏入口标识，和游戏名称一样，是非常重要的吸量元素，如果游戏图标设计的好，游戏名称起的好。同样的位置会获得比其它游戏更多的点击率。游戏图标需要提供 192*192 的正方形尺寸。 4、游戏版本名称 游戏版本名称是真实的版本，一般是用于功能性版本的区别。比如我有个大版本改动。原来是1.0，可以变成2.0，如果只是改改Bug，那1.0完全可以改成1.1。以此类推，我们建议采用浮点数命名。比如“0.1”、“1.3”、“5.0”…… 5、游戏版本 游戏版本与版本名称用处不同，这里是渠道平台用于区别版本更新。每次提审都要至少递归+1，自己测试无所谓。但是提审这里的值必须要比上次提审的值至少要+1，+N也是可以的，绝对不能等于或者小于上个版本值，建议是提审版本号递归+1。这里需要注意的是，游戏版本必须为正整数。 6、最小平台号 vivo目前在官网支持的最小平台版本号可以点击这里查看。 7、日志等级 七种日志等级，先级从高到底依次为OFF、ERROR、WARN、INFO、LOG、DEBUG、TRACE，可以方便地知道当前程序的运行状态。 8、是否使用正式版签名 如果只是测试版本调试，这里可以不用勾选。正式上线发布前（提版本到平台）必须勾选。 如果勾选了，就会启用正式版签名。关于release签名: ①对于公司,一般一个公司只用一个签名，如果公司已经有签名了，推荐使用公司的签名。如果没有的话，IDE中的发布集成了这个功能，方便开发者生成签名。 ②对于个人开发者，可以多个项目使用一个正式签名。只需要生成一次即可。 如果已经release签名了，将签名文件放到Laya项目 sign/release 文件夹下。 9.压缩纹理 压缩纹理：一般需要勾选“允许使用压缩纹理格式”，如果不勾选，则忽略所有图片对于压缩格式的设置。 纹理源文件：可以不勾选“始终包含纹理源文件”，如果勾选，则即使图片使用了压缩格式，仍然把源文件（png/jpg)打包。目的是遇到不支持压缩格式的系统时，fallback到源文件。 2.2 发布后的小游戏目录介绍 点击版本发布，由于在发布前会检查rpk发布环境（用于生成rpk包），如果没有发布环境的，则会开始下载。 发布后的目录结构如图2-3所示，图2-2是build文件夹下的目录。 （图2-2） （图2-3） engine： js项目文件与libs引擎库目录，是项目代码和类库。 resources： 资源目录和资源文件，小游戏由于初始包的限制，建议将初始包的内容在规划好，最好能放到统一的目录下，便于初始包的剥离。 game.js： vivo小游戏的入口文件，游戏项目入口JS文件与适配库JS等都是在这里进行引入。IDE创建项目的时候已生成好，一般情况下，这里不需要动。 manifest.json： 小游戏的项目配置文件，文件里包括了小游戏项目的一些信息，如果想修改，可以直接在这里面编辑。 三、用vivo小游戏调试器 3.1 vivo小游戏发布、调试环境准备 1、vivo品牌的手机 2、下载安装vivo的调试APP，下载页面：https://minigame.vivo.com.cn/documents/#/download/debugger 进入页面后，点击 立即下载 ，即可下载安装。至于如何安装vivo调试APP，这里就不介绍了。 3、下载vivo小游戏引擎 当前调试APP内置的vivo引擎版本是1034，这个版本存在已知BUG，我们必须要前往vivo小游戏官网下载最新版本的小游戏引擎apk。 下载页面为： https://minigame.vivo.com.cn/documents/#/download/engine 当前的推荐的版本是1090，下载安装后，我们可以看到vivo快应用调试器的平台版本号那里也是显示的1090。 4、PC电脑的chrome浏览器与手机数据连接线。 5、安装nodejs 环境 [node官网：https://nodejs.org/en/] 就是下载安装，比较简单，也不细介绍。能在命令行里调起npm命令就算是成功了。 6、安装ADB ADB可以用于授权，以及发布推送等，可以前往ADB的官网下载并安装。 [ ADB官网下载: http://adbshell.com/downloads ] 简单提示一下，下载 ADB Kits，下载后的压缩包，建议解压放到一个路径简单一些的目录（如: D:\\adb）。要记得添加环境变量（不知如何添加环境变量的可自行百度）。 3.2 vivo小游戏发布与接入完整流程 3.2.1 安装并进入快应用调试器 要启动电脑PC的chrome调试环境，我们要先安装好vivo小游戏的调试APP（快应用调试器），如图3-1所示。然后点击进入。 （图3-1） 3.2.2 在快应用调试器界面扫码安装vivo小游戏的rpk包 进入快应用调试器之后，我们可以看到如图3-2所示的APP操作界面。 (图3-2) 把发布目录下/dist目录内的rpk包传到手机里，通过点 本地安装 按钮来安装。 3.2.3 保持物理线路连接以及授权 对于比较有相关经验的开发者，确保USB手机连接线物理线路是已连接状态，并且USB调试授权也没问题的，可以跳过本步骤。 相关操作如下： 1、先用手机连接线将手机与PC保持物理上的连接。 2、在之前打开的命令行下，输入adb shell，如图3-3所示。则是未获得USB调试模式授权。 （图3-3） 此时，我们要关注手机端，是否出现如图3-4所示的提示，如果有，则点 确定 允许USB调试。 （图3-4） 3、再次验证授权。 当USB调试模式授权成功之后，我们再次输入adb shell，应该如图3-5所示。 （图3-5） 总之，在这个环节里，我们要保障PC是有权限调试这个手机设备的。 3.2.4 启动chrome调试环境 之前扫码安装后，会自动进入刚刚安装的游戏或者DEMO。 要启动调试，就要先退出来。 然后，如图3-6所示，点击开始调试，进入vivo小游戏的调试模式。 （图3-6） 真机进入调试模式后，我们再到PC上打开chrome浏览器。 这时候别忘了，要联接USB数据线，将手机设备与PC相联，权限的问题上面已经说过，不再重复。 我们要在手机端查找到手机的IP（不知道怎么查的自行百度）并记住他。一定要注意的是，手机网要和PC网始终保持在同一个局域网段。 在chrome浏览器的输入栏里输入： chrome-devtools://devtools/bundled/inspector.html?v8only=true&ws={IP}:5086/00010002-0003-4004-8005-000600070008 将{IP}替换为手机IP地址即可，如图3-7所示。 (图3-7) 至此，vivo小游戏从发布到启动chrome调试的完整流程已介绍完。如果想了解关于更多vivo小游戏的接入流程与文档介绍，记住这个网址： https://minigame.vivo.com.cn 四、vivo小游戏分包 开发者可以先看一下通用设置的分包。可以通过以下步骤进行分包加载，如图4-1所示，点击构建发布后，勾选开启分包，然后选择要进行分包的文件夹即可，IDE自动加载分包需要在发布时勾选分包的“启动时自动加载”选项。 （图4-1） 将“sub1”、“sub2”设置为分包的资源文件夹后，manifest.json里会自动生成配置信息。分包加载的能力首先依赖于编译时工具，根据开发者在manifest.json中配置的subpackages规则，将项目打包成多个分包。这些分包的大小是有限制的，目前vivo小游戏的分包大小有如下限制： com.application.demo.rpk整体压缩包(包名+.rpk) ------------- com.application.demo.rpk 原整包(包名+.rpk) (兼容老版本引擎的原整包=分包主包+分包A+分包B) ------------- main.rpk 分包主包(main+.rpk) （4M） ------------- pkgA.rpk pkgA分包(子包名+.rpk) (A+B 16M) ------------- pkgB.rpk pkgB分包(子包名+.rpk) 参考vivo小游戏分包加载。 如果是代码引用资源，加载代码示例如下： const { regClass, property } = Laya; @regClass() export class Script extends Laya.Script { //declare owner : Laya.Sprite3D; @property({ type: Laya.Scene3D }) scene3d: Laya.Scene3D; constructor() { super(); } /** * 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 */ onAwake(): void { //小游戏加载分包 Laya.loader.loadPackage(\"sub1\", this.printProgress).then(() => { Laya.loader.load(\"sub1/Cube.lh\").then((res: Laya.PrefabImpl) => { let sp3: Laya.Sprite3D = res.create() as Laya.Sprite3D; this.scene3d.addChild(sp3); }); }) Laya.loader.loadPackage(\"sub2\", this.printProgress).then(() => { Laya.loader.load(\"sub2/Sphere.lh\").then((res: any) => { let sp3 = res.create(); this.scene3d.addChild(sp3); }); }) } printProgress(res: any) { console.log(\"加载进度\" + JSON.stringify(res)); } } 这里介绍一下printProgress打印的内容，在小游戏调试器平台打我们导出的项目后，连接vivo官网提供的调试地址会打印如下日志： （图4-2） vivo小游戏官方提供了qg.loadSubpackage()API来触发分包的加载，调用qg.loadSubpackage()在加载完成后，通过qg.loadSubpackage()的成功回调来通知加载完成。 同时，qg.loadSubpackage()会返回一个 LoadSubpackageTask ，可以通过 LoadSubpackageTask 获取当前下载进度。 五、常见问题 粒子渲染黑屏问题 vivo小游戏勾选使用3D粒子有时会遇到卡死、黑屏问题，这是由于vivo支持instance扩展以及支持vao扩展存在问题导致的。 建议直接配置vao为true来避免直接修改引擎的麻烦，可以在项目中配置vivo的发布模板：在发布模板的manifest.json中配置好vao，并设置最小平台版本为最低支持引擎版本（1102）以上。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2024-02-21 17:22:35 "},"released/miniGame/xiaomi/readme.html":{"url":"released/miniGame/xiaomi/readme.html","title":"小米快游戏","keywords":"","body":"小米快游戏一、概述二、发布为小米快游戏2.1 选择目标平台2.2 发布后的小游戏目录介绍三、用小米快游戏调试器3.1 小米快游戏发布、调试环境准备3.2 小米快游戏发布与接入完整流程四、小米快游戏分包小米快游戏 一、概述 推荐要看一看小米快游戏官方的文档，LayaAir引擎的文档更多的是引擎相关的。 小米快游戏中没有可视化开发调试工具，所以只能是LayaAir IDE中配置好相关参数，然后直接在LayaAir IDE内一键发布成功（生成一个rpk的包）。至于调试方式，则是通过小米手机里安装一个apk调试环境，在apk里选择打开rpk的文件，然后通过Chrome浏览器在PC上用数据线连接手机进行调试。 在小米快游戏发布前，需要先进行通用设置。 二、发布为小米快游戏 2.1 选择目标平台 在构建发布面板中，侧边栏选择目标平台为小米快游戏。如图2-1所示， （图2-1） 点击“构建小米快游戏”，或“构建其它”选项中的“小米快游戏”，即可发布项目为小米快游戏。 下面我们来介绍一下这些功能参数的填写： 1、游戏名称 一般都填写中文汉字，英文也可以。用于应用商店、桌面图标、弹窗等游戏入口处。一个好的名字是游戏能不能吸量的重要元素。我们的建议是都不要超过6个汉字，游戏名太长没什么好处。 2、游戏包名 游戏包名的格式是 com.company.module 第一位com不要变，第二位是公司名，第三位是项目名。都要写英文，例如：com.layabox.demoGame。 3、游戏图标 游戏图标也是重要的游戏入口标识，和游戏名称一样，是非常重要的吸量元素，如果游戏图标设计的好，游戏名称起的好。同样的位置会获得比其它游戏更多的点击率。游戏图标需要提供 192*192 的正方形尺寸。 4、游戏版本名称 游戏版本名称是真实的版本，一般是用于功能性版本的区别。比如我有个大版本改动。原来是1.0，可以变成2.0，如果只是改改Bug，那1.0完全可以改成1.1。以此类推，我们建议采用浮点数命名。比如“0.1”、“1.3”、“5.0”…… 5、游戏版本 游戏版本与版本名称用处不同，这里是渠道平台用于区别版本更新。每次提审都要至少递归+1，自己测试无所谓。但是提审这里的值必须要比上次提审的值至少要+1，+N也是可以的，绝对不能等于或者小于上个版本值，建议是提审版本号递归+1。这里需要注意的是，游戏版本必须为正整数。 6、最小平台号 最小平台号，按调试器上显示的平台版本号，进行填写即可。 7、日志等级 七种日志等级，先级从高到底依次为OFF、ERROR、WARN、INFO、DEBUG、TRACE、ALL，可以方便地知道当前程序的运行状态。 8、是否使用正式版签名 如果只是测试版本调试，这里可以不用勾选。正式上线发布前（提版本到平台）必须勾选。 如果勾选了，就会启用正式版签名。关于release签名: ①对于公司,一般一个公司只用一个签名，如果公司已经有签名了，推荐使用公司的签名。如果没有的话，IDE中的发布集成了这个功能，方便开发者生成签名。 ②对于个人开发者，可以多个项目使用一个正式签名。只需要生成一次即可。 如果已经release签名了，将签名文件放到Laya项目 sign/release 文件夹下。 9、压缩纹理 压缩纹理：一般需要勾选“允许使用压缩纹理格式”，如果不勾选，则忽略所有图片对于压缩格式的设置。 纹理源文件：可以不勾选“始终包含纹理源文件”，如果勾选，则即使图片使用了压缩格式，仍然把源文件（png/jpg)打包。目的是遇到不支持压缩格式的系统时，fallback到源文件。 2.2 发布后的小游戏目录介绍 点击版本发布，由于在发布前会检查rpk发布环境（用于生成rpk包），如果没有发布环境的，则会开始下载。 发布后的目录结构如图2-2所示： （图2-2） js目录 与 libs目录： 项目代码和引擎库。 resources目录 与 Scene.ls： resources资源目录和场景文件Scene.ls，小游戏由于初始包的限制，建议将初始包的内容在规划好，最好能放到统一的目录下，便于初始包的剥离。 main.js： 小米快游戏的入口文件，游戏项目入口JS文件与适配库JS等都是在这里进行引入。IDE创建项目的时候已生成好，一般情况下，这里不需要动。 manifest.json： 小游戏的项目配置文件，文件里包括了小游戏项目的一些信息，如果想修改，可以直接在这里面编辑。 三、用小米快游戏调试器 3.1 小米快游戏发布、调试环境准备 1、小米品牌的手机（注意必须是MIUI 8.5或以上版本）。 2、下载安装小米的测试APP，进入下载页面后，找到第三步，直接按提示下载即可。 3、PC电脑的Chrome浏览器与手机数据连接线。 4、安装node.js环境，详细步骤在《搭建基础开发环境》中有介绍。 5、安装ADB。 建议安装ADB，因为有些时候，因为授权或者别的莫名其怪的原因。会导致无法正常启动Chrome联真机调试。所以安装ADB 可以验证手机与PC电脑的连接授权。如果确保无USB调试授权问题的，也可以不装。 简单提示一下，下载 ADB Kits，下载后的压缩包，建议解压放到一个路径简单的目录（如: D:\\adb）。要记得添加环境变量（不知如何添加环境变量的可自行百度）。 3.2 小米快游戏发布与接入完整流程 3.2.1 安装并进入快应用调试器 先在手机上安装好小米快游戏的调试APP（快应用调试器），如图3-1所示。然后点击进入。 （图3-1） 3.2.2 在快应用调试器界面扫码安装小米快游戏的rpk包 进入快应用调试器之后，我们可以看到如图3-2所示的APP操作界面。 (图3-2) 可以扫码安装，或者连接USB数据线把发布目录下/dist目录内的rpk包传到手机里，通过点本地安装按钮来安装。 3.2.3 保持物理线路连接以及授权 对于比较有相关经验的开发者，确保USB手机连接线物理线路是已连接状态，并且USB调试授权也没问题的，可以跳过本步骤。 相关操作如下： 1、先用手机连接线将手机与PC保持物理上的连接。打开手机的开发者模式，且打开USB调试。 此时，我们要关注手机端，是否出现如图3-3所示的提示，如果有，则点 确定 允许调试。 （图3-3） 2、验证授权。 当USB调试模式授权成功之后，我们在PC端打开cmd窗口，输入adb devices，应该如图3-4所示。 （图3-4） 总之，在这个环节里，我们要保障PC是有权限调试这个手机设备的。 4.4 启动chrome调试环境 小米快游戏在PC上没有工具的开发调试环境，是通过USB联接到手机设备，然后在PC命令行模式下，通过 npm run debug 命令调起Chrome调试器（前提要保障PC是已安装了Chrome浏览器的）来联调手机真机环境的rpk包，如图3-5所示。当我们能看到Debugger URL opened in Chrome.这个提示的时候，说明chrome已被成功调起。 (图3-5) 或者在Chrome浏览器中输入chrome://inspect/#devices，进入后找到连接的手机选项，点击inspect，如图3-6所示： （图3-6） 操作完成后，如图3-7所示，就可以按Chrome的调试方式来调试小米快游戏项目。 (图3-7) 至此，小米快游戏从发布到启动Chrome调试的完整流程已介绍完。 四、小米快游戏分包 开发者在开发完成后，能够将需要分包的文件夹进行分包，项目中分包之外的其他文件打包成主包。 小米快游戏分包加载包大小的限制 整个小游戏的所有分包总和不超过 10M； 单个分包/基础包大小不能超过 5M； 整体压缩包（包含原整包和所有分包；）不超过20M。 如图4-1所示，点击开启分包后，选择要进行分包的文件夹即可。 （图4-1） 分包加载的API等，可参考小米官方文档。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2024-02-21 17:22:35 "},"released/miniGame/alipaygame/readme.html":{"url":"released/miniGame/alipaygame/readme.html","title":"支付宝小游戏","keywords":"","body":"支付宝小游戏一、概述二、构建发布为支付宝小游戏2.1 选择目标平台2.2 发布后的小游戏目录介绍三、使用支付宝小游戏开发工具3.1 申请小游戏应用3.2 安装小游戏开发工具3.3 登录支付宝开发者账号3.4 预览或真机调试3.5 上传与发布四、分包加载支付宝小游戏 一、概述 支付宝小游戏不需要用户进行下载，是点开即玩的全新游戏类型。 相较 APP，小游戏有着开发周期短、开发成本低等特性，能够让开发者更简单的参与到开发过程中。实现快速上线，快速变现。 推荐要看一下支付宝小游戏的文档，其中第一篇《如何快速上线一个小游戏》能够帮助开发者快速发布上线小游戏项目，安装小游戏开发工具也会用到这篇文章的内容。LayaAir引擎的文档更多的是引擎相关的，当然也会混合了一些小游戏接口的应用介绍。 在支付宝小游戏发布前，需要先进行通用设置。 二、构建发布为支付宝小游戏 2.1 选择目标平台 在构建发布面板中，侧边栏选择目标平台为支付宝小游戏。如图2-1所示， （图2-1） 点击“构建支付宝小游戏”，或“构建其它”选项中的“支付宝小游戏”，即可发布项目为支付宝小游戏。 ES6转ES5：若构建发布后，需要使用支付宝小游戏开发工具的“真机调试”功能，则需要勾选该选项。一般建议勾选。 压缩纹理：一般需要勾选“允许使用压缩纹理格式”，如果不勾选，则忽略所有图片对于压缩格式的设置。 纹理源文件：可以不勾选“始终包含纹理源文件”，如果勾选，则即使图片使用了压缩格式，仍然把源文件（png/jpg)打包。目的是遇到不支持压缩格式的系统时，fallback到源文件。 2.2 发布后的小游戏目录介绍 发布后的目录结构如图2-2所示 ： （图2-2） js目录 与 libs目录： 项目代码和引擎库。 resources资源目录 与 Scene.ls： resources资源目录和场景文件Scene.ls，小游戏由于初始包的限制，建议将初始包的内容提前规划好，最好能放到统一的目录下，便于初始包的剥离。 game.js： 支付宝小游戏的入口文件，游戏项目入口JS文件与适配库JS等都是在这里进行引入。IDE创建项目的时候已生成好，一般情况下，这里不需要动。 game.json： 小游戏的配置文件，开发者工具和客户端需要读取这个配置，完成相关界面渲染和属性设置。 project.config.json： 小游戏的项目配置文件，文件里包括了小游戏项目的一些信息。 my-adapter.js： 支付宝小游戏适配库文件，用于适配支付宝小游戏。 三、使用支付宝小游戏开发工具 调试LayaAir构建发布后的支付宝小游戏项目，需要安装小游戏开发工具。步骤如下： 3.1 申请小游戏应用 不论是调试还是发布支付宝小游戏，都需要一个AppID。获取这个AppID需要登录开发者官网，登录自己的开发者账号（支付宝账号），创建小游戏，具体的操作可以参考支付宝的文档。创建一个小游戏后，就会生成一个AppID，开发者在调试和发布环节都会用到它。 3.2 安装小游戏开发工具 支付宝小游戏开发工具需要通过命令行使用，开发者可以打开命令行面板（以管理员身份运行），输入如下命令进行安装： npm i -g minidev@1.8.10 安装过程中，可能会因为网络问题造成卡顿，要注意的是，这里的node.js版本不能过低，最起码要高于12。 字符@后面的1.8.10表示小游戏开发工具的版本，开发者在安装时要根据需求选择合适的版本。 3.3 登录支付宝开发者账号 下载好小游戏开发工具后，就要进行登录了，登录也是通过命令行。 接着上一步，执行minidev login命令后，会出现一个二维码，开发者使用支付宝扫码登陆开发者账号即可。 如图3-1所示，登录成功后会显示“完成授权”字样。 （图3-1） 3.4 预览或真机调试 准备好小游戏开发工具后，就要调试LayaAir构建发布的小游戏项目了。支付宝给出了预览和真机调试两种方式，都需要通过命令行来执行。一般LayaAir项目构建发布为支付宝小游戏后，都是使用真机调试。因为真机调试会在PC的浏览器上打开调试面板，而预览只能在手机端打开调试面板。 3.4.1 预览 预览，要求安装的小游戏开发工具版本\\>= @ali/minidev@1.2.10。 在项目目录执行命令：minidev preview -a 2021xxx --ignore-http-domain-check，其中“2021xxx”为3.1节中生成的AppID。效果如图3-2所示： （图3-2） 执行后的结果如图3-3所示， （图3-3） 用支付宝扫码预览效果，如图3-4所示，可以点击右上角的三个点打开调试面板。 （图3-4） 实际操作时，不推荐使用预览，开发者有兴趣可以查看支付宝文档中的相关详细内容。 3.4.2 真机调试 真机调试，要求安装的小游戏开发工具版本\\>= @ali/minidev@1.3.0，真机调试需要在图2-1中，即LayaAir构建发布为支付宝小游戏时勾选ES6转ES5。 在项目目录执行命令：minidev remote-debug -a 2021xxx --ignore-http-domain-check，其中“2021xxx”为3.1节中生成的AppID。效果如图3-5所示： （图3-5） 执行后的结果如图3-6所示，会生成一个地址用于远程调试，并且生成一个二维码，开发者使用支付宝扫码就可以查看效果。 （图3-6） 此时在PC的浏览器上打开远程地址，会显示出调试面板，如图3-7所示， （图3-7） 对于个人开发者来说，真机调试可能会遇到看不到对应小游戏等问题，支付宝的文档中总结了一些常见问题。 3.5 上传与发布 若想将调试好的支付宝小游戏真正发布到线上，还需要上传和发布操作。 上传，要求安装的小游戏开发工具版本\\>=@ali/minidev@1.4.2，也需要在项目目录中使用命令执行：minidev upload -a 2021xxx -v 0.0.1 --game，其中“2021xxx”为3.1节中生成的AppID。上传之后，在开放平台，就可以对上传的版本生成体验码。 发布，审核通过后，在小程序官网进行发布上线。 上传命令的具体参数要求可以参考支付宝文档。 四、分包加载 下面介绍LayaAir IDE给支付宝小游戏分包的方法，开发者可以先看一下通用设置的分包。可以通过以下步骤进行分包加载，如图4-1所示，勾选开启分包，然后选择要分包的文件夹即可。开发者还可以选择是否开启远程包。 （图4-1） 支付宝小游戏分包限制： 整个小游戏所有主包+分包大小不超过 20M 主包不超过 4M 单个普通分包不限制大小 请参考支付宝小游戏文档。 调试分包加载时使用的支付宝小游戏开发工具，需要升级到1.8.10及以上版本。 IDE自动加载分包需要在发布时勾选分包的“启动时自动加载”选项。如果是代码引用资源，方法与web发布略有不同，加载代码示例如下： const { regClass, property } = Laya; @regClass() export class Script extends Laya.Script { @property({ type: Laya.Scene3D }) scene3d: Laya.Scene3D; constructor() { super(); } // 组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只执行一次 onAwake(): void { //支付宝小游戏 Laya.loader.loadPackage(\"sub1\", this.printProgress).then(() => { Laya.loader.load(\"sub1/Cube.lh\").then((res: Laya.PrefabImpl) => { let sp3: Laya.Sprite3D = res.create() as Laya.Sprite3D; this.scene3d.addChild(sp3); }); }) Laya.loader.loadPackage(\"sub2\", this.printProgress).then(() => { Laya.loader.load(\"sub2/Sphere.lh\").then((res: any) => { let sp3 = res.create(); this.scene3d.addChild(sp3); }); }) } printProgress(res: any) { console.log(\"加载进度\" + JSON.stringify(res)); } } 代码中printProgress会打印加载进度日志，效果如下所示： （图4-2） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2024-02-21 17:22:35 "},"released/miniGame/tbgame/readme.html":{"url":"released/miniGame/tbgame/readme.html","title":"淘宝小游戏","keywords":"","body":"淘宝小游戏一、概述二、发布为淘宝小游戏2.1 选择目标平台2.2 发布后的小游戏目录介绍三、使用淘宝开发者工具创建小游戏项目3.1 账号准备3.2 导入项目3.3 真机测试与调试四、分包加载五、Q&A淘宝小游戏 Version >= LayaAir 3.1.1 一、概述 淘宝小游戏是指开发者基于淘宝开放平台开发，直接投放至手淘、猫客、淘特等消费者端为淘宝、淘特消费者提供各年龄段适用游戏，包含养成类、益智类、合成类、建造类等。 推荐开发者查看淘宝官方对于小游戏的介绍，能够了解应用场景、查看接入指南等。还可以浏览一下淘宝官方的开发指南。 下载并安装淘宝开发者工具 淘宝开发者工具主要用于小游戏产品的预览与调试、真机测试、上传提交等。是淘宝小游戏开发的必备工具。 在淘宝小游戏发布前，需要先进行通用设置。 二、发布为淘宝小游戏 2.1 选择目标平台 在构建发布面板中，侧边栏选择目标平台为淘宝小游戏。如图2-1所示， （图2-1） 点击“构建淘宝小游戏”，或“构建其它”选项中的“淘宝小游戏”，即可发布项目为淘宝小游戏。 压缩纹理：一般需要勾选“允许使用压缩纹理格式”，如果不勾选，则忽略所有图片对于压缩格式的设置。 纹理源文件：可以不勾选“始终包含纹理源文件”，如果勾选，则即使图片使用了压缩格式，仍然把源文件（png/jpg)打包。目的是遇到不支持压缩格式的系统时，fallback到源文件。 2.2 发布后的小游戏目录介绍 发布后的目录结构如图2-2所示 ： （图2-2） js目录 与 libs目录： 项目代码和引擎库。 resources目录 与 Scene.ls： resources资源目录和场景文件Scene.ls，小游戏由于初始包的限制，建议将初始包的内容在规划好，最好能放到统一的目录下，便于初始包的剥离。 game.js： 淘宝小游戏的入口文件，游戏项目入口JS文件与适配库JS等都是在这里进行引入。IDE创建项目的时候已生成好，一般情况下，这里不需要动。 game.json： 小游戏的配置文件，开发者工具和客户端需要读取这个配置，完成相关界面渲染和属性设置。比如屏幕的横竖屏方向。 mini.project.json： 小游戏的项目配置文件，文件里包括了小游戏项目的一些信息，如果想修改，可以直接在这里面编辑。 my-adapter.js： 淘宝小游戏适配库文件。 三、使用淘宝开发者工具创建小游戏项目 3.1 账号准备 预览和调试淘宝小游戏时，需要进行入驻。开发者需要登录淘宝开放平台，登录自己的开发者账号（淘宝账号）并创建应用。具体的操作可以参考官方的文档，入驻成功后就可以进行后续的步骤。 3.2 导入项目 在LayaAir IDE中创建并发布淘宝小游戏项目后，打开淘宝开发者工具，在侧边栏选择小游戏，点击打开项目，如图3-1所示， （图3-1） 然后，选择项目路径，项目类型选择“小游戏-新”一栏的选项，关联应用则是在3.1节中创建的应用，最后点击确定打开项目。 （图3-2） 3.3 真机测试与调试 打开淘宝开发者工具后，一般预览时都要勾选云构建，如图3-3所示， （图3-3） 然后就可以进行预览和真机调试了。如图3-4所示，点击调试按钮，等待二维码生成，使用手机淘宝APP扫码即可。 （图3-4） 四、分包加载 下面介绍LayaAir IDE给淘宝小游戏分包的方法，开发者可以先看一下通用设置的分包。可以通过以下步骤进行分包加载，如图4-1所示，勾选开启分包，然后选择要分包的文件夹即可。开发者还可以选择是否开启远程包。 （图4-1） 需要注意，远程包的地址需要使用“阿里云的CDN地址”或“在淘宝开放平台上创建的应用中进行白名单的配置”。所以，远程包地址如果是本地服务器地址会报错，出现下载失败等情况。因此，最好使用https的外部服务器资源地址，并添加到小游戏后台的白名单作用域上。 淘宝小游戏分包限制： 1）整个小程序所有分包大小不超过20MB。 2）单个分包或主包大小不能超过2MB。 请参考淘宝小游戏官方文档。 五、Q&A 1、真机与IDE表现不一致，或者IDE出现报错 这个以真机预览为准，淘宝IDE出现报错可以反馈给淘宝。 2、作用域问题 由于淘宝小游戏与其他平台的作用域不同，淘宝小游戏作用域为$global，LayaAir已经在发布后的js内，使用var window = $global来替代使用，使用过程中如果存在“xx is undefined”的情况，可以排查下对应js内是否没有进行声明。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2024-03-08 17:26:02 "},"released/native/LayaNative_Introduction/readme.html":{"url":"released/native/LayaNative_Introduction/readme.html","title":"Native打包发布","keywords":"","body":"LayaNative综述LayaNative包含以下内容:1. 测试器：2. 构建工具：3. 反射机制:4. 渠道对接工具内(conchMarket):5. LayaPlayer：6.LayaNative的原理和开发流程LayaNative综述 LayaNative是LayaAir引擎针对移动端原生App的开发、测试、发布的一套完整的开发解决方案，但不局限于LayaAir引擎。LayaNative以LayaPlayer为核心运行时的基础上，利用反射机制、渠道对接方案提供开发者在原生App上进行二次开放和渠道对接，并提供测试器、构建工具，为开发者将html5项目打包、发布成原生App提供便利。 LayaNative包含以下内容: 1. 测试器： 下载安装测试器后，通过扫码URL二维码的方式，帮助开发者快速在移动端看到运行效果, 节省大量反复打包测试的时间； 2. 构建工具： 构建工具可帮助开发者快速构建移动端APP项目工程, 然后使用Android Studio、Eclipce、XCode 等开发工具打开->构建->运行； 3. 反射机制: 通过反射机制,开发者可以实现JavaScript与原生语言(Android/Java 或 iOS/Objective-C)的相互调用，通过反射机制开发者可以很方便的对应用程序进行二次扩展； 4. 渠道对接工具内(conchMarket): 渠道对接工具内嵌了渠道常用对接API，例如: 登录, 分享, 充值,好友关系链等； 5. LayaPlayer： LayaPlayer是LayaNative最核心的部分，它是一个基于JavaScript脚本引擎 + openGLES硬件加速渲染的跨平台引擎，通过对内存与渲染流程进行极致优化，为基于HTML5、WEBGL的多媒体应用、游戏等产品加速，使其性能媲美原生Native-APP。LayaPlayer采用C++语言编写,可嵌入浏览器或操作系统运行，也可以独立运行。 6.LayaNative的原理和开发流程 （1）、使用LayaAir开发的项目，准备在发布成app版本（ios或android）。（2）、LayaNative会使用核心引擎LayaPlayer进行加速。（3）、开发者可以使用测试器，快速安装到移动设备上进行简单的测试。（4）、最终通过命令行或者IDE，构建ios或android的工程，进行编译、执行。（5）、如果需要发布到各大渠道（例如：百度、360、AppStroe、google等），需要通过反射机制进行二次开发（即：对接渠道的SDK，登录、充值、分享等）。（6）、最后构建成app进行安装、测试、发布。 流程如图1所示： ​ ​ 图（1） Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/native/native_index/readme.html":{"url":"released/native/native_index/readme.html","title":"LayaNative不是浏览器","keywords":"","body":"LayaNative首页说明1、LayaNative的启动入口2、LayaNative的启动文件配置说明LayaNative首页说明 重要的事情需要说三遍： LayaNative不是浏览器！ LayaNative不是浏览器！ LayaNative不是浏览器！ 1、LayaNative的启动入口 由于LayaNative不是浏览器，也不是通过封装浏览器或者webkit之类的控件来运行html的内容。 所以，LayaNative不能启动和运行html页面文件。 引擎项目bin目录下的index.html可以作为浏览器里的入口，但是不能作为LayaNative的启动入口。 LayaNative的启动入口默认为 通过LayaAirIDE的菜单栏文件--> 构建发布 ，打开的构建项目窗口里，URL那里配置好即可，配置方式如图1所示。 还需要进行通用配置。 在图1里，入口默认为index.js 2、LayaNative的启动文件配置说明 入口文件主要确定项目运行时屏幕方向和需要加载的js文件的信息 如果我们使用项目的index.js作为LayaNative的启动入口文件，在点击版本发布后 示例如下： /** * 设置LayaNative屏幕方向，可设置以下值 * landscape 横屏 * portrait 竖屏 * sensor_landscape 横屏(双方向) * sensor_portrait 竖屏(双方向) */ window.screenOrientation = \"portrait\"; // 设置屏幕为竖屏 //-----引擎库开始----- loadLib(\"libs/laya.core.js\") loadLib(\"libs/laya.ui.js\") loadLib(\"libs/laya.d3.js\") //-----引擎库结束------- loadLib(\"js/bundle.js\");//项目代码js 注意： 请不要在index.js文件里编写任何逻辑代码，如果编写可能会发生未知的错误。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2024-04-17 17:15:15 "},"released/native/build_Tool/readme.html":{"url":"released/native/build_Tool/readme.html","title":"安卓/iOS构建","keywords":"","body":"LayaBox 构建工具1. 运行需求2. 面向用户3. 在IDE中构建项目4. 项目构建界面参数５. 构建好的项目工程的使用6. 手动切换单机版和网络版7. 资源刷新8. 其他注意问题LayaBox 构建工具 　　构建工具用来生成LayaPlayer的移动端App项目，相当于App项目向导。目前支持Android（Eclipse项目、Android studio项目）和iOS(XCode项目)。注意： LayaNative3.0-Android，要求系统最低版本为4.3 LayaNative3.0-iOS，要求系统最低版本为10.0 1. 运行需求 1.1 基础开发环境 ​ 构建项目必须要准备好开发环境。比如：构建iOS项目需要准备好Mac电脑和XCode，android需要准备好Android studio。 2. 面向用户 　无论是构建Android还是iOS项目，则必须要有相应的Android或iOS的App开发基础。 如果不具备，请先去学习了解相关的基础知识。 3. 在IDE中构建项目 使用IDE 发布项目，开发者首先在文件菜单中，打开“构建项目”选项，如动图1所示 （动图1） 　目标平台选择iOS或者Adroid, 由于构建工具需的库文件比较大，因此并没有直接包含在LayaAirIDE中，在第一次使用这个工具的时候，会先下载SDK包，如下图： ​ (图2) 注意 这个文件比较大，所以下载的时候需要耐心等待。 4. 项目构建界面参数 在LayaAirIDE中打开项目构建的界面，如图3所示： (图3) 目标平台 构建生成的项目工程的类型，有Android studio项目、iOS 项目 两种选项，如果需要生成Android项目，可以选择Android-studio。 如果需要生成XCode(iOS)项目，则选择iOS选项。 版本 Native工程的版本，尽量与LayaAir引擎版本一致，否则可能存在版本兼容性问题 单机 如果勾选此选项，则构建的项目打包的App是单机版，否则就是在线版。单机版不需要联网，没有对应的url，不用提供url。但是必须提供游戏资源，否则打包之后无法运行。单机版的地址固定为 http://stand.alone.version/index.js 打包资源 资源是脚本、图片、声音等资源。对于在线游戏，只要有游戏的url就能正常运行，但是把资源直接打进App包中的话，可以避免网络下载，加快资源载入速度。如果是单机游戏，由于没有提供游戏url，就必须给资源目录，把所需的资源全部打包进App。 打包进App的资源依然可以通过我们的dcc工具（资源缓存管理）进行更新。 如果这时候没有设置资源路径，在构建完项目以后，依然可以手动添加资源，添加方法参考 LayaDcc工具。 注意： 　　把资源打包的缺点是会增加包体的大小。 　　打包资源的在线游戏，必须在server端打dcc，否则就会失去打包的优势，依然会下载所有的资源。如何打dcc，参考 LayaDcc工具。 App名称 App的名称。同时也是构建项目的输出目录。 应用ID 应用的包名，这个正常情况下是不可见的。一般采用反域名命名规则（有利于分辨和避免与系统中已经有的APP冲突)。 例如 : com.layabox.runtime.demo　　包名必须是 xxx.yyy.zzz 的格式，至少要有两级，即xxx.yyy 。否则打包会失败。 URL 如果要打包的应用是一个在线项目，则需要提供一个启动url，指向一个js或json文件，是应用的入口。而通过LayaAir生成的项目，会输出一个启动页面，一般是index.js。 在测试的时候，为了方便，通常是使用的本地URL地址在浏览器中测试，当打成Android App的时候，必须有一个真正的webserver的地址， 例如： 　　局域网地址： http://10.10.20.19:8888/index.js 　　实际地址: http://nativetest.layabox.com/layaplayer/index.js ５. 构建好的项目工程的使用 构建好的 App工程，可以用对应的开发工具打开进行二次开发和打包等操作。 Android-studio（android）项目可以使用 android-studio软件进行导入和开发。 XCode（ios）项目可以使用 xcode 软件进行导入和开发。打开XCode(ios)项目后需要选择真正的ios设备进行build。（注意：真正的设备是 armv7、armv7s、arm64 架构。而如果使用ios Simulator 则是 X86 架构，目前 LayaNative 在 ios 设备上尚未支持 X86 架构，如果使用模拟器编译是无法通过的。 参考资源： Android Studio的使用和配置 IOS打包发布App详细流程 ​ 6. 手动切换单机版和网络版 构建完成之后，可以通过直接在项目中修改代码来切换单机版和网络版。 Android 项目 在构建的项目中打开MainActivity.java，搜索 mPlugin.game_plugin_set_option(\"localize\",\"false\"); 单机版需要设置为\"true\"，如mPlugin.game_plugin_set_option(\"localize\",\"true\"); 如果要设置为网络版，就要修改为：mPlugin.game_plugin_set_option(\"localize\",\"false\");， 并且设置正确的地址： mPlugin.game_plugin_set_option(\"gameUrl\", \"http://你的地址/index.js\"); iOS 项目 iOS项目构建完成后，项目目录下的 resource/scripts/index.js 脚本的最后有个执行loadUrl的函数，这里会加载首页地址，修改这里的地址就能切换单机版和网络版，单机版的地址固定为 http://stand.alone.version/index.js。 例如一开始是网络版，地址为： loadUrl(conch.presetUrl||\"http://10.10.20.19:7788/index.js\");要改成单机版的话，修改这句话： loadUrl(conch.presetUrl||\"http://stand.alone.version/runtime.json\");反之亦然。 注意一旦修改了url地址，原来打包的资源就都失效了。这时候，需要手动删除 cache目录下内容，重新用layadcc来生成打包资源，参见LayaDCC工具。 7. 资源刷新 通过IDE构建好工程，如果选择的是单机版和打包资源版本。会在resource/cache目录下，把所有h5项目的资源（包括：脚本、图片、html、声音等）全部打包到了这个目录下。android的目录： assets/cache/iOS的目录： resource/cache/ 但是在开发过程中，h5的项目一直在变化，为了避免每次都重新构建工程，可以通过命令行进行刷新。 资源包版本调用命令：layanative3 refreshres -u http://testgame.layabox.com/index.js单机版本调用命令：layanative3 refreshres Tips1、必须在构建的app工程目录下，执行命令。最明显的标志就是要在navtie.json的目录下，如下图所示： 关于layanative命令行如何安装使用，请参考layanative命令行工具使用 8. 其他注意问题 　　android studio构建完成后，需要根据自己的环境修改android sdk的版本号，现在设置的是23，需要修改的 文件是 app/build.gradle。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/native/screen_orientation/readme.html":{"url":"released/native/screen_orientation/readme.html","title":"横竖屏设置","keywords":"","body":"横竖屏设置一、项目构建前横竖屏的设置二、项目构建后横竖屏的设置2.1 iOS2.2 Android三、执行顺序横竖屏设置 本篇文档进一步全面介绍LayaNative横竖屏的设置。 一、项目构建前横竖屏的设置 如果想设置横竖屏，通过LayaAirIDE的菜单栏工具--> app构建 ，打开的构建项目窗口里，屏幕方向那里配置好即可，配置方式如下图所示。 当设置屏幕方向后，点击版本发布，在index.js中会添加screenOrientation属性： /** * 设置LayaNative屏幕方向，可设置以下值 * landscape 横屏 * portrait 竖屏 * sensor_landscape 横屏(双方向) * sensor_portrait 竖屏(双方向) */ window.screenOrientation = \"portrait\"; // 设置屏幕为竖屏 //-----引擎库开始----- loadLib(\"libs/laya.core.js\") loadLib(\"libs/laya.ui.js\") loadLib(\"libs/laya.d3.js\") //-----引擎库结束------- loadLib(\"js/bundle.js\");//项目代码js 二、项目构建后横竖屏的设置 2.1 iOS iOS项目构建成功后，打开resource/config.ini文件，修改orientation=16的值，如下图所示： 参数的意义如下： orientation=2 //竖屏：IOS home键在下 orientation=4 //竖屏：IOS home键在上 orientation=8 //横屏：IOS home键在左 orientation=16 //横屏：IOS home键在右 orientation的值可以使用按位或的方式进行设置，例如: orientation=6 //代表竖屏可以任意旋转 orientation=24 //代表横屏可以任意旋转 注意： iOS工程项目内的横竖屏设置最好和config.ini设置一致。如果设置的不一致可能会导致未知的情况发生。设置如下图： 2.2 Android android项目构建成功，打开AndroidManifest.xml文件，在activity标签内有一个screenOrientation参数，开发者可以根据自己需求进行修改，如下图所示： 可配置的参数是android的标准，在这不做过多解释，如下所示： \"landscape\",\"portrait\",\"full_sensor\",\"sensor_landscape\",\"sensor_portrait\",\"reverse_landscape\",\"reverse_portrait\" 三、执行顺序 应用程序在启动的时候会先读取iOS的config.ini中设置的屏幕方向或android的AndroidManifest.xml中设置的屏幕方向。当解析到index.js的时候再读取屏幕横竖屏设置的值，并重新设置屏幕方向。 例如：android的AndroidManifest.xml中设置为portrait，index.js中的标签设置为landscape，运行过程中就会发现在android设备上，屏幕会旋转一下，从竖屏旋转成了横屏。 Tips：建议开发者把两个值设定一致，这样避免程序在执行过程中出现屏幕旋转的现象。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/native/loading_view_new/readme.html":{"url":"released/native/loading_view_new/readme.html","title":"启动画面LoadingView","keywords":"","body":"加载界面1.进度条控制2.进度条控制实例3.去掉所有文字显示4.自定义界面和功能5.特别说明加载界面 为了方便开发者，自定义LoadingView，LayaNative使用原生功能实现的新的LoadingView。 应用程序在启动的时候，需要加载必要的html、js、图片，这个时候就需要通过加载界面显示进度，LayaNative在运行项目的时候，默认有一个LoadingView界面，一段时间后，即可进入游戏，如图1所示： ​ 图1 1.进度条控制 ​开发者可以在config.js中，控制LoadingView的背景色、字体颜色、Tips等。 config.js的位置： Android: 工程目录下的assets/scripts/config.js IOS:工程目录下的resources/scripts/config.js config.js中的内容如下所示，开发者可以根据自己的需求进行修改： window.loadingView = new loadingView(); if(window.loadingView) { window.loadingView.loadingAutoClose=true;//true代表引擎控制关闭时机。false为开发者手动控制 window.loadingView.bgColor(\"#FFFFFF\");//设置背景颜色 window.loadingView.setFontColor(\"#000000\");//设置字体颜色 window.loadingView.setTips([\"新世界的大门即将打开\",\"敌军还有30秒抵达战场\",\"妈妈说，心急吃不了热豆腐\"]);//设置tips数组，会随机出现 } 2.进度条控制实例 在实际开发过程中，通常想要精确控制LoadingView的隐藏和显示，那么开发者可以在config.js中这样设置loadingView.loadingAutoClose的值为false 然后在项目中根据加载完成情况，设置进度条的显示进度，调用函数如下: window.loadingView.loading(nPercent);//参数为0-100的整数值，当值为100的时候LoadingView自动关闭 具体的步骤如下： 步骤1： 在config.js中设置loadingView.loadingAutoClose的值为false window.loadingView = new loadingView(); if(window.loadingView) { window.loadingView.loadingAutoClose=false; // 设置值为false，开发者手动控制加载界面的关闭 ... } 步骤2： 调用loadingView.loading(nPercent)更新进度条 伪代码如下： var nPercent=0; var image1 = document.createElement('img'); image1.onload=function() { if(window.loadingView){ nPercent+=33; window.loadingView.loading(nPercent); } } image1.src = \"a.png\"; var image2 = document.createElement('img'); image2.onload=function() { if(window.loadingView){ nPercent+=33; window.loadingView.loading(nPercent); } } image2.src = \"b.png\"; var image3 = document.createElement('img'); image3.onload=function() { if(window.loadingView){ nPercent+=33; window.loadingView.loading(nPercent); } } image3.src = \"c.png\"; Tips： 当loadingView.loading(nPercent)函数传入的值等于100时，加载界面会自动关闭。也可以通过调用loadingView.hideLoadingView()关闭加载界面。 3.去掉所有文字显示 可以去掉所有文字的显示，包括tips和加载百分比，修改config.js，把showTextInfo的值设置为false即可，代码如下： window.loadingView = new loadingView(); if(window.loadingView) { ... window.loadingView.setTips([\"新世界的大门即将打开\",\"敌军还有30秒抵达战场\",\"妈妈说，心急吃不了热豆腐\"]);//设置tips数组，会随机出现 window.loadingView.showTextInfo=false; // 值设置为false } 4.自定义界面和功能 所有代码公开，因此开发者可以根据需要修改代码实现任何所需自定义功能。 5.特别说明 启动画面，Android版本使用原生Java开发，iOS版本使用Object-C开发，代码都是开源的，开发者如果需要自定义界面，可自行修改，如果不会Android和iOS编写界面，那就去学一下吧。 后续LayaBox会有白名单机制，如果开发者购买了授权，便可以去掉LayaBox的Logo，如果没有购买，则需要强制增加LayaBox的logo，引擎内部会有检测机制，随机检测，如果检测不通过，会强制Crash应用程序。 LayaNative不是开源引擎，但免费给开发者使用，如果想要去掉LayaBox的Logo需要付费。开发者可以通过LayaBox公众号、官网等联系LayaBox商务进行购买。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/native/network/readme.html":{"url":"released/native/network/readme.html","title":"关于网络监听","keywords":"","body":"关于网络状态监听1.监听方式2.查询方式关于网络状态监听 由于移动设备网络环境不太稳定，当网络发生变化的时候，项目中经常需要给用户一些提示，在LayaNative中有两种方法，可以获得网络环境变化。 1.监听方式 开发者可以使用注册监听函数的方式进行监听网络变化，代码如下： JS代码如下 if( conch ) { conch.setNetworkEvtFunction(function(type) { alert(type) }); } AS代码如下： if ( Render.isConchApp) { Browser.window[\"conch\"].setNetworkEvtFunction(function(type):void { alert(type) }); } 返回值类为int类型 NET_NO = 0; NET_WIFI = 1; NET_2G = 2; NET_3G = 3; NET_4G = 4; NET_YES = 5; Tips1、conch只能LayaNative环境下调用，在网页版本中是没有conch定义的，所以需要判断一下是否存在。2、或者使用if(Render.isConchApp )进行判断都可以。 2.查询方式 开发者还可以通过主动查询的方式，查询网络状态，代码如下： if( conch ) { var nType = conch.config.getNetworkType(); } 返回值类为int类型 NET_NO = 0; NET_WIFI = 1; NET_2G = 2; NET_3G = 3; NET_4G = 4; NET_YES = 5; Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/native/LocalStrorage/readme.html":{"url":"released/native/LocalStrorage/readme.html","title":"关于LocalStorage","keywords":"","body":"关于LocalStorageAS下的用法JS和TS下的用法错误的用法：关于LocalStorage LayaNative支持LocalStorage的使用，但是有格式要求，必须使用getItem()、setItem()来存储值以及取值 AS下的用法 //存储指定键名和键值，字符串类型。 LocalStorage.setItem(\"LayaBox\",\"H5引擎！\"); //获取指定键名的值。 LocalStorage.getItem(\"LayaBox\"); JS和TS下的用法 //存储指定键名和键值，字符串类型。 Laya.LocalStorage.setItem(\"LayaBox\",\"H5引擎！\"); //获取指定键名的值。 Laya.LocalStorage.getItem(\"LayaBox\"); 错误的用法： 下面js语法的用法在PC端浏览器或者移动端（浏览器裸跑）支持，但是LayaNative下不支持 //存储，LayaNative下不支持 localStorage.test = 100; //取值，LayaNative下不支持 alert(localStorage.test); Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/native/Android_BackPress/readme.html":{"url":"released/native/Android_BackPress/readme.html","title":"处理Android后退按钮","keywords":"","body":"接管android的后退按钮接管android的后退按钮 在LayaNative中可以使用这两个函数， conch.setOnBackPressedFunction(onBack) 和conch.exit(), 接管按下“后退键”的处理方式。接管setOnBackPressedFunction后，当用户按下后退键时便会执行此函数。 一旦调用了这个函数，就屏蔽了引擎中默认按下两次退出的功能，这时候，如果想要退出应用的话，可以通过调用exit()函数来实现。 Tips1、conch只能LayaNative环境下调用，在网页版本中是没有conch定义的，所以需要判断一下是否存在。2、LayaNative只有Android版有这两个函数。 js示例如下： var n=3; if(window.conch){ window.conch.setOnBackPressedFunction(()=>{ console.log('press back '+n); if(n-- Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/native/real_device_debugging/readme.html":{"url":"released/native/real_device_debugging/readme.html","title":"Android真机调试JavaScript","keywords":"","body":"在android真机上调试JavaScript代码一、调试的原理二、调试layaAirIDE构建的Android项目步骤1:步骤2：修改调试模式步骤3：编译并运行项目步骤4：使用Chrome连接工程步骤5：进行调试四、目前版本存在的问题在android真机上调试JavaScript代码 一、调试的原理 JavaScript代码的调试，是使用调试机上的Chrome浏览器进行的。Android测试机上的LayaNative启动的时候，会同时启动一个WebSocket服务器。Chrome浏览器通过WebSocket与LayaNative连接通信，从而实现使用Chrome对项目的JavaScript的调试。 在调试项目中的JavaScript的代码时，有以下两种调试模式可以选择： Debug/Normal模式 在该模式下，Android测试机上的项目可以直接启动并运行，Chrome浏览器可以在项目运行后连接调试。 Debug/Wait模式 在该模式下，Android测试机上的项目启动后，会一直等待Chrome浏览器的连接。当Chrome连接成功后，才会继续执行JavaScript脚本。 当需要对启动时加载的JavaScript脚本进行调试时，请优先选择该模式。 注意：在调试的工程中请确保调试机与Android测试机在同一网络上。 二、调试layaAirIDE构建的Android项目 步骤1: 使用LayaAirIDE对项目进行构建，生成Android的工程。 步骤2：修改调试模式 使用Android Studio打开构建后的工程。 打开android_studio/app/src/main/assets/config.ini，修改JSDebugMode的值,设置需要的调试模式。如图1： 图1 JSDebugMode的取值和含义如下： 取值 含义 0 关闭调试功能 1 Debug/Normal模式 2 Debug/Wait模式 Tips： 当项目正式发布后，请将JSDebugMode的值设置为0，否者会对项目运行时的性能有影响。 步骤3：编译并运行项目 使用Android Studio编译工程。 如果选择的是Debug/Normal模式，等待Android测试机成功启动并运行项目。 图2 Android测试机成功启动并运行项目 如果选择的是Debug/Wait模式，等待Android测试机成功启动项目。 图3 Android测试机成功启动 步骤4：使用Chrome连接工程 打开调试机上的Chrome浏览器，输入以下网址： devtools://devtools/bundled/js_app.html?v8only=true&ws=10.10.82.142:5959/177987ab-1d16-4ea6-afcc-c11c0a1bb9e9 注意： ws=10.10.82.142:5959里的10.10.82.142是Android测试机的ip地址，5959是步骤2中config.ini文件里JSDebugPort设置的端口号值，请根据自己设备的实际情况和需求进行更改。 步骤5：进行调试 连接成功后，便可以使用Chrome对项目中JavaScript进行调试。如图2所示： 图4 四、目前版本存在的问题 下面的问题会在以后的版本里解决，敬请谅解。 在调试器调试的过程中，使用调试器手动添加的断点（非debugger断点)，有几率会出现调试混乱。 如果遇到这种情况，请按以下步骤进行处理： 步骤1：设置的断点如下 图11 步骤2：取消所有的断点 图12 步骤3：重启启动工程，再使用Chrome连接工程。 图13 步骤4：恢复需要的断点 图14 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/native/LayaDcc_Tool/readme.html":{"url":"released/native/LayaDcc_Tool/readme.html","title":"缓存工具-layadcc","keywords":"","body":"LayaDCC工具介绍LayaPlayer资源包的类型安装和使用layadcc1. 安装Node.js2. 安装 layadcc3.使用方法4. 实战操作常见问题附录LayaDCC工具 介绍 LayaDCC：Laya-Dynamic Content Check，是LayaPlayer提供的一种热更新解决方案。其优点是运行时差异更新，能有效减少网络流量。他的主要数据是DCC文件，DCC文件用来描述项目中所有文件的校验值。DCC文件是通过工具 layadcc 来产生的。 layadcc会遍历所有的项目文件，生成一个包含所有文件校验值的二进制文件filetable.bin。LayaPlayer在启动的时候，会从服务器获取这个文件（如果需要的话）来确定需要更新什么文件。 layadcc 还可以用来把生成资源包，用来把资源打包到App中。 LayaPlayer资源包的类型 目前的资源打包方案有三种。 App联网包： App本身不带任何资源，体积最小。LayaPlayer第一次运行时，所有用到的资源都会从服务器端下载，并缓存在本地。第二次及以后运行时，会先从服务器获取dcc文件，然后在需要下载某个文件的时候，检查本地的资源是否需要更新，只有需要更新的时候才真正下载，未更新的资源则直接从本地缓存读取。本地缓存会逐渐增大。 带资源的App联网包： App包本身包含了部分或者全部的游戏资源，包体积较大。数据依然能更新，即每次运行依然会从服务器取dcc文件进行校验，如果发现包中的某个文件已经老了，就会下载新的文件，缓存在本地，以后再运行的时候，只要缓存的文件没改，就依然使用缓存的。在多次更新后，App包的文件可能大部分都无效了，每次都是取的本地缓存，这时候建议重新更新App包，用新的资源来打包。 App离线包（单机包）： 直接把所有的资源都打包到App中，完全不需要网络下载，甚至不需要联网。体积最大。因为是单机版本，没有url，所以无法进行资源动态更新，想要更新资源的话，只能更新App。 安装和使用layadcc layadcc基于Node.js，所以需要Node.js的环境。 1. 安装Node.js 到nodejs官网下载。node.js不能太老，不支持 0.xx的版本，可以用命令查看node版本 例如: $ node -v v4.2.0 这个版本就可以。 2. 安装 layadcc npm install -g layadcc 如果顺利安装完，就可以在命令行中直接执行layadcc。 3.使用方法 layadcc 资源目录 [options] options: -cache 生成资源包. -lwr 文件路径全部转为小写。（一般不需要） -url url 如果要打包资源的话，对应的url. -cout outpath 打包资源的输出目录，如果不设置的话，就是在资源目录下。 例如: layadcc d:/game/wow -cache -url www.game.com 4. 实战操作 4.1 运行环境 确保正确安装了Node.js，npm，layadcc验证方法：图1只要执行layadcc没有报错就可以了。 4.2 html5项目环境 假设有一个游戏项目，放在F:/work/test/bestgame/目录下(启动页index.html在这个目录下)，他的目录结构为： 图2这个项目发布后对应的url地址是： http://www.layabox.com/bestgame/index.html（如果单机版不需要url地址） 4.3 打包资源 现在要把这个html5项目打包，放到App项目中。 layadcc F:/work/test/bestgame -cache -url http://www.layabox.com/bestgame/index.html 如果是单机包的话，输入: layadcc F:/work/test/bestgame -cache -url http://stand.alone.version/index.html 如下图:图3 加了-cache参数后，就会遍历所有的资源文件，输出到-cout指定的目录下，如果没有-cout参数，就在工作目录下创建一个layadccout目录（如上图），输出目录下的cache目录就是打包App的时候需要使用的资源。然后把这个目录拷贝到构建的项目的对应的目录中，就可以编译打包生成App。在不同的开发环境下，需要放到不同的目录中（如果使用LayaAirIDE或者layabox命令行工具，可以自动完成这一步）。 Android Eclipse: （图4） android的资源目录是项目下的assets目录 Android Studio:（图5） iOS XCode: （图6）IOS是resource目录 4.4 更新服务器 这是App发布后最常见的操作。每当更新了html5项目的内容，需要提交到服务器或者本地测试的时候，都要生成新的dcc，以便客户端能更新到最新资源。操作过程如下图：图7 可以看到执行完layadcc后，在指定目录（现在是当前路径 . ）下面会生成一个update目录。然后把这个update目录拷贝到本地或者远程服务器的相同目录即可。Tips:为了方便和不出错误，建议直接在服务器所在目录下执行layadcc。 update目录介绍：图8 allfiles.txt 所有的资源文件的相对路径。assetsid.txt 本次dcc统计的整个资源包的校验码。filetable.bin dcc主文件，里面是每个文件的校验值。filetable.txt 文本格式的dcc文件，除了前三行，每一行代表一个文件和对应的校验值，与allfiles.txt正好对应起来，即第4行对应的文件是allfiles.txt的第一行。filetable1.txt 这个文件不再使用。 注意: 如果web服务器上的目录里面没有update目录，或者update目录里面没有内容，则客户端的dcc更新机制就会关闭，这样所有的资源每次都会重新下载。在开发期间建议用这种方式。 上面的例子是在当前目录下，实际也可以指定其他路径，相对或绝对都可以，例如:layadcc d:/game/bin/h5 或者 layadcc ../bin/h5 4.5 测试 资源打包成功的测试先说包中没有资源的情况，这种情况下所有的资源都会从网上下载，日志如下:图9 可以看到有很多的Download打印信息说明： 这里面的url后面跟着的 @127.0.0.1是调试用的，表示这个文件对应的服务器地址。s=0表示这个文件没有dcc信息， l=xxx表示下载的文件的长度。 如果打了资源包，即cache目录下的东西拷贝到上面指定的目录了，这时候最直观的变化是包变大了。然后运行app，会有从资源包读取资源的打印，如下： 图10打印信息说明打印 found the file in the package: 就表示对应的资源是从包中获取的，没有去网络下载，看到这个日志就表示打包资源成功。如果打的单机版，则所有资源都应该有这个打印，不应该有任何下载。 服务是否有dcc的测试：在浏览器里打开地址： http://www.layabox.com/bestgame/update/filetable.txt注意要改成自己的地址，如果文件存在，表示打过dcc。如下图：图11 更新机制起作用的测试直观的测试就是更新了资源，App产生了对应的改变，例如修改了的图片，能在app上看到。从日志看的话，就是资源获取的时候，凡是没有改变的都是打印 found the file in the package:， 而改变了的都是打印 download [ ] xxxurl。注意 1 Download只执行一次，第二次再进入app，这个资源如果没改，就会直接从缓存取。 2 DCC的机制是运行时更新，所以只有执行到需要这个资源的时候才会下载，而不是一启动就下载所有更新。 总结 凡是有 download [ ] url就表示下载，说明没有dcc或者资源更新了 凡是有found the file in the package:，说明打包资源成功，dcc起作用了。 注意: layadcc执行的时候会修改所有文件的修改时间，目的是为了防止cdn在回源的时候以为文件没有被修改。 上面的地址是虚构的，不存在一个 http://www.layabox.com/bestgame/index.html 的地址。 常见问题 打包资源以后，没感觉速度变快，怀疑所有的资源还是都在下载。 确定是否真的都是在下载，看日志是不是有上面提到的Download和find，如果既有读缓存，也有下载，则没有问题，只是真的下载慢。 如果全部都是Download，没有读缓存 是不是忘了打dcc了，通过浏览器检查服务器是否有dcc信息。 检查打包资源路径是否正确。 App发布后，修改了部分资源，但是没有被App更新到。 是不是忘了打dcc了？ 打了dcc了，但是忘了提交到服务器上（建议在服务器打dcc）？ 打了dcc了，也提交到服务器了，但是由于有cdn，还没有把这个变化分发到你所在的节点。 我确认dcc流程都对了，但是某个资源每次都会重新下载，不走缓存。 确认这个资源是否在打包资源中，即dcc列表中，可以在 update/allfiles.txt中搜索这个文件。 如果在。确认请求这个资源的url是否有search部分，即?xxx, 如果加了的话，是无法走dcc流程的。 如果也没有search，那有可能是这个文件的实际内容与校验值不匹配，dcc会以为是错误的文件，就不缓存了。可能的原因： 打完dcc以后，有人把这个文件的内容又给改了，导致dcc校验值与实际文件内容不匹配。解决方法：重新打dcc 没人改文件内容，但是dcc是在客户端打的，文件在上传到服务器以后，被上传软件修改内容了。这种情况一般发生在文本文件上，例如有的版本管理工具和ftp工具会把windows下的回车换行变成unix的回车。解决方法：用zip的方式传文件，或者在服务器上打dcc。 没有上面的问题，而且错误的是图片。可能原因是有的系统会全局截获http请求，在请求图片的时候，通过自己的服务器来缓存一个被压缩过的图片，来达到所谓的节省流量。这个压缩过的图片的校验值肯定与dcc记录的不一样。解决方法：关掉节省流量功能。 如果没有开流量节省。但是使用了cdn，则还可能是cdn的问题，例如dcc文件被刷新了，但是对应的资源文件没有刷新。确认方法：通过curl命令下载本节点上的资源文件（方法见附录），与源站的资源文件比较，如果不同，即确认。解决方法：强制刷新cdn节点，或者找cdn客服。 开发期间，每次更新都打dcc太麻烦。 不要用layadcc来打dcc，如果已经打了， 把update目录删掉，然后重新安装一下app，以去掉内部的缓存，这样dcc机制就关掉了，每个文件每次请求都会重新下载。 如果某次又打了一下dcc，在服务器端生成了update目录，则缓存又会起作用，想关掉的话，再来一遍上面的操作。 为了减少包的体积，希望只是打包部分资源，正确的姿势是什么？ 无论是初次安装，还是以后升级app，如果只打部分资源的话，要保证资源里的dcc信息是基于完整数据生成的。例如共有100个资源，只想打包50个到app中，需要先在完整资源状态下打dcc，保存生成的dcc信息（主要是filetable.txt），然后删掉50个资源，用layadcc生成cache文件，这时候cache目录下生成dcc信息是不完整的，所以要用上一步生成的文件来覆盖他。 如果使用了不完整的dcc会导致的问题：更新app的时候，native会优先使用app中缓存的dcc文件，导致丢失部分缓存信息，这样不在filetable.txt中的文件会被认为不需要缓存，从而一直下载，直到下次服务器dcc更新。 附录 LayaDCC的流程图12对应的代码在 index.js 中。 下载某个cdn节点上的文件。 curl -H \"Host:www.layabox.com\" http://182.110.238.110/bestgame/index.html >a.html 表示把 182.110.238.110 节点上的 http://www.layabox.com/bestgame/index.html的文件下载下来，保存到 a.html中。 其中的 Host：后面的内容改成自己的域名， http://后面的ip地址改成节点服务器的地址，那怎么获得节点服务器地址呢？在LayaPlayer中，节点服务器通常不会改变，所以可以通过任意一个Download的打印来得到地址，例如: Downloaded http://www.layabox.com/bestgame/bestgame.min.js@182.110.238.110 s=44216b56 l=422 就知道节点地址是182.110.238.110。 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/native/Secondary_Development/readme.html":{"url":"released/native/Secondary_Development/readme.html","title":"二次开发","keywords":"","body":"用反射机制实现二次开发1. 调用静态函数3.平台代码（android/ios）主动执行js脚本3.1 IOS/OC执行JS脚本3.2 Android/Java执行JS脚本用反射机制实现二次开发 LayaNative通过提供反射机制来帮助开发者可以方便的进行二次开发, 下面通过示例来了解一下如何进行二次开发. 1. 调用静态函数 使用LayaNative, 可以在JavaScript层调用移动端的原生开发语言(Android下Java, iOS下Objective-C)编写的静态函数。 1.1 JavaScript层: JavaScript层的调用方式: var os = conchConfig.getOS(); var bridge; var obj = {}; if (os == \"Conch-ios\") { bridge = PlatformClass.createClass(\"JSBridge\");//创建脚步代理 } else if (os == \"Conch-android\") { //需要完整的类路径，注意与iOS的不同 bridge = PlatformClass.createClass(\"demo.JSBridge\");//创建脚步代理 } if (os == \"Conch-ios\") { //iOS注意函数签名，注意与Android的不同 alert(bridge.call(\"testString:\",\"hello\")); alert(bridge.call(\"testNumber:\",256.0)); alert(bridge.call(\"testBool:\",false)); obj.value = \"Hello OC!\"; bridge.callWithBack(function(value) { var obj = JSON.parse(value) alert(obj.value); },\"testAsyncCallback:\", JSON.stringify(obj)); } else if (os == \"Conch-android\") { alert(bridge.call(\"testString\",\"hello\")); alert(bridge.call(\"testNumber\",256.0)); alert(bridge.call(\"testBool\",false)); obj.value = \"Hello Java!\"; bridge.callWithBack(function(value) { var obj = JSON.parse(value) alert(obj.value); },\"testAsyncCallback\",JSON.stringify(obj)); } 1.2 Android/Java层 在类JSBridge中添加下列函数: public static String testString(String value) { Log.d(\"JSBridge\", \"java: \" + value); return \"LayaBox\"; } public static double testNumber(double value) { Log.d(\"JSBridge\", \"java: \" + value); return 512; } public static boolean testBool(boolean value) { Log.d(\"JSBridge\", \"java: \" + value); return value ? false : true; } public static void testAsyncCallback(String json) { //js thread try { JSONObject root = new JSONObject(json); Log.d(\"JSBridge\", \"java: \" + root.getString( \"value\" )); } catch (JSONException e) { e.printStackTrace(); } m_Handler.post( new Runnable() { public void run() { //ui thread update ui JSONObject obj = new JSONObject(); try { obj.put(\"value\", \"Hello JS!\"); } catch (JSONException e) { e.printStackTrace(); } ExportJavaFunction.CallBackToJS(JSBridge.class,\"testAsyncCallback\", obj.toString()); } }); } 2.1.4 iOS/OC层 在类JSBridge中添加下列函数: +(NSString*)testString:(NSString*)value { NSLog(@\"OC: %@\",value); return @\"LayaBox\"; } +(NSNumber*)testNumber:(NSNumber*)value { NSLog(@\"OC: %@\",value); return @512; } +(NSNumber*)testBool:(NSNumber*)value { NSLog(@\"OC: %d\",value.boolValue); return [NSNumber numberWithBool:value.boolValue ? NO : YES]; } +(void)testAsyncCallback:(NSString*)json { //js thread NSError* error = nil; NSData* jsonData = [json dataUsingEncoding:NSUTF8StringEncoding]; NSDictionary* dict = [NSJSONSerialization JSONObjectWithData:jsonData options:NSJSONReadingMutableContainers error:&error]; NSLog(@\"OC: %@\", [dict objectForKey:@\"value\"]); dispatch_async(dispatch_get_main_queue(), ^{ //ui thread NSError* error = nil; NSDictionary* dic = [NSDictionary dictionaryWithObject:@\"Hello JS!\" forKey:@\"value\"]; NSData* jsonData = [NSJSONSerialization dataWithJSONObject:dic options:NSJSONWritingPrettyPrinted error:&error]; NSString* jsonStr = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding]; [[conchRuntime GetIOSConchRuntime] callbackToJSWithClass:self.class methodName:@\"testAsyncCallback:\" ret:jsonStr]; }); } 注意： 函数参数只支持布尔、浮点、字符串等基本类型，支持返回值。原生函数运行在脚本线程，更新UI需要转到UI线程，支持异步回调函数。 OC源文件后缀要改成.mm，OC的方法是静态的类方法要用+。 通过上述方法可以很方便的进行原生代码相关的二次开发。 3.平台代码（android/ios）主动执行js脚本 3.1 IOS/OC执行JS脚本 [[conchRuntime GetIOSConchRuntime] runJS:@\"alert('hello')\"]; 3.2 Android/Java执行JS脚本 ConchJNI.RunJS(\"alert('hello world')\"); Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/native/webview/readme.html":{"url":"released/native/webview/readme.html","title":"webview","keywords":"","body":"webview一、介绍1. 接口定义2. 限制二、如何在代码中动态关闭webview页面webview 一、介绍 由于LayaNative不支持标准的html，有时候项目需要显示一个完整的html页面，这时候可以通过LayaNative提供的一个显示webview界面的接口来实现。 1. 接口定义 /** * 显示一个webview * @param url {string} 要显示的url地址。 * @param posx {number} weview的左上角位置 * @param posy {number} webivew的左上角位置 * @param width {number} webview的宽度 * @param height {number} webview的高度 * @param canclose {boolean} webview是否可以被关掉。 */ setExternalLinkEx(url:string,posx:number,posy:number,width:number,height:number,canclose:boolean):void; 这个函数会在画布的最上层显示一个新的view，在其中显示url的内容。 canclose参数用来控制这个webview是否能被关掉： 设置为false时: 代码如下： document.addEventListener('touchstart',()=>{ if(conch){ var l = 50; var t = 50; var w = window.innerWidth - l * 2; var h = window.innerHeight - t * 2; conch.setExternalLinkEx('http://www.layabox.com',l,t,w,h,false); // canclose设置为false //conch.setExternalLink('http://www.baidu.com'); } }); webview显示出来后就无法关闭，效果如下： 图1 设置为true时: 代码如下： document.addEventListener('touchstart',()=>{ if(conch){ var l = 50; var t = 50; var w = window.innerWidth - l * 2; var h = window.innerHeight - t * 2; conch.setExternalLinkEx('http://www.layabox.com',l,t,w,h,true); // canclose设置为true //conch.setExternalLink('http://www.baidu.com'); } }); 在ios下，会有一个小关闭按钮，点击这个按钮，就可以关闭webview。 效果如下： 图2 因为关闭按钮会覆盖部分页面内容，且Android设备上提供了后退键，因此Android设备上webview显示后没有关闭按钮，可以通过后退键关闭webview。如下图： 图3 此时可以点击后退键关闭webview 2. 限制 目前webview无法与app进行交互。 webview的实现依赖于系统，低版本的android可能无法显示。 Tips1、conch只能LayaNative环境下调用，在网页版本中是没有conch定义的，所以需要判断一下是否存在。 二、如何在代码中动态关闭webview页面 调用下面的代码可以动态的关闭webview页面： conch.closeExternalLink(); Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/native/built_in_font/readme.html":{"url":"released/native/built_in_font/readme.html","title":"嵌入字体","keywords":"","body":"嵌入字体1. 字体介绍2.如何嵌入字体3.iOS嵌入字体3.1版本后字体修改1.读取本地assets目录字体文件，然后代码通过registerFont注册，后续通过注册时传入的字体名称layabox使用关联字体2。通过ttfloader下载远程字体文件，注册时传入的字体名称为ttf文件名嵌入字体 1. 字体介绍 由于andriod设备种类繁多、android的字体文件不统一，每个系统默认的中文字体路径有差异（再加之国内很多厂商个性化定制），读取font.ttf是一个难题。 LayaNative的策略是根据android的系统版本号，枚举出字体文件的路径，如果加载成功，则使用系统默认字体，如果加载不成功，就从LayaBox网站下载一个字体存储到本地，第二次进入时，直接读取本地字体。 开发者在打包app的时候，要默认将字体打包到app中，如果在网络上下载4MB的TTF字体，会影响用户体验。 2.如何嵌入字体 1、构建好android项目，找到assets目录，再创建一个font目录，把要植入的字体文件改名为“layabox.ttf”，放到该目录下。如图1所示： Tips: 模板工程默认是内嵌了ttf字体，这样会导致apk体积增加，如果你比较在乎apk大小，可以删除assets/font/layabox.ttf这个字体文件。 3.iOS嵌入字体 1、LayaNative支持iOS嵌入默认字体，具体做法同android，在resource下创建font目录，把要嵌入的字体改名为layabox.ttf即可，如下图2所示： 3.1版本后字体修改 3.1版本后优化了字体系统，默认优先使用系统字体。如果需要嵌入自定义字体，需要注册到系统后才能使用。下面示例展示两种嵌入方式。 1.读取本地assets目录字体文件，然后代码通过registerFont注册，后续通过注册时传入的字体名称layabox使用关联字体 function registerFont() { var assetFontData = conch.readFileFromAsset('font/layabox.ttf', 'raw'); if (assetFontData) { if (conch.registerFont(\"layabox\", assetFontData)) { log('字体注册成功'); } else { log('字体注册失败'); } } } 2。通过ttfloader下载远程字体文件，注册时传入的字体名称为ttf文件名 Laya.loader.load(\"res/maobi.ttf\", Loader.TTF).then(() => { var label: Label = new Label(); label.font = \"maobi\"; label.text = \"自定义嵌入字体\"; label.fontSize = 30; label.color = '#FFFFFF'; this.Main.box2D.addChild(label); label.pos(30, 50) }); Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2024-02-21 17:22:35 "},"released/native/zipUpdate/readme.html":{"url":"released/native/zipUpdate/readme.html","title":"zip更新","keywords":"","body":"LayaNative的资源更新方法1. 用户不可见的更新（推荐）。2. 用户可见的，进入游戏前的集中更新。LayaNative的资源更新方法 游戏发布之后必然会遇到更新的问题，这里的更新是指用LayaNative打包的游戏发布后，因为修改bug或者添加功能，想要修改客户端的部分代码和图片等数据。目前LayaNative支持两种资源更新方式： 1. 用户不可见的更新（推荐）。 这是一种持续的，随时进行的更新。这种方式符合网页的更新思想：只有当需要使用某个资源的时候，才会触发资源的更新流程。这种化整为零的更新的机制，可以让用户立即进入游戏，在不知不觉间就完成了更新。这种更新基于LayaNative的DCC机制,LayaDCC的介绍和使用方法见这里。 2. 用户可见的，进入游戏前的集中更新。 大部分传统的app的更新方式，一上来就检查是否需要更新，如果需要更新就下载一个大的zip文件进行整体更新。这种更新的维护成本较高，用户需要较长时间的等待才能进入游戏，而且还明显违反Apple的禁止热更的政策。他的好处是用户可以在有wifi的地方更新，在没有wifi的地方玩，避免在没有wifi的时候浪费数据流量。 LayaNative虽然没有直接支持这种更新，但是通过下面的几个接口（注意这些接口属于内部接口，以后有改变的可能性）也能实现这个功能： 支持断点续传的大文件下载函数downloadBigFile。(注意不要用XMLHttpRequest下载大文件，因为这种方式下LayaNative会把结果先保存在内存中，所以大文件可能会导致内存爆掉，而这个函数是随时存盘的。) /** * @param url 远程地址 * @param local 存到本地文件 * @param onprog 下载进度回调 * @param oncomp 下载完成回调 * @param trynum 重试次数（0无限重试） * @param opttimeout 超时时间（建议足够大） */ declare var downloadBigFile:(url:string, local:string, onprog:(total:number,now:number,speed:number)=>boolean,oncomp:(curlret:number, httpret:number)=>void, trynum:number, opttimeout:number)=>void; 处理zip文件的ZipFile类 interface ZipFile{ setSrc(src:string):boolean; /** * 遍历zip中的文件。 * id: * name:文件名，包含路径 * dir:是否是目录 * sz:文件大小 */ forEach(func:(id:number,name:string,dir:boolean,sz:number)=>void):void; /** * 读取zip中的文件的内容，返回一个ArrayBuffer */ readFile(id:number):ArrayBuffer; close():void; new ():ZipFile; } declare var ZipFile:ZipFile; 手动更新dcc缓存的功能。 interface AppCache{ ... /** * 更新dcc缓存中的一个文件 * @param nameid 更新的文件的id。 * 路径规则：/，表示app根目录。例如：hashstr('/index.html')， 不要带参数，如果带参数的话-- hashstr('/aa/bb.html?ff=2') 会导致谁也找不到这个文件 * @param chksum 校验码，如果0则此函数自己计算。如果是外部版本控制，则这个是hashstr后的版本号。 * @param buf ArrayBuffer 文件内容。 * @param extversion 是否使用外部版本号 * @return boolean 如果返回true则表示更新成功，否则的话，表示校验码不一致，即 * 先要更新dcc才能工作。 */ updateFile(nameid:number,chksum:number,buf:ArrayBuffer,extversion:boolean):boolean; ... } 通过这几个函数，就可以在layaDCC之上实现一个集中更新的功能。例如LayaNative提供的一个封装好了的更新函数updateByZip： ​ /** * 用zip进行更新。 * @param {string} url zip下载地址 * @param {(event:string,downloadPercent:number,curfile:string)=>void} onEvent 事件的回调。 * 其中的event是事件名称，可能的事件如下： * 'downloading' 下载中，这时候downloadPercent有值 * 'downloadError' 下载错误 * 'downloadOK' 下载成功。 * 'updating' 更新中，这时候 curfile有值，表示正在更新的文件 * 'updateError' curfile更新错误。因为curfile不在dcc列表，或者文件内容与dcc内容不一致。少量更新错误可以忽略，因为在实际使用的时候还是会下载 * 'unknownError' * @param {function(localfile:string):void} onEnd 更新完成的回调 */ function updateByZip(url, onEvent, onEnd) 这个函数的实现代码，在引擎的 index.js中。所以如果有特殊需求，也可以参考这个函数来实现自己的更新函数。 ​需要注意的是这个函数实际上只是做了下载zip，然后把里面的每个文件更新到cache中的事情。实际使用的时候，还要自己实现版本管理，界面，下载进度提示等功能。为了实现这些功能可能需要本地读写文件的接口，可以使用下面的全局函数（同样是内部接口，可能会改变）： ​ declare var fs_readFileSync:(file:string)=>ArrayBuffer; declare var fs_writeFileSync:(file:string,data:string|ArrayBuffer)=>boolean; declare var readFileSync:(file:string,encode:string)=>string;//这个直接返回字符串。 如果需要获得缓存路径，需要LayaNative内部的appcache对象： ​ var cachepath = window.appcache.getCachePath() Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/native/apk_expansion/readme.html":{"url":"released/native/apk_expansion/readme.html","title":"APK扩展机制","keywords":"","body":"android文件扩展机制1.机制详解1.生成DCC2.压缩文件3.将zip文件拷贝到设备目录4.修改代码中的扩展路径5.开启外部存储权限5.运行测试2. Google Play APK扩展文件机制android文件扩展机制 LayaNative不仅支持把资源打包在assets目录下，还支持把资源打包成zip文件，放到任意文件路径下。LayaNative文件系统会先在assets目录下查找文件是否存在，如果没有找到，再去指定的zip路径下查找。通过这种zip机制便可以解决GooglePlay规定APK的size超过100MB，要求增加扩展包的问题。 1.机制详解 1.生成DCC 测试项目用DCC工具打包资源 2.压缩文件 把资源包放到扩展文件中，压缩cache文件，文件要求zip格式，文件结构必须保持DCC工具生成的结构相同，如下图： 3.将zip文件拷贝到设备目录 在Android手机上建立目录/storage/emulated/0/Android/test/com.layabox.conch6，上传test.zip到这个目录下 4.修改代码中的扩展路径 修改RuntimeProxy.java中的getExpansionMainPath函数，设置正确的zip路径。 public String getExpansionMainPath() { return \"/storage/emulated/0/Android/test/com.layabox.conch6/test.zip\"; } public String getExpansionPatchPath() { return \"\"; } 5.开启外部存储权限 安卓6.0以上的机器可能不能读取外部存储，需要主动请求权限。请加上如下代码或者Google相关解决方案。 public static boolean isGrantExternalRW(Activity activity) { if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M && activity.checkSelfPermission( Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) { activity.requestPermissions(new String[]{ Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE }, 1); return false; } return true; } TIPS:LayaNative中最多支持两个zip文件，第二个zip修改·getExpansionPatchPath·这个函数 5.运行测试 运行APP，看见下面的日志说明从主扩展包读取资源文件成功 2. Google Play APK扩展文件机制 (https://developer.android.com/google/play/expansion-files.html) Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/native/build_Cmd/readme.html":{"url":"released/native/build_Cmd/readme.html","title":"layaAirNative命令行工具使用","keywords":"","body":"LayaNative命令行工具1.命令详解1.安装layanative1.查看SDK版本信息2.创建native项目3.刷新native项目资源包4.删除native项目资源包3.应用实例LayaNative命令行工具 layanative命令行工具用来生成Android和iOS原生项目，以及项目的资源刷新功能， 方便项目迭代过程中的资源更新。 1.命令详解 1.安装layanative windows $ npm install -g layanative3 mac $ sudo npm install -g layanative3 1.查看SDK版本信息 SDK就是native项目的模板。listversion命令会列出当前所有可用的SDK版本信息，在下面创建native项目的时候可以通过参数指定需要的版本。 $ layanative3 listversions 2.创建native项目 createapp命令用于创建native项目可以先用下面的命令查看下命令createapp的帮助信息 $ layanative3 createapp --help 用法: layanative3 createapp [-f res_path] [--path output_path] [-s sdk_path | -v version] [-p all|ios|android_studio] [-t 0|1|2] [-u url] [-n project_name] [-a app_name] [--package_name package_name] 参数说明: 关键字 描述 --folder,-f 资源路径：把游戏资源打包进客户端以减少网络下载,选择本地的游戏目录，例如启动index在d:/game/index.js下,那资源路径就是d:/game。t为0时可不填 --path native项目输出目录 [默认值: \".\"] --version，-v SDK版本：自动使用特定版本的SDK，系统会从服务器下载SDK并存放在特定位置。--version和--sdk互相矛盾不能同时指定，都不指定时默认使用最新版本的SDK --platform, -p 项目平台 [可选值: all, ios, android_studio][默认值: all] --type, -t 创建类型 [0: 不打资源包 1: 打资源包 2: 单机版本] [默认值: 0] --url, -u 游戏地址 [当t为0或者1的时候，必须填，当t为2的时候，不用填写] --name, -n 项目名称：native项目的名称 [默认值: LayaBox] --app_name, -a 应用名称：app安装到手机后显示的名称 [默认值: LayaBox] --package_name 包名 [默认值: com.layabox.game] --sdk,-s SDK本地目录：自定义的SDK目录，可选参数。断网情况下使用，一般情况下建议使用参数--version。 当type为1或2时会打资源包到native项目，为0时不打。打包资源底层实际是调用dcc的方法。打包资源dcc相关，参考 LayaDcc工具。可以用--path参数指定项目的输出路径，默认输出到当前路径下。 根据-v使用v2.0版本的SDK $ layanative3 createapp -f SnowBallH5 -t 1 -n SnowBallNative -u http://10.10.20.102:8899/index.js -v v2.0 既没指定-v也没指定-s，使用最新版本的SDK $ layanative3 createapp -f SnowBallH5 -t 1 -n SnowBallNative -u http://10.10.20.102:8899/index.js 用--version或者-v指定版本需要联网环境，断网情况下可以用--sdk或者-s指定SDK目录。SDK下载地址 $ layanative3 createapp -f SnowBallH5 -t 1 -n SnowBallNative -u http://10.10.20.102:8899/index.js -s D:/v2.0 3.刷新native项目资源包 refreshres命令用于刷新native项目的资源包项目迭代过程中，h5项目有了修改，可以用refreshres命令，重新打包刷新资源和代码到native项目中。 用法: layanative3 refreshres [-p all|ios|android_studio] [--path path] [-u url] 参数说明: 关键字 描述 --platform, -p 项目平台 [可选值: all, ios, android_studio][默认值: all] --path native项目路径 [默认值: \".\"] --url, -u 游戏地址 如果创建的项目是单机版，refreshres时不需要输入url。如果输入网络版url，打的是网络版的资源包，那么还需要更改项目代码，才能变成网络版的项目。如果创建的项目是网络版，refreshres时必须输入url。如果输入新的地址，那么还要更改项目中设置url的代码，才能完成URL的替换。如果输入单机版地址，打的是单机版的资源包，那么还需要更改项目代码，才能变成单机版的项目。手动切换单机版和网络版相关，参考 LayaBox 构建工具。 createapp时把资源路径写在了生成的native项目目录下的native.json文件中。如果后来资源移到了别的地方，会报错找不到资源目录。createapp时，如果-t参数指定为0时，不打资源，可以不指定资源路径参数，native.json中写的资源路径为空，这种项目refreshres时会报资源路径为空的错误。上述两种情况可以手动修改native.json文件，指定正确的资源路径。 4.删除native项目资源包 removeres命令用于删除native项目的资源包 用法: layanative3 removeres [--path path] 参数说明: 关键字 描述 --path native项目路径 [默认值: \".\"] 3.应用实例 1.首先建立下图所示的目录结构。jellyfish是html5项目目录 2.查看SDK版本信息3.创建native项目4.生成下图所示目录结构。5.随时刷新资源包在dev目录下，通过--path指定native工程的目录进入native项目目录，不需要指定--path参数了5.如果不需要资源包，删除它在dev目录下，通过--path指定native工程的目录进入native项目目录，不需要指定--path参数了 Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "},"released/native/Other_settings/readme.html":{"url":"released/native/Other_settings/readme.html","title":"其他","keywords":"","body":"其他说明1. 关于第三方地图2. 关于文件格式3. debug模式和release模式4.关于iOS对接微信5. 关于iOS模拟器6. 获取各种信息7. 屏蔽项目中报错弹框8. 引擎初始化或加载启动脚本过程中的异常处理9. 获取设备型号其他说明 1. 关于第三方地图 LayaNative底层渲染使用openGLES渲染，使用android的GLSurfaceView控件和iOS的GLKView控件，所以无法支持第三方地图，如百度地图。 2. 关于文件格式 项目中的文本格式文件（例如:ini、xml、html、json、js等）都必须是utf8编码格式，因为iOS设备不支持非utf8格式编码的文件。 3. debug模式和release模式 LayaNative底层LOG分为三种： LOGI 普通流程log LOGW 警告log LOGE 错误log 在js脚本中，开发者可以通过以下函数设置Debug模式： if( window.conch ) { //值为0：表示关闭所有日志输出 //值为1：表示所有LOGE全部弹出alert //值为2：表示所有LOGE和LOGW全部弹出alert window.conch.config.setDebugLevel(1); } Tips 1、conch只能LayaNative环境下调用，在网页版本中是没有conch定义的，所以需要判断一下是否存在。 4.关于iOS对接微信 在iOS平台下对接微信SDK，微信1.77版本以后需要增加-Objc的参数，微信的官方文档中默认让增加-Objc -all_load,但是这样会导致编译报错。 遇到到这种情况可以把参数变成 -Objc -force_load libWeChatSDK.a，配置后，如图1所示： 5. 关于iOS模拟器 LayaNative支持iOS模拟器，但是由于模拟器运行效率比较低，建议开发者使用iOS真机调试。 6. 获取各种信息 函数名称 函数说明 返回值说明 备注 getTotalMem() 获得运行设备总内存 单位为KB getUsedMem() 获得当前应用程序占用的内存 单位为KB 返回值不太准确，但是可以作为参考 getAvalidMem() 获得可用的内存 单位为KB 返回值不太准确，但是可以作为参考 getNetworkType() 获得网络状态 返回int值，NET_NO = 0;NET_WIFI = 1;NET_2G = 2;NET_3G = 3;NET_4G = 4;NET_UNKNOWN=5 getRuntimeVersion() 获得Runtime的版本 返回值是一个字符串，类似ios-conch5-0.9.2、android-conch5-0.9 getOS() 获得当前系统 返回值类似“Conch-ios” “Conch-android”字符串 getAppVersion() 获得iOS-App的版本号 返回字符串 1.1 iOS-app的版本号，通过这个版本号，可以做APP的更新提示。 getAppLocalVersion() 获得iOS-App的Local版本号 返回字符串1.2 iOS-app的版本号，通过这个版本号，可以做APP的更新提示。 这些函数都属于conch.config类的函数，调用实例： if( window.conch ) { window.conch.config.getRuntimeVersion(); } Tips 1、conch只能LayaNative环境下调用，在网页版本中是没有conch定义的，所以需要判断一下是否存在。 7. 屏蔽项目中报错弹框 项目运行过程中有时会弹出一些错误的提示，这些提示都是项目中有代码写错了。我们的建议是解决掉这些错误弹框里边的错，如果实在是解决不掉再去屏蔽。报错弹框代码如下所示： window.showAlertOnJsException(false); 8. 引擎初始化或加载启动脚本过程中的异常处理 在LayaNative版本中，当引擎初始化、加载启动脚本过程中，如果发生异常（如网络不稳定），引擎会自动调用到window.onLayaInitError(error)函数，该函数默认在config.js中定义，代码如下： window.onLayaInitError=function(e) { console.log(\"onLayaInitError error=\" + e); alert(\"加载游戏失败，可能由于您的网络不稳定，请退出重进\"); } 开发者可以根据自己需求，修改报错信息和报错方式。 9. 获取设备型号 在LayaNative中，iOS可以通过调用conch.config.getDeviceInfo()获取设备型号。可以用于iPhone X的头帘适配，代码如下： if( window.conch ) { var devInfo = JSON.parse(window.conch.config.getDeviceInfo()); if (devInfo.devicename === 'iPhone10,3' || devInfo.devicename === 'iPhone10,6') { // iPhone X适配 } } Copyright ©Layabox 2022 all right reserved，powered by LayaAir Engine更新时间： 2023-03-03 17:34:16 "}}